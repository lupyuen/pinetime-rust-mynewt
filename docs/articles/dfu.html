<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Firmware Update over Bluetooth Low Energy on PineTime Smart Watch</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Firmware Update over Bluetooth Low Energy on PineTime Smart Watch" 
    data-rh="true">
<meta property="og:description" 
    content="Flash any firmware to PineTime from our mobile phone... Without opening the watch!" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/dfu-platforms.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Firmware Update over Bluetooth Low Energy on PineTime Smart Watch</h1>
    <nav id="TOC"><ul>
<li><a href="#simple-management-procotol-for-firmware-update">1 Simple Management Procotol for Firmware Update</a><ul></ul></li>
<li><a href="#robust-firmware-update-on-pinetime-with-rollback">2 Robust Firmware Update on PineTime with Rollback</a><ul></ul></li>
<li><a href="#pinetime-flash-rom-layout">3 PineTime Flash ROM Layout</a><ul></ul></li>
<li><a href="#mcu-manager-library-for-firmware-update">4 MCU Manager Library for Firmware Update</a><ul></ul></li>
<li><a href="#write-firmware-image-to-pinetimes-flash-rom">5 Write Firmware Image to PineTime's Flash ROM</a><ul></ul></li>
<li><a href="#nimble-stack-for-bluetooth-le-on-pinetime">6 NimBLE Stack for Bluetooth LE on PineTime</a><ul>
<li><a href="#nimble-types">6.1 NimBLE Types</a><ul></ul></li>
<li><a href="#nimble-general-functions">6.2 NimBLE General Functions</a><ul></ul></li>
<li><a href="#nimble-mutex-functions">6.3 NimBLE Mutex Functions</a><ul></ul></li>
<li><a href="#nimble-semaphore-functions">6.4 NimBLE Semaphore Functions</a><ul></ul></li>
<li><a href="#nimble-callout-functions">6.5 NimBLE Callout Functions</a><ul></ul></li>
<li><a href="#nimble-event-queue-functions">6.6 NimBLE Event Queue Functions</a><ul></ul></li>
<li><a href="#nimble-time-functions">6.7 NimBLE Time Functions</a><ul></ul></li>
<li><a href="#nimble-interrupt-functions">6.8 NimBLE Interrupt Functions</a><ul></ul></li></ul></li>
<li><a href="#mcuboot-bootloader-for-pinetime">7 MCUBoot Bootloader for PineTime</a><ul></ul></li>
<li><a href="#generate-a-firmware-image-file-for-pinetime">8 Generate a Firmware Image File for PineTime</a><ul></ul></li>
<li><a href="#mark-pinetime-firmware-as-pending">9 Mark PineTime Firmware As Pending</a><ul></ul></li>
<li><a href="#mark-pinetime-firmware-as-ok">10 Mark PineTime Firmware As OK</a><ul></ul></li>
<li><a href="#checklist-for-pinetime-firmware-developers">11 Checklist for PineTime Firmware Developers</a><ul></ul></li>
<li><a href="#optional-command-handlers-for-mcu-manager-on-pinetime">12 Optional: Command Handlers for MCU Manager on PineTime</a><ul></ul></li>
<li><a href="#test-pinetime-firmware-update-over-bluetooth-le">13 Test PineTime Firmware Update over Bluetooth LE</a><ul></ul></li>
<li><a href="#upcoming-enhancements-for-pinetime-firmware-update-over-bluetooth-le">14 Upcoming Enhancements for PineTime Firmware Update over Bluetooth LE</a><ul></ul></li>
<li><a href="#android-ios-and-linux-companion-apps-for-pinetime">15 Android, iOS and Linux Companion Apps for PineTime</a><ul>
<li><a href="#android-app-for-pinetime">15.1 Android App for PineTime</a><ul></ul></li>
<li><a href="#ios-app-for-pinetime">15.2 iOS App for PineTime</a><ul></ul></li>
<li><a href="#flutter-app-for-android-and-ios">15.3 Flutter App for Android and iOS</a><ul></ul></li>
<li><a href="#linux-app-for-pinetime">15.4 Linux App for PineTime</a><ul></ul></li></ul></li>
<li><a href="#other-pinetime-firmware-update-solutions">16 Other PineTime Firmware Update Solutions</a><ul></ul></li>
<li><a href="#further-reading">17 Further Reading</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/dfu-platforms.png" alt="Platforms in development for PineTime Smart Watch" /></p>
<p>üìù <em>11 May 2020</em></p>
<p>[ UPDATE: <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">Check out the followup article here</a> ]</p>
<p>Thanks to the FOSS Community, <a href="https://wiki.pine64.org/index.php/PineTime">PineTime Smart Watch</a> has an incredible variety of FOSS operating systems in the works: <a href="https://github.com/JF002/Pinetime">FreeRTOS</a>, <a href="https://github.com/daniel-thompson/wasp-os">MicroPython</a>, <a href="https://github.com/lupyuen/pinetime-rust-mynewt">Mynewt</a>, <a href="https://github.com/bosmoment/PineTime-apps">RIOT</a>, Rust <a href="https://github.com/wose/xochron">RTFM</a> (<a href="https://github.com/dbrgn/pinetime-rtfm">another</a>), <a href="https://github.com/aykevl/go-smartwatch">TinyGo</a>, <a href="https://www.tockos.org/">Tock</a>, <a href="https://github.com/najnesnaj/pinetime-zephyr">Zephyr</a> (<a href="https://github.com/Dejvino/pinetime-hermes-firmware.git">another</a>, <a href="https://github.com/endian-albin/pinetime-hypnos">yet another</a>), ...</p>
<p>But these embedded platforms are accessible only by brave PineTime Owners who dare to pry open their watches very carefully... And connect a Raspberry Pi (or ST-Link) to the tiny delicate 4-pin SWD port recessed deep inside... Just to flash the PineTime firmware.</p>
<p><em>What if we could flash any firmware to PineTime from our mobile phone... Without opening the watch?</em></p>
<p>Yes we can! Just download the firmware file into our phone and push it wirelessly to our watch, like this...</p>
<p><img src="https://lupyuen.github.io/images/dfu-flow2.png" alt="Firmware Update over Bluetooth Low Energy for PineTime Smart Watch" /></p>
<p><em>Firmware Update over Bluetooth Low Energy for PineTime Smart Watch</em></p>
<p>What's the magic behind this? It's the <strong><a href="https://github.com/apache/mynewt-mcumgr">Simple Management Protocol (SMP)</a></strong></p>
<p>By transmitting a bunch of SMP messages over Bluetooth Low Energy (LE), it's possible to send a file to PineTime and update its firmware. (Assuming that our PineTime supports SMP)</p>
<p><em>What mobile app would we use for flashing PineTime over Bluetooth LE?</em></p>
<p>The <a href="https://www.nordicsemi.com/Software-and-tools/Development-Tools/nRF-Connect-for-mobile">Nordic nRF Connect</a> mobile app for iOS and Android is all that we need for flashing PineTime. Here's how it looks when the app is connected to a PineTime that supports SMP...</p>
<p><img src="https://lupyuen.github.io/images/dfu-nrfconnect.png" alt="nRF Connect mobile app connected to PineTime for Firmware Update" /></p>
<p><em>nRF Connect mobile app connected to PineTime for Firmware Update</em></p>
<p>See the circular <code>DFU</code> icon at the top right? That stands for <strong>Direct Firmware Upgrade</strong>.</p>
<p>Tapping the <code>DFU</code> icon will let us select a downloaded firmware file for flashing our watch. It's really that easy!</p>
<p><em>What about PinePhone? Raspberry Pi?</em></p>
<p>PinePhone, Raspberry Pi and other Linux devices may use the open-source <a href="https://github.com/apache/mynewt-newtmgr">Newt Manager</a> tool.  (I have tested Newt Manager on Raspberry Pi with PineTime)</p>
<p>It runs on a command line, but it should be easy to wrap up in a graphical user interface.</p>
<p><em>What needs to be done on PineTime?</em></p>
<p>If you're developing firmware for PineTime: Thanks for the great job! I strongly urge you to implement the SMP protocol in your firmware... It will make PineTime Owners a lot happier when updating their watch firmware!</p>
<p>And we'll give PineTime Owners an easy way to try out all the awesome platforms that the PineTime FOSS Community has to offer!</p>
<p>We would like Pine64 to ship PineTime with a FOSS firmware (created by the PineTime Community) that implements the SMP protocol. So PineTime owners can just unbox their watch and start flashing right away from their phones.</p>
<p>In this article I'll walk you through the steps of implementing the SMP protocol in your PineTime firmware. I'll show you my implementation for Mynewt OS, which you may use for reference.</p>
<h1 id="simple-management-procotol-for-firmware-update" class="section-header"><a href="#simple-management-procotol-for-firmware-update">1 Simple Management Procotol for Firmware Update</a></h1>
<p>The open-source Simple Management Protocol (SMP) was originally created for flashing firmware on devices running Mynewt and Zephyr operating systems.  SMP is based on the Bluetooth LE Generic Attribute (GATT) Profile. </p>
<p>GATT defines the standard way for a Bluetooth LE Client (like our mobile phone) to access a Bluetooth LE Service (like the firmware update service on PineTime). <a href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt">More about GATT</a></p>
<p>Here's how the SMP protocol works...</p>
<p><img src="https://lupyuen.github.io/images/dfu-gatt.png" alt="SMP Firmware Update over Bluetooth LE" /></p>
<p><em>SMP Firmware Update over Bluetooth LE</em></p>
<ol>
<li>
<p>PineTime broadcasts its name <code>pinetime</code> over Bluetooth LE to allow mobile phones to discover the smart watch</p>
</li>
<li>
<p>Mobile App connects to PineTime via the advertised name <code>pinetime</code></p>
</li>
<li>
<p>Mobile App queries PineTime for a GATT Service that has ID <code>8D53DC1D-1DB7-4CD3-868B-8A527460AA84</code>. This is the GATT Service ID for SMP.</p>
</li>
<li>
<p>Mobile App then queries PineTime for the GATT Characteristic ID <code>DA2E7828-FBCE-4E01-AE9E-261174997C48</code>. This is the GATT Characteristic ID for SMP.</p>
</li>
<li>
<p>Mobile App uses the GATT Characteristic ID for SMP to transmit an encoded request to update PineTime's firmware. In GATT lingo, we call this sending a &quot;Write Request&quot; to the GATT Characteristic for SMP.</p>
</li>
<li>
<p>PineTime performs the firmware update using the firmware file that was embedded in the request</p>
</li>
</ol>
<p>This flow becomes clearer when we look at the nRF Connect mobile app connected to PineTime. Observe how we connect to PineTime by the device name <code>pinetime</code>, also note the SMP Service and SMP Characteristic that appear under PineTime...</p>
<p><img src="https://lupyuen.github.io/images/dfu-gattapp3.png" alt="nRF Connect mobile app connected to PineTime's SMP Service" /></p>
<p><em>nRF Connect mobile app connected to PineTime's SMP Service</em></p>
<p>The circular <code>DFU</code> icon at top right (Direct Firmware Upgrade) appears when the mobile app detects the presence of the SMP Service and Characteristic. Tapping the <code>DFU</code> icon will transmit a firmware update request to PineTime.</p>
<p><em>How shall we implement the SMP protocol in PineTime firmware?</em></p>
<p>Fortunately there's an open-source library that implements the SMP protocol: the <a href="https://github.com/apache/mynewt-mcumgr"><strong>MCU Manager Library</strong></a>. More about this in a while.</p>
<p>For reference, the generic SMP protocol is <a href="https://github.com/apache/mynewt-mcumgr">documented here</a>. The SMP protocol based on Bluetooth LE is <a href="https://github.com/apache/mynewt-mcumgr/blob/master/transport/smp-bluetooth.md">documented here</a>.</p>
<h1 id="robust-firmware-update-on-pinetime-with-rollback" class="section-header"><a href="#robust-firmware-update-on-pinetime-with-rollback">2 Robust Firmware Update on PineTime with Rollback</a></h1>
<p>PineTime Smart Watch will be worn by people of all ages (maybe pets too)... Thus we shall <em>plan for failure!</em></p>
<p><em>What happens if the firmware gets corrupted or truncated while transmitting the firmware update over Bluetooth LE? Will PineTime get bricked?</em></p>
<p>We won't overwrite the existing firmware as we receive the new firmware.  We'll stage the new firmware in a separate area in PineTime's Flash ROM. </p>
<p>We'll overwrite the existing firmware only when we're absolutely sure that the new firmware has passed our integrity checks.</p>
<p><em>What happens if there's a bug in the new firmware that causes PineTime to crash during startup?</em></p>
<p>We'll roll back the firmware to the previous version. Here's how it works...</p>
<p><img src="https://lupyuen.github.io/images/dfu-rollback.png" alt="Firmware Update with Rollback on PineTime" /></p>
<p><em>Firmware Update with Rollback on PineTime</em></p>
<ol>
<li>
<p>PineTime stores two firmware images in Flash ROM: <strong>Active and Standby.</strong> PineTime boots from the Active Firmware Image. It activates the SMP service for firmware update over Bluetooth LE.</p>
</li>
<li>
<p>During firmware update, PineTime writes the received firmware image into the Standby Firmware slot. PineTime checks that the firmware image has been received correctly, and reboots itself.</p>
</li>
<li>
<p>On reboot, the bootloader (MCUBoot) swaps the Active and Standby Firmware images. The bootloader starts the Active Firmware Image (containing the new firmware)</p>
</li>
<li>
<p>If the new firmware doesn't start properly, at the next reboot the bootloader swaps back the Active and Standby Firmware images. The bootloader starts the Active Firmware Image (now containing the old firmware)</p>
</li>
<li>
<p>PineTime should start correctly with the old firmware with SMP service operational. We may perform the firmware update again when the new firmware is fixed.</p>
</li>
</ol>
<p>Thankfully most of this firmware update and rollback logic is built into the <a href="https://github.com/apache/mynewt-mcumgr">MCU Manager Library</a>. For the swapping of firmware we'll use another open-source component: <a href="https://mcuboot.com"><strong>MCUBoot Bootloader</strong></a>.  More about MCUBoot in a while.</p>
<h1 id="pinetime-flash-rom-layout" class="section-header"><a href="#pinetime-flash-rom-layout">3 PineTime Flash ROM Layout</a></h1>
<p>To support firmware update (with rollback) via Bluetooth LE, PineTime Firmware Developers would have to adopt a common layout for storing flash images in Flash ROM.</p>
<p>Here's the proposed <strong>Flash ROM Layout</strong> that supports Active and Standby Firmware Images for firmware update and rollback...</p>
<table><thead><tr><th align="left">¬†¬†¬†¬† Flash ROM Area</th><th align="left">Address</th><th align="right">Size</th></tr></thead><tbody>
<tr><td align="left">¬†¬†¬†¬† Bootloader (MCUBoot)</td><td align="left"><code>0x0000 0000</code></td><td align="right">28 KB</td></tr>
<tr><td align="left">¬†¬†¬†¬† Reboot Log</td><td align="left"><code>0x0000 7000</code></td><td align="right">4 KB</td></tr>
<tr><td align="left">¬†¬†¬†¬† <strong>Active Firmware Image</strong>  ¬†¬†¬†¬†</td><td align="left"><strong><code>0x0000 8000</code></strong></td><td align="right">¬†¬†¬† <strong>464 KB</strong></td></tr>
<tr><td align="left">¬†¬†¬†¬† Scratch Area</td><td align="left"><code>0x0007 C000</code></td><td align="right">4 KB</td></tr>
<tr><td align="left"><br></td><td align="left"></td><td align="right"></td></tr>
</tbody></table>
<p><em>TODO: <code>0x7f00</code> to <code>0x7fff</code> is reserved for the relocated Vector Table. Active Firmware Image should be extended by 12 KB. Scratch Area should be moved down by 12 KB</em></p>
<p>And the layout for <strong>PineTime's SPI Flash</strong>...</p>
<table><thead><tr><th align="left">¬†¬†¬†¬† SPI Flash Area</th><th align="left">Address</th><th align="right">Size</th></tr></thead><tbody>
<tr><td align="left">¬†¬†¬†¬† Bootloader Assets</td><td align="left"><code>0x0000 0000</code></td><td align="right">256 KB</td></tr>
<tr><td align="left">¬†¬†¬†¬† <em>Standby Firmware Image</em> ¬†¬†¬†¬†</td><td align="left"><code>0x0004 0000</code></td><td align="right"><em>464 KB</em></td></tr>
<tr><td align="left">¬†¬†¬†¬† User File System</td><td align="left"><code>0x000B 4000</code></td><td align="right">¬†¬†¬†¬† 3,376 KB</td></tr>
<tr><td align="left"><br></td><td align="left"></td><td align="right"></td></tr>
</tbody></table>
<p><em>TODO: Standby Firmware Image should be extended by 12 KB. User File System should be moved down by 12 KB</em></p>
<p><em>Proposed Flash ROM Layout for PineTime. Derived from this <a href="https://github.com/apache/mynewt-core/blob/master/hw/bsp/nordic_pca10040/bsp.yml">Flash ROM layout for nRF52832</a>.</em></p>
<ol>
<li>
<p><strong>Bootloader</strong>: Located at the start of PineTime's Flash ROM, the open-source <a href="https://mcuboot.com">MCUBoot Bootloader</a> is the first thing that PineTime runs upon booting. </p>
<p>For firmware update and rollback, the Bootloader swaps the Active and Standby Firmware Images. Then it jumps to the Active Firmware code.</p>
</li>
<li>
<p><strong>Reboot Log</strong>: This is a log of debugging messages generated by the firmware upon starting. Useful for debugging startup failures.</p>
</li>
<li>
<p><strong>Active Firmware Image</strong>: Contains PineTime firmware code that will be executed. The image starts with a Firmware Image Header (<code>0x20</code> bytes) followed by the Arm Cortex-M4 Interrupt Vector Table (<code>0xD8</code> bytes).</p>
<p>Hence the executable firmware code begins at address <code>0x0000 80F8</code>. PineTime Firmware Developers should assume that their firmware code will be located at this address.</p>
</li>
<li>
<p><strong>Standby Firmware Image</strong>: Staging area for receiving the new firmware over Bluetooth LE. During firmware update, the Bootloader swaps the Active and Standby Firmware Images, so that the new firmware becomes active.</p>
<p>If the new firmware fails to start, the Bootloader swaps the old firmware back so that the old firmware becomes active.</p>
</li>
<li>
<p><strong>Scratch Area</strong>: Temporary storage used by the Bootloader for swapping the Active and Standby Firmware Images.</p>
</li>
<li>
<p><strong>User File System</strong>: PineTime Firmware Developers may store the user's settings here. The contents of this flash area are preserved during firmware updates.</p>
</li>
</ol>
<p>Now we'll learn how the MCU Manager Library manages the Active and Standby Firmware Images to perform firmware updates.</p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">More details on the Flash ROM Layout</a></p>
<h1 id="mcu-manager-library-for-firmware-update" class="section-header"><a href="#mcu-manager-library-for-firmware-update">4 MCU Manager Library for Firmware Update</a></h1>
<p>Let's look at the <a href="https://github.com/apache/mynewt-mcumgr">MCU Manager Library</a> (coded in C) and how it handles firmware updates...</p>
<p><img src="https://lupyuen.github.io/images/dfu-mcumgr.png" alt="Firmware Update with MCU Manager Library" /></p>
<p><em>Firmware Update with MCU Manager Library</em></p>
<ol>
<li>
<p>Mobile App transmits the new firmware to PineTime over Bluetooth LE in <em>mutiple chunks</em>. Mobile App writes each chunk of firmware as an <strong>Image Upload Request</strong> to the SMP Characteristic on PineTime's GATT interface.</p>
</li>
<li>
<p>The open-source <strong>NimBLE Bluetooth LE</strong> networking stack interprets each Image Upload Request request and calls the <strong>Command Handler for Image Management</strong>, part of the MCU Manager Library. More about NimBLE in a while.</p>
</li>
<li>
<p>Image Management Command Handler (in MCU Manager Library) inspects the Image Upload Request, by calling <code>img_mgmt_impl_upload_inspect</code></p>
</li>
<li>
<p>Image Management Command Handler erases the Standby Firmware Image in PineTime's Flash ROM, by calling <code>img_mgmt_impl_erase_if_needed</code></p>
</li>
<li>
<p>Then it writes the received firmware chunk into the Standby Firmware slot by calling <code>img_mgmt_impl_write_image_data</code></p>
</li>
</ol>
<p>PineTime Firmware Developers would need to implement these functions in C to inspect, erase and write firmware images in Flash ROM...</p>
<ol>
<li>
<p><strong>Inspect Upload:</strong> <code>img_mgmt_impl_upload_inspect(&amp;req, &amp;action, &amp;errstr)</code></p>
<p>Inspects the Image Upload Request in <code>req</code> (<a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/include/img_mgmt/img_mgmt.h#L75-L84">defined here</a>) and returns 0 if valid: </p>
<p><code>off</code>: Offset of this chunk. Starts at 0. <br>
<code>size</code>: Total size of the firmware image <br>
<code>data_len</code>: Size of this chunk <br>
<code>data_sha_len</code>: Size of the SHA hash <br>
<code>upgrade</code>: If true, the version number of the new firmware must be greater than the Active Firmware version in Flash ROM</p>
<p>The function also sets <code>action</code> (<a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/include/img_mgmt/img_mgmt.h#L103-L115">defined here</a>) to specify how the Image Upload Request should be handled:</p>
<p><code>size</code>: Total size of the firmware image <br>
<code>write_bytes</code>: Number of image bytes to write to flash for the chunk <br>
<code>area_id</code>: The flash area to write to <br>
<code>proceed</code>: Whether to process the request; false if offset is wrong. <br>
<code>erase</code>: Whether to erase the destination flash area.</p>
<p>Refer to the reference implementation here: <a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/port/mynewt/src/mynewt_img_mgmt.c#L102-L252"><code>mynewt_img_mgmt.c</code></a></p>
</li>
<li>
<p><strong>Erase Image:</strong> <code>img_mgmt_impl_erase_if_needed(offset, num_bytes)</code></p>
<p>Erase a sector in Flash ROM. Erasing the entire Flash ROM at one time can take significant time, causing Bluetooth disconnect or significant battery sag. That's why we will erase a sector immediately before writing it.</p>
<p>Refer to the reference implementation here: <a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/port/mynewt/src/mynewt_img_mgmt.c#L481-L509"><code>mynewt_img_mgmt.c</code></a></p>
</li>
<li>
<p><strong>Write Image:</strong> <code>img_mgmt_impl_write_image_data(offset, data, num_bytes, last)</code></p>
<p>Write the chunk of uploaded firmware to the Standby Firmware slot. We'll cover this function in the next section.</p>
</li>
</ol>
<p>The usage of these functions may be found in <a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/src/img_mgmt.c#L364-L534"><code>img_mgmt.c</code></a></p>
<p>The complete list of C functions for Image Management to be implemented by PineTime Firmware Developers may be found here: <a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/include/img_mgmt/img_mgmt_impl.h"><code>img_mgmt_impl.h</code></a></p>
<p>Note that the Active Firmware is stored in Slot 0 and the Standby Firmware is stored in Slot 1 (or the Spare Slot).</p>
<h1 id="write-firmware-image-to-pinetimes-flash-rom" class="section-header"><a href="#write-firmware-image-to-pinetimes-flash-rom">5 Write Firmware Image to PineTime's Flash ROM</a></h1>
<p>To update PineTime's firmware over Bluetooth LE, the MCU Manager Library calls <code>img_mgmt_impl_write_image_data</code> to write each chunk of received firmware to PineTime's Flash ROM. PineTime Firmware Developers would have to implement <code>img_mgmt_impl_write_image_data</code> in C, so let's look inside the function...</p>
<pre><code class="language-c">int img_mgmt_impl_write_image_data(
    unsigned int offset, 
    const void *data,
    unsigned int num_bytes, 
    bool last);
</code></pre>
<p><code>img_mgmt_impl_write_image_data</code> writes the chunk of firmware in <code>data</code> to the Standby Firmware Image (Slot 1), at the target offset indicated by <code>offset</code>. </p>
<p><code>num_bytes</code> is the number of bytes in the chunk of firmware. <code>last</code> is true if this is the last chunk of firmware for the entire firmware update. The function returns 0 on success.</p>
<p>According to the <a href="https://github.com/apache/mynewt-mcumgr/blob/master/cmd/img_mgmt/port/mynewt/src/mynewt_img_mgmt.c#L391-L435">reference implementation</a>, the function does the following...</p>
<ol>
<li>
<p>PineTime's Flash ROM is accessed as <strong>Flash ROM Sectors</strong> when writing and erasing the Flash ROM. PineTime's 512 KB Flash ROM is divided into <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/src/hal_flash.c#L73-L81">128 Sectors</a>, with <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/src/hal_flash.c#L26">4 KB per Sector</a>.</p>
</li>
<li>
<p>For every Flash ROM Sector (4 KB each) that will be written:</p>
<p>Call <code>flash_area_getnext_sector( fa-&gt;fa_id, &amp;sector_id, &amp;sector)</code> to get the Flash ROM Sector ID (<code>sector_id</code>, from 0 to 127) and Flash ROM Sector Details (<code>sector</code>).</p>
<p><code>fa</code> is the handle to the Standby Firmware ROM Area.</p>
<p>Then erase the Flash ROM Sector (set all bits to <code>1</code>) by calling <code>flash_area_erase( &amp;sector, 0, sector.fa_size)</code></p>
</li>
<li>
<p>Write the firmware data to the Standby Firmware Flash ROM  by calling <code>flash_area_write( fa, offset, data, num_bytes)</code></p>
</li>
</ol>
<p>For details on the parameters of the <code>flash_area_*</code> functions, refer to the function declarations in <a href="https://github.com/apache/mynewt-core/blob/master/sys/flash_map/include/flash_map/flash_map.h"><code>flash_map.h</code></a></p>
<p><em>Why do we erase PineTime's Flash ROM before writing?</em></p>
<p>PineTime's Internal Flash Controller (<a href="https://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.nrf52832.ps.v1.1%2Fnvmc.html">nRF52832 NVMC</a>) can only write <code>0</code> bits to Flash ROM. To write <code>1</code> bits, we erase the Flash ROM to set all bits to <code>1</code>, then write the <code>0</code> bits.</p>
<p>That's why we call <code>flash_area_erase</code> before <code>flash_area_write</code>.</p>
<p><em>How shall we implement <code>flash_area_erase</code> to erase PineTime's Flash ROM?</em></p>
<p>According to the official documentation...</p>
<p><img src="https://lupyuen.github.io/images/dfu-flash2.png" alt="Erasing Flash ROM on nRF52832" /></p>
<p><em>Erasing Flash ROM on nRF52832. From <a href="https://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.0.pdf">Nordic nRF52832 Product Specification</a></em></p>
<p>We should erase the Flash ROM like this...</p>
<ol>
<li>
<p>Set the <code>CONFIG</code> Register to <code>EEN</code> (value <code>2</code>) to enable erase</p>
</li>
<li>
<p>Set the <code>ERASEPAGE</code> Register to the address of the 4 KB Flash ROM Sector to be erased. (That's the address of the first word in the Flash ROM Sector)</p>
</li>
<li>
<p>Set the <code>CONFIG</code> Register to <code>REN</code> (value <code>0</code>) to disable erase</p>
</li>
</ol>
<p>For the reference implementation of <code>flash_area_erase</code>, check out <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/src/hal_flash.c#L181-L205"><code>nrf52k_flash_erase_sector</code></a> in <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/src/hal_flash.c#L181-L205">Mynewt's Flash Driver for nRF52</a>.</p>
<p><em>How shall we implement <code>flash_area_write</code> to write to PineTime's Flash ROM?</em></p>
<p><img src="https://lupyuen.github.io/images/dfu-flash1.png" alt="Writing to Flash ROM on nRF52832" /></p>
<p><em>Writing to Flash ROM on nRF52832. From <a href="https://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.0.pdf">Nordic nRF52832 Product Specification</a></em></p>
<p>We should write to the Flash ROM like this...</p>
<ol>
<li>
<p>Set the <code>CONFIG</code> Register to <code>WEN</code> (value <code>1</code>) to enable writing</p>
</li>
<li>
<p>Write the data (4 bytes at a time) to the target Flash ROM address</p>
</li>
<li>
<p>Set the <code>CONFIG</code> Register to <code>REN</code> (value <code>0</code>) to disable writing</p>
</li>
</ol>
<p>For the reference implementation of 
<code>flash_area_write</code>, check out <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/src/hal_flash.c#L109-L179"><code>nrf52k_flash_write</code></a> in <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/src/hal_flash.c#L109-L179">Mynewt's Flash Driver for nRF52</a>.</p>
<p><em>How shall we implement <code>flash_area_getnext_sector</code> to get the Flash ROM Sector?</em></p>
<p>The reference implementation of <code>flash_area_getnext_sector</code> may be found in <a href="https://github.com/apache/mynewt-core/blob/master/sys/flash_map/src/flash_map.c#L193-L229"><code>flash_map.c</code></a>.</p>
<p>The function returns the 4 KB Flash ROM Sector that corresponds to an address in the Standby Flash ROM Area, by walking through the list of Flash ROM Sectors.</p>
<h1 id="nimble-stack-for-bluetooth-le-on-pinetime" class="section-header"><a href="#nimble-stack-for-bluetooth-le-on-pinetime">6 NimBLE Stack for Bluetooth LE on PineTime</a></h1>
<p><a href="https://github.com/apache/mynewt-nimble">NimBLE</a> is an open-source networking stack for Bluetooth LE, coded in C. NimBLE talks directly to the Bluetooth hardware controller on PineTime's nRF52 microcontroller. NimBLE supports Nordic nRF51 and nRF52 microcontrollers</p>
<p>To support firmware updates over Bluetooth LE, PineTime Firmware Developers would have to include NimBLE in their firmware. NimBLE takes care of the firmware update process by interpreting GATT Read/Write Requests, and forwarding the SMP Commands to the MCU Manager Library (which writes the new firmware into Flash ROM).</p>
<p><img src="https://lupyuen.github.io/images/dfu-nimble.png" alt="NimBLE Networking Stack for Bluetooth LE on PineTime" /></p>
<p><em>NimBLE Networking Stack for Bluetooth LE on PineTime</em></p>
<p>NimBLE runs in the background handling Bluetooth LE packets, so it depends on the multitasking capabilities provided by the operating system embedded in the firmware. This adaptation of NimBLE to the operating system happens in the <strong>NimBLE Porting Layer</strong>. </p>
<p>PineTime Firmware Developers would have to implement the NimBLE Porting Layer in C, covering these functions...</p>
<ol>
<li>
<p><strong>Time Functions:</strong> Get the elapsed time since startup, in milliseconds and in ticks (1 tick equals 1 millisecond)</p>
</li>
<li>
<p><strong>Mutex Functions:</strong> When multiple tasks run at the same time on PineTime, they may clash when accessing common resources (like the Bluetooth hardware). NimBLE uses a Mutex (Mutually Exclusive Lock) to prevent concurrent access to common resources. <a href="https://mynewt.apache.org/latest/os/core_os/mutex/mutex.html">More about Mutexes</a></p>
</li>
<li>
<p><strong>Semaphore Functions:</strong> A Semaphore works like a Mutex but it's more flexible. Think of a Semaphore as a Ticket Queueing System for shared resources. <a href="https://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html">More about Semaphores</a> </p>
</li>
<li>
<p><strong>Callout Functions:</strong> Callouts are deferred functions that will be executed after a specified time interval. <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html">More about Callouts</a></p>
</li>
<li>
<p><strong>Event Queue Functions:</strong> Event Queues allow a task to delegate processing steps (i.e. Events) to one or more queues and tasks. <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html">More about Event Queues</a></p>
</li>
<li>
<p><strong>Interrupt Functions:</strong> For managing interrupts</p>
</li>
</ol>
<p>We'll see the list of functions at the end of this section.</p>
<p><em>What if our embedded operating system doesn't support Mutex / Semaphore / Callout / Event Queue?</em></p>
<p>It may be possible to emulate the missing functions using the multitasking features found in our operating system. Or we may implement them using simple counters and locks. </p>
<p>Let's check out how the NimBLE Porting Layer was implemented on various operating systems...</p>
<ol>
<li>
<p><strong>RIOT</strong>: Callouts are not supported in RIOT, so they are implemented with a combination of RIOT Timers and Event Queues. See <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/riot/include/nimble/nimble_npl_os.h#L43-L65"><code>riot/nimble_npl_os.h</code></a> and <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/riot/src/npl_os_riot.c"><code>npl_os_riot.c</code></a> from the <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/riot">NimBLE Porting Layer for RIOT</a></p>
</li>
<li>
<p><strong>FreeRTOS</strong>: Callouts are also implemented with Timers and Queues in FreeRTOS. Mutexes are implemented with FreeRTOS Semaphores. See <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/freertos/include/nimble/nimble_npl_os.h#L44-L66"><code>freertos/nimble_npl_os.h</code></a> from the <a href="https://github.com/apache/mynewt-nimble/tree/master/porting/npl/freertos">NimBLE Porting Layer for FreeRTOS</a></p>
</li>
<li>
<p><strong>MicroPython</strong>: Mutexes, Semaphores, Callouts and Event Queues don't exist in MicroPython, so they are implemented using simple counters and locks. See <a href="https://github.com/micropython/micropython/blob/master/extmod/nimble/nimble/nimble_npl_os.h#L38-L64"><code>micropython/nimble_npl_os.h</code></a> and <a href="https://github.com/micropython/micropython/blob/master/extmod/nimble/nimble/npl_os.c"><code>npl_os.c</code></a> from the <a href="https://github.com/micropython/micropython/tree/master/extmod/nimble">NimBLE Porting Layer for MicroPython</a></p>
</li>
<li>
<p><strong>Mynewt</strong>: NimBLE was created originally for Mynewt. Thus Mutexes, Semaphores, Callouts and Event Queues are used directly from Mynewt. See <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/mynewt/include/nimble/nimble_npl_os.h#L37-L60"><code>mynewt/nimble_npl_os.h</code></a> from the <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/mynewt">NimBLE Porting Layer for Mynewt</a></p>
</li>
</ol>
<p>For porting NimBLE to Real Time Operating Systems, we may use <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/riot">NimBLE Porting Layer for RIOT</a> as the reference.</p>
<p>Otherwise we may use the <a href="https://github.com/micropython/micropython/tree/master/extmod/nimble">NimBLE Porting Layer for MicroPython</a>.</p>
<p><em>What is the Interrupt Service Routine in the diagram above?</em></p>
<p>When PineTime receives a Bluetooth LE data packet, the Bluetooth hardware controller triggers an Interrupt. The <a href="https://en.wikipedia.org/wiki/Interrupt_handler">Interrupt Service Routine</a> is the function provided by NimBLE to handle that Interrupt.</p>
<p>The Interrupt Service Routine forwards all received packets to the NimBLE background task for processing. We'll see in a while how NimBLE calls the NimBLE Porting Layer to set the Interrupt Service Routine.</p>
<p><em>Why does NimBLE need Event Queues?</em></p>
<p>The NimBLE Interrupt Service Routine runs at a higher priority than normal tasks (because handling interrupts needs to be super urgent). But it shouldn't hog the CPU and process the received Bluetooth packet immediately... That wouldn't be fair to other tasks!</p>
<p>Hence the NimBLE Interrupt Service Routine defers the processing of the received Bluetooth packet by adding it to an Event Queue. Another NimBLE task (running at normal priority) will pick up the Bluetooth packet and process it.</p>
<p><em>How shall we start the NimBLE Stack and listen for firmware update commands?</em></p>
<p>PineTime Firmware Developers would have to call the C function <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/apps/my_sensor_app/src/ble_main.c#L300-L357"><code>start_ble()</code></a> defined in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/apps/my_sensor_app/src/ble_main.c#L300-L357"><code>ble_main.c</code></a></p>
<p>This starts the NimBLE Stack to listen for SMP firmware update commands transmitted over GATT.  The GATT command handlers for SMP are defined in  <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/apps/my_sensor_app/src/ble_prph.h"><code>ble_prph.h</code></a>, 
<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/apps/my_sensor_app/src/ble_gatt_svr.c"><code>ble_gatt_svr.c</code></a>, 
<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/apps/my_sensor_app/src/ble_misc.c"><code>ble_misc.c</code></a> and
<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/apps/my_sensor_app/src/ble_phy.c"><code>ble_phy.c</code></a></p>
<p>Here are the types and functions in the NimBLE Porting Layer that would be implemented by the PineTime Firmware Developer...</p>
<h2 id="nimble-types" class="section-header"><a href="#nimble-types">6.1 NimBLE Types</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>struct </code> <br> <strong><code>ble_npl_mutex</code></strong> <br><br></td><td align="left">Contains the OS-specific Mutex</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/mutex/mutex.html#c.os_mutex"><code>os_mutex</code></a></td></tr>
<tr><td align="left"><code>struct </code> <br> <strong><code>ble_npl_sem</code></strong> <br><br></td><td align="left">Contains the OS-specific Semaphore</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html#c.os_sem"><code>os_sem</code></a></td></tr>
<tr><td align="left"><code>struct </code> <br> <strong><code>ble_npl_callout</code></strong> <br><br></td><td align="left">Contains the OS-specific Callout</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html#c.os_callout"><code>os_callout</code></a></td></tr>
<tr><td align="left"><code>struct</code> <br> <strong><code>ble_npl_event</code></strong> <br><br></td><td align="left">Contains the OS-specific Event</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_event"><code>os_event</code></a></td></tr>
<tr><td align="left"><code>struct </code> <br> <strong><code>ble_npl_eventq</code></strong> <br><br></td><td align="left">Contains the OS-specific Event Queue</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_eventq"><code>os_eventq</code></a></td></tr>
<tr><td align="left"><code>typedef </code> <br> <strong><code>ble_npl_time_t</code></strong> <br><br></td><td align="left">OS-specific unsigned type that represents elapsed time, like <code>uint32_t</code></td><td align="left"></td></tr>
<tr><td align="left"><code>typedef </code> <br> <strong><code>ble_npl_stime_t</code></strong> <br><br></td><td align="left">OS-specific signed type that represents elapsed time, like <code>int32_t</code></td><td align="left"></td></tr>
</tbody></table>
<h2 id="nimble-general-functions" class="section-header"><a href="#nimble-general-functions">6.2 NimBLE General Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>bool </code> <br> <strong><code>ble_npl_os_started()</code></strong> <br><br></td><td align="left">Return true if OS has started and is ready to run tasks</td><td align="left">See <code>os_started</code> in <a href="https://github.com/apache/mynewt-core/blob/master/kernel/os/include/os/os.h#L70-L75"><code>os.h</code></a> and <a href="https://github.com/apache/mynewt-core/blob/master/kernel/os/src/arch/cortex_m4/os_arch_arm.c#L277-L299"><code>os_arch_arm.c</code></a></td></tr>
<tr><td align="left"><code>void *</code> <br> <strong><code>ble_npl_get_current_task_id()</code></strong> <br><br></td><td align="left">Returns the currently running task</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/context_switch/context_switch.html#c.os_sched_get_current_task"><code>os_sched_get_current_task</code></a></td></tr>
</tbody></table>
<h2 id="nimble-mutex-functions" class="section-header"><a href="#nimble-mutex-functions">6.3 NimBLE Mutex Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_mutex_init(</code></strong> <br> <code>struct ble_npl_mutex *mu)</code> <br><br></td><td align="left">Create a Mutex and initialise it</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/mutex/mutex.html?highlight=os_mutex_init#c.os_mutex_init"><code>os_mutex_init(&amp;mu-&gt;mu)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_mutex_pend(</code></strong> <br> <code>struct ble_npl_mutex *mu,</code> <br> <code>ble_npl_time_t timeout)</code> <br><br></td><td align="left">Wait for a Mutex</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/mutex/mutex.html?highlight=os_mutex_pend#c.os_mutex_pend"><code>os_mutex_pend(&amp;mu-&gt;mu, timeout)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_mutex_release(</code></strong> <br> <code>struct ble_npl_mutex *mu)</code> <br><br></td><td align="left">Release a Mutex</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/mutex/mutex.html?highlight=os_mutex_release#c.os_mutex_release"><code>os_mutex_release(&amp;mu-&gt;mu)</code></a></td></tr>
</tbody></table>
<h2 id="nimble-semaphore-functions" class="section-header"><a href="#nimble-semaphore-functions">6.4 NimBLE Semaphore Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_sem_init(</code></strong> <br> <code>struct ble_npl_sem *sem, </code> <br> <code>uint16_t tokens)</code> <br><br></td><td align="left">Create a Semaphore and initialise it</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html?highlight=os_sem_init#c.os_sem_init"><code>os_sem_init(&amp;sem-&gt;sem, tokens</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_sem_pend(</code></strong> <br> <code>struct ble_npl_sem *sem,</code> <br> <code>ble_npl_time_t timeout)</code> <br><br></td><td align="left">Wait for a Semaphore</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html?highlight=os_sem_pend#c.os_sem_pend"><code>os_sem_pend(&amp;sem-&gt;sem, timeout)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_sem_release(</code></strong> <br> <code>struct ble_npl_sem *sem)</code> <br><br></td><td align="left">Release a Semaphore</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html?highlight=os_sem_release#c.os_sem_release"><code>os_sem_release(&amp;sem-&gt;sem)</code></a></td></tr>
<tr><td align="left"><code>uint16_t </code> <br> <strong><code>ble_npl_sem_get_count(</code></strong> <br> <code>struct ble_npl_sem *sem)</code> <br><br></td><td align="left">Get the Semaphore's current count</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/semaphore/semaphore.html?highlight=os_sem_get_count#c.os_sem_get_count"><code>os_sem_get_count(&amp;sem-&gt;sem)</code></a></td></tr>
</tbody></table>
<h2 id="nimble-callout-functions" class="section-header"><a href="#nimble-callout-functions">6.5 NimBLE Callout Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_callout_init(</code></strong> <br> <code>struct ble_npl_callout *co, </code> <br> <code>struct ble_npl_eventq *evq, </code> <br> <code>ble_npl_event_fn *ev_cb, </code> <br> <code>void *ev_arg)</code> <br><br></td><td align="left">Create a Callout and initialise it</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html?highlight=os_callout_init#c.os_callout_init"><code>os_callout_init(&amp;co-&gt;co, &amp;evq-&gt;evq, ev_cb, ev_arg)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t </code> <br> <strong><code>ble_npl_callout_reset(</code></strong> <br> <code>struct ble_npl_callout *co, </code> <br> <code>ble_npl_time_t ticks)</code> <br><br></td><td align="left">Reset the callout to fire off in <code>ticks</code> ticks</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html?highlight=os_callout_reset#c.os_callout_reset"><code>os_callout_reset(&amp;co-&gt;co, ticks)</code></a></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_callout_stop(</code></strong> <br> <code>struct ble_npl_callout *co)</code> <br><br></td><td align="left">Stop the Callout from firing off, any pending events will be cleared</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html?highlight=os_callout_stop#c.os_callout_stop"><code>os_callout_stop(&amp;co-&gt;co)</code></a></td></tr>
<tr><td align="left"><code>bool </code> <br> <strong><code>ble_npl_callout_is_active(</code></strong> <br> <code>struct ble_npl_callout *co)</code> <br><br></td><td align="left">Returns whether the Callout is pending or not</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html?highlight=os_callout_queued#c.os_callout_queued"><code>os_callout_queued(&amp;co-&gt;co)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_time_t </code> <br> <strong><code>ble_npl_callout_get_ticks(</code></strong> <br> <code>struct ble_npl_callout *co)</code> <br><br></td><td align="left">Number of ticks in the future to expire the Callout</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html?highlight=c_ticks#c.os_callout::c_ticks"><code>co-&gt;co.c_ticks</code></a></td></tr>
<tr><td align="left"><code>ble_npl_time_t </code> <br> <strong><code>ble_npl_callout_remaining_ticks(</code></strong> <br> <code>struct ble_npl_callout *co, </code> <br> <code>ble_npl_time_t time)</code> <br><br></td><td align="left">Returns the number of ticks which remains till Callout</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html?highlight=os_callout_remaining_ticks#c.os_callout_remaining_ticks"><code>os_callout_remaining_ticks(&amp;co-&gt;co, time)</code></a></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_callout_set_arg(</code></strong> <br> <code>struct ble_npl_callout *co, </code> <br> <code>void *arg)</code> <br><br></td><td align="left">Set the argument that will be passed to the Callout callback</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_event::ev_arg"><code>co-&gt;co.c_ev.ev_arg</code></a></td></tr>
</tbody></table>
<h2 id="nimble-event-queue-functions" class="section-header"><a href="#nimble-event-queue-functions">6.6 NimBLE Event Queue Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_eventq_init(</code></strong> <br> <code>struct ble_npl_eventq *evq)</code> <br><br></td><td align="left">Create an Event Queue and initialise it</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html?highlight=os_eventq_init#c.os_eventq_init"><code>os_eventq_init(&amp;evq-&gt;evq)</code></a></td></tr>
<tr><td align="left"><code>struct ble_npl_event *</code> <br> <strong><code>ble_npl_eventq_get(</code></strong> <br> <code>struct ble_npl_eventq *evq, </code> <br> <code>ble_npl_time_t tmo)</code> <br><br></td><td align="left">Pull a single Event from an Event Queue</td><td align="left">See <a href="https://gist.github.com/lupyuen/5da47d633315039e76262434a4faae46">this note</a></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_eventq_put(</code></strong> <br> <code>struct ble_npl_eventq *evq, </code> <br> <code>struct ble_npl_event *ev)</code> <br><br></td><td align="left">Put an Event on the Event Gueue</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_eventq_put"><code>os_eventq_put(&amp;evq-&gt;evq, &amp;ev-&gt;ev)</code></a></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_eventq_remove(</code></strong> <br> <code>struct ble_npl_eventq *evq, </code> <br> <code>struct ble_npl_event *ev)</code> <br><br></td><td align="left">Remove an Event from the Event Queue</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_eventq_remove"><code>os_eventq_remove</code></a></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_event_init(</code></strong> <br> <code>struct ble_npl_event *ev, </code> <br> <code>ble_npl_event_fn *fn, </code> <br> <code>void *arg)</code> <br><br></td><td align="left">Create an Event and initialise it</td><td align="left">See <a href="https://gist.github.com/lupyuen/5da47d633315039e76262434a4faae46">this note</a></td></tr>
<tr><td align="left"><code>bool </code> <br> <strong><code>ble_npl_event_is_queued(</code></strong> <br> <code>struct ble_npl_event *ev)</code> <br><br></td><td align="left">Return true if the Event is queued on an Event Queue</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_event::ev_queued"><code>ev-&gt;ev.ev_queued</code></a></td></tr>
<tr><td align="left"><code>void *</code> <br> <strong><code>ble_npl_event_get_arg(</code></strong> <br> <code>struct ble_npl_event *ev)</code> <br><br></td><td align="left">Return the argument that will be passed to the Event Queue callback</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_event::ev_arg"><code>ev-&gt;ev.ev_arg</code></a></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_event_set_arg(</code></strong> <br> <code>struct ble_npl_event *ev, </code> <br> <code>void *arg)</code> <br><br></td><td align="left">Set the argument that will be passed to the Event Queue callback</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_event::ev_arg"><code>ev-&gt;ev.ev_arg</code></a></td></tr>
<tr><td align="left"><code>bool </code> <br> <strong><code>ble_npl_eventq_is_empty(</code></strong> <br> <code>struct ble_npl_eventq *evq)</code> <br><br></td><td align="left">Return true if the Event Queue is empty</td><td align="left"></td></tr>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_event_run(</code></strong> <br> <code>struct ble_npl_event *ev)</code> <br><br></td><td align="left">Execute the Event callback</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/event_queue/event_queue.html#c.os_event::ev_cb"><code>ev-&gt;ev.ev_cb(&amp;ev-&gt;ev)</code></a></td></tr>
</tbody></table>
<h2 id="nimble-time-functions" class="section-header"><a href="#nimble-time-functions">6.7 NimBLE Time Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>ble_npl_time_t</code> <br> <strong><code>ble_npl_time_get()</code></strong> <br><br></td><td align="left">Get the current OS time in ticks</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/time/os_time.html?highlight=os_time_get#c.os_time_get"><code>os_time_get()</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t</code> <br> <strong><code>ble_npl_time_ms_to_ticks(</code></strong> <br> <code>uint32_t ms, </code> <br> <code>ble_npl_time_t *out_ticks)</code> <br><br></td><td align="left">Converts milliseconds to OS ticks</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/time/os_time.html?highlight=os_time_ms_to_ticks#c.os_time_ms_to_ticks"><code>os_time_ms_to_ticks(ms, out_ticks)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_error_t</code> <br> <strong><code>ble_npl_time_ticks_to_ms(</code></strong> <br> <code>ble_npl_time_t ticks, </code> <br> <code>uint32_t *out_ms)</code> <br><br></td><td align="left">Converts OS ticks to milliseconds</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/time/os_time.html?highlight=os_time_ticks_to_ms#c.os_time_ticks_to_ms"><code>os_time_ticks_to_ms(ticks, out_ms)</code></a></td></tr>
<tr><td align="left"><code>ble_npl_time_t</code> <br> <strong><code>ble_npl_time_ms_to_ticks32(</code></strong> <br> <code>uint32_t ms)</code> <br><br></td><td align="left">Converts milliseconds to OS ticks</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/time/os_time.html?highlight=os_time_ms_to_ticks32#c.os_time_ms_to_ticks32"><code>os_time_ms_to_ticks32(ms)</code></a></td></tr>
<tr><td align="left"><code>uint32_t</code> <br> <strong><code>ble_npl_time_ticks_to_ms32(</code></strong> <br> <code>ble_npl_time_t ticks)</code> <br><br></td><td align="left">Converts OS ticks to milliseconds</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/time/os_time.html?highlight=os_time_ticks_to_ms32#c.os_time_ticks_to_ms32"><code>os_time_ticks_to_ms32(ticks)</code></a></td></tr>
<tr><td align="left"><code>void</code> <br> <strong><code>ble_npl_time_delay(</code></strong> <br> <code>ble_npl_time_t ticks)</code> <br><br></td><td align="left">Puts the current task to sleep for the specified number of os ticks</td><td align="left">See <a href="https://mynewt.apache.org/latest/os/core_os/time/os_time.html?highlight=os_time_delay#c.os_time_delay"><code>os_time_delay(ticks)</code></a></td></tr>
</tbody></table>
<h2 id="nimble-interrupt-functions" class="section-header"><a href="#nimble-interrupt-functions">6.8 NimBLE Interrupt Functions</a></h2><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th align="left">Documentation</th></tr></thead><tbody>
<tr><td align="left"><code>void </code> <br> <strong><code>ble_npl_hw_set_isr(</code></strong> <br><code>int irqn, </code> <br> <code>void (*addr)(void))</code> <br><br></td><td align="left">Set the Interrupt Service Routine for interrupt <code>irqn</code> to <code>addr</code></td><td align="left">See the RIOT implementation of <code>ble_npl_hw_set_isr</code> in <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/riot/src/nrf5x_isr.c"><code>nrf5x_isr.c</code></a></td></tr>
<tr><td align="left"><code>uint32_t</code> <br> <strong><code>ble_npl_hw_enter_critical</code></strong><code>()</code> <br><br></td><td align="left">Disable interrupts</td><td align="left">See <a href="https://github.com/apache/mynewt-core/blob/master/kernel/os/src/arch/cortex_m4/os_arch_arm.c#L126-L140"><code>os_arch_save_sr()</code></a></td></tr>
<tr><td align="left"><code>void</code> <br> <strong><code>ble_npl_hw_exit_critical(</code></strong> <br> <code>uint32_t ctx)</code> <br><br></td><td align="left">Enable interrupts</td><td align="left">See <a href="https://github.com/apache/mynewt-core/blob/master/kernel/os/src/arch/cortex_m4/os_arch_arm.c#L142-L152"><code>os_arch_restore_sr(ctx)</code></a></td></tr>
<tr><td align="left"><code>bool</code> <br> <strong><code>ble_npl_hw_is_in_critical</code></strong><code>()</code> <br><br></td><td align="left">Returns true if interrupts are disabled</td><td align="left"></td></tr>
<tr><td align="left"><br></td><td align="left"></td><td align="left"></td></tr>
</tbody></table>
<p>The complete list of NimBLE Porting Library functions to be implemented by PineTime Firmware Developers may be found in <a href="https://github.com/apache/mynewt-nimble/blob/master/nimble/include/nimble/nimble_npl.h"><code>nimble_npl.h</code></a></p>
<p>The documentation above was derived from <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/mynewt/include/nimble/nimble_npl_os.h"><code>mynewt/nimble_npl_os.h</code></a> from the <a href="https://github.com/apache/mynewt-nimble/blob/master/porting/npl/mynewt">NimBLE Porting Layer for Mynewt</a></p>
<p><em><a href="https://github.com/apache/mynewt-nimble">Browse the NimBLE source code</a></em></p>
<h1 id="mcuboot-bootloader-for-pinetime" class="section-header"><a href="#mcuboot-bootloader-for-pinetime">7 MCUBoot Bootloader for PineTime</a></h1>
<p>We have covered two software components necessary for rolling out PineTime firmware updates over Bluetooth LE...</p>
<ol>
<li>
<p><strong>MCU Manager Library:</strong> Implements the Simple Management Protocol for updating firmware</p>
</li>
<li>
<p><strong>NimBLE Bluetooth Stack:</strong> Implements the Bluetooth LE network transport for communicating with mobile phones</p>
</li>
</ol>
<p>Now we'll cover the third and final open-source component: <a href="https://mcuboot.com"><strong>MCUBoot Bootloader</strong></a>.  When PineTime has been configured for firmware update, the MCUBoot Bootloader is the first thing that PineTime executes when booting.</p>
<p>MCUBoot (coded in C) plays a critical role in the firmware update process... During firmware update, MCUBoot swaps the old and new firmware images (and swaps them back if the new firmware fails to start)</p>
<p><img src="https://lupyuen.github.io/images/dfu-rollback.png" alt="Firmware Update with Rollback on PineTime" /></p>
<p><em>What's inside the Firmware Image?</em></p>
<p>For flashing firmware over Bluetooth, PineTime Firmware Developers would have to generate a Firmware Image File with this layout that MCUBoot understands...</p>
<table><thead><tr><th align="left">ROM Address¬†¬†¬†¬†</th><th align="left">Offset in Image File¬†¬†¬†¬†</th><th align="right">Size in bytes¬†¬†¬†¬†</th><th align="left">Contents</th></tr></thead><tbody>
<tr><td align="left"><code>0x8000</code></td><td align="left"><code>0x0000</code></td><td align="right">32 (<code>0x20</code>)¬†¬†¬†¬†</td><td align="left">Image Header</td></tr>
<tr><td align="left"><code>0x8020</code></td><td align="left"><code>0x0020</code></td><td align="right">216 (<code>0xD8</code>)¬†¬†¬†¬†</td><td align="left">Interrupt Vector Table</td></tr>
<tr><td align="left"><code>0x80F8</code></td><td align="left"><code>0x00F8</code></td><td align="right"></td><td align="left">Firmware Code and Data</td></tr>
<tr><td align="left"><br></td><td align="left"></td><td align="right"></td><td align="left"></td></tr>
</tbody></table>
<p>This layout looks clearer when we peek inside a Firmware Image File <code>my_sensor_app.img</code> with the command...</p>
<pre><code class="language-bash">od -A x -t x1 my_sensor_app.img
</code></pre>
<p><img src="https://lupyuen.github.io/images/dfu-image.png" alt="Firmware Update Image for PineTime" /></p>
<p><em>What's inside the Image Header?</em></p>
<p>The Image Header consists of 32 bytes (<code>0x20</code>) in little endian byte order (<a href="https://mcuboot.com/design.html">as defined here</a>)...</p>
<table><thead><tr><th align="left">ROM Address</th><th align="left">Offset in <br> Image File</th><th align="right">Size <br> (bytes)</th><th align="left">Example</th><th align="left">Contents</th></tr></thead><tbody>
<tr><td align="left"><code>0x8000</code>¬†¬†</td><td align="left"><code>0x0000</code>¬†¬†</td><td align="right">4 ¬†¬†¬†¬†</td><td align="left"><code>3d  b8  f3  96</code> ¬†¬†¬†¬†</td><td align="left"><code>ih_magic</code>: <br> Magic Number, <br> must be <code>3d  b8  f3  96</code> <br><br></td></tr>
<tr><td align="left"><code>0x8004</code></td><td align="left"><code>0x0004</code></td><td align="right">4 ¬†¬†¬†¬†</td><td align="left"><code>00  00  00  00</code></td><td align="left"><code>ih_load_addr</code>: <br> Must be <code>00 00 00 00</code> <br><br></td></tr>
<tr><td align="left"><code>0x8008</code></td><td align="left"><code>0x0008</code></td><td align="right">2 ¬†¬†¬†¬†</td><td align="left"><code>20  00</code></td><td align="left"><code>ih_hdr_size</code>: <br> Size of image header, must be 32 (<code>0x20</code>) <br><br></td></tr>
<tr><td align="left"><code>0x800A</code></td><td align="left"><code>0x000A</code></td><td align="right">2 ¬†¬†¬†¬†</td><td align="left"><code>00  00</code></td><td align="left"><code>ih_protect_tlv_size</code>:  <br> Size of protected TLV area, in bytes. <br> Usually <code>00 00</code> <br><br></td></tr>
<tr><td align="left"><code>0x800C</code></td><td align="left"><code>0x000C</code></td><td align="right">4 ¬†¬†¬†¬†</td><td align="left"><code>18  29  03  00</code></td><td align="left"><code>ih_img_size</code>: <br> Size of firmware image, in bytes. <br> Does not include header. <br> In this example, <code>0x032918</code> = 207,128 bytes <br><br></td></tr>
<tr><td align="left"><code>0x8010</code></td><td align="left"><code>0x0010</code></td><td align="right">4 ¬†¬†¬†¬†</td><td align="left"><code>00  00  00  00</code></td><td align="left"><code>ih_flags</code>: <br> <code>IMAGE_F_[...]</code> flags, <br> usually <code>00 00 00 00</code> <br><br></td></tr>
<tr><td align="left"><code>0x8014</code></td><td align="left"><code>0x0014</code></td><td align="right">1 ¬†¬†¬†¬†</td><td align="left"><code>01</code></td><td align="left"><code>ih_ver.iv_major</code>: <br> Major version number <br><br></td></tr>
<tr><td align="left"><code>0x8015</code></td><td align="left"><code>0x0015</code></td><td align="right">1 ¬†¬†¬†¬†</td><td align="left"><code>00</code></td><td align="left"><code>ih_ver.iv_minor</code>: <br> Minor version number <br><br></td></tr>
<tr><td align="left"><code>0x8016</code></td><td align="left"><code>0x0016</code></td><td align="right">2 ¬†¬†¬†¬†</td><td align="left"><code>00  00</code></td><td align="left"><code>ih_ver.iv_revision</code>: <br> Revision number <br><br></td></tr>
<tr><td align="left"><code>0x8018</code></td><td align="left"><code>0x0018</code></td><td align="right">4 ¬†¬†¬†¬†</td><td align="left"><code>00  00  00  00</code></td><td align="left"><code>ih_ver.iv_build_num</code>: <br> Build number <br><br></td></tr>
<tr><td align="left"><code>0x801C</code></td><td align="left"><code>0x001C</code></td><td align="right">4 ¬†¬†¬†¬†</td><td align="left"><code>00  00  00  00</code></td><td align="left"><code>_pad1</code>: <br> Padding, must be <code>00 00 00 00</code> <br><br></td></tr>
</tbody></table>
<p><em>How shall we generate a Firmware Image that contains the Image Header?</em></p>
<p>MCUBoot provides a script <code>imgtool.py</code> (<a href="https://github.com/JuulLabs-OSS/mcuboot/tree/master/scripts">located here</a>) that generates a Firmware Image using the Firmware ELF File produced by the GCC Compiler.</p>
<p>More about <code>imgtool.py</code> in the next section.</p>
<p><em>How does MCUBoot know if the new firmware is bad... And needs to be rolled back to the old firmware?</em></p>
<p>PineTime Firmware Developers need to set the <strong>Firmware OK</strong> status when the new firmware is running fine. </p>
<p>During startup, MCUBoot checks the Firmware OK status. If the Firmware OK status is missing, it rolls back to the old firmware.</p>
<p>More about the Firmware OK status later.</p>
<p><em>When shall we mark the new firmware as OK?</em></p>
<p>When new firmware runs on PineTime, it shall display a message prompt to indicate that the new firmware is indeed running...</p>
<p><em>&quot;Mynewt on PineTime has been updated to version 2.0.1&quot;</em></p>
<p>When the user taps <code>OK</code>, the firmware shall write the Firmware OK status.</p>
<p>This ensures that the new firmware is able to start up, display messages and accept input properly.</p>
<p><em>Do we need to build MCUBoot ourselves?</em></p>
<p>Good news for PineTime Firmware Developers: We don't need to build MCUBoot ourselves or link it with our firmware... Just use the <strong>Common Build of MCUBoot Bootloader</strong> that I have prepared!</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/releases/tag/v4.0.1"><code>pinetime-rust-mynewt/releases/tag/v4.0.1</code></a></p>
<p>This build of MCUBoot (<code>mynewt.elf.bin</code>) assumes that the PineTime firmware follows the Flash ROM Map described earlier in this article. The MCUBoot image should be flashed to PineTime at address <code>0x0</code>.</p>
<p>Here are the build settings and build script for MCUBoot: <a href="https://www.github.com/lupyuen/pinetime-rust-mynewt/tree/ota/targets%2Fnrf52_boot"><code>targets/nrf52_boot</code></a>, <a href="https://www.github.com/lupyuen/pinetime-rust-mynewt/tree/ota/scripts%2Fnrf52%2Fbuild-boot.sh"><code>build-boot.sh</code></a></p>
<p>MCUBoot may be flashed to PineTime with these OpenOCD scripts: <a href="https://www.github.com/lupyuen/pinetime-rust-mynewt/tree/ota/scripts%2Fnrf52%2Fflash-boot.sh"><code>flash-boot.sh</code></a>, <a href="https://www.github.com/lupyuen/pinetime-rust-mynewt/tree/ota/scripts%2Fnrf52%2Fflash-boot.ocd"><code>flash-boot.ocd</code></a></p>
<h1 id="generate-a-firmware-image-file-for-pinetime" class="section-header"><a href="#generate-a-firmware-image-file-for-pinetime">8 Generate a Firmware Image File for PineTime</a></h1>
<p>To flash PineTime over Bluetooth LE, PineTime Firmware Developers would have to create a Firmware Image File that includes the Image Header (used by MCUBoot for swapping firmware images).</p>
<p>Here are the steps for creating the Firmware Image File...</p>
<ol>
<li>
<p><strong>Modify the GCC Linker Script</strong> for our firmware to include the Image Header</p>
</li>
<li>
<p>Build our firmware with the modified Linker Script to create a <strong>Firmware ELF File</strong></p>
</li>
<li>
<p>Convert the ELF file to a <strong>Firmware BIN File</strong> with <code>arm-none-eabi-objcopy</code></p>
</li>
<li>
<p>Convert the BIN file to a <strong>Firmware Image File</strong> with MCUBoot's <code>imgtool.py</code> script</p>
</li>
</ol>
<p>Thus the flow goes like this...</p>
<p><img src="https://lupyuen.github.io/images/dfu-imgtool.png" alt="Generate a Firmware Image File for PineTime" /></p>
<p><em>How shall we modify the GCC Linker Script for our firmware to include the Image Header?</em></p>
<p>For building our firmware, we'll modify our Linker Script like this (See <a href="https://github.com/apache/mynewt-core/blob/master/hw/mcu/nordic/nrf52xxx/nrf52.ld"><code>nrf52.ld</code></a> and <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota/hw/bsp/nrf52/nrf52xxaa.ld"><code>nrf52xxaa.ld</code></a>)</p>
<pre><code class="language-text">_imghdr_size = 0x20;

MEMORY
{
  FLASH (rx) : ORIGIN = 0x00008000, LENGTH = 464K
  RAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 64K
}

SECTIONS
{
    .imghdr (NOLOAD):
    {
        . = . + _imghdr_size;
    } &gt; FLASH

    __text = .;

    .text :
    {
        __isr_vector_start = .;
        KEEP(*(.isr_vector))
        __isr_vector_end = .;
        *(.text*)
</code></pre>
<p>This Linker Script says...</p>
<ol>
<li>
<p>The usable Flash ROM (<code>FLASH</code>) starts at address <code>0x8000</code> with size 464 KB. RAM starts at address <code>0x2000 0000</code> with size 64 KB.</p>
</li>
<li>
<p>At the beginning of the Firmware Image in Flash ROM (<code>FLASH</code>), reserve 32 bytes (<code>_imghdr_size</code>) for the Image Header (<code>.imghdr</code>)</p>
</li>
<li>
<p>After the Image Header, write the Text Section (<code>.text</code>) into the Firmware Image. The Text Section contains the firmware code and data.</p>
</li>
<li>
<p>At the start of the Text Section, write out the standard Interrupt Vector Table (<code>.isr_vector</code>), which has 216 bytes (<code>0xD8</code>)</p>
</li>
</ol>
<p>When GCC links our firmware with the above Linker Script, it produces a <a href="https://linuxhint.com/understanding_elf_file_format/">Firmware ELF File</a> that has the following layout...</p>
<pre><code class="language-text">/* Section   Address      Size */
.imghdr      0x8000       0x20
.text        0x8020    0x32578
 .isr_vector 0x8020       0xd8
             0x80f8 Reset_Handler
</code></pre>
<p>In the example above, <code>Reset_Handler</code> is the first function in our firmware. That's why it was allocated address <code>0x80f8</code>.</p>
<p><em>How shall we convert the Firmware ELF File to a Firmware BIN File?</em></p>
<p>To create the Firmware BIN File <code>my_sensor_app.elf.bin</code> from the Firmware ELF File <code>my_sensor_app.elf</code>, we run <code>arm-none-eabi-objcopy</code> (<a href="http://web.mit.edu/gnu/doc/html/binutils_4.html">documented here</a>)...</p>
<pre><code class="language-text">arm-none-eabi-objcopy \
    -R .bss \
    -R .bss.core \
    -R .bss.core.nz \
    -O binary \
    my_sensor_app.elf \
    my_sensor_app.elf.bin
</code></pre>
<p>(Refer to <a href="https://github.com/lupyuen/pinetime-rust-mynewt/releases/tag/v4.0.1"><code>my_sensor_app.elf.cmd</code></a>)</p>
<p><code>arm-none-eabi-objcopy</code> takes an ELF file compiled for Arm Cortex-M and copies the binary sections (code and data) to the BIN file. It strips away the ELF headers and other metadata that are not required at runtime.</p>
<p>We use the <code>-R</code> option to remove unwanted ELF sections from the Firmware BIN File. The unwanted sections (like <code>.bss.core</code>) may be named differently for your embedded operating system.</p>
<p><em>How shall we convert the Firmware BIN File to a Firmware Image File?</em></p>
<p>MCUBoot provides a script <code>imgtool.py</code> (<a href="https://github.com/JuulLabs-OSS/mcuboot/tree/master/scripts">located here</a>) that takes a Firmware BIN File and produces the Firmware Image File.</p>
<p>Here's how we generate the Firmware Image File <code>my_sensor_app.img</code> from a Firmware BIN File <code>my_sensor_app.elf.bin</code>...</p>
<pre><code class="language-bash"># Install Python modules needed by imgtool.py
pip3 install --user -r mcuboot/scripts/requirements.txt 

# Generate the Firmware Image File (including Image Header) from the Firmware BIN file
# Based on our updated Flash ROM Layout, the Firmware Image Slot Size is 464 KB (475,136 bytes)
mcuboot/scripts/imgtool.py create \
  --align 4 \
  --version 1.0.0 \
  --header-size 32 \
  --slot-size 475136 \
  --pad-header \
  my_sensor_app.elf.bin \
  my_sensor_app.img

# Verify the Firmware Image
mcuboot/scripts/imgtool.py verify my_sensor_app.img
# Should show:
# Image was correctly validated
# Image version: 1.0.0+0
</code></pre>
<p>This produces the Firmware Image File <code>my_sensor_app.img</code> that PineTime Owners may use to flash PineTime over Bluetooth LE.</p>
<p><em>In the above Linker Script, why is the Image Header (<code>.imghdr</code>) marked as <code>NOLOAD</code>?</em></p>
<p><code>NOLOAD</code> means that the Image Header will NOT be written to the Firmware BIN File. Let's compare the Firmware BIN and Firmware Image Files...</p>
<p><img src="https://lupyuen.github.io/images/dfu-image2.png" alt="Firmware BIN vs Image File" /></p>
<p>The files are identical... Just that the Firmware BIN File doesn't have the Image Header.</p>
<p>Thus when <code>imgtool.py</code> transforms the Firmware BIN File to a Firmware Image File... It's merely inserting the Image Header at the front of the BIN file!</p>
<p>That's why we use <code>NOLOAD</code> to drop the empty Image Header from the BIN file, and let <code>imgtool.py</code> insert a proper Image Header into the final firmware file.</p>
<p><em>Why not omit the Image Header from the Linker Script?</em></p>
<p>So that the GCC Linker can compute the ROM addresses correctly. Let's look again at the dumps of the Firmware BIN and Image Files...</p>
<p><img src="https://lupyuen.github.io/images/dfu-image3.png" alt="Firmware BIN vs Image File: Reset_Handler" /></p>
<p>In both files, the Interrupt Vector Tables point to the <code>Reset_Handler</code> function, the first function in our firmware.  The addresses in both Interrupt Vector Tables are the same: <code>0x80F9</code></p>
<p>But how did the GCC Linker allocate ROM address <code>0x80F9</code> for <code>Reset_Handler</code>? The offset (<code>0xF9</code>) was computed based on Image Header size (<code>0x20</code>) + Interrupt Vector Table size (<code>0xD8</code>) + 1.</p>
<p>Hence we had to insert an empty Image Header for GCC Linker to compute the correct ROM addresses.</p>
<p>BTW that's not a typo: The Interrupt Vector Table uses address <code>0x80F9</code> to refer to function <code>Reset_Handler</code>, which is actually located at <code>0x80F8</code> (i.e. the address is off by 1). This is a known quirk of Interrupt Vector Tables on Arm CPUs.</p>
<p><em>Are there sample Firmware ELF, BIN and Image Files available for inspection and testing?</em></p>
<p>Sample Firmware ELF (<code>my_sensor_app.elf</code>), BIN (<code>my_sensor_app.elf.bin</code>) and Image (<code>my_sensor_app.img</code>) Files may be found here...</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/releases/tag/v4.0.1"><code>pinetime-rust-mynewt/releases/tag/v4.0.1</code></a></p>
<p>When running the firmware image with the build of MCUBoot from the previous section, the following log will be shown...</p>
<p><img src="https://lupyuen.github.io/images/dfu-runimage.png" alt="Running the sample firmware image" /></p>
<p><a href="https://mcuboot.com/mcuboot/imgtool.html">More about <code>imgtool.py</code></a></p>
<h1 id="mark-pinetime-firmware-as-pending" class="section-header"><a href="#mark-pinetime-firmware-as-pending">9 Mark PineTime Firmware As Pending</a></h1>
<p>We need to set the Firmware Status to Pending so that MCUBoot will swap the firmware from External SPI Flash to Internal Flash ROM.</p>
<p>Here is the function <code>boot_set_pending</code> from the MCUBoot Library for setting the Firmware Status to Pending...</p>
<p><a href="https://github.com/mcu-tools/mcuboot/blob/master/boot/bootutil/src/bootutil_public.c#L484-L544"><code>mcuboot/boot/bootutil/src/bootutil_public.c</code></a></p>
<p>The function sets the pending flag in the image trailer...</p>
<p><a href="https://mcuboot.com/mcuboot/design.html#image-trailer">MCUBoot Image Trailer</a></p>
<p>Once we set the Swap Type to <code>BOOT_SWAP_TYPE_TEST</code>, MCUBoot will swap in the new firmware.</p>
<h1 id="mark-pinetime-firmware-as-ok" class="section-header"><a href="#mark-pinetime-firmware-as-ok">10 Mark PineTime Firmware As OK</a></h1>
<p>MCUBoot Bootloader has a helpful feature that prevents PineTime from getting bricked during firmware update... When MCUBoot senses that the new firmware isn't running properly, MCUBoot rolls back PineTime to the old firmware.</p>
<p><em>How does MCUBoot know whether the new firmware is OK?</em></p>
<p>The new firmware is required to set the <strong>Image OK</strong> status in MCUBoot when it has started properly after a firmware update.  This needs to be implemented by the PineTime Firmware Developer.</p>
<p><em>When shall we set the Image OK status?</em></p>
<p>Only when the new firmware is able to start up, display messages and accept input properly.  See the MCUBoot section on the user confirmation prompt that shall be implemented by PineTime Firmware Developers.</p>
<p><em>How shall we set the Image OK status?</em></p>
<p>Call the C function <code>boot_set_confirmed()</code> from the MCUBoot Library...</p>
<pre><code class="language-c">//  Marks the image in the primary slot as confirmed.  The system will continue
//  booting into the image in the primary slot until told to boot from a
//  different slot. Returns 0 on success; nonzero on failure.
int boot_set_confirmed(void)
</code></pre>
<p><code>boot_set_confirmed()</code> is supported on Mynewt, RIOT and Zephyr.</p>
<p>See <a href="https://github.com/mcu-tools/mcuboot/blob/master/boot/bootutil/include/bootutil/bootutil_public.h#L170"><code>bootutil_public.h</code></a> and <a href="https://github.com/mcu-tools/mcuboot/blob/master/boot/bootutil/src/bootutil_public.c#L553-L602"><code>bootutil_public.c</code></a></p>
<p><em>Where is the Image OK status stored?</em></p>
<p>In the <strong>Image Trailer</strong> located at the end of the Active Flash Slot.</p>
<p>The Image OK field in the Image Trailer contains a single byte indicating whether the image in this slot has been confirmed as good by the user (<code>0x01</code> means confirmed; <code>0xff</code> means not confirmed).</p>
<p><em>The Image Trailer is not part of the Firmware Image. How does it get written?</em></p>
<p>During firmware update, MCUBoot writes the Image Trailer at the end of the Active Flash Slot.</p>
<p>To check whether there is a valid Image Trailer, MCUBoot looks for the following 16 &quot;Magic&quot; bytes (in host-byte-order)...</p>
<pre><code class="language-c">const uint32_t boot_img_magic[4] = { 
  0xf395c277, 
  0x7fefd260, 
  0x0f505235, 
  0x8079b62c };
</code></pre>
<p>More about the <a href="https://mcuboot.com/design.html#image-trailer">Image Trailer</a></p>
<p><em>How do we inspect the Image OK status?</em></p>
<p>Use <a href="https://mynewt.apache.org/latest/os/modules/devmgmt/newtmgr.html">Newt Manager</a> on Raspberry Pi. In the log below, <code>image=0 slot=0 ... active confirmed</code> means that the Active Firmware (Slot 0) is confirmed OK...</p>
<pre><code class="language-bash"># Build Newt Manager on Raspberry Pi
$ cd ~/go
$ mkdir -p src/mynewt.apache.org
$ cd src/mynewt.apache.org/
$ git clone https://github.com/apache/mynewt-newtmgr
$ mv mynewt-newtmgr newtmgr
$ cd newtmgr/newtmgr
$ export GO111MODULE=on
$ go build

# Run Newt Manager on Raspberry Pi
$ cd ~/go/src/mynewt.apache.org/newtmgr/newtmgr
$ sudo ./newtmgr conn add mybleprph type=ble connstring=&quot;peer_name=pinetime&quot;
Connection profile mybleprph successfully added

# Connect to PineTime and list firmware images
$ sudo ./newtmgr image list -c mybleprph --loglevel debug
Images:
 image=0 slot=0
    version: 1.0.0
    bootable: true
    flags: active confirmed
    hash: eab2886947a1df6f850463601f3dad409411d7ea21855eb0a70e965732258c92
Split status: N/A (0)
</code></pre>
<p>The complete Raspberry Pi log may be found near the end of the article.</p>
<p><a href="https://mcuboot.com/design.html">More about the design of MCUBoot</a></p>
<h1 id="checklist-for-pinetime-firmware-developers" class="section-header"><a href="#checklist-for-pinetime-firmware-developers">11 Checklist for PineTime Firmware Developers</a></h1>
<p>In summary, PineTime Firmware Developers would have to do the following to support firmware updates over Bluetooth LE...</p>
<ol>
<li>
<p>Adopt the <strong>Standard Flash ROM Layout</strong> for building the firmware, by modifying the GCC Linker Script</p>
</li>
<li>
<p>Port <strong>MCU Manager Library</strong> to the firmware, including the functions for writing the flash image to Flash ROM</p>
</li>
<li>
<p>Port <strong>NimBLE Bluetooth LE networking stack</strong> to the firmware by coding a NimBLE Porting Layer</p>
</li>
<li>
<p>Generate a <strong>Firmware Image containing Image Header in MCUBoot format</strong> with <code>arm-none-eabi-objcopy</code> and <code>imgtool.py</code></p>
</li>
<li>
<p>When a new version of the firmware starts on PineTime, the firmware shall <strong>show the version number in a message prompt</strong></p>
</li>
<li>
<p>When the user dismisses the message prompt, the firmware shall <strong>set the Image OK status</strong></p>
</li>
</ol>
<p><strong>For Mynewt and Zephyr:</strong> Some of the steps in this article may not be necessary... Check the simpler porting instructions for Mynewt and Zephyr on the <a href="https://github.com/apache/mynewt-nimble/">NimBLE</a>, <a href="https://github.com/apache/mynewt-mcumgr">MCU Manager</a> and <a href="https://github.com/JuulLabs-OSS/mcuboot">MCUBoot</a> websites.</p>
<h1 id="optional-command-handlers-for-mcu-manager-on-pinetime" class="section-header"><a href="#optional-command-handlers-for-mcu-manager-on-pinetime">12 Optional: Command Handlers for MCU Manager on PineTime</a></h1>
<p>When PineTime is configured for firmware update over Bluetooth LE, additional GATT Services may be exposed by the MCU Manager Library.</p>
<p>Here are the GATT Services that appear when the <a href="https://www.nordicsemi.com/Software-and-tools/Development-Tools/nRF-Connect-for-mobile">Nordic nRF Connect</a> mobile app is connected to PineTime...</p>
<p><img src="https://lupyuen.github.io/images/dfu-gattservices.jpg" alt="GATT Services exposed by MCU Manager on PineTime" /></p>
<p><em>GATT Services exposed by MCU Manager on PineTime</em></p>
<p>Let's examine the GATT Services shown above...</p>
<p><strong>Simple Management Protocol (SMP) Service</strong> (<code>8D53DC1D-1DB7-4CD3-868B-8A527460AA84</code>) is managed by the MCU Manager Library as <a href="https://github.com/apache/mynewt-mcumgr/tree/master/cmd">Command Handlers</a>...</p>
<ol>
<li>
<p><strong>Image Management:</strong> For querying and updating firmware images in PineTime's Flash ROM. This is the Command Handler that we have implemented to support firmware update on PineTime. See <a href="https://github.com/apache/mynewt-mcumgr/tree/master/cmd/img_mgmt"><code>img_mgmt</code></a></p>
</li>
<li>
<p><strong>File System Management:</strong> For accessing the user file system in PineTime's Flash ROM. See <a href="https://github.com/apache/mynewt-mcumgr/tree/master/cmd/fs_mgmt"><code>fs_mgmt</code></a></p>
</li>
<li>
<p><strong>Log Management:</strong> For browsing the debugging messages logged by the firmware. See <a href="https://github.com/apache/mynewt-mcumgr/tree/master/cmd/log_mgmt"><code>log_mgmt</code></a></p>
</li>
<li>
<p><strong>OS Management:</strong> Execute Operating System functions. See <a href="https://github.com/apache/mynewt-mcumgr/tree/master/cmd/os_mgmt"><code>os_mgmt</code></a></p>
</li>
<li>
<p><strong>Statistics Management:</strong> Runtime statistics useful for troubleshooting. See <a href="https://github.com/apache/mynewt-mcumgr/tree/master/cmd/stat_mgmt"><code>stat_mgmt</code></a></p>
</li>
</ol>
<p>PineTime Firmware Developers only need to implement the Image Management Command Handler to support firmware updates. The other Command Handlers are optional, though they may be useful for diagnostics and troubleshooting.</p>
<p>PineTime also exposes <a href="https://www.bluetooth.com/specifications/gatt/services/"><strong>Standard GATT Services</strong></a> that are defined in the Bluetooth LE Specifications...</p>
<ol>
<li>
<p><strong>Generic Access</strong> (<code>0x1800</code>):
Device Name (<code>pinetime</code>) and Appearance. <a href="https://www.bluetooth.com/xml-viewer/?src=https://www.bluetooth.com/wp-content/uploads/Sitecore-Media-Library/Gatt/Xml/Services/org.bluetooth.service.generic_access.xml">Specifications</a></p>
</li>
<li>
<p><strong>Generic Attribute</strong> (<code>0x1801</code>): Notify the mobile app of any changes in PineTime's GATT Services.
<a href="https://www.bluetooth.com/xml-viewer/?src=https://www.bluetooth.com/wp-content/uploads/Sitecore-Media-Library/Gatt/Xml/Services/org.bluetooth.service.generic_attribute.xml">Specifications</a></p>
</li>
<li>
<p><strong>Device Information</strong> (<code>0x180A</code>): Model Number (<code>Apache Mynewt NimBLE</code>) and Firmware Revision (<code>1.0.0</code>).
<a href="https://www.bluetooth.com/xml-viewer/?src=https://www.bluetooth.com/wp-content/uploads/Sitecore-Media-Library/Gatt/Xml/Services/org.bluetooth.service.device_information.xml">Specifications</a></p>
</li>
<li>
<p><strong>Alert Notification Service</strong>	(<code>0x1811</code>): Alerts and Notifications.
<a href="https://www.bluetooth.com/xml-viewer/?src=https://www.bluetooth.com/wp-content/uploads/Sitecore-Media-Library/Gatt/Xml/Services/org.bluetooth.service.alert_notification.xml">Specifications</a></p>
</li>
</ol>
<p>The final GATT Service (<code>59462f12-9543-9999-12c8-58b459a2712d</code>) in the screen above is the <strong>Security Test Service</strong>, which is also optional. See <a href="https://github.com/apache/mynewt-nimble/blob/master/apps/btshell/src/gatt_svr.c#L67-L94"><code>gatt_svr.c</code></a></p>
<h1 id="test-pinetime-firmware-update-over-bluetooth-le" class="section-header"><a href="#test-pinetime-firmware-update-over-bluetooth-le">13 Test PineTime Firmware Update over Bluetooth LE</a></h1>
<p>We are now testing PineTime firmware update on Mynewt+Rust with the <code>ota</code> branch of <code>pinetime-rust-mynewt</code>...</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/tree/ota">Browse <code>pinetime-rust-mynewt/ota</code> repository</a></p>
<p>This branch of <code>pinetime-rust-mynewt</code> has the Newt Manager Library (Mynewt's version of the MCU Manager Library) injected here: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/tree/ota/apps/my_sensor_app/src"><code>my_sensor_app/src</code></a></p>
<p>(Look for the files <code>ble_*.c</code> and <code>ble_*.h</code>)</p>
<p>The source files were derived from the Mynewt <code>bleprph</code> sample. <a href="https://github.com/apache/mynewt-nimble/tree/master/apps/bleprph">See <code>bleprph</code></a></p>
<p>The Firmware ELF (<code>my_sensor_app.elf</code>), BIN (<code>my_sensor_app.elf.bin</code>) and Image (<code>my_sensor_app.img</code>) Files may be found here...</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/releases/tag/v4.0.1"><code>pinetime-rust-mynewt/releases/tag/v4.0.1</code></a></p>
<p>The built Firmware Image is 201 KB in size. Here are the sizes of each library linked into the firmware...</p>
<pre><code class="language-text">----- Build Mynewt and link with Rust app
+ newt build nrf52_my_sensor
Building target targets/nrf52_my_sensor
Linking /Users/Luppy/PineTime/pinetime-rust-mynewt/bin/targets/nrf52_my_sensor/app/apps/my_sensor_app/my_sensor_app.elf
Target successfully built: targets/nrf52_my_sensor
+ newt size -v nrf52_my_sensor
Size of Application Image: app
Mem FLASH: 0x8000-0x7bc00
Mem RAM: 0x20000000-0x20010000
  FLASH     RAM 
    740     330 *fill*
   1018      98 apps_my_sensor_app.a
   1810     112 boot_bootutil.a
    438      26 boot_split.a
   1180       0 crypto_mbedtls.a
   2302       0 crypto_tinycrypt.a
    401       0 encoding_base64.a
   1622       0 encoding_cborattr.a
   3002       0 encoding_tinycbor.a
    440     444 hw_bsp_nrf52.a
     52       0 hw_cmsis-core.a
    706       1 hw_hal.a
   7074     154 hw_mcu_nordic_nrf52xxx.a
      2       0 hw_sensor_creator.a
   1264     260 hw_sensor.a
   8756   35712 kernel_os.a
   3044      50 libc_baselibc.a
     16       0 libs_mynewt_rust.a
  57400    9582 libs_rust_app.a
  12912       0 libs_rust_libcore.a
    738      42 libs_semihosting_console.a
     40       9 libs_sensor_coap.a
    583      99 libs_sensor_network.a
    677     212 libs_temp_stub.a
   3428      72 mgmt_imgmgr.a
    231      20 mgmt_mgmt.a
    884     100 mgmt_newtmgr.a
   1410      44 mgmt_newtmgr_nmgr_os.a
    454     108 mgmt_newtmgr_transport_ble.a
    405     388 net_oic.a
  35496    2107 nimble_controller.a
   4086    1203 nimble_drivers_nrf52.a
  41721    2797 nimble_host.a
    822     218 nimble_host_services_ans.a
    241     112 nimble_host_services_dis.a
    396     118 nimble_host_services_gap.a
    204      62 nimble_host_services_gatt.a
   1814     648 nimble_host_store_config.a
    114       0 nimble_host_util.a
    692    1096 nimble_transport_ram.a
   1578      54 sys_config.a
    634     128 sys_flash_map.a
      2       0 sys_log_modlog.a
    686      29 sys_mfg.a
    839      51 sys_reboot.a
    226      37 sys_sysdown.a
     30       5 sys_sysinit.a
   1746       0 time_datetime.a
    120       0 util_mem.a
    208       0 nrf52_my_sensor-sysinit-app.a
    166       0 libg.a
    968       0 libgcc.a
Loading compiler /Users/Luppy/PineTime/pinetime-rust-mynewt/repos/apache-mynewt-core/compiler/arm-none-eabi-m4, buildProfile debug

objsize
   text    data     bss     dec     hex filename
 205760     904   55224  261888   3ff00 /Users/Luppy/PineTime/pinetime-rust-mynewt/bin/targets/nrf52_my_sensor/app/apps/my_sensor_app/my_sensor_app.elf
</code></pre>
<h1 id="upcoming-enhancements-for-pinetime-firmware-update-over-bluetooth-le" class="section-header"><a href="#upcoming-enhancements-for-pinetime-firmware-update-over-bluetooth-le">14 Upcoming Enhancements for PineTime Firmware Update over Bluetooth LE</a></h1>
<p>[ UPDATE: <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">Check out the followup article here</a> ]</p>
<p>Based on feedback from the PineTime Community, the following enhancements are planned for the implementation of firmware updates...</p>
<ol>
<li>
<p><strong>Allow larger firmware images to be flashed:</strong> Based on the present Flash ROM Layout, the size of a firmware image may not exceed 232 KB. That's because we need to fit both Active and Standby Firmware Images into PineTime's 512 KB Flash ROM.</p>
<p>To support larger firmware images (up to 464 KB), we shall move the Standby Firmware Image to PineTime's External SPI Flash (4 MB). </p>
</li>
<li>
<p><strong>Store Standby Firmware Image in External SPI Flash</strong>: MCUBoot shall be enhanced to swap firmware images across PineTime's Internal Flash ROM (512 KB) and External SPI Flash (4 MB).</p>
<p>MCUBoot shall access the External SPI Flash via Mynewt's driver for SPI Flash. <a href="https://github.com/apache/mynewt-core/tree/master/hw/drivers/flash/spiflash">See <code>spiflash</code></a></p>
<p>Check out my article <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/spiflash">&quot;Configure Mynewt for SPI Flash on PineTime Smart Watch (nRF52)&quot;</a></p>
<p>PineTime Firmware Developers would also need to enhance the Image Management Command Handler (MCU Manager Library) to write firmware images to External SPI Flash (instead of Internal Flash). (Possibly based on Mynewt's <a href="https://github.com/apache/mynewt-core/tree/master/hw/drivers/flash/spiflash"><code>spiflash</code> driver</a>)</p>
</li>
<li>
<p><strong>Manual rollback of firmware images:</strong> We shall allow the PineTime Owner to roll back firmware images manually (in case the Owner decides that the new firmware isn't working properly).</p>
<p>To roll back the firmware manually when PineTime boots, press and hold the watch button for 5 seconds.</p>
<p>MCUBoot shall be enhanced to wait 5 seconds for the button press and to roll back the firmware.</p>
<p>PineTime Firmware Developers shall implement a Reboot or Watchdog feature, so that the Owner won't have to wait for the battery to drain completely before rolling back the firmware.</p>
</li>
<li>
<p><strong>Allow flashing of firmware that doesn't implement firmware update</strong>: Implementing the firmware update functionality may not be feasible for some types of PineTime firmware. (Some firmware developers may get stuck at the NimBLE Porting Layer) Here's how we shall allow such firmware to be flashed...</p>
<p>As long as the firmware adopts the proposed Flash ROM Layout, and includes the MCUBoot Image Header, we shall allow the firmware to be flashed via PineTime's factory-installed firmware (which could be based on FreeRTOS, Mynewt, RIOT, Zephyr, ...)</p>
<p>To upgrade the firmware to a newer version, the PineTime Owner would have to rollback manually to the factory-installed firmware, then flash the upgraded firmware.</p>
</li>
<li>
<p><strong>Bootloader Log</strong>: Log MCUBoot messages to the Arm Semihosting Console when PineTime's SWD port is connected. Useful for troubleshooting the bootloader.</p>
<p>To enable Semihosting Console in <code>repos/mcuboot/boot/mynewt/src/main.c</code>...</p>
<pre><code class="language-c">void os_msys_init(void); ///

int main(void) {
    hal_bsp_init();  //  Init Board Support Package
    os_msys_init();  //  Create pool of MSYS buffers used by Semihosting Console
    console_printf(&quot;Starting MCUBoot...\n&quot;);  //  Display a message
    console_flush(); //  Flush the message
</code></pre>
</li>
<li>
<p>Ensure that the same firmware version doesn't get flashed twice</p>
</li>
</ol>
<h1 id="android-ios-and-linux-companion-apps-for-pinetime" class="section-header"><a href="#android-ios-and-linux-companion-apps-for-pinetime">15 Android, iOS and Linux Companion Apps for PineTime</a></h1>
<p>For flashing PineTime over Bluetooth LE, we would need to find a suitable app for our mobile phones. The mobile app shall also be used to sync the current date/time with PineTime, also to forward notifications for display on PineTime.</p>
<p>The <a href="https://www.nordicsemi.com/Software-and-tools/Development-Tools/nRF-Connect-for-mobile">Nordic nRF Connect</a> mobile app works fine for flashing PineTime... But it seems too complicated for most PineTime Owners.</p>
<p>Here's how we may build friendly apps for Android, iOS and Linux (e.g. PinePhone) mobile phones that will work with PineTime...</p>
<h2 id="android-app-for-pinetime" class="section-header"><a href="#android-app-for-pinetime">15.1 Android App for PineTime</a></h2>
<p>Firmware update on PineTime is based on the MCU Manager Library. We may use the <strong>Android MCU Manager Library</strong> (coded in Java) to build the Android app.</p>
<p><a href="https://github.com/JuulLabs-OSS/mcumgr-android">Check out <code>mcumgr-android</code></a></p>
<h2 id="ios-app-for-pinetime" class="section-header"><a href="#ios-app-for-pinetime">15.2 iOS App for PineTime</a></h2>
<p>There is a similar libary for iOS: The <strong>iOS MCU Manager Library</strong>, coded in Swift.</p>
<p>Among all the MCU Manager Libraries, the iOS Swift version is easiest to understand because it calls high-level Bluetooth LE functions from the <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1">iOS Core Bluetooth API</a>. </p>
<p>The source code is helpful for learning how MCU Manager composes a Simple Management Protocol (SMP) request over GATT.</p>
<p><a href="https://github.com/JuulLabs-OSS/mcumgr-ios">Check out <code>mcumgr-ios</code></a></p>
<p>To see how a GATT Request for firmware update is composed and transmitted, check out <a href="https://github.com/JuulLabs-OSS/mcumgr-ios/blob/master/Source/Managers/DFU/FirmwareUpgradeManager.swift"><code>FirmwareUpgradeManager</code></a>, <a href="https://github.com/JuulLabs-OSS/mcumgr-ios/blob/master/Source/Managers/ImageManager.swift"><code>ImageManager</code></a>, <a href="https://github.com/JuulLabs-OSS/mcumgr-ios/blob/master/Source/McuManager.swift"><code>McuManager</code></a> and <a href="https://github.com/JuulLabs-OSS/mcumgr-ios/blob/master/Source/Bluetooth/McuMgrBleTransport.swift"><code>McuMgrBleTransport</code></a></p>
<h2 id="flutter-app-for-android-and-ios" class="section-header"><a href="#flutter-app-for-android-and-ios">15.3 Flutter App for Android and iOS</a></h2>
<p>Alternatively, we may build the Android and iOS apps in <a href="https://flutter.dev"><strong>Flutter</strong></a> based on this Flutter library for Bluetooth LE: <a href="https://github.com/pauldemarco/flutter_blue"><code>flutter_blue</code></a></p>
<p>We will have to code ourselves the GATT Requests for SMP (using the iOS Swift code as reference). But there's a huge benefit: This approach allows us to maintain <strong>a single code base (in Dart) to target both Android and iOS.</strong></p>
<p>The Flutter app would also be a great reference for teaching how to talk to Bluetooth LE devices (like PineTime) and access GATT services, even though it won't look like a polished app.</p>
<p><a href="https://github.com/pauldemarco/flutter_blue/tree/master/example/lib">Check out a sample Bluetooth LE app built with Flutter</a></p>
<h2 id="linux-app-for-pinetime" class="section-header"><a href="#linux-app-for-pinetime">15.4 Linux App for PineTime</a></h2>
<p>For PinePhone and other Linux phones, we may reuse the code from the <strong>Newt Manager</strong> command-line tool.</p>
<p>Coded in Go, Newt Manager is the official command-line tool for performing all MCU Manager functions on PineTime, including firmware flashing and date/time synchronisation. See <a href="https://mynewt.apache.org/latest/newtmgr/command_list/newtmgr_image.html"><code>newtmgr_image</code></a> and <a href="https://mynewt.apache.org/latest/newtmgr/command_list/newtmgr_datetime.html"><code>newtmgr_datetime</code></a></p>
<p><a href="https://mynewt.apache.org/latest/newtmgr/index.html">More about Newt Manager</a></p>
<p><a href="https://github.com/apache/mynewt-newtmgr">Source code for Newt Manager</a></p>
<p>Newt Manager on Raspberry Pi 4 (Raspbian and Ubuntu) has been successfully tested with PineTime...</p>
<p><img src="https://lupyuen.github.io/images/dfu-newtmgr.png" alt="Newt Manager on 64-bit Ubuntu Desktop and Raspberry Pi 4, connected to PineTime via Bluetooth LE" /></p>
<p><em>Newt Manager on 64-bit Ubuntu Desktop and Raspberry Pi 4, connected to PineTime via Bluetooth LE</em></p>
<p>The Newt Manager code in Go should be easy to wrap up with the <a href="https://www.gtk.org">GTK Library</a> in Go, to create a GUI app for PinePhone and other Linux phones...</p>
<p><img src="https://lupyuen.github.io/images/dfu-gtk.png" alt="Developing a GTK app in Go with VSCode on 64-bit Ubuntu Desktop and Raspberry Pi 4" /></p>
<p><em>Developing a GTK app in Go with VSCode on 64-bit Ubuntu Desktop and Raspberry Pi 4. The compiled file size was 16 MB (Arm64).</em></p>
<p>See <a href="https://github.com/gotk3/gotk3"><code>gotk3</code></a> and the <a href="https://github.com/gotk3/gotk3-examples/tree/master/gtk-examples/stack">sample GTK app</a></p>
<p>Here are the steps for building Newt Manager on Raspberry Pi 4 (Raspbian and Ubuntu) and connecting to PineTime.  For Ubuntu, we will need to connect a USB Bluetooth dongle, since the onboard Bluetooth hardware is not supported.</p>
<pre><code class="language-bash"># Build Newt Manager on Raspberry Pi
$ cd ~/go
$ mkdir -p src/mynewt.apache.org
$ cd src/mynewt.apache.org/
$ git clone https://github.com/apache/mynewt-newtmgr
$ mv mynewt-newtmgr newtmgr
$ cd newtmgr/newtmgr
$ export GO111MODULE=on
$ go build

# Run Newt Manager on Raspberry Pi
$ cd ~/go/src/mynewt.apache.org/newtmgr/newtmgr
$ sudo ./newtmgr conn add mybleprph type=ble connstring=&quot;peer_name=pinetime&quot;
Connection profile mybleprph successfully added

# Connect to PineTime and list firmware images
$ sudo ./newtmgr image list -c mybleprph --loglevel debug
DEBU[2020-04-29 08:23:56.54] Using connection profile: name=mybleprph type=ble connstring=peer_name=pinetime
DEBU[2020-04-29 08:23:56.701] Connecting to peer
DEBU[2020-04-29 08:23:56.773] Exchanging MTU
DEBU[2020-04-29 08:23:56.822] Connecting to peer
DEBU[2020-04-29 08:23:56.907] Exchanging MTU
DEBU[2020-04-29 08:23:56.922] Exchanged MTU; ATT MTU = 256
DEBU[2020-04-29 08:23:56.922] Discovering profile
DEBU[2020-04-29 08:23:57.176] Subscribing to NMP response characteristic
DEBU[2020-04-29 08:23:57.191] {add-nmp-listener} [bll_sesn.go:392] seq=66
DEBU[2020-04-29 08:23:57.191] Encoded &amp;{NmpBase:{hdr:{Op:0 Flags:0 Len:0 Group:1 Seq:66 Id:0}}} to:
00000000  a0                                                |.|
DEBU[2020-04-29 08:23:57.191] Encoded:
00000000  00 00 00 01 00 01 42 00  a0                       |......B..|
DEBU[2020-04-29 08:23:57.191] Tx NMP request: 00000000  00 00 00 01 00 01 42 00  a0                       |......B..|
DEBU[2020-04-29 08:23:57.213] rx nmp response: 00000000  01 00 00 86 00 01 42 00  bf 66 69 6d 61 67 65 73  |......B..fimages|
00000010  9f bf 64 73 6c 6f 74 00  67 76 65 72 73 69 6f 6e  |..dslot.gversion|
00000020  65 31 2e 30 2e 30 64 68  61 73 68 58 20 ea b2 88  |e1.0.0dhashX ...|
00000030  69 47 a1 df 6f 85 04 63  60 1f 3d ad 40 94 11 d7  |iG..o..c`.=.@...|
00000040  ea 21 85 5e b0 a7 0e 96  57 32 25 8c 92 68 62 6f  |.!.^....W2%..hbo|
00000050  6f 74 61 62 6c 65 f5 67  70 65 6e 64 69 6e 67 f4  |otable.gpending.|
00000060  69 63 6f 6e 66 69 72 6d  65 64 f5 66 61 63 74 69  |iconfirmed.facti|
00000070  76 65 f5 69 70 65 72 6d  61 6e 65 6e 74 f4 ff ff  |ve.ipermanent...|
00000080  6b 73 70 6c 69 74 53 74  61 74 75 73 00 ff        |ksplitStatus..|
DEBU[2020-04-29 08:23:57.214] Received nmp rsp: &amp;{NmpBase:{hdr:{Op:1 Flags:0 Len:134 Group:1 Seq:66 Id:0}} Rc:0 Images:[{NmpBase:{hdr:{Op:0 Flags:0 Len:0 Group:0 Seq:0 Id:0}} Image:0 Slot:0 Version:1.0.0 Hash:[234 178 136 105 71 161 223 111 133 4 99 96 31 61 173 64 148 17 215 234 33 133 94 176 167 14 150 87 50 37 140 146] Bootable:true Pending:false Confirmed:true Active:true Permanent:false}] SplitStatus:N/A}
DEBU[2020-04-29 08:23:57.214] {remove-nmp-listener} [bll_sesn.go:392] seq=66
Images:
 image=0 slot=0
    version: 1.0.0
    bootable: true
    flags: active confirmed
    hash: eab2886947a1df6f850463601f3dad409411d7ea21855eb0a70e965732258c92
Split status: N/A (0)
</code></pre>
<h1 id="other-pinetime-firmware-update-solutions" class="section-header"><a href="#other-pinetime-firmware-update-solutions">16 Other PineTime Firmware Update Solutions</a></h1>
<ol>
<li>
<p>Nordic SoftDevice includes a proprietary Bluetooth LE DFU implementation. <a href="https://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v15.0.0/lib_bootloader_dfu_process.html">More about SoftDevice</a></p>
</li>
<li>
<p>wasp-os with Adafruit NRF52 Bootloader (based on Nordic SoftDevice). <a href="https://github.com/daniel-thompson/wasp-os">More about wasp-os</a></p>
</li>
<li>
<p><a href="https://gadgetbridge.org/">Gadgetbridge for Android</a></p>
</li>
<li>
<p><a href="https://github.com/atc1441/DaFlasherFiles">DaFlasher for Android</a></p>
</li>
</ol>
<h1 id="further-reading" class="section-header"><a href="#further-reading">17 Further Reading</a></h1>
<p>[ UPDATE: <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot">Check out the followup article here</a> ]</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/rust/app/src/dfu.md"><code>pinetime-rust-mynewt/rust/ app/src/dfu.md</code></a></p>

    
</body>
</html>