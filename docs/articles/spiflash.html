<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Configure Mynewt for SPI Flash on PineTime Smart Watch (nRF52)</title>

    
    <!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<!-- TODO -->
<meta property="og:image" content="https://lupyuen.github.io/images/spiflash-config.png">
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Configure Mynewt for SPI Flash on PineTime Smart Watch (nRF52)</h1>
    <nav id="TOC"><ul>
<li><a href="#syscfgyml-configure-pins-for-spi-port">1 <code>syscfg.yml:</code> Configure Pins for SPI Port</a><ul></ul></li>
<li><a href="#syscfgyml-configure-flash-interface">2 <code>syscfg.yml:</code> Configure flash interface</a><ul></ul></li>
<li><a href="#syscfgyml-configure-flash-timings">3 <code>syscfg.yml:</code> Configure Flash Timings</a><ul></ul></li>
<li><a href="#hal_bspc-include-spiflashh">4 <code>hal_bsp.c:</code> Include <code>spiflash.h</code></a><ul></ul></li>
<li><a href="#hal_bspc-define-internal-and-external-flash-devices">5 <code>hal_bsp.c:</code> Define Internal and External Flash Devices</a><ul></ul></li>
<li><a href="#hal_bspc-access-flash-devices-by-id">6 <code>hal_bsp.c:</code> Access Flash Devices by ID</a><ul></ul></li>
<li><a href="#pkgyml-add-spiflash-driver">7 <code>pkg.yml:</code> Add <code>spiflash</code> driver</a><ul></ul></li>
<li><a href="#test-spi-flash">8 Test SPI Flash</a><ul>
<li><a href="#read-spi-flash">8.1 Read SPI Flash</a><ul></ul></li>
<li><a href="#erase-spi-flash">8.2 Erase SPI Flash</a><ul></ul></li>
<li><a href="#write-spi-flash">8.3 Write SPI Flash</a><ul></ul></li>
<li><a href="#spi-flash-sector-map">8.4 SPI Flash Sector Map</a><ul></ul></li></ul></li>
<li><a href="#spi-flash-benchmark">9 SPI Flash Benchmark</a><ul></ul></li>
<li><a href="#mcuboot-bootloader-with-spi-flash">10 MCUBoot Bootloader with SPI Flash</a><ul></ul></li>
<li><a href="#debug-spi-flash-with-mcuboot-bootloader">11 Debug SPI Flash with MCUBoot Bootloader</a><ul></ul></li>
<li><a href="#switch-mcuboot-to-stub-bootloader">12 Switch MCUBoot to Stub Bootloader</a><ul></ul></li>
<li><a href="#inside-the-spi-flash-driver">13 Inside the SPI Flash Driver</a><ul></ul></li>
<li><a href="#spi-flash-file-system">14 SPI Flash File System</a><ul></ul></li>
<li><a href="#further-reading">15 Further Reading</a><ul></ul></li></ul></nav><p><img src="https://lupyuen.github.io/images/spiflash-config.png" alt="Configure Mynewt for SPI Flash on PineTime Smart Watch (nRF52)" /></p>
<p><a href="https://lupyuen.github.io/images/spiflash-config.png"><em>Larger image here</em></a></p>
<p>There's one thing truly remarkable about the <a href="https://mynewt.apache.org/"><strong>Apache Mynewt</strong></a> embedded operating system... <strong>Almost any feature may be switched on by editing a configuration file!</strong></p>
<p>Today we'll learn to configure Mynewt OS to enable access to <strong>SPI Flash Memory</strong> on <a href="https://wiki.pine64.org/index.php/PineTime"><strong>PineTime Smart Watch</strong></a>... Just by editing two configuration files (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a> and <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/pkg.yml"><code>pkg.yml</code></a>), and making some minor code changes (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a>).</p>
<p>These steps will work for any Nordic nRF52 device, and probably STM32 devices too (<a href="https://lupyuen.github.io/images/spiflash-config.png">see diagram above</a>)...</p>
<ol>
<li>
<p><strong>Configure pins for SPI Port</strong> in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a></p>
</li>
<li>
<p><strong>Configure flash interface</strong> in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a></p>
</li>
<li>
<p><strong>Configure flash timings</strong> in<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a></p>
</li>
<li>
<p><strong>Include <code>spiflash.h</code></strong> in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a></p>
</li>
<li>
<p><strong>Define internal and external flash devices</strong> in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a></p>
</li>
<li>
<p><strong>Access flash devices by ID</strong> in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a></p>
</li>
<li>
<p><strong>Add <code>spiflash</code> driver</strong> to <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/pkg.yml"><code>pkg.yml</code></a></p>
</li>
</ol>
<p>Read on for the details...</p>
<p><img src="https://lupyuen.github.io/images/spiflash-config1.png" alt="syscfg.yml: Configuration for Board Support Package" /></p>
<p><em><code>syscfg.yml</code>: Configuration for Board Support Package</em></p>
<h1 id="syscfgyml-configure-pins-for-spi-port" class="section-header"><a href="#syscfgyml-configure-pins-for-spi-port">1 <code>syscfg.yml:</code> Configure Pins for SPI Port</a></h1>
<p>The first configuration file we'll edit is <code>syscfg.yml</code> from Mynewt's Board Support Package. For PineTime, this file is located at...</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>hw/bsp/nrf52/syscfg.yml</code></a></p>
<p>Let's add the PineTime SPI settings according to the <a href="https://wiki.pine64.org/index.php/PineTime">PineTime Wiki</a>: <a href="http://files.pine64.org/doc/PineTime/PineTime%20Port%20Assignment%20rev1.0.pdf">PineTime Port Assignment</a>...</p>
<table><thead><tr><th align="left">nRF52 Pin    </th><th align="left">Function</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>P0.02</code></td><td align="left"><code>SPI-SCK, LCD_SCK</code></td><td align="left">SPI Clock</td></tr>
<tr><td align="left"><code>P0.03</code></td><td align="left"><code>SPI-MOSI, LCD_SDI</code>    </td><td align="left">SPI MOSI (master to slave)</td></tr>
<tr><td align="left"><code>P0.04</code></td><td align="left"><code>SPI-MISO</code></td><td align="left">SPI MISO (slave to master)</td></tr>
<tr><td align="left"><code>P0.05</code></td><td align="left"><code>SPI-CE# (SPI-NOR)</code></td><td align="left">SPI Chip Select<br><br></td></tr>
</tbody></table>
<p>Here's how it looks in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a>...</p>
<pre><code class="language-yaml">syscfg.vals:
    ...
    # Default Pins for Peripherals
    # Defined in http://files.pine64.org/doc/PineTime/PineTime%20Port%20Assignment%20rev1.0.pdf

    # SPI port 0 connected to ST7789 display and XT25F32B flash
    SPI_0_MASTER_PIN_SCK:  2  # P0.02/AIN0: SPI-SCK, LCD_SCK    SPI clock for display and flash
    SPI_0_MASTER_PIN_MOSI: 3  # P0.03/AIN1: SPI-MOSI, LCD_SDI   SPI MOSI for display and flash
    SPI_0_MASTER_PIN_MISO: 4  # P0.04/AIN2: SPI-MISO            SPI MISO for flash only
    ...
</code></pre>
<p>For pin numbers on nRF52, we may drop the <code>P0</code> prefix and write <code>P02.02</code> as <code>2</code>.</p>
<p>We'll add SPI Chip Select (<code>Pin 5</code>) in a while.</p>
<h1 id="syscfgyml-configure-flash-interface" class="section-header"><a href="#syscfgyml-configure-flash-interface">2 <code>syscfg.yml:</code> Configure flash interface</a></h1>
<p>Now we'll edit <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a> to tell Mynewt how to access our Flash Memory.  From the <a href="https://wiki.pine64.org/index.php/PineTime">PineTime Wiki</a>...</p>
<blockquote>
<p><strong>SPI Flash information:</strong> 
<a href="https://www.elnec.com/en/device/XTX/XT25F32B+%28QuadSPI%29+%5BSOP8-200%5D/">XTX XT25F32B</a> 32 Mb (4 MB) SPI NOR Flash <br><br>
Data sheets for this part are hard to find but it acts similar to other QuadSPI SPI NOR Flash such as <a href="https://www.macronix.com/Lists/Datasheet/Attachments/7426/MX25L3233F,%203V,%2032Mb,%20v1.6.pdf">Macronix</a> 32 Mb (4 MB) SPI NOR Flash <br><br>
IDs for XT25F32B are: <strong>Manufacturer (<code>0x0b</code>)</strong>, Device (<code>0x15</code>), <strong>Memory Type (<code>0x40</code>)</strong>, <strong>Density (<code>0x16</code>)</strong></p>
</blockquote>
<p>Confused about <code>MB</code> and <code>Mb</code>? <code>MB</code> stands for Mega Byte (roughly a million bytes), whereas <code>Mb</code> stands for Mega Bit (roughly a million bits). Divide <code>Mb</code> by 8 to get <code>MB</code>.</p>
<p>We don't have the datasheet for <a href="https://www.elnec.com/en/device/XTX/XT25F32B+%28QuadSPI%29+%5BSOP8-200%5D/">XT25F32B</a> Flash Memory... But fortunately the <a href="https://en.wikipedia.org/wiki/Common_Flash_Memory_Interface">JEDEC IDs</a> for Manufacturer, Memory Type and Density (Capacity) are all that we need for <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a>...</p>
<pre><code class="language-yaml">syscfg.vals:
    ...
    # SPI Flash
    # XTX XT25F32B 32 Mb (4 MB) SPI NOR Flash (similar to QuadSPI SPI NOR Flash like Macronix 32 Mb (4 MB) MX25L3233F)
    # manufacturer (0x0b), device (0x15), memory type (0x40), density (0x16)
    # Settings below are documented at https://github.com/apache/mynewt-core/blob/master/hw/drivers/flash/spiflash/syscfg.yml

    SPIFLASH:               1   # Enable SPI Flash
    SPIFLASH_SPI_NUM:       0   # SPI Interface 0
    SPIFLASH_SPI_CS_PIN:    5   # SPI interface CS pin: P0.05/AIN3, SPI-CE# (SPI-NOR)
    SPIFLASH_BAUDRATE:      8000    # Requested baudrate, 8000 is the fastest baudrate supported by nRF52832
    SPIFLASH_MANUFACTURER:  0x0B    # Expected SpiFlash manufacturer as read by Read JEDEC ID command 9FH
    SPIFLASH_MEMORY_TYPE:   0x40    # Expected SpiFlash memory type as read by Read JEDEC ID command 9FH
    SPIFLASH_MEMORY_CAPACITY: 0x16  # Expected SpiFlash memory capactity as read by Read JEDEC ID command 9FH (2 ^ 0x16 = 32 Mb)
    SPIFLASH_SECTOR_COUNT:  1024    # Number of sectors: 1024 sectors of 4 KB each
    SPIFLASH_SECTOR_SIZE:   4096    # Number of bytes that can be erased at a time: 4 KB sector size
    SPIFLASH_PAGE_SIZE:     256     # TODO Number of bytes that can be written at a time
    ...
</code></pre>
<p>The JEDEC Device ID (<code>0x15</code>) is not used.</p>
<p><code>SPIFLASH_SECTOR_COUNT</code> and <code>SPIFLASH_SECTOR_SIZE</code> were copied from <a href="https://www.macronix.com/Lists/Datasheet/Attachments/7426/MX25L3233F,%203V,%2032Mb,%20v1.6.pdf">Macronix MX25L3233F</a> since it's similar to our XT25F32B.</p>
<p><code>SPIFLASH_PAGE_SIZE</code> was copied from another Mynewt configuration: <a href="https://github.com/apache/mynewt-core/blob/master/hw/bsp/black_vet6/syscfg.yml"><code>black_vet6</code></a></p>
<h1 id="syscfgyml-configure-flash-timings" class="section-header"><a href="#syscfgyml-configure-flash-timings">3 <code>syscfg.yml:</code> Configure Flash Timings</a></h1>
<p>Finally we edit <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a> to tell Mynewt the timing characteristics of our Flash Memory...</p>
<pre><code class="language-yaml">syscfg.vals:
    ...
    # Copied from https://github.com/apache/mynewt-core/blob/master/hw/bsp/black_vet6/syscfg.yml
    SPIFLASH_TBP1_TYPICAL:  20      # Byte program time (first byte) (us)
    SPIFLASH_TBP1_MAXIMUM:  50      # Maximum byte program time (first byte) (us)
    SPIFLASH_TPP_TYPICAL:   700     # Page program time (us)
    SPIFLASH_TPP_MAXIMUM:   3000    # Maximum page program time (us)
    SPIFLASH_TSE_TYPICAL:   30000   # Sector erase time (4KB) (us)
    SPIFLASH_TSE_MAXIMUM:   400000  # Maximum sector erase time (us)
    SPIFLASH_TBE1_TYPICAL:  120000  # Block erase time (32KB) (us)
    SPIFLASH_TBE1_MAXIMUM:  800000  # Maximum block erase time (32KB) (us)
    SPIFLASH_TBE2_TYPICAL:  150000  # Block erase time (64KB) (us)
    SPIFLASH_TBE2_MAXIMUM:  1000000 # Maximum block erase time (64KB) (us)
    SPIFLASH_TCE_TYPICAL:   3000000 # Chip erase time (us)
    SPIFLASH_TCE_MAXIMUM:   10000000 # Maximum chip erase time (us)
    ...
</code></pre>
<p>If we have the Flash Memory Datasheet, fill in the numbers from the datasheet.</p>
<p>The above settings were copied from another Mynewt configuration: <a href="https://github.com/apache/mynewt-core/blob/master/hw/bsp/black_vet6/syscfg.yml"><code>black_vet6</code></a></p>
<p><img src="https://lupyuen.github.io/images/spiflash-config2.png" alt="hal_bsp.c: Code for Board Support Package" /></p>
<p><em><code>hal_bsp.c</code>: Code for Board Support Package</em> </p>
<h1 id="hal_bspc-include-spiflashh" class="section-header"><a href="#hal_bspc-include-spiflashh">4 <code>hal_bsp.c:</code> Include <code>spiflash.h</code></a></h1>
<p>After editing <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a> in the Board Support Package, let's make some minor tweaks to the source code (<code>hal_bsp.c</code>) of the Board Support Package.</p>
<p>For PineTime, the source file is located at...</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hw/bsp/nrf52/src/hal_bsp.c</code></a></p>
<p>First we insert the header file for the SPI Flash Driver into <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a> like this...</p>
<pre><code class="language-c">#if MYNEWT_VAL(SPIFLASH)  //  If External SPI Flash exists...
#include &lt;spiflash/spiflash.h&gt;
#endif  //  MYNEWT_VAL(SPIFLASH)
</code></pre>
<h1 id="hal_bspc-define-internal-and-external-flash-devices" class="section-header"><a href="#hal_bspc-define-internal-and-external-flash-devices">5 <code>hal_bsp.c:</code> Define Internal and External Flash Devices</a></h1>
<p>Next we define two Mynewt Flash Devices...</p>
<ul>
<li><strong>Internal Flash ROM</strong> with Flash Device ID 0</li>
<li><strong>External SPI Flash</strong> with Flash Device ID 1</li>
</ul>
<p>Edit <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a> and insert this block of code...</p>
<pre><code class="language-c">/// Array of Flash Devices
static const struct hal_flash *flash_devs[] = {
    [0] = &amp;nrf52k_flash_dev,  //  Internal Flash ROM
#if MYNEWT_VAL(SPIFLASH)      //  If External SPI Flash exists...
    [1] = &amp;spiflash_dev.hal,  //  External SPI Flash
#endif                        //  MYNEWT_VAL(SPIFLASH)
};
</code></pre>
<p>Later we'll use Flash Device ID 1 when accessing SPI Flash.</p>
<h1 id="hal_bspc-access-flash-devices-by-id" class="section-header"><a href="#hal_bspc-access-flash-devices-by-id">6 <code>hal_bsp.c:</code> Access Flash Devices by ID</a></h1>
<p>Finally we edit the code to fetch the Flash Devices by the Flash Device ID.</p>
<p>Edit <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/src/hal_bsp.c"><code>hal_bsp.c</code></a>. Look for the function <code>hal_bsp_flash_dev()</code> and replace the function by this code...</p>
<pre><code class="language-c">/// Return the Flash Device for the ID. 0 for Internal Flash ROM, 1 for External SPI Flash
const struct hal_flash *
hal_bsp_flash_dev(uint8_t id)
{
    if (id &gt;= ARRAY_SIZE(flash_devs)) {
        return NULL;
    }
    return flash_devs[id];
}
</code></pre>
<p>This function returns the Internal Flash ROM for ID 0, and External SPI Flash for ID 1.</p>
<p><img src="https://lupyuen.github.io/images/spiflash-config3.png" alt="pkg.yml: Drivers for Board Support Package`" /></p>
<p><em><code>pkg.yml</code>: Drivers for Board Support Package</em></p>
<h1 id="pkgyml-add-spiflash-driver" class="section-header"><a href="#pkgyml-add-spiflash-driver">7 <code>pkg.yml:</code> Add <code>spiflash</code> driver</a></h1>
<p>The last file we'll edit is <code>pkg.yml</code> from the Board Support Package. For PineTime this file is located at...</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/pkg.yml"><code>hw/bsp/nrf52/pkg.yml</code></a></p>
<p>Edit <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/pkg.yml"><code>pkg.yml</code></a>. Look for the <code>pkg.deps</code> section and add <code>spiflash</code> like this...</p>
<pre><code class="language-yaml">pkg.deps:
    ...
    - &quot;@apache-mynewt-core/hw/drivers/flash/spiflash&quot;  # SPI Flash Driver
</code></pre>
<p>This starts up the SPI Flash Driver whenever Mynewt boots.  And we're done!</p>
<p>Now let's write a simple program to read, write and erase the SPI Flash.</p>
<h1 id="test-spi-flash" class="section-header"><a href="#test-spi-flash">8 Test SPI Flash</a></h1>
<p>Here's the C code to test reading, writing and erasing SPI Flash on Mynewt: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>. The code was derived from <a href="https://github.com/apache/mynewt-core/blob/master/test/flash_test/src/flash_test.c">Mynewt's test code for Flash Devices</a>.</p>
<p>The test code calls Mynewt's Flash HAL (Hardware Adaptation Layer) to access the flash memory...</p>
<ol>
<li>
<p><strong>Erase Flash</strong> <code>hal_flash_erase(id, offset, size)</code></p>
<p>Erase internal / external flash memory at the <code>offset</code> address, for <code>size</code> bytes. <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_flash/hal_flash.html#c.hal_flash_erase">See <code>hal_flash_erase</code></a></p>
</li>
<li>
<p><strong>Read Flash</strong> <code>hal_flash_read(id, offset, buf, sector_count)</code></p>
<p>Read internal / external flash memory from the <code>offset</code> address into the <code>buf</code> buffer, for <code>sector_count</code> sectors. On PineTime, one sector contains 4 KB. <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_flash/hal_flash.html#c.hal_flash_read">See <code>hal_flash_read</code></a></p>
</li>
<li>
<p><strong>Write Flash</strong> <code>hal_flash_write(id, offset, buf, sector_count)</code></p>
<p>Write internal / external flash memory from the <code>buf</code> buffer to the <code>offset</code> address, for <code>sector_count</code> sectors. On PineTime, one sector contains 4 KB. <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_flash/hal_flash.html#c.hal_flash_write">See <code>hal_flash_write</code></a></p>
</li>
</ol>
<p>For the above functions, <code>id</code> is 0 for Internal Flash ROM, 1 for External SPI Flash.</p>
<p>For easier testing, the above functions are wrapped inside the <code>flash_cmd()</code> function, which is also defined in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a></p>
<p>Let's call <code>flash_cmd()</code> to test the SPI Flash functions...</p>
<h2 id="read-spi-flash" class="section-header"><a href="#read-spi-flash">8.1 Read SPI Flash</a></h2>
<p>Here's the test code in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a> to read Internal Flash ROM and External SPI Flash...</p>
<pre><code class="language-c">/// Test internal flash ROM and external SPI flash
int test_flash() {
  //  Keep running tests until a test returns an error (non-zero result)
  if (
    ////////////////////////////////
    //  Read Flash
    //  &lt;flash-id&gt; &lt;offset&gt; &lt;size&gt;

    //  Read internal flash ROM
    flash_cmd(READ_COMMAND, 0, 0x0, 32) ||

    //  Read external SPI flash
    flash_cmd(READ_COMMAND, 1, 0x0, 32) ||
    ...
    0
  ) { return -1; }  //  Tests failed
    return 0;  //  Tests OK
}
</code></pre>
<p>This code reads 32 bytes, starting at offset 0, from both Internal Flash ROM and External SPI Flash. As expected, the flash memory contents are different for Internal Flash ROM and External SPI Flash...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Testing</span> <span class="ident">flash</span>...
<span class="ident">Read</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x20</span> <span class="number">0xd9</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0008</span>: <span class="number">0x35</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x37</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0010</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0018</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
<span class="ident">Read</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x01</span> <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x04</span> <span class="number">0x05</span> <span class="number">0x06</span> <span class="number">0x07</span> <span class="number">0x08</span> 
  <span class="number">0x0008</span>: <span class="number">0x09</span> <span class="number">0x0a</span> <span class="number">0x0b</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x0e</span> <span class="number">0x0f</span> <span class="number">0x10</span> 
  <span class="number">0x0010</span>: <span class="number">0x11</span> <span class="number">0x12</span> <span class="number">0x13</span> <span class="number">0x14</span> <span class="number">0x15</span> <span class="number">0x16</span> <span class="number">0x17</span> <span class="number">0x18</span> 
  <span class="number">0x0018</span>: <span class="number">0x19</span> <span class="number">0x1a</span> <span class="number">0x1b</span> <span class="number">0x1c</span> <span class="number">0x1d</span> <span class="number">0x1e</span> <span class="number">0x1f</span> <span class="number">0x20</span> </pre></div>
<h2 id="erase-spi-flash" class="section-header"><a href="#erase-spi-flash">8.2 Erase SPI Flash</a></h2>
<p>Next in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a> we erase the External SPI Flash...</p>
<pre><code class="language-c">/////////////////////////////////////
//  Erase Flash: Set all bits to 1
//  &lt;flash-id&gt; &lt;offset&gt; &lt;size&gt;

//  Erase external SPI flash
flash_cmd(ERASE_COMMAND, 1, 0x0, 32) ||
</code></pre>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Erase</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Erase</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
<span class="macro">Done</span><span class="macro">!</span></pre></div>
<p>After erasing, let's read both Internal Flash ROM and External SPI Flash (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>)...</p>
<pre><code class="language-c">////////////////////////////////////////
//  Read Flash
//  &lt;flash-id&gt; read &lt;offset&gt; &lt;size&gt;

//  Read internal flash ROM
flash_cmd(READ_COMMAND, 0, 0x0, 32) ||

//  Read external SPI flash
flash_cmd(READ_COMMAND, 1, 0x0, 32) ||
</code></pre>
<p>Here are the contents...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Read</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x20</span> <span class="number">0xd9</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0008</span>: <span class="number">0x35</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x37</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0010</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0018</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
<span class="ident">Read</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> 
  <span class="number">0x0008</span>: <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> 
  <span class="number">0x0010</span>: <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> 
  <span class="number">0x0018</span>: <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> <span class="number">0xff</span> </pre></div>
<p><em>Why was SPI Flash wiped out with <code>0xff</code>?</em></p>
<p>That's expected when we erase <a href="https://en.wikipedia.org/wiki/Flash_memory#NOR_memories">NOR Flash Memory</a>... All bits will get set to <code>1</code>.</p>
<p>When we write to NOR Flash Memory, we may only flip <code>1</code> bits to <code>0</code>, not <code>0</code> to <code>1</code>.</p>
<p>Hence before writing any data into NOR Flash Memory, we need to erase all bits to <code>1</code>. Then we write the data to flash, flipping some <code>1</code> bits to <code>0</code>.</p>
<h2 id="write-spi-flash" class="section-header"><a href="#write-spi-flash">8.3 Write SPI Flash</a></h2>
<p>Now that SPI Flash has been flipped to <code>1</code>, let's write some data (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>)...</p>
<pre><code class="language-c">//////////////////////////////////////////////
//  Write Flash: Write 0x01, 0x02, 0x03, ... 
//  (Must erase before writing)
//  &lt;flash-id&gt; &lt;offset&gt; &lt;size&gt;

//  Write external SPI flash
flash_cmd(WRITE_COMMAND, 1, 0x0, 32) ||
</code></pre>
<p>This shows...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Write</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Write</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
<span class="macro">Done</span><span class="macro">!</span></pre></div>
<p><code>flash_cmd()</code> writes to SPI Flash the bytes <code>0x01</code>, <code>0x02</code>, <code>0x03</code>, ... </p>
<p>Let's read SPI Flash and check (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>)...</p>
<pre><code class="language-c">////////////////////////////////////////////
//  Read Flash
//  &lt;flash-id&gt; &lt;offset&gt; &lt;size&gt;

//  Read internal flash ROM
flash_cmd(READ_COMMAND, 0, 0x0, 32) ||

//  Read external SPI flash
flash_cmd(READ_COMMAND, 1, 0x0, 32) ||
</code></pre>
<p>Here's the result...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Read</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x20</span> <span class="number">0xd9</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0008</span>: <span class="number">0x35</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x37</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0010</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
  <span class="number">0x0018</span>: <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00</span> 
<span class="ident">Read</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Read</span> <span class="number">0x0</span> <span class="op">+</span> <span class="number">20</span>
  <span class="number">0x0000</span>: <span class="number">0x01</span> <span class="number">0x02</span> <span class="number">0x03</span> <span class="number">0x04</span> <span class="number">0x05</span> <span class="number">0x06</span> <span class="number">0x07</span> <span class="number">0x08</span> 
  <span class="number">0x0008</span>: <span class="number">0x09</span> <span class="number">0x0a</span> <span class="number">0x0b</span> <span class="number">0x0c</span> <span class="number">0x0d</span> <span class="number">0x0e</span> <span class="number">0x0f</span> <span class="number">0x10</span> 
  <span class="number">0x0010</span>: <span class="number">0x11</span> <span class="number">0x12</span> <span class="number">0x13</span> <span class="number">0x14</span> <span class="number">0x15</span> <span class="number">0x16</span> <span class="number">0x17</span> <span class="number">0x18</span> 
  <span class="number">0x0018</span>: <span class="number">0x19</span> <span class="number">0x1a</span> <span class="number">0x1b</span> <span class="number">0x1c</span> <span class="number">0x1d</span> <span class="number">0x1e</span> <span class="number">0x1f</span> <span class="number">0x20</span> </pre></div>
<p>Yep the flipping of bits from <code>1</code> to <code>0</code> worked!</p>
<h2 id="spi-flash-sector-map" class="section-header"><a href="#spi-flash-sector-map">8.4 SPI Flash Sector Map</a></h2>
<p>To check whether SPI Flash is correctly configured, we may dump the Flash Sector Map like this (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>)...</p>
<pre><code class="language-c">////////////////////
//  Dump Sector Map

//  Dump sector map for internal flash ROM
map_cmd(0) ||

//  Dump sector map for external SPI flash
map_cmd(1) ||

</code></pre>
<p>Here's the output...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Sector</span> <span class="ident">Map</span> <span class="kw">for</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Flash</span> <span class="number">0</span> <span class="ident">at</span> <span class="number">0x0</span> <span class="ident">size</span> <span class="number">0x80000</span> <span class="ident">with</span> <span class="number">128</span> <span class="ident">sectors</span>, <span class="ident">alignment</span> <span class="ident">req</span> <span class="number">1</span> <span class="ident">bytes</span>
  <span class="number">0</span>: <span class="number">1000</span>
  <span class="number">1</span>: <span class="number">1000</span>
  <span class="number">2</span>: <span class="number">1000</span>
  ...  
  <span class="number">127</span>: <span class="number">1000</span>
<span class="ident">Sector</span> <span class="ident">Map</span> <span class="kw">for</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Flash</span> <span class="number">1</span> <span class="ident">at</span> <span class="number">0x0</span> <span class="ident">size</span> <span class="number">0x400000</span> <span class="ident">with</span> <span class="number">1024</span> <span class="ident">sectors</span>, <span class="ident">alignment</span> <span class="ident">req</span> <span class="number">1</span> <span class="ident">bytes</span>
  <span class="number">0</span>: <span class="number">1000</span>
  <span class="number">1</span>: <span class="number">1000</span>
  <span class="number">2</span>: <span class="number">1000</span>
  ...  
  <span class="number">1023</span>: <span class="number">1000</span></pre></div>
<p>This says that SPI Flash has been configured with 1024 sectors, each sector 4 KB in size (<code>0x1000</code>).</p>
<h1 id="spi-flash-benchmark" class="section-header"><a href="#spi-flash-benchmark">9 SPI Flash Benchmark</a></h1>
<p><em>How fast can we read SPI Flash? Compared with Internal Flash ROM?</em></p>
<p>Let's run the flash speed tests found in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>...</p>
<pre><code class="language-c">//////////////////////
//  Test Flash Speed
//  &lt;flash_id&gt; &lt;addr&gt; &lt;rd_sz&gt;|range [move]
//  range=0 for size mode, range=1 for range mode, move=1 for move

//  Internal flash ROM, size mode, no move
speed_cmd(0, 0x0, 32, 0, 0) ||

//  External SPI flash, size mode, no move
speed_cmd(1, 0x0, 32, 0, 0) ||
</code></pre>
<p>This code repeatedly reads 32 bytes from Internal Flash ROM and External SPI Flash... And counts how many Read Operations were completed in 2 seconds.</p>
<p>Here's the output...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Speed</span> <span class="ident">Test</span> <span class="kw">for</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Speed</span> <span class="ident">test</span>, <span class="ident">hal_flash_read</span>(<span class="number">0</span>, <span class="number">0x0</span>, <span class="number">32</span>)
<span class="number">207503</span>
<span class="ident">Speed</span> <span class="ident">Test</span> <span class="kw">for</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Speed</span> <span class="ident">test</span>, <span class="ident">hal_flash_read</span>(<span class="number">1</span>, <span class="number">0x0</span>, <span class="number">32</span>)
<span class="number">16107</span></pre></div>
<p>That's 207,503 Read Operations Per 2 Seconds for Internal Flash ROM, and 16,107 Read Operations Per 2 Seconds for External SPI Flash.</p>
<p>When we divide the numbers by 2, we get the Read Operations Per Second...</p>
<table><thead><tr><th align="right">Size (Bytes)</th><th align="right">Flash ROM<br>Reads/Sec</th><th align="right">SPI Flash<br>Reads/Sec</th></tr></thead><tbody>
<tr><td align="right">32</td><td align="right">103,751</td><td align="right">8,053</td></tr>
<tr><td align="right"><br></td><td align="right"></td><td align="right"></td></tr>
</tbody></table>
<p>As expected, Internal Flash ROM is faster than External SPI Flash, roughly 13 times faster.</p>
<p>Let's run the test speed on a range of data sizes, from 1 byte to 256 bytes (<a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/apps/my_sensor_app/src/flash_test.c"><code>flash_test.c</code></a>
)...</p>
<pre><code class="language-c">//  Internal flash ROM, range mode, no move
speed_cmd(0, 0x0, 0, 1, 0) ||

//  External SPI flash, range mode, no move
speed_cmd(1, 0x0, 0, 1, 0) ||
</code></pre>
<p>Now we get a table of Read Operations Per 2 Seconds (second column), for data sizes ranging from 1 byte to 256 bytes (first column)...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">Speed</span> <span class="ident">Test</span> <span class="kw">for</span> <span class="ident">Internal</span> <span class="ident">Flash</span> <span class="ident">ROM</span>...
<span class="ident">Speed</span> <span class="ident">test</span>, <span class="ident">hal_flash_read</span>(<span class="number">0</span>, <span class="number">0x0</span>, <span class="ident">X</span>)
  <span class="number">1</span> <span class="number">271962</span>
  <span class="number">2</span> <span class="number">261931</span>
  <span class="number">4</span> <span class="number">271962</span>
  <span class="number">8</span> <span class="number">260862</span>
 <span class="number">16</span> <span class="number">241174</span>
 <span class="number">24</span> <span class="number">221913</span>
 <span class="number">32</span> <span class="number">207503</span>
 <span class="number">48</span> <span class="number">182082</span>
 <span class="number">64</span> <span class="number">162210</span>
 <span class="number">96</span> <span class="number">133148</span>
<span class="number">128</span> <span class="number">112917</span>
<span class="number">192</span> <span class="number">86600</span>
<span class="number">256</span> <span class="number">70232</span>
<span class="ident">Speed</span> <span class="ident">Test</span> <span class="kw">for</span> <span class="ident">External</span> <span class="ident">SPI</span> <span class="ident">Flash</span>...
<span class="ident">Speed</span> <span class="ident">test</span>, <span class="ident">hal_flash_read</span>(<span class="number">1</span>, <span class="number">0x0</span>, <span class="ident">X</span>)
  <span class="number">1</span> <span class="number">44139</span>
  <span class="number">2</span> <span class="number">42048</span>
  <span class="number">4</span> <span class="number">37684</span>
  <span class="number">8</span> <span class="number">31639</span>
 <span class="number">16</span> <span class="number">23955</span>
 <span class="number">24</span> <span class="number">19250</span>
 <span class="number">32</span> <span class="number">16107</span>
 <span class="number">48</span> <span class="number">12132</span>
 <span class="number">64</span> <span class="number">9731</span>
 <span class="number">96</span> <span class="number">6971</span>
<span class="number">128</span> <span class="number">5431</span>
<span class="number">192</span> <span class="number">3766</span>
<span class="number">256</span> <span class="number">2883</span></pre></div>
<p>Divide the numbers by 2 to get Read Operations Per Second for various data sizes...</p>
<table><thead><tr><th align="right">Size (Bytes)</th><th align="right">Flash ROM<br>Reads/Sec</th><th align="right">SPI Flash <br>Reads/Sec</th></tr></thead><tbody>
<tr><td align="right">1</td><td align="right">135,981</td><td align="right">22,069</td></tr>
<tr><td align="right">2</td><td align="right">130,965</td><td align="right">21,024</td></tr>
<tr><td align="right">4</td><td align="right">135,981</td><td align="right">18,842</td></tr>
<tr><td align="right">8</td><td align="right">130,431</td><td align="right">15,819</td></tr>
<tr><td align="right">16</td><td align="right">120,587</td><td align="right">11,977</td></tr>
<tr><td align="right">24</td><td align="right">110,956</td><td align="right">9,625</td></tr>
<tr><td align="right">32</td><td align="right">103,751</td><td align="right">8,053</td></tr>
<tr><td align="right">48</td><td align="right">91,041</td><td align="right">6,066</td></tr>
<tr><td align="right">64</td><td align="right">81,105</td><td align="right">4,865</td></tr>
<tr><td align="right">96</td><td align="right">66,574</td><td align="right">3,485</td></tr>
<tr><td align="right">128</td><td align="right">56,458</td><td align="right">2,715</td></tr>
<tr><td align="right">192</td><td align="right">43,300</td><td align="right">1,883</td></tr>
<tr><td align="right">256</td><td align="right">35,116</td><td align="right">1,441</td></tr>
<tr><td align="right"><br></td><td align="right"></td><td align="right"></td></tr>
</tbody></table>
<p>Internal Flash ROM is still faster than External SPI Flash. For reads of 1 byte, Internal Flash ROM is faster by 6 times. But reads of 256 bytes, Internal Flash ROM is faster by 24 times!</p>
<h1 id="mcuboot-bootloader-with-spi-flash" class="section-header"><a href="#mcuboot-bootloader-with-spi-flash">10 MCUBoot Bootloader with SPI Flash</a></h1>
<p><a href="https://juullabs-oss.github.io/mcuboot/"><strong>MCUBoot</strong></a> is an open-source Bootloader that supports Mynewt, <a href="https://www.riot-os.org">RIOT</a> and <a href="https://www.zephyrproject.org">Zephyr</a> operating systems... It's the first thing that will <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu">run on PineTime when it boots</a>.</p>
<p>During firmware updates, MCUBoot stores the previous version of the firmware into Internal Flash ROM, and rolls back to the previous firmware if the new firmware doesn't start properly. </p>
<p>But on constrained devices like PineTime, this robustness will cost us... We might run out of space in Internal Flash ROM to store the old firmware!</p>
<p>Fortunately MCUBoot on Mynewt works seamlessly with SPI Flash... Watch how the new firmware <code>FLASH_AREA_IMAGE_0</code> coexists with the old firmware <code>FLASH_AREA_IMAGE_1</code> in this Flash Memory Map for MCUBoot for Mynewt: <a href="https://github.com/apache/mynewt-core/blob/master/hw/bsp/black_vet6/bsp.yml"><code>hw/bsp/black_vet6/bsp.yml</code></a></p>
<pre><code class="language-yaml">bsp.flash_map:
    areas:
        # System areas.
        FLASH_AREA_BOOTLOADER:
            device: 0
            offset: 0x08000000
            size: 32kB
        FLASH_AREA_IMAGE_0:
            device: 0
            offset: 0x08020000
            size: 256kB
        FLASH_AREA_IMAGE_SCRATCH:
            device: 0
            offset: 0x08060000
            size: 128kB

        # User areas.
        FLASH_AREA_REBOOT_LOG:
            user_id: 0
            device: 0
            offset: 0x08008000
            size: 32kB

        FLASH_AREA_IMAGE_1:
            device: 1
            offset: 0x00000000
            size: 256kB

        FLASH_AREA_NFFS:
            user_id: 1
            device: 1
            offset: 0x00040000
            size: 32kB
</code></pre>
<p>Note that the new firmware <code>FLASH_AREA_IMAGE_0</code> resides on <strong>Flash Device 0 (Internal Flash ROM)</strong>, while the old firmware <code>FLASH_AREA_IMAGE_1</code> resides on <strong>Flash Device 1 (External SPI Flash)</strong>.</p>
<p>This means that we won't waste any previous space in Internal Flash ROM for storing the old firmware... MCUBoot automatically swaps the old firmware into External SPI Flash! Using MCUBoot Bootloader with SPI Flash is really that easy!</p>
<h1 id="debug-spi-flash-with-mcuboot-bootloader" class="section-header"><a href="#debug-spi-flash-with-mcuboot-bootloader">11 Debug SPI Flash with MCUBoot Bootloader</a></h1>
<p>If we're using the MCUBoot Bootloader (like on PineTime), debugging and testing SPI Flash can be somewhat challenging.</p>
<p>Remember that we added the SPI Flash Driver to the Board Support Package?</p>
<p>The Board Support Package is used by <em>both</em> the MCUBoot Bootloader as well as the Application Firmware. Which means that the SPI Flash Driver is loaded when MCUBoot starts.</p>
<p><em>What happens if the SPI Flash Driver is configured incorrectly?</em></p>
<p>MCUBoot may crash... Before starting the Application Firmware! (This happened to me)</p>
<p>Hence for debugging and testing SPI Flash, I strongly recommend switching the Bootloader to a simpler one that doesn't require any drivers: the <a href="https://github.com/lupyuen/pinetime-rust-mynewt/tree/ota2/apps/boot_stub"><strong>Stub Bootloader</strong></a>.</p>
<p>The Stub Bootloader doesn't do anything... It simply jumps to the Application Firmware.</p>
<p>This will enable us to debug and test SPI Flash with our Application Firmware, before using it with MCUBoot.</p>
<p>Also MCUBoot expects the Application Firmware Image to start with the MCUBoot Image Header. When the GDB debugger flashes the Firmware ELF File into ROM, the Image Header is empty. So MCUBoot won't work start the Application Firmware properly when the debugger is running. Switching MCUBoot to the Stub Bootloader will solve this.</p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/tree/ota2/apps/boot_stub"><em>Source code for Stub Bootloader</em></a></p>
<h1 id="switch-mcuboot-to-stub-bootloader" class="section-header"><a href="#switch-mcuboot-to-stub-bootloader">12 Switch MCUBoot to Stub Bootloader</a></h1>
<p>To switch the PineTime Bootloader from MCUBoot to the Stub Bootloader, edit the Bootloader Target Settings <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/targets/nrf52_boot/target.yml"><code>targets/nrf52_boot/target.yml</code></a>.</p>
<p>Comment out this line (insert <code>#</code> at the beginning of the line)...</p>
<pre><code class="language-yaml"># target.app: &quot;@mcuboot/boot/mynewt&quot;  # Use MCUBoot, which doesn't support debugging
</code></pre>
<p>And uncomment this line (remove <code>#</code> from the beginning of the line)...</p>
<pre><code class="language-yaml">target.app: &quot;apps/boot_stub&quot;  # Use Stub Bootloader, which supports debugging
</code></pre>
<p>Then edit the Bootloader OpenOCD Script <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/scripts/nrf52/flash-boot.ocd"><code>scripts/nrf52/flash-boot.ocd</code></a></p>
<p>Comment out the <code>program</code> line below (insert <code>#</code> at the beginning of the line)...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
</pre></div>
<p>And uncomment the <code>program</code> line below (remove <code>#</code> from the beginning of the line)...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">program</span> <span class="ident">bin</span><span class="op">/</span><span class="ident">targets</span><span class="op">/</span><span class="ident">nrf52_boot</span><span class="op">/</span><span class="ident">app</span><span class="op">/</span><span class="ident">apps</span><span class="op">/</span><span class="ident">boot_stub</span><span class="op">/</span><span class="ident">boot_stub</span>.<span class="ident">elf</span>.<span class="ident">bin</span> <span class="ident">verify</span> <span class="number">0x00000000</span></pre></div>
<p>Build the Stub Bootloader by clicking <code>Terminal -&gt; Run Task -&gt; Build Bootloader</code>. Or run the Bootloader Build Script: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/scripts/nrf52/build-boot.sh"><code>scripts/nrf52/build-boot.sh</code></a></p>
<p>Flash the Stub Bootloader to PineTime by clicking <code>Terminal -&gt; Run Task -&gt; Flash Bootloader</code>. Or run the Bootloader Flash Script: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/scripts/nrf52/flash-boot.sh"><code>scripts/nrf52/flash-boot.sh</code></a></p>
<p>Our PineTime now boots with the Stub Bootloader... Ready for debugging!</p>
<h1 id="inside-the-spi-flash-driver" class="section-header"><a href="#inside-the-spi-flash-driver">13 Inside the SPI Flash Driver</a></h1>
<p>We have been using Mynewt's SPI Flash Driver: <a href="https://github.com/apache/mynewt-core/blob/master/hw/drivers/flash/spiflash/include/spiflash/spiflash.h"><code>spiflash.h</code></a> and <a href="https://github.com/apache/mynewt-core/blob/master/hw/drivers/flash/spiflash/src/spiflash.c"><code>spiflash.c</code></a></p>
<p>Remember the configuration we have set in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/ota2/hw/bsp/nrf52/syscfg.yml"><code>syscfg.yml</code></a> like <code>SPIFLASH_MANUFACTURER</code>, <code>SPIFLASH_MEMORY_TYPE</code>, <code>SPIFLASH_MEMORY_CAPACITY</code>?</p>
<p>The flash driver uses these configuration settings to access our SPI flash memory. Everything in Mynewt's SPI Flash Driver is configured via <code>syscfg.yml</code>... Amazing!</p>
<p>Mynewt's SPI Flash Driver seemed very mysterious... Until I stumbled upon this Board Support Package in Mynewt: <a href="https://github.com/apache/mynewt-core/blob/master/hw/bsp/black_vet6/syscfg.yml"><code>black_vet6/syscfg.yml</code></a></p>
<p>The configuration and code in this article were derived from that Board Support Package.</p>
<h1 id="spi-flash-file-system" class="section-header"><a href="#spi-flash-file-system">14 SPI Flash File System</a></h1>
<p>We have seen <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_flash/hal_flash.html">Mynewt's Flash HAL</a> functions for reading, writing and erasing SPI Flash at the byte and sector level. That's too low-level for us firmware programmers.</p>
<p><em>Can we have files and directories in SPI Flash?</em></p>
<p>Yes we can, with a Flash File System like <a href="https://github.com/ARMmbed/littlefs"><strong>littlefs</strong></a>.</p>
<p>Earlier we saw this Flash Memory Map: <a href="https://github.com/apache/mynewt-core/blob/master/hw/bsp/black_vet6/bsp.yml"><code>hw/bsp/black_vet6/bsp.yml</code></a></p>
<pre><code class="language-yaml">bsp.flash_map:
    areas:
        ...
        FLASH_AREA_NFFS:
            user_id: 1
            device: 1
            offset: 0x00040000
            size: 32kB
</code></pre>
<p><code>FLASH_AREA_NFFS</code> is a Flash Area that's available for use by the Application Firmware for storing application data. Note that it's located on Flash Device 1, which is the External SPI Flash.</p>
<p>Mynewt will let us install a File System into the <code>FLASH_AREA_NFFS</code> Flash Area for storing our files and directories.</p>
<p>Here's a simple example from <a href="https://github.com/ARMmbed/littlefs/blob/master/README.md"><code>littlefs/README.md</code></a> that updates a file named <code>boot_count</code> every time the program runs. The program can be interrupted at any time without losing track of how many times it has been booted and without corrupting the filesystem...</p>
<pre><code class="language-c">#include &quot;lfs.h&quot;

// variables used by the filesystem
lfs_t lfs;
lfs_file_t file;

// configuration of the filesystem is provided by this struct
const struct lfs_config cfg = {
    // block device operations
    .read  = flash_read,   //  TODO: Implement with hal_flash_read()
    .prog  = flash_prog,   //  TODO: Implement with hal_flash_write()
    .erase = flash_erase,  //  TODO: Implement with hal_flash_erase()
    .sync  = flash_sync,   //  TODO: Provide a sync function

    // block device configuration
    .read_size = 16,
    .prog_size = 16,
    .block_size = 4096,
    .block_count = 128,
    .cache_size = 16,
    .lookahead_size = 16,
    .block_cycles = 500,
};

// entry point
int test_littlefs(void) {
    // mount the filesystem
    int err = lfs_mount(&amp;lfs, &amp;cfg);

    // reformat if we can't mount the filesystem
    // this should only happen on the first boot
    if (err) {
        lfs_format(&amp;lfs, &amp;cfg);
        lfs_mount(&amp;lfs, &amp;cfg);
    }

    // read current count
    uint32_t boot_count = 0;
    lfs_file_open(&amp;lfs, &amp;file, &quot;boot_count&quot;, LFS_O_RDWR | LFS_O_CREAT);
    lfs_file_read(&amp;lfs, &amp;file, &amp;boot_count, sizeof(boot_count));

    // update boot count
    boot_count += 1;
    lfs_file_rewind(&amp;lfs, &amp;file);
    lfs_file_write(&amp;lfs, &amp;file, &amp;boot_count, sizeof(boot_count));

    // remember the storage is not updated until the file is closed successfully
    lfs_file_close(&amp;lfs, &amp;file);

    // release any resources we were using
    lfs_unmount(&amp;lfs);

    // print the boot count
    console_printf(&quot;boot_count: %d\n&quot;, boot_count); console_flush();
}
</code></pre>
<p>The <code>lfs_config</code> struct points to functions that will be used by littlefs for reading, writing and erasing the flash device: <code>flash_read</code>, <code>flash_prog</code>, <code>flash_erase</code>.</p>
<p>These functions may be implemented with similar functions defined in <a href="https://mynewt.apache.org/latest/os/modules/hal/hal_flash/hal_flash.html">Mynewt's Flash HAL</a>: <code>hal_flash_read</code>, <code>hal_flash_write</code>, <code>hal_flash_erase</code>.</p>
<p><code>lfs_config</code> is documented here: <a href="https://github.com/ARMmbed/littlefs/blob/master/lfs.h"><code>lfs.h</code></a></p>
<p>Note that Mynewt's Flash HAL uses absolute addresses (instead of addresses relative to the Flash Area) when accessing SPI Flash. We need to map Flash Area addresses in the Flash Map to absolute addresses using Mynewt's Flash Map functions: <a href="https://github.com/apache/mynewt-core/blob/master/sys/flash_map/include/flash_map/flash_map.h"><code>flash_map.h</code></a></p>
<p><a href="https://github.com/ARMmbed/littlefs/blob/master/README.md">More about littlefs</a></p>
<p><a href="https://github.com/ARMmbed/littlefs/blob/master/DESIGN.md">Design of littlefs</a></p>
<p><a href="https://github.com/ARMmbed/littlefs/blob/master/SPEC.md">Specification of littlefs</a></p>
<h1 id="further-reading" class="section-header"><a href="#further-reading">15 Further Reading</a></h1>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/README.md">Check out the other PineTime articles</a></p>

    
</body>
</html>