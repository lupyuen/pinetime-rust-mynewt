//! This program was automatically generated by Visual Embedded Rust. Don't edit here!
#![no_std]                       // Don't link with standard Rust library, which is not compatible with embedded systems
#![feature(trace_macros)]        // Allow macro tracing: `trace_macros!(true)`
#![feature(concat_idents)]       // Allow `concat_idents!()` macro used in `coap!()` macro
#![feature(const_transmute)]     // Allow `transmute` for initialising Mynewt structs
#![feature(proc_macro_hygiene)]  // Allow Procedural Macros like `run!()`
#![feature(custom_attribute)]    // Allow Custom Attributes like `#[safe_wrap]`

extern crate cortex_m;                  // Declare the external library `cortex_m`
extern crate mynewt;                    // Declare the Mynewt library
extern crate macros as mynewt_macros;   // Declare the Mynewt Procedural Macros library

use core::panic::PanicInfo; // Import `PanicInfo` type which is used by `panic()` below
use core::ptr::null_mut;
use cortex_m::asm::bkpt;    // Import cortex_m assembly function to inject breakpoint
use mynewt::{
    result::*,              // Import Mynewt API Result and Error types
    kernel::os,             // Import Mynewt OS API
    sys::console,           // Import Mynewt Console API
    encoding::coap_context::*,  // Import Mynewt Encoding API
    hw::sensor::{
        self,               // Import Mynewt Sensor API functions
        sensor_type_t,      // Import Mynewt Sensor API types
        SensorValue, SensorValueType,
        SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW,
    },
    libs::sensor_network,   // Import Mynewt Sensor Network Library
    Strn, coap, d,          // Import Mynewt macros
};
use mynewt_macros::{ infer_type, init_strn, strn };  // Import Mynewt procedural macros

// This Rust program polls the internal temperature sensor every
// 10 seconds and sends the sensor data to the server over NB-IoT.
/// Will be run upon startup to initialise the app
fn on_start() -> MynewtResult<()> {
    console::print("on_start\n");
    // Blue Pill's internal temperature sensor
    let SENSOR_DEVICE = &init_strn!( "temp_stm32_0" );
    // Poll the sensor every 10,000 milliseconds (10 seconds)
    let SENSOR_POLL_TIME = 10000;
    // Sensor data will be transmitted to server as field `t`
    let TEMP_SENSOR_KEY = &init_strn!( "t" );
    // Sensor data is raw temperature in whole numbers (0 to 4095)
    let TEMP_SENSOR_TYPE = SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW;
    // Poll the sensor every 10 seconds
    start_sensor_listener(SENSOR_DEVICE, TEMP_SENSOR_KEY, TEMP_SENSOR_TYPE, SENSOR_POLL_TIME) ? ;
    // Start connecting to NB-IoT network in a background task
    sensor_network::start_server_transport() ? ;

    // Return success to `main()` function
    Ok(())
}

/// Poll the temperature sensor every 10 seconds
/// and call function `handle_sensor_data()`.
#[infer_type]  //  Infer the missing types
fn start_sensor_listener(sensor_name: _, sensor_key: _, sensor_type: _, poll_time: _) -> MynewtResult<()> {
    console::print("start_sensor_listener\n");
    // Schedule the sensor to be polled every 10 seconds
    sensor::set_poll_rate_ms(sensor_name, poll_time) ? ;
    // Find the sensor driver by name
    let sensor_driver = sensor::mgr_find_next_bydevname(sensor_name, null_mut()) ? ;
    // If the sensor driver has been found...
    if sensor_driver != null_mut() {
        // Create a sensor listener that will call function `handle_sensor_data` after polling the sensor data
        let listener = sensor::new_sensor_listener(sensor_key, sensor_type, handle_sensor_data) ? ;
        // Register the sensor listener
        sensor::register_listener(sensor_driver, listener) ? ;
    }
    Ok(())
}

/// This listener function is called every 10 seconds to
/// handle the polled sensor data. We convert the sensor data
/// to our transmission format and transmit to the server.
#[infer_type]  //  Infer the missing types
fn handle_sensor_data(sensor_data: _) -> MynewtResult<()> {
    console::print("handle_sensor_data\n");
    // Transmit the sensor data to the server
    send_sensor_data(sensor_data) ? ;
    Ok(())
}

/// Compose a CoAP JSON message with the Sensor Key (field name)
/// and Sensor Value in `sensor_data` and send to the CoAP server.
#[infer_type]  //  Infer the missing types
fn send_sensor_data(sensor_data: _) -> MynewtResult<()> {
    console::print("send_sensor_data\n");
    // Get a randomly-generated device ID that changes each time we restart the device
    let device_id = &sensor_network::get_device_id() ? ;
    // Start composing a CoAP message
    let network_ready = sensor_network::init_server_post(DEFAULT_URI) ? ;
    // Proceed to compose the CoAP message only when
    // the device has connected to the NB-IoT network
    if network_ready {
        // Create a CoAP message with payload in JSON format
        // Fill in the random device ID
        // And the sensor data like `t: 2870`
        let _payload = coap!( @json {
            "device": device_id,
            sensor_data
        });
        // Transmit the CoAP message to the CoAP Server over
        // NB-IoT. This takes place in a background task.
        sensor_network::do_server_post() ? ;
        // Show a URL that may be clicked to display the sensor data received by the server
        console::print("View your sensor at https://blue-pill-geolocate.appspot.com?device=");
        console::print_strn(device_id);
        console::print("\n");
    }
    Ok(())
}

/// main() will be called at Mynewt startup. It replaces the C version of the `main()` function.
#[no_mangle]                 // Don't mangle the name "main"
extern "C" fn main() -> ! {  // Declare `extern "C"` because it will be called by Mynewt
    // Initialise Mynewt OS
    mynewt::sysinit();

    // Initialise the app
    on_start()
        .expect("on_start fail");

    // Mynewt event loop
    loop {                         // Loop forever...
        os::eventq_run(            // Processing events...
            os::eventq_dflt_get()  // From default event queue
                .expect("get fail")
        ).expect("run fail")
    }
    // Never comes here
}

/// This function is called on panic, like an assertion failure. We display the filename and line number and pause in the debugger. From https://os.phil-opp.com/freestanding-rust-binary/
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    // Display the filename and line number in the Semihosting Console
    console::print("panic ");
    if let Some(location) = info.location() {
        let file = location.file();
        let line = location.line();
        console::print("at ");       console::buffer(&file);
        console::print(" line 0x");  console::printhex(line as u8);  // TODO: Print in decimal not hex. Allow more than 255 lines.
        console::print("\n");       console::flush();
    } else {
        console::print("no loc\n");  console::flush();
    }
    // Pause in the debugger
    bkpt();
    //  Loop forever so that device won't restart
    loop {}
}

/// Use default COAP_URI from syscfg.yml
const DEFAULT_URI: &Strn = &init_strn!("");

//  Globals: sensor_name, sensor_key, sensor_type, poll_time, sensor_data, eventq, millisec, previous, sensor_driver, listener, uri, func, SENSOR_DEVICE, device_id, SENSOR_POLL_TIME, network_ready, TEMP_SENSOR_KEY, TEMP_SENSOR_TYPE, DEFAULT_URI, _payload, SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW;

//  -- BEGIN BLOCKS --<xml xmlns="http://www.w3.org/1999/xhtml"><variables><variable type="" id="{0:uoGS8Ut7qbrMxY+DT">sensor_name</variable><variable type="" id="7c!C)pNqbjcj7pfQh;(X">sensor_key</variable><variable type="" id=".)wBsSE`u,#%GX!r%rS!">sensor_type</variable><variable type="" id="+}/LZ2zn|5qu,#8oejOB">poll_time</variable><variable type="" id="JrEYqy*^|anEi:~R^~.I">sensor_data</variable><variable type="" id="g(}L4e(EcS=?9mr@Sse?">eventq</variable><variable type="" id="@k2]dh4RQ4wcej_BOd0w">millisec</variable><variable type="" id="HZ:-oBbqC=}eyls/F!Pk">previous</variable><variable type="" id="hIh3XLNku1OauD,!B1pA">sensor_driver</variable><variable type="" id="pW#H4#F0sFg9vRWVahxG">listener</variable><variable type="" id="Pp`tD3_WsBvu+eS=#e?J">uri</variable><variable type="" id="jBKm0@bX]LJI~ItBD}~Z">func</variable><variable type="" id=",2Y@MNx0?i|V5kdPi{7e">SENSOR_DEVICE</variable><variable type="" id="RO2d0yDF8:oHMw[-Uj3t">device_id</variable><variable type="" id="D?Y#zZ*zFk8Jm_p[S5DK">SENSOR_POLL_TIME</variable><variable type="" id="DsgFmEV5|UdiQI~NCCyq">network_ready</variable><variable type="" id="%]#:m|ipJ/Q90Ll(IsoB">TEMP_SENSOR_KEY</variable><variable type="" id="gD!;kECmlnKwow^$@,$b">TEMP_SENSOR_TYPE</variable><variable type="" id="1N7^|lHGQloM|XIAQ,,q">DEFAULT_URI</variable><variable type="" id="}BJ%MDhN{/((:45os0[w">_payload</variable><variable type="" id="%IO`6@izJo0navJh-2_c">SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW</variable></variables><block type="on_start" id="^vGc^r(:XZYLALbQLyIo" x="37" y="13"><comment pinned="false" h="80" w="160">This Rust program polls the internal temperature sensor every 10 seconds and sends the sensor data to the server over NB-IoT.</comment><statement name="STMTS"><block type="variables_set" id="i+pd{7.}H{kf=7UzaH7j"><field name="VAR" id=",2Y@MNx0?i|V5kdPi{7e" variabletype="">SENSOR_DEVICE</field><comment pinned="false" h="80" w="160">Blue Pill's internal temperature sensor</comment><value name="VALUE"><block type="text" id="r}Pwl*3h6;BSjf}6q}_5"><field name="TEXT">temp_stm32_0</field></block></value><next><block type="variables_set" id="GKnT!z1`gQ+xv6#!g80W"><field name="VAR" id="D?Y#zZ*zFk8Jm_p[S5DK" variabletype="">SENSOR_POLL_TIME</field><comment pinned="false" h="80" w="160">Poll the sensor every 10,000 milliseconds (10 seconds)</comment><value name="VALUE"><block type="math_number" id="3rp#U?EVe|SIbr:4|VC$"><field name="NUM">10000</field></block></value><next><block type="variables_set" id="oJWI-`_?$g$k_QWIWLV*"><field name="VAR" id="%]#:m|ipJ/Q90Ll(IsoB" variabletype="">TEMP_SENSOR_KEY</field><comment pinned="false" h="80" w="160">Sensor data will be transmitted to server as field `t`</comment><value name="VALUE"><block type="text" id="{FWpl_$66JK%(Kj_I!+u"><field name="TEXT">t</field></block></value><next><block type="variables_set" id="^*K*S,6+W`Dpo}H|zJ]q"><field name="VAR" id="gD!;kECmlnKwow^$@,$b" variabletype="">TEMP_SENSOR_TYPE</field><comment pinned="false" h="80" w="160">Sensor data is raw temperature in whole numbers (0 to 4095)</comment><value name="VALUE"><block type="variables_get" id="WKpbBqYZ?u,wH8Oe(QDd"><field name="VAR" id="%IO`6@izJo0navJh-2_c" variabletype="">SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW</field></block></value><next><block type="procedures_callnoreturn" id="?45T0G%^uW0zb$AF52MS"><mutation name="start_sensor_listener"><arg name="sensor_name"></arg><arg name="sensor_key"></arg><arg name="sensor_type"></arg><arg name="poll_time"></arg></mutation><comment pinned="false" h="80" w="160">Poll the sensor every 10 seconds</comment><value name="ARG0"><block type="variables_get" id="/-~CoQ[o^Q~`H118qV7["><field name="VAR" id=",2Y@MNx0?i|V5kdPi{7e" variabletype="">SENSOR_DEVICE</field></block></value><value name="ARG1"><block type="variables_get" id="ABXxhH!z/co#DK5V57hK"><field name="VAR" id="%]#:m|ipJ/Q90Ll(IsoB" variabletype="">TEMP_SENSOR_KEY</field></block></value><value name="ARG2"><block type="variables_get" id="BGS`(xh^w[B(^yz!DQ6!"><field name="VAR" id="gD!;kECmlnKwow^$@,$b" variabletype="">TEMP_SENSOR_TYPE</field></block></value><value name="ARG3"><block type="variables_get" id="R3|phL$LS.v]02Xa~T2Z"><field name="VAR" id="D?Y#zZ*zFk8Jm_p[S5DK" variabletype="">SENSOR_POLL_TIME</field></block></value><next><block type="procedures_callnoreturn" id="=L}9h{.d]#2`Ik^C)y(E"><mutation name="sensor_network::start_server_transport"></mutation><comment pinned="false" h="80" w="160">Start connecting to NB-IoT network in a background task</comment></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type="procedures_defnoreturn" id="KY`rjgq5Z]H8nKy_%SbR" x="38" y="337"><mutation><arg name="sensor_name" varid="{0:uoGS8Ut7qbrMxY+DT"></arg><arg name="sensor_key" varid="7c!C)pNqbjcj7pfQh;(X"></arg><arg name="sensor_type" varid=".)wBsSE`u,#%GX!r%rS!"></arg><arg name="poll_time" varid="+}/LZ2zn|5qu,#8oejOB"></arg></mutation><field name="NAME">start_sensor_listener</field><comment pinned="false" h="80" w="160">Poll the temperature sensor every 10 seconds and call function `handle_sensor_data()`.</comment><statement name="STACK"><block type="procedures_callnoreturn" id="7zl-|;/*+_em`,/$a^|n"><mutation name="sensor::set_poll_rate_ms"><arg name="sensor_name"></arg><arg name="millisec"></arg></mutation><comment pinned="false" h="80" w="160">Schedule the sensor to be polled every 10 seconds</comment><value name="ARG0"><block type="variables_get" id="F;QLh/,eA62MaiFP.g1%"><field name="VAR" id="{0:uoGS8Ut7qbrMxY+DT" variabletype="">sensor_name</field></block></value><value name="ARG1"><block type="variables_get" id=".,}J,XVMp1!~,-?zkobg"><field name="VAR" id="+}/LZ2zn|5qu,#8oejOB" variabletype="">poll_time</field></block></value><next><block type="variables_set" id="]o/{kRm?eXa-W;;a^0%C"><field name="VAR" id="hIh3XLNku1OauD,!B1pA" variabletype="">sensor_driver</field><value name="VALUE"><block type="procedures_callreturn" id="*L7}[@[8(Pr:#SMM$2,n"><mutation name="sensor::mgr_find_next_bydevname"><arg name="sensor_name"></arg><arg name="previous"></arg></mutation><comment pinned="false" h="80" w="160">Find the sensor driver by name</comment><value name="ARG0"><block type="variables_get" id="Y_DR2%(VY1$n6MUL^QaI"><field name="VAR" id="{0:uoGS8Ut7qbrMxY+DT" variabletype="">sensor_name</field></block></value><value name="ARG1"><block type="logic_null" id="d]S$}@?~PNik0WpM~60f"></block></value></block></value><next><block type="controls_if" id=".UHdt/ex`})JM^j[pfNB"><comment pinned="false" h="80" w="160">If the sensor driver has been found...</comment><value name="IF0"><block type="logic_compare" id="bd/.^x[4`h|h;CEO3po="><field name="OP">NEQ</field><value name="A"><block type="variables_get" id="Mk3!:U5x*lclmgl-^cZ?"><field name="VAR" id="hIh3XLNku1OauD,!B1pA" variabletype="">sensor_driver</field></block></value><value name="B"><block type="logic_null" id="[N`{;VVc*F5*wL+]hB0."></block></value></block></value><statement name="DO0"><block type="variables_set" id="x9jKBC+Q|JW|QR%BEB?4"><field name="VAR" id="pW#H4#F0sFg9vRWVahxG" variabletype="">listener</field><value name="VALUE"><block type="procedures_callreturn" id="W;M2t0}/X?%gYq@WjMU="><mutation name="sensor::new_sensor_listener"><arg name="sensor_key"></arg><arg name="sensor_type"></arg><arg name="func"></arg></mutation><comment pinned="false" h="80" w="160">Create a sensor listener that will call function `handle_sensor_data` after polling the sensor data</comment><value name="ARG0"><block type="variables_get" id="0Fy_x?O?U-Oqu[jba3Xh"><field name="VAR" id="7c!C)pNqbjcj7pfQh;(X" variabletype="">sensor_key</field></block></value><value name="ARG1"><block type="variables_get" id="b(nCGoy%Yy3)=Uqdjs7="><field name="VAR" id=".)wBsSE`u,#%GX!r%rS!" variabletype="">sensor_type</field></block></value><value name="ARG2"><block type="text" id=":R(*i7s;@j/qr9e@:n}A"><field name="TEXT">handle_sensor_data</field></block></value></block></value><next><block type="procedures_callnoreturn" id="jfH_849uIS#u3r0982fN"><mutation name="sensor::register_listener"><arg name="sensor_driver"></arg><arg name="listener"></arg></mutation><comment pinned="false" h="80" w="160">Register the sensor listener</comment><value name="ARG0"><block type="variables_get" id="]i{;V_ypo:Ljx/0UW*NJ"><field name="VAR" id="hIh3XLNku1OauD,!B1pA" variabletype="">sensor_driver</field></block></value><value name="ARG1"><block type="variables_get" id="Pm5*H9+Z:G:$CR@*.3+%"><field name="VAR" id="pW#H4#F0sFg9vRWVahxG" variabletype="">listener</field></block></value></block></next></block></statement></block></next></block></next></block></statement></block><block type="procedures_defnoreturn" id="fl`yW^^_4l+SknDsFvl4" x="37" y="787"><mutation><arg name="sensor_data" varid="JrEYqy*^|anEi:~R^~.I"></arg></mutation><field name="NAME">handle_sensor_data</field><comment pinned="false" h="94" w="281">This listener function is called every 10 seconds to handle the polled sensor data. We convert the sensor data to our transmission format and transmit to the server.</comment><statement name="STACK"><block type="procedures_callnoreturn" id="10ko7!S__/Nj7|w(3E?B"><mutation name="send_sensor_data"><arg name="sensor_data"></arg></mutation><comment pinned="false" h="80" w="160">Transmit the sensor data to the server</comment><value name="ARG0"><block type="variables_get" id="k=r51M^s3H#o.;((~X@y"><field name="VAR" id="JrEYqy*^|anEi:~R^~.I" variabletype="">sensor_data</field></block></value></block></statement></block><block type="procedures_defnoreturn" id="t9O!Y}._PlhTjJHyAvwn" x="38" y="913"><mutation><arg name="sensor_data" varid="JrEYqy*^|anEi:~R^~.I"></arg></mutation><field name="NAME">send_sensor_data</field><comment pinned="false" h="75" w="390">Compose a CoAP JSON message with the Sensor Key (field name) and Sensor Value in `sensor_data` and send to the CoAP server.</comment><statement name="STACK"><block type="variables_set" id="cs4263HP^nZOYNb`|A7V"><field name="VAR" id="RO2d0yDF8:oHMw[-Uj3t" variabletype="">device_id</field><value name="VALUE"><block type="procedures_callreturn" id="Eno|r%Z@koj%ni]Hu-e:"><mutation name="sensor_network::get_device_id"></mutation><comment pinned="false" h="80" w="160">Get a randomly-generated device ID that changes each time we restart the device</comment></block></value><next><block type="variables_set" id="oKf{~Lu63Ocq4gl;zaRd"><field name="VAR" id="DsgFmEV5|UdiQI~NCCyq" variabletype="">network_ready</field><value name="VALUE"><block type="procedures_callreturn" id="pG@NWjolgpj08RFHM?ev"><mutation name="sensor_network::init_server_post"><arg name="uri"></arg></mutation><comment pinned="false" h="80" w="160">Start composing a CoAP message</comment><value name="ARG0"><block type="variables_get" id=",%Y2j~/iSE|X@lvZXZ(k"><field name="VAR" id="1N7^|lHGQloM|XIAQ,,q" variabletype="">DEFAULT_URI</field></block></value></block></value><next><block type="controls_if" id="R7$Wk^LOse[oi8Q.^2Sv"><comment pinned="false" h="80" w="160">Proceed to compose the CoAP message only when the device has connected to the NB-IoT network</comment><value name="IF0"><block type="variables_get" id="V5-,V^Pq]/%tR9Z$?d._"><field name="VAR" id="DsgFmEV5|UdiQI~NCCyq" variabletype="">network_ready</field></block></value><statement name="DO0"><block type="variables_set" id="Z0$@)|y921DbN0kSddbO"><field name="VAR" id="}BJ%MDhN{/((:45os0[w" variabletype="">_payload</field><value name="VALUE"><block type="coap" id=":([H5K2n%WnR5`Sizh9C"><mutation items="2"></mutation><comment pinned="false" h="80" w="160">Create a CoAP message with payload in JSON format</comment><value name="ADD0"><block type="field" id="^6fHdax-y+:8zGkvi3LS"><field name="NAME">device</field><comment pinned="false" h="80" w="160">Fill in the random device ID</comment><value name="name"><block type="variables_get" id="Enc[hG3~{.AO$tZ97XKo"><field name="VAR" id="RO2d0yDF8:oHMw[-Uj3t" variabletype="">device_id</field></block></value></block></value><value name="ADD1"><block type="variables_get" id="ZNl3OZt$9VZ3=7QS23Sa"><field name="VAR" id="JrEYqy*^|anEi:~R^~.I" variabletype="">sensor_data</field><comment pinned="false" h="80" w="160">And the sensor data like `t: 2870`</comment></block></value></block></value><next><block type="procedures_callnoreturn" id="tc/EWZNB{if?Hk[r(w8A"><mutation name="sensor_network::do_server_post"></mutation><comment pinned="false" h="80" w="160">Transmit the CoAP message to the CoAP Server over NB-IoT. This takes place in a background task.</comment><next><block type="text_print" id="z$8.whQlNDleL#kb0gu{"><comment pinned="false" h="80" w="160">Show a URL that may be clicked to display the sensor data received by the server</comment><value name="TEXT"><shadow type="text" id="Ed8;ecAuHPZmlQzD#h|G"><field name="TEXT">View your sensor at https://blue-pill-geolocate.appspot.com?device=</field></shadow></value><next><block type="text_print" id="9dQhy)Vpl:|?vF52n#W_"><value name="TEXT"><shadow type="text" id="@oTMDBw/pbV^]E%i3gbD"><field name="TEXT">abc</field></shadow><block type="variables_get" id="Zp=M(9.cCWEG8C^Xn2Pc"><field name="VAR" id="RO2d0yDF8:oHMw[-Uj3t" variabletype="">device_id</field></block></value><next><block type="text_print" id="U.%)$JVtb~`eH)57VyH7"><value name="TEXT"><shadow type="text" id="t%Osi6c{NxLAt_$*!!o)"><field name="TEXT">\n</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block></next></block></next></block></statement></block><block type="procedures_defnoreturn" id="Ny4W{:ArnXek8XO}zd[o" x="-337" y="1138"><field name="NAME">os::sysinit</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="Xw{:o4uh]%~h6;PKK!yM" x="-338" y="1213"><mutation><arg name="eventq" varid="g(}L4e(EcS=?9mr@Sse?"></arg></mutation><field name="NAME">os::eventq_run</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="K,gOd#6I?+U_3r}Ki.qh" x="-337" y="1287"><field name="NAME">os::eventq_dflt_get</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="037^3_Ln_M0LB;?,1pm;" x="588" y="1463"><field name="NAME">sensor_network::get_device_id</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="[fJkz[Ay6X2JAYvRINM5" x="38" y="1512"><mutation><arg name="sensor_name" varid="{0:uoGS8Ut7qbrMxY+DT"></arg><arg name="millisec" varid="@k2]dh4RQ4wcej_BOd0w"></arg></mutation><field name="NAME">sensor::set_poll_rate_ms</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="V7_4a|rA}$-9K{/9v$o5" x="38" y="1587"><mutation statements="false"><arg name="sensor_name" varid="{0:uoGS8Ut7qbrMxY+DT"></arg><arg name="previous" varid="HZ:-oBbqC=}eyls/F!Pk"></arg></mutation><field name="NAME">sensor::mgr_find_next_bydevname</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="x8HC)hVxiLkuLgW_uU]i" x="588" y="1563"><field name="NAME">sensor_network::start_server_transport</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="`{AbNvOKicSC/jqf@x{x" x="37" y="1662"><mutation><arg name="sensor_driver" varid="hIh3XLNku1OauD,!B1pA"></arg><arg name="listener" varid="pW#H4#F0sFg9vRWVahxG"></arg></mutation><field name="NAME">sensor::register_listener</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="1(_S?yj!][ZE7)d1b/^:" x="588" y="1638"><mutation><arg name="uri" varid="Pp`tD3_WsBvu+eS=#e?J"></arg></mutation><field name="NAME">sensor_network::init_server_post</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="#3mI_^T-zd$ff{L|G-qA" x="38" y="1738"><mutation statements="false"><arg name="sensor_key" varid="7c!C)pNqbjcj7pfQh;(X"></arg><arg name="sensor_type" varid=".)wBsSE`u,#%GX!r%rS!"></arg><arg name="func" varid="jBKm0@bX]LJI~ItBD}~Z"></arg></mutation><field name="NAME">sensor::new_sensor_listener</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id=")Gs9;%U7lg,N1F~dBmh[" x="588" y="1738"><field name="NAME">sensor_network::do_server_post</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block></xml>-- END BLOCKS --