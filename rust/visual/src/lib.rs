//! This program was automatically generated by Visual Embedded Rust. Don't edit here!
#![no_std]                       //  Don't link with standard Rust library, which is not compatible with embedded systems
#![feature(trace_macros)]        //  Allow macro tracing: `trace_macros!(true)`
#![feature(concat_idents)]       //  Allow `concat_idents!()` macro used in `coap!()` macro
#![feature(const_transmute)]     //  Allow `transmute` for initialising Mynewt structs
#![feature(proc_macro_hygiene)]  //  Allow Procedural Macros like `run!()`
#![feature(custom_attribute)]    //  Allow Custom Attributes like `#[safe_wrap]`

extern crate cortex_m;                  //  Declare the external library `cortex_m`
extern crate mynewt;                    //  Declare the Mynewt library
extern crate macros as mynewt_macros;   //  Declare the Mynewt Procedural Macros library

use core::panic::PanicInfo; //  Import `PanicInfo` type which is used by `panic()` below
use core::ptr::null_mut;
use cortex_m::asm::bkpt;    //  Import cortex_m assembly function to inject breakpoint
use mynewt::{
    result::*,              //  Import Mynewt API Result and Error types
    kernel::os,             //  Import Mynewt OS API
    sys::console,           //  Import Mynewt Console API
    encoding::coap_context::*,  //  Import Mynewt Encoding API
    hw::sensor::{
        self,               //  Import Mynewt Sensor API functions
        sensor_ptr,         //  Import Mynewt Sensor API types
        sensor_arg, sensor_data_ptr, sensor_listener,
        sensor_temp_raw_data, sensor_type_t,
        SensorValue, SensorValueType,
        SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW,
    },
    libs::sensor_network,      //  Import Mynewt Sensor Network Library
    Strn, fill_zero, coap, d,  //  Import Mynewt macros
};
use mynewt_macros::{ init_strn, strn };  //  Import Mynewt procedural macros

/// Will be run upon startup to initialise the app
fn on_start() -> MynewtResult<()> {
    let SENSOR_DEVICE = strn!( "temp_stm32_0" );
    let SENSOR_POLL_TIME = 10000;
    let TEMP_SENSOR_KEY = strn!( "t" );
    let TEMP_SENSOR_TYPE = SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW;
    start_sensor_listener(SENSOR_DEVICE, TEMP_SENSOR_TYPE, SENSOR_POLL_TIME) ? ;
    sensor_network::start_server_transport() ? ;

    //  Return success to `main()`.
    Ok(())
}

/// Ask Mynewt to poll the temperature sensor every
/// 10 seconds and call `handle_sensor_data()`.
#[mynewt_macros::infer_type(attr)]  //  Infer the missing types
fn start_sensor_listener(sensor: _, sensor_type: _, poll_time: _) -> MynewtResult<()> {
  sensor::set_poll_rate_ms(sensor, poll_time) ? ;
  let sensor_object = sensor::mgr_find_next_bydevname(sensor, null_mut()) ? ;
  if sensor_object != null_mut() {
    let listener = sensor::new_sensor_listener(sensor_type, handle_sensor_data) ? ;
    sensor::register_listener(sensor_object, listener) ? ;
  }
  Ok(())
}

/// This listener function is called every 10 seconds by Mynewt
/// to handle the polled sensor data. We convert the sensor
/// data to our transmission format and transmit to the server.
#[mynewt_macros::infer_type(attr)]  //  Infer the missing types
fn handle_sensor_data(sensor_data: _) -> MynewtResult<()> {
  send_sensor_data(sensor_data) ? ;
  Ok(())
}

/// Compose a CoAP JSON message with the Sensor Key (field name)
/// and Sensor Value in `sensor_data` and send to the CoAP server.
#[mynewt_macros::infer_type(attr)]  //  Infer the missing types
fn send_sensor_data(sensor_data: _) -> MynewtResult<()> {
  let device_id = sensor_network::get_device_id() ? ;
  let network_ready = sensor_network::init_server_post(DEFAULT_URI) ? ;
  if network_ready {
    let payload = coap!( @json {
      "device": device_id,
      sensor_data
    });
    sensor_network::do_server_post() ? ;
  }
  Ok(())
}

/// main() will be called at Mynewt startup. It replaces the C version of the `main()` function.
#[no_mangle]                 //  Don't mangle the name "main"
extern "C" fn main() -> ! {  //  Declare `extern "C"` because it will be called by Mynewt
    //  Initialise Mynewt OS.
    mynewt::sysinit();

    //  Initialise the app.
    on_start()
        .expect("on_start fail");

    //  Mynewt event loop
    loop {                         //  Loop forever...
        os::eventq_run(            //  Process events...
            os::eventq_dflt_get()  //  From default event queue
                .expect("get fail")
        ).expect("run fail")
    }
    //  Never comes here
}

/// This function is called on panic, like an assertion failure. We display the filename and line number and pause in the debugger. From https://os.phil-opp.com/freestanding-rust-binary/
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    //  Display the filename and line number in the Semihosting Console.
    console::print("panic ");
    if let Some(location) = info.location() {
        let file = location.file();
        let line = location.line();
        console::print("at ");       console::buffer(&file);
        console::print(" line 0x");  console::printhex(line as u8);  //  TODO: Print in decimal not hex. Allow more than 255 lines.
        console::print("\n");       console::flush();
    } else {
        console::print("no loc\n");  console::flush();
    }
    //  Pause in the debugger.
    bkpt();
    //  Loop forever so that device won't restart.
    loop {}
}

const DEFAULT_URI: Strn = init_strn!("");

//  Globals: sensor, sensor_type, poll_time, sensor_data, eventq, millisec, previous, sensor_object, listener, uri, func, SENSOR_DEVICE, device_id, SENSOR_POLL_TIME, network_ready, TEMP_SENSOR_KEY, TEMP_SENSOR_TYPE, DEFAULT_URI, payload, SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW;

//  -- BEGIN BLOCKS --<xml xmlns="http://www.w3.org/1999/xhtml"><variables><variable type="" id="{0:uoGS8Ut7qbrMxY+DT">sensor</variable><variable type="" id=".)wBsSE`u,#%GX!r%rS!">sensor_type</variable><variable type="" id="+}/LZ2zn|5qu,#8oejOB">poll_time</variable><variable type="" id="JrEYqy*^|anEi:~R^~.I">sensor_data</variable><variable type="" id="g(}L4e(EcS=?9mr@Sse?">eventq</variable><variable type="" id="@k2]dh4RQ4wcej_BOd0w">millisec</variable><variable type="" id="HZ:-oBbqC=}eyls/F!Pk">previous</variable><variable type="" id="hIh3XLNku1OauD,!B1pA">sensor_object</variable><variable type="" id="pW#H4#F0sFg9vRWVahxG">listener</variable><variable type="" id="Pp`tD3_WsBvu+eS=#e?J">uri</variable><variable type="" id="jBKm0@bX]LJI~ItBD}~Z">func</variable><variable type="" id=",2Y@MNx0?i|V5kdPi{7e">SENSOR_DEVICE</variable><variable type="" id="RO2d0yDF8:oHMw[-Uj3t">device_id</variable><variable type="" id="D?Y#zZ*zFk8Jm_p[S5DK">SENSOR_POLL_TIME</variable><variable type="" id="DsgFmEV5|UdiQI~NCCyq">network_ready</variable><variable type="" id="%]#:m|ipJ/Q90Ll(IsoB">TEMP_SENSOR_KEY</variable><variable type="" id="gD!;kECmlnKwow^$@,$b">TEMP_SENSOR_TYPE</variable><variable type="" id="1N7^|lHGQloM|XIAQ,,q">DEFAULT_URI</variable><variable type="" id="}BJ%MDhN{/((:45os0[w">payload</variable><variable type="" id="%IO`6@izJo0navJh-2_c">SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW</variable></variables><block type="on_start" id="^vGc^r(:XZYLALbQLyIo" x="37" y="13"><statement name="STMTS"><block type="variables_set" id="i+pd{7.}H{kf=7UzaH7j"><field name="VAR" id=",2Y@MNx0?i|V5kdPi{7e" variabletype="">SENSOR_DEVICE</field><value name="VALUE"><block type="text" id="r}Pwl*3h6;BSjf}6q}_5"><field name="TEXT">temp_stm32_0</field></block></value><next><block type="variables_set" id="GKnT!z1`gQ+xv6#!g80W"><field name="VAR" id="D?Y#zZ*zFk8Jm_p[S5DK" variabletype="">SENSOR_POLL_TIME</field><value name="VALUE"><block type="math_number" id="3rp#U?EVe|SIbr:4|VC$"><field name="NUM">10000</field></block></value><next><block type="variables_set" id="oJWI-`_?$g$k_QWIWLV*"><field name="VAR" id="%]#:m|ipJ/Q90Ll(IsoB" variabletype="">TEMP_SENSOR_KEY</field><value name="VALUE"><block type="text" id="{FWpl_$66JK%(Kj_I!+u"><field name="TEXT">t</field></block></value><next><block type="variables_set" id="^*K*S,6+W`Dpo}H|zJ]q"><field name="VAR" id="gD!;kECmlnKwow^$@,$b" variabletype="">TEMP_SENSOR_TYPE</field><value name="VALUE"><block type="variables_get" id="WKpbBqYZ?u,wH8Oe(QDd"><field name="VAR" id="%IO`6@izJo0navJh-2_c" variabletype="">SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW</field></block></value><next><block type="procedures_callnoreturn" id="?45T0G%^uW0zb$AF52MS"><mutation name="start_sensor_listener"><arg name="sensor"></arg><arg name="sensor_type"></arg><arg name="poll_time"></arg></mutation><value name="ARG0"><block type="variables_get" id="/-~CoQ[o^Q~`H118qV7["><field name="VAR" id=",2Y@MNx0?i|V5kdPi{7e" variabletype="">SENSOR_DEVICE</field></block></value><value name="ARG1"><block type="variables_get" id="BGS`(xh^w[B(^yz!DQ6!"><field name="VAR" id="gD!;kECmlnKwow^$@,$b" variabletype="">TEMP_SENSOR_TYPE</field></block></value><value name="ARG2"><block type="variables_get" id="R3|phL$LS.v]02Xa~T2Z"><field name="VAR" id="D?Y#zZ*zFk8Jm_p[S5DK" variabletype="">SENSOR_POLL_TIME</field></block></value><next><block type="procedures_callnoreturn" id="=L}9h{.d]#2`Ik^C)y(E"><mutation name="sensor_network::start_server_transport"></mutation></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type="procedures_defnoreturn" id="KY`rjgq5Z]H8nKy_%SbR" x="37" y="312"><mutation><arg name="sensor" varid="{0:uoGS8Ut7qbrMxY+DT"></arg><arg name="sensor_type" varid=".)wBsSE`u,#%GX!r%rS!"></arg><arg name="poll_time" varid="+}/LZ2zn|5qu,#8oejOB"></arg></mutation><field name="NAME">start_sensor_listener</field><comment pinned="false" h="80" w="160">Ask Mynewt to poll the temperature sensor every 10 seconds and call `handle_sensor_data()`.</comment><statement name="STACK"><block type="procedures_callnoreturn" id="7zl-|;/*+_em`,/$a^|n"><mutation name="sensor::set_poll_rate_ms"><arg name="sensor"></arg><arg name="millisec"></arg></mutation><value name="ARG0"><block type="variables_get" id="F;QLh/,eA62MaiFP.g1%"><field name="VAR" id="{0:uoGS8Ut7qbrMxY+DT" variabletype="">sensor</field></block></value><value name="ARG1"><block type="variables_get" id=".,}J,XVMp1!~,-?zkobg"><field name="VAR" id="+}/LZ2zn|5qu,#8oejOB" variabletype="">poll_time</field></block></value><next><block type="variables_set" id="]o/{kRm?eXa-W;;a^0%C"><field name="VAR" id="hIh3XLNku1OauD,!B1pA" variabletype="">sensor_object</field><value name="VALUE"><block type="procedures_callreturn" id="*L7}[@[8(Pr:#SMM$2,n"><mutation name="sensor::mgr_find_next_bydevname"><arg name="sensor"></arg><arg name="previous"></arg></mutation><value name="ARG0"><block type="variables_get" id="Y_DR2%(VY1$n6MUL^QaI"><field name="VAR" id="{0:uoGS8Ut7qbrMxY+DT" variabletype="">sensor</field></block></value><value name="ARG1"><block type="logic_null" id="d]S$}@?~PNik0WpM~60f"></block></value></block></value><next><block type="controls_if" id=".UHdt/ex`})JM^j[pfNB"><value name="IF0"><block type="logic_compare" id="bd/.^x[4`h|h;CEO3po="><field name="OP">NEQ</field><value name="A"><block type="variables_get" id="Mk3!:U5x*lclmgl-^cZ?"><field name="VAR" id="hIh3XLNku1OauD,!B1pA" variabletype="">sensor_object</field></block></value><value name="B"><block type="logic_null" id="[N`{;VVc*F5*wL+]hB0."></block></value></block></value><statement name="DO0"><block type="variables_set" id="x9jKBC+Q|JW|QR%BEB?4"><field name="VAR" id="pW#H4#F0sFg9vRWVahxG" variabletype="">listener</field><value name="VALUE"><block type="procedures_callreturn" id="W;M2t0}/X?%gYq@WjMU="><mutation name="sensor::new_sensor_listener"><arg name="sensor_type"></arg><arg name="func"></arg></mutation><value name="ARG0"><block type="variables_get" id="b(nCGoy%Yy3)=Uqdjs7="><field name="VAR" id=".)wBsSE`u,#%GX!r%rS!" variabletype="">sensor_type</field></block></value><value name="ARG1"><block type="text" id=":R(*i7s;@j/qr9e@:n}A"><field name="TEXT">handle_sensor_data</field></block></value></block></value><next><block type="procedures_callnoreturn" id="jfH_849uIS#u3r0982fN"><mutation name="sensor::register_listener"><arg name="sensor_object"></arg><arg name="listener"></arg></mutation><value name="ARG0"><block type="variables_get" id="]i{;V_ypo:Ljx/0UW*NJ"><field name="VAR" id="hIh3XLNku1OauD,!B1pA" variabletype="">sensor_object</field></block></value><value name="ARG1"><block type="variables_get" id="Pm5*H9+Z:G:$CR@*.3+%"><field name="VAR" id="pW#H4#F0sFg9vRWVahxG" variabletype="">listener</field></block></value></block></next></block></statement></block></next></block></next></block></statement></block><block type="procedures_defnoreturn" id="fl`yW^^_4l+SknDsFvl4" x="37" y="738"><mutation><arg name="sensor_data" varid="JrEYqy*^|anEi:~R^~.I"></arg></mutation><field name="NAME">handle_sensor_data</field><comment pinned="false" h="80" w="160">This listener function is called every 10 seconds by Mynewt to handle the polled sensor data. We convert the sensor data to our transmission format and transmit to the server.</comment><statement name="STACK"><block type="procedures_callnoreturn" id="10ko7!S__/Nj7|w(3E?B"><mutation name="send_sensor_data"><arg name="sensor_data"></arg></mutation><value name="ARG0"><block type="variables_get" id="k=r51M^s3H#o.;((~X@y"><field name="VAR" id="JrEYqy*^|anEi:~R^~.I" variabletype="">sensor_data</field></block></value></block></statement></block><block type="procedures_defnoreturn" id="t9O!Y}._PlhTjJHyAvwn" x="38" y="863"><mutation><arg name="sensor_data" varid="JrEYqy*^|anEi:~R^~.I"></arg></mutation><field name="NAME">send_sensor_data</field><comment pinned="false" h="80" w="160">Compose a CoAP JSON message with the Sensor Key (field name) and Sensor Value in `sensor_data` and send to the CoAP server.</comment><statement name="STACK"><block type="variables_set" id="cs4263HP^nZOYNb`|A7V"><field name="VAR" id="RO2d0yDF8:oHMw[-Uj3t" variabletype="">device_id</field><value name="VALUE"><block type="procedures_callreturn" id="Eno|r%Z@koj%ni]Hu-e:"><mutation name="sensor_network::get_device_id"></mutation></block></value><next><block type="variables_set" id="oKf{~Lu63Ocq4gl;zaRd"><field name="VAR" id="DsgFmEV5|UdiQI~NCCyq" variabletype="">network_ready</field><value name="VALUE"><block type="procedures_callreturn" id="pG@NWjolgpj08RFHM?ev"><mutation name="sensor_network::init_server_post"><arg name="uri"></arg></mutation><value name="ARG0"><block type="variables_get" id=",%Y2j~/iSE|X@lvZXZ(k"><field name="VAR" id="1N7^|lHGQloM|XIAQ,,q" variabletype="">DEFAULT_URI</field></block></value></block></value><next><block type="controls_if" id="R7$Wk^LOse[oi8Q.^2Sv"><value name="IF0"><block type="variables_get" id="V5-,V^Pq]/%tR9Z$?d._"><field name="VAR" id="DsgFmEV5|UdiQI~NCCyq" variabletype="">network_ready</field></block></value><statement name="DO0"><block type="variables_set" id="Z0$@)|y921DbN0kSddbO"><field name="VAR" id="}BJ%MDhN{/((:45os0[w" variabletype="">payload</field><value name="VALUE"><block type="coap" id=":([H5K2n%WnR5`Sizh9C"><mutation items="2"></mutation><value name="ADD0"><block type="field" id="^6fHdax-y+:8zGkvi3LS"><field name="NAME">device</field><value name="name"><block type="variables_get" id="Enc[hG3~{.AO$tZ97XKo"><field name="VAR" id="RO2d0yDF8:oHMw[-Uj3t" variabletype="">device_id</field></block></value></block></value><value name="ADD1"><block type="variables_get" id="ZNl3OZt$9VZ3=7QS23Sa"><field name="VAR" id="JrEYqy*^|anEi:~R^~.I" variabletype="">sensor_data</field></block></value></block></value><next><block type="procedures_callnoreturn" id="tc/EWZNB{if?Hk[r(w8A"><mutation name="sensor_network::do_server_post"></mutation></block></next></block></statement></block></next></block></next></block></statement></block><block type="procedures_defnoreturn" id="Ny4W{:ArnXek8XO}zd[o" x="-337" y="1138"><field name="NAME">os::sysinit</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="Xw{:o4uh]%~h6;PKK!yM" x="-338" y="1213"><mutation><arg name="eventq" varid="g(}L4e(EcS=?9mr@Sse?"></arg></mutation><field name="NAME">os::eventq_run</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="K,gOd#6I?+U_3r}Ki.qh" x="-337" y="1287"><field name="NAME">os::eventq_dflt_get</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="037^3_Ln_M0LB;?,1pm;" x="588" y="1463"><field name="NAME">sensor_network::get_device_id</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="[fJkz[Ay6X2JAYvRINM5" x="38" y="1512"><mutation><arg name="sensor" varid="{0:uoGS8Ut7qbrMxY+DT"></arg><arg name="millisec" varid="@k2]dh4RQ4wcej_BOd0w"></arg></mutation><field name="NAME">sensor::set_poll_rate_ms</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="V7_4a|rA}$-9K{/9v$o5" x="38" y="1587"><mutation statements="false"><arg name="sensor" varid="{0:uoGS8Ut7qbrMxY+DT"></arg><arg name="previous" varid="HZ:-oBbqC=}eyls/F!Pk"></arg></mutation><field name="NAME">sensor::mgr_find_next_bydevname</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="x8HC)hVxiLkuLgW_uU]i" x="588" y="1563"><field name="NAME">sensor_network::start_server_transport</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id="`{AbNvOKicSC/jqf@x{x" x="37" y="1662"><mutation><arg name="sensor_object" varid="hIh3XLNku1OauD,!B1pA"></arg><arg name="listener" varid="pW#H4#F0sFg9vRWVahxG"></arg></mutation><field name="NAME">sensor::register_listener</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="1(_S?yj!][ZE7)d1b/^:" x="588" y="1638"><mutation><arg name="uri" varid="Pp`tD3_WsBvu+eS=#e?J"></arg></mutation><field name="NAME">sensor_network::init_server_post</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defreturn" id="#3mI_^T-zd$ff{L|G-qA" x="38" y="1738"><mutation statements="false"><arg name="sensor_type" varid=".)wBsSE`u,#%GX!r%rS!"></arg><arg name="func" varid="jBKm0@bX]LJI~ItBD}~Z"></arg></mutation><field name="NAME">sensor::new_sensor_listener</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block><block type="procedures_defnoreturn" id=")Gs9;%U7lg,N1F~dBmh[" x="588" y="1738"><field name="NAME">sensor_network::do_server_post</field><comment pinned="false" h="80" w="160">Describe this function...</comment></block></xml>-- END BLOCKS --