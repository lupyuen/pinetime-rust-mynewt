/* automatically generated by rust-bindgen */

pub
const
CborIndefiniteLength:usize=0xffffffffusize;

pub type __uint8_t = ::cty::c_uchar;
pub type __uint16_t = ::cty::c_ushort;
pub type __uint32_t = ::cty::c_ulong;
pub type __int64_t = ::cty::c_longlong;
pub type __uint64_t = ::cty::c_ulonglong;
pub type __uintptr_t = ::cty::c_uint;
pub type FILE = File;
#[repr(C)]
#[derive(Default)]
pub struct File_methods {
    pub write: ::core::option::Option<
        unsafe extern "C" fn(instance: *mut FILE, bp: *const ::cty::c_char, n: usize) -> usize,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(instance: *mut FILE, bp: *mut ::cty::c_char, n: usize) -> usize,
    >,
}
#[repr(C)]
pub struct File {
    pub vmt: *const File_methods,
}
impl Default for File {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const CborType_CborIntegerType: CborType = 0;
pub const CborType_CborByteStringType: CborType = 64;
pub const CborType_CborTextStringType: CborType = 96;
pub const CborType_CborArrayType: CborType = 128;
pub const CborType_CborMapType: CborType = 160;
pub const CborType_CborTagType: CborType = 192;
pub const CborType_CborSimpleType: CborType = 224;
pub const CborType_CborBooleanType: CborType = 245;
pub const CborType_CborNullType: CborType = 246;
pub const CborType_CborUndefinedType: CborType = 247;
pub const CborType_CborHalfFloatType: CborType = 249;
pub const CborType_CborFloatType: CborType = 250;
pub const CborType_CborDoubleType: CborType = 251;
pub const CborType_CborInvalidType: CborType = 255;
pub type CborType = u32;
pub type CborTag = u64;
pub const CborKnownTags_CborDateTimeStringTag: CborKnownTags = 0;
pub const CborKnownTags_CborUnixTime_tTag: CborKnownTags = 1;
pub const CborKnownTags_CborPositiveBignumTag: CborKnownTags = 2;
pub const CborKnownTags_CborNegativeBignumTag: CborKnownTags = 3;
pub const CborKnownTags_CborDecimalTag: CborKnownTags = 4;
pub const CborKnownTags_CborBigfloatTag: CborKnownTags = 5;
pub const CborKnownTags_CborExpectedBase64urlTag: CborKnownTags = 21;
pub const CborKnownTags_CborExpectedBase64Tag: CborKnownTags = 22;
pub const CborKnownTags_CborExpectedBase16Tag: CborKnownTags = 23;
pub const CborKnownTags_CborUriTag: CborKnownTags = 32;
pub const CborKnownTags_CborBase64urlTag: CborKnownTags = 33;
pub const CborKnownTags_CborBase64Tag: CborKnownTags = 34;
pub const CborKnownTags_CborRegularExpressionTag: CborKnownTags = 35;
pub const CborKnownTags_CborMimeMessageTag: CborKnownTags = 36;
pub const CborKnownTags_CborSignatureTag: CborKnownTags = 55799;
pub type CborKnownTags = u32;
pub const CborError_CborNoError: CborError = 0;
pub const CborError_CborUnknownError: CborError = 1;
pub const CborError_CborErrorUnknownLength: CborError = 2;
pub const CborError_CborErrorAdvancePastEOF: CborError = 3;
pub const CborError_CborErrorIO: CborError = 4;
pub const CborError_CborErrorGarbageAtEnd: CborError = 256;
pub const CborError_CborErrorUnexpectedEOF: CborError = 257;
pub const CborError_CborErrorUnexpectedBreak: CborError = 258;
pub const CborError_CborErrorUnknownType: CborError = 259;
pub const CborError_CborErrorIllegalType: CborError = 260;
pub const CborError_CborErrorIllegalNumber: CborError = 261;
pub const CborError_CborErrorIllegalSimpleType: CborError = 262;
pub const CborError_CborErrorUnknownSimpleType: CborError = 512;
pub const CborError_CborErrorUnknownTag: CborError = 513;
pub const CborError_CborErrorInappropriateTagForType: CborError = 514;
pub const CborError_CborErrorDuplicateObjectKeys: CborError = 515;
pub const CborError_CborErrorInvalidUtf8TextString: CborError = 516;
pub const CborError_CborErrorTooManyItems: CborError = 768;
pub const CborError_CborErrorTooFewItems: CborError = 769;
pub const CborError_CborErrorDataTooLarge: CborError = 1024;
pub const CborError_CborErrorNestingTooDeep: CborError = 1025;
pub const CborError_CborErrorUnsupportedType: CborError = 1026;
pub const CborError_CborErrorJsonObjectKeyIsAggregate: CborError = 1027;
pub const CborError_CborErrorJsonObjectKeyNotString: CborError = 1028;
pub const CborError_CborErrorJsonNotImplemented: CborError = 1029;
pub const CborError_CborErrorOutOfMemory: CborError = 2147483648;
pub const CborError_CborErrorInternalError: CborError = 4294967295;
pub type CborError = u32;
extern "C" {
    pub fn cbor_error_string(error: CborError) -> *const ::cty::c_char;
}
pub type cbor_encoder_write = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cbor_encoder_writer,
        data: *const ::cty::c_char,
        len: ::cty::c_int,
    ) -> ::cty::c_int,
>;
#[repr(C)]
#[derive(Default)]
pub struct cbor_encoder_writer {
    pub write: cbor_encoder_write,
    pub bytes_written: ::cty::c_int,
}
#[repr(C)]
pub struct cbor_iovec {
    pub iov_base: *mut ::cty::c_void,
    pub iov_len: usize,
}
impl Default for cbor_iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct CborEncoder {
    pub writer: *mut cbor_encoder_writer,
    pub writer_arg: *mut ::cty::c_void,
    pub added: usize,
    pub flags: ::cty::c_int,
}
impl Default for CborEncoder {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Initializes a CborEncoder structure \\a encoder by pointing it to buffer \\a"]
    #[doc = " buffer of size \\a size. The \\a flags field is currently unused and must be"]
    #[doc = " zero."]
    pub fn cbor_encoder_init(
        encoder: *mut CborEncoder,
        pwriter: *mut cbor_encoder_writer,
        flags: ::cty::c_int,
    );
}
extern "C" {
    #[doc = " Appends the unsigned 64-bit integer \\a value to the CBOR stream provided by"]
    #[doc = " \\a encoder."]
    #[doc = ""]
    #[doc = " \\sa cbor_encode_negative_int, cbor_encode_int"]
    pub fn cbor_encode_uint(encoder: *mut CborEncoder, value: u64) -> CborError;
}
extern "C" {
    #[doc = " Appends the signed 64-bit integer \\a value to the CBOR stream provided by"]
    #[doc = " \\a encoder."]
    #[doc = ""]
    #[doc = " \\sa cbor_encode_negative_int, cbor_encode_uint"]
    pub fn cbor_encode_int(encoder: *mut CborEncoder, value: i64) -> CborError;
}
extern "C" {
    #[doc = " Appends the negative 64-bit integer whose absolute value is \\a"]
    #[doc = " absolute_value to the CBOR stream provided by \\a encoder."]
    #[doc = ""]
    #[doc = " \\sa cbor_encode_uint, cbor_encode_int"]
    pub fn cbor_encode_negative_int(encoder: *mut CborEncoder, absolute_value: u64) -> CborError;
}
extern "C" {
    #[doc = " Appends the CBOR Simple Type of value \\a value to the CBOR stream provided by"]
    #[doc = " \\a encoder."]
    #[doc = ""]
    #[doc = " This function may return error CborErrorIllegalSimpleType if the \\a value"]
    #[doc = " variable contains a number that is not a valid simple type."]
    pub fn cbor_encode_simple_value(encoder: *mut CborEncoder, value: u8) -> CborError;
}
extern "C" {
    #[doc = " Appends the CBOR tag \\a tag to the CBOR stream provided by \\a encoder."]
    #[doc = ""]
    #[doc = " \\sa CborTag"]
    pub fn cbor_encode_tag(encoder: *mut CborEncoder, tag: CborTag) -> CborError;
}
extern "C" {
    #[doc = " Appends the byte string \\a string of length \\a length to the CBOR stream"]
    #[doc = " provided by \\a encoder. CBOR byte strings are arbitrary raw data."]
    #[doc = ""]
    #[doc = " \\sa cbor_encode_text_stringz, cbor_encode_text_string"]
    pub fn cbor_encode_text_string(
        encoder: *mut CborEncoder,
        string: *const ::cty::c_char,
        length: usize,
    ) -> CborError;
}
extern "C" {
    #[doc = " Appends the text string \\a string of length \\a length to the CBOR stream"]
    #[doc = " provided by \\a encoder. CBOR requires that \\a string be valid UTF-8, but"]
    #[doc = " TinyCBOR makes no verification of correctness."]
    #[doc = ""]
    #[doc = " \\sa CborError cbor_encode_text_stringz, cbor_encode_byte_string"]
    pub fn cbor_encode_byte_string(
        encoder: *mut CborEncoder,
        string: *const u8,
        length: usize,
    ) -> CborError;
}
extern "C" {
    #[doc = " Appends the byte string passed as \\a iov and \\a iov_len to the CBOR"]
    #[doc = " stream provided by \\a encoder. CBOR byte strings are arbitrary raw data."]
    #[doc = ""]
    #[doc = " \\sa CborError cbor_encode_text_stringz, cbor_encode_byte_string"]
    pub fn cbor_encode_byte_iovec(
        encoder: *mut CborEncoder,
        iov: *const cbor_iovec,
        iov_len: ::cty::c_int,
    ) -> CborError;
}
extern "C" {
    #[doc = " Appends the floating-point value of type \\a fpType and pointed to by \\a"]
    #[doc = " value to the CBOR stream provided by \\a encoder. The value of \\a fpType must"]
    #[doc = " be one of CborHalfFloatType, CborFloatType or CborDoubleType, otherwise the"]
    #[doc = " behavior of this function is undefined."]
    #[doc = ""]
    #[doc = " This function is useful for code that needs to pass through floating point"]
    #[doc = " values but does not wish to have the actual floating-point code."]
    #[doc = ""]
    #[doc = " \\sa cbor_encode_half_float, cbor_encode_float, cbor_encode_double"]
    pub fn cbor_encode_floating_point(
        encoder: *mut CborEncoder,
        fpType: CborType,
        value: *const ::cty::c_void,
    ) -> CborError;
}
extern "C" {
    #[doc = " Creates a CBOR array in the CBOR stream provided by \\a encoder and"]
    #[doc = " initializes \\a arrayEncoder so that items can be added to the array using"]
    #[doc = " the CborEncoder functions. The array must be terminated by calling either"]
    #[doc = " cbor_encoder_close_container() or cbor_encoder_close_container_checked()"]
    #[doc = " with the same \\a encoder and \\a arrayEncoder parameters."]
    #[doc = ""]
    #[doc = " The number of items inserted into the array must be exactly \\a length items,"]
    #[doc = " otherwise the stream is invalid. If the number of items is not known when"]
    #[doc = " creating the array, the constant \\ref CborIndefiniteLength may be passed as"]
    #[doc = " length instead."]
    #[doc = ""]
    #[doc = " \\sa cbor_encoder_create_map"]
    pub fn cbor_encoder_create_array(
        encoder: *mut CborEncoder,
        arrayEncoder: *mut CborEncoder,
        length: usize,
    ) -> CborError;
}
extern "C" {
    #[doc = " Creates a CBOR map in the CBOR stream provided by \\a encoder and"]
    #[doc = " initializes \\a mapEncoder so that items can be added to the map using"]
    #[doc = " the CborEncoder functions. The map must be terminated by calling either"]
    #[doc = " cbor_encoder_close_container() or cbor_encoder_close_container_checked()"]
    #[doc = " with the same \\a encoder and \\a mapEncoder parameters."]
    #[doc = ""]
    #[doc = " The number of pair of items inserted into the map must be exactly \\a length"]
    #[doc = " items, otherwise the stream is invalid. If the number of items is not known"]
    #[doc = " when creating the map, the constant \\ref CborIndefiniteLength may be passed as"]
    #[doc = " length instead."]
    #[doc = ""]
    #[doc = " \\b{Implementation limitation:} TinyCBOR cannot encode more than SIZE_MAX/2"]
    #[doc = " key-value pairs in the stream. If the length \\a length is larger than this"]
    #[doc = " value, this function returns error CborErrorDataTooLarge."]
    #[doc = ""]
    #[doc = " \\sa cbor_encoder_create_array"]
    pub fn cbor_encoder_create_map(
        encoder: *mut CborEncoder,
        mapEncoder: *mut CborEncoder,
        length: usize,
    ) -> CborError;
}
extern "C" {
    #[doc = " Creates a indefinite-length byte string in the CBOR stream provided by"]
    #[doc = " \\a encoder and initializes \\a stringEncoder so that chunks of original string"]
    #[doc = " can be added using the CborEncoder functions. The string must be terminated by"]
    #[doc = " calling cbor_encoder_close_container() with the same \\a encoder and"]
    #[doc = " \\a stringEncoder parameters."]
    #[doc = ""]
    #[doc = " \\sa cbor_encoder_create_array"]
    pub fn cbor_encoder_create_indef_byte_string(
        encoder: *mut CborEncoder,
        stringEncoder: *mut CborEncoder,
    ) -> CborError;
}
extern "C" {
    #[doc = " Closes the CBOR container (array, map or indefinite-length string) provided"]
    #[doc = " by \\a containerEncoder and updates the CBOR stream provided by \\a encoder."]
    #[doc = " Both parameters must be the same as were passed to cbor_encoder_create_array() or"]
    #[doc = " cbor_encoder_create_map() or cbor_encoder_create_indef_byte_string()."]
    #[doc = ""]
    #[doc = " This function does not verify that the number of items (or pair of items, in"]
    #[doc = " the case of a map) was correct. To execute that verification, call"]
    #[doc = " cbor_encoder_close_container_checked() instead."]
    #[doc = ""]
    #[doc = " \\sa cbor_encoder_create_array(), cbor_encoder_create_map()"]
    pub fn cbor_encoder_close_container(
        encoder: *mut CborEncoder,
        containerEncoder: *const CborEncoder,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_close_container_checked(
        encoder: *mut CborEncoder,
        containerEncoder: *const CborEncoder,
    ) -> CborError;
}
pub const CborParserIteratorFlags_CborIteratorFlag_IntegerValueTooLarge: CborParserIteratorFlags =
    1;
pub const CborParserIteratorFlags_CborIteratorFlag_NegativeInteger: CborParserIteratorFlags = 2;
pub const CborParserIteratorFlags_CborIteratorFlag_UnknownLength: CborParserIteratorFlags = 4;
pub const CborParserIteratorFlags_CborIteratorFlag_ContainerIsMap: CborParserIteratorFlags = 32;
pub type CborParserIteratorFlags = u32;
pub type cbor_reader_get8 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u8,
>;
pub type cbor_reader_get16 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u16,
>;
pub type cbor_reader_get32 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u32,
>;
pub type cbor_reader_get64 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u64,
>;
pub type cbor_memcmp = ::core::option::Option<
    unsafe extern "C" fn(
        d: *mut cbor_decoder_reader,
        buf: *mut ::cty::c_char,
        offset: ::cty::c_int,
        len: usize,
    ) -> usize,
>;
pub type cbor_memcpy = ::core::option::Option<
    unsafe extern "C" fn(
        d: *mut cbor_decoder_reader,
        buf: *mut ::cty::c_char,
        offset: ::cty::c_int,
        len: usize,
    ) -> usize,
>;
#[repr(C)]
#[derive(Default)]
pub struct cbor_decoder_reader {
    pub get8: cbor_reader_get8,
    pub get16: cbor_reader_get16,
    pub get32: cbor_reader_get32,
    pub get64: cbor_reader_get64,
    pub cmp: cbor_memcmp,
    pub cpy: cbor_memcpy,
    pub message_size: usize,
}
#[repr(C)]
pub struct CborParser {
    pub d: *mut cbor_decoder_reader,
    pub end: ::cty::c_int,
    pub flags: ::cty::c_int,
}
impl Default for CborParser {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct CborValue {
    pub parser: *const CborParser,
    pub offset: ::cty::c_int,
    pub remaining: u32,
    pub extra: u16,
    pub type_: u8,
    pub flags: u8,
}
impl Default for CborValue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn cbor_parser_init(
        d: *mut cbor_decoder_reader,
        flags: ::cty::c_int,
        parser: *mut CborParser,
        it: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_advance_fixed(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_advance(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_enter_container(it: *const CborValue, recursed: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_leave_container(it: *mut CborValue, recursed: *const CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_int64_checked(value: *const CborValue, result: *mut i64) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_int_checked(
        value: *const CborValue,
        result: *mut ::cty::c_int,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_skip_tag(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_calculate_string_length(
        value: *const CborValue,
        length: *mut usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_text_string_equals(
        value: *const CborValue,
        string: *const ::cty::c_char,
        result: *mut bool,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_map_find_value(
        map: *const CborValue,
        string: *const ::cty::c_char,
        element: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_half_float(
        value: *const CborValue,
        result: *mut ::cty::c_void,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_to_pretty_advance(out: *mut FILE, value: *mut CborValue) -> CborError;
}
pub const CborMajorTypes_UnsignedIntegerType: CborMajorTypes = 0;
pub const CborMajorTypes_NegativeIntegerType: CborMajorTypes = 1;
pub const CborMajorTypes_ByteStringType: CborMajorTypes = 2;
pub const CborMajorTypes_TextStringType: CborMajorTypes = 3;
pub const CborMajorTypes_ArrayType: CborMajorTypes = 4;
pub const CborMajorTypes_MapType: CborMajorTypes = 5;
pub const CborMajorTypes_TagType: CborMajorTypes = 6;
pub const CborMajorTypes_SimpleTypesType: CborMajorTypes = 7;
pub type CborMajorTypes = u32;
pub const CborSimpleTypes_FalseValue: CborSimpleTypes = 20;
pub const CborSimpleTypes_TrueValue: CborSimpleTypes = 21;
pub const CborSimpleTypes_NullValue: CborSimpleTypes = 22;
pub const CborSimpleTypes_UndefinedValue: CborSimpleTypes = 23;
pub const CborSimpleTypes_SimpleTypeInNextByte: CborSimpleTypes = 24;
pub const CborSimpleTypes_HalfPrecisionFloat: CborSimpleTypes = 25;
pub const CborSimpleTypes_SinglePrecisionFloat: CborSimpleTypes = 26;
pub const CborSimpleTypes_DoublePrecisionFloat: CborSimpleTypes = 27;
pub const CborSimpleTypes_Break: CborSimpleTypes = 31;
pub type CborSimpleTypes = u32;
