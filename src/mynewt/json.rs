/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const JSON_VALUE_TYPE_BOOL: u32 = 0;
pub const JSON_VALUE_TYPE_UINT64: u32 = 1;
pub const JSON_VALUE_TYPE_INT64: u32 = 2;
pub const JSON_VALUE_TYPE_STRING: u32 = 3;
pub const JSON_VALUE_TYPE_ARRAY: u32 = 4;
pub const JSON_VALUE_TYPE_OBJECT: u32 = 5;
pub const JSON_ATTR_MAX: u32 = 31;
pub const JSON_VAL_MAX: u32 = 512;
pub const JSON_ERR_OBSTART: u32 = 1;
pub const JSON_ERR_ATTRSTART: u32 = 2;
pub const JSON_ERR_BADATTR: u32 = 3;
pub const JSON_ERR_ATTRLEN: u32 = 4;
pub const JSON_ERR_NOARRAY: u32 = 5;
pub const JSON_ERR_NOBRAK: u32 = 6;
pub const JSON_ERR_STRLONG: u32 = 7;
pub const JSON_ERR_TOKLONG: u32 = 8;
pub const JSON_ERR_BADTRAIL: u32 = 9;
pub const JSON_ERR_ARRAYSTART: u32 = 10;
pub const JSON_ERR_OBJARR: u32 = 11;
pub const JSON_ERR_SUBTOOLONG: u32 = 12;
pub const JSON_ERR_BADSUBTRAIL: u32 = 13;
pub const JSON_ERR_SUBTYPE: u32 = 14;
pub const JSON_ERR_BADSTRING: u32 = 15;
pub const JSON_ERR_CHECKFAIL: u32 = 16;
pub const JSON_ERR_NOPARSTR: u32 = 17;
pub const JSON_ERR_BADENUM: u32 = 18;
pub const JSON_ERR_QNONSTRING: u32 = 19;
pub const JSON_ERR_NONQSTRING: u32 = 19;
pub const JSON_ERR_MISC: u32 = 20;
pub const JSON_ERR_BADNUM: u32 = 21;
pub const JSON_ERR_NULLPTR: u32 = 22;
pub type __uint8_t = ::cty::c_uchar;
pub type __uint16_t = ::cty::c_ushort;
pub type __uint64_t = ::cty::c_ulonglong;
#[repr(C)]
pub struct json_value {
    pub jv_pad1: u8,
    pub jv_type: u8,
    pub jv_len: u16,
    pub jv_val: json_value__bindgen_ty_1,
}
#[repr(C)]
pub struct json_value__bindgen_ty_1 {
    pub u: __BindgenUnionField<u64>,
    pub fl: __BindgenUnionField<f32>,
    pub str: __BindgenUnionField<*mut ::cty::c_char>,
    pub composite: __BindgenUnionField<json_value__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
pub struct json_value__bindgen_ty_1__bindgen_ty_1 {
    pub keys: *mut *mut ::cty::c_char,
    pub values: *mut *mut json_value,
}
impl Default for json_value__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for json_value__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for json_value {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type json_write_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *mut ::cty::c_void,
        data: *mut ::cty::c_char,
        len: ::cty::c_int,
    ) -> ::cty::c_int,
>;
#[repr(C)]
pub struct json_encoder {
    pub je_write: json_write_func_t,
    pub je_arg: *mut ::cty::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub je_encode_buf: [::cty::c_char; 64usize],
}
impl Default for json_encoder {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl json_encoder {
    #[inline]
    pub fn je_wr_commas(&self) -> ::cty::c_int {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_je_wr_commas(&mut self, val: ::cty::c_int) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(je_wr_commas: ::cty::c_int) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let je_wr_commas: u32 = unsafe { ::core::mem::transmute(je_wr_commas) };
            je_wr_commas as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn json_encode_object_start(arg1: *mut json_encoder) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_object_key(
        encoder: *mut json_encoder,
        key: *mut ::cty::c_char,
    ) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_object_entry(
        arg1: *mut json_encoder,
        arg2: *mut ::cty::c_char,
        arg3: *mut json_value,
    ) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_object_finish(arg1: *mut json_encoder) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_array_name(
        encoder: *mut json_encoder,
        name: *mut ::cty::c_char,
    ) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_array_start(encoder: *mut json_encoder) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_array_value(
        encoder: *mut json_encoder,
        val: *mut json_value,
    ) -> ::cty::c_int;
}
extern "C" {
    pub fn json_encode_array_finish(encoder: *mut json_encoder) -> ::cty::c_int;
}
pub const json_type_t_integer: json_type = 0;
pub const json_type_t_uinteger: json_type = 1;
pub const json_type_t_real: json_type = 2;
pub const json_type_t_string: json_type = 3;
pub const json_type_t_boolean: json_type = 4;
pub const json_type_t_character: json_type = 5;
pub const json_type_t_object: json_type = 6;
pub const json_type_t_structobject: json_type = 7;
pub const json_type_t_array: json_type = 8;
pub const json_type_t_check: json_type = 9;
pub const json_type_t_ignore: json_type = 10;
pub type json_type = u32;
#[repr(C)]
pub struct json_enum_t {
    pub name: *mut ::cty::c_char,
    pub value: ::cty::c_longlong,
}
impl Default for json_enum_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_array_t {
    pub element_type: json_type,
    pub arr: json_array_t__bindgen_ty_1,
    pub count: *mut ::cty::c_int,
    pub maxlen: ::cty::c_int,
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1 {
    pub objects: __BindgenUnionField<json_array_t__bindgen_ty_1__bindgen_ty_1>,
    pub strings: __BindgenUnionField<json_array_t__bindgen_ty_1__bindgen_ty_2>,
    pub integers: __BindgenUnionField<json_array_t__bindgen_ty_1__bindgen_ty_3>,
    pub uintegers: __BindgenUnionField<json_array_t__bindgen_ty_1__bindgen_ty_4>,
    pub reals: __BindgenUnionField<json_array_t__bindgen_ty_1__bindgen_ty_5>,
    pub booleans: __BindgenUnionField<json_array_t__bindgen_ty_1__bindgen_ty_6>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1__bindgen_ty_1 {
    pub subtype: *const json_attr_t,
    pub base: *mut ::cty::c_char,
    pub stride: usize,
}
impl Default for json_array_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1__bindgen_ty_2 {
    pub ptrs: *mut *mut ::cty::c_char,
    pub store: *mut ::cty::c_char,
    pub storelen: ::cty::c_int,
}
impl Default for json_array_t__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1__bindgen_ty_3 {
    pub store: *mut ::cty::c_longlong,
}
impl Default for json_array_t__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1__bindgen_ty_4 {
    pub store: *mut ::cty::c_ulonglong,
}
impl Default for json_array_t__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1__bindgen_ty_5 {
    pub store: *mut f64,
}
impl Default for json_array_t__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_array_t__bindgen_ty_1__bindgen_ty_6 {
    pub store: *mut bool,
}
impl Default for json_array_t__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for json_array_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for json_array_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_attr_t {
    pub attribute: *mut ::cty::c_char,
    pub type_: json_type,
    pub addr: json_attr_t__bindgen_ty_1,
    pub dflt: json_attr_t__bindgen_ty_2,
    pub len: usize,
    pub map: *const json_enum_t,
    pub nodefault: bool,
}
#[repr(C)]
pub struct json_attr_t__bindgen_ty_1 {
    pub integer: __BindgenUnionField<*mut ::cty::c_longlong>,
    pub uinteger: __BindgenUnionField<*mut ::cty::c_ulonglong>,
    pub real: __BindgenUnionField<*mut f64>,
    pub string: __BindgenUnionField<*mut ::cty::c_char>,
    pub boolean: __BindgenUnionField<*mut bool>,
    pub character: __BindgenUnionField<*mut ::cty::c_char>,
    pub array: __BindgenUnionField<json_array_t>,
    pub offset: __BindgenUnionField<usize>,
    pub bindgen_union_field: [u64; 6usize],
}
impl Default for json_attr_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct json_attr_t__bindgen_ty_2 {
    pub integer: __BindgenUnionField<::cty::c_longlong>,
    pub uinteger: __BindgenUnionField<::cty::c_ulonglong>,
    pub real: __BindgenUnionField<f64>,
    pub boolean: __BindgenUnionField<bool>,
    pub character: __BindgenUnionField<::cty::c_char>,
    pub check: __BindgenUnionField<*mut ::cty::c_char>,
    pub bindgen_union_field: u64,
}
impl Default for json_attr_t__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for json_attr_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type json_buffer_read_next_byte_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut json_buffer) -> ::cty::c_char>;
pub type json_buffer_read_prev_byte_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut json_buffer) -> ::cty::c_char>;
pub type json_buffer_readn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut json_buffer,
        buf: *mut ::cty::c_char,
        n: ::cty::c_int,
    ) -> ::cty::c_int,
>;
#[repr(C)]
#[derive(Default)]
pub struct json_buffer {
    pub jb_readn: json_buffer_readn_t,
    pub jb_read_next: json_buffer_read_next_byte_t,
    pub jb_read_prev: json_buffer_read_prev_byte_t,
}
extern "C" {
    pub fn json_read_object(arg1: *mut json_buffer, arg2: *const json_attr_t) -> ::cty::c_int;
}
extern "C" {
    pub fn json_read_array(arg1: *mut json_buffer, arg2: *const json_array_t) -> ::cty::c_int;
}
