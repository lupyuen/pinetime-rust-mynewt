# 1 "libs/sensor_coap/src/sensor_coap.c"
# 1 "/Users/Luppy/mynewt/stm32bluepill-mynewt-sensor//"
# 1 "<built-in>"
#define __STDC__ 1
#define __STDC_VERSION__ 201112L
#define __STDC_UTF_16__ 1
#define __STDC_UTF_32__ 1
#define __STDC_HOSTED__ 1
#define __GNUC__ 7
#define __GNUC_MINOR__ 3
#define __GNUC_PATCHLEVEL__ 1
#define __VERSION__ "7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907]"
#define __ATOMIC_RELAXED 0
#define __ATOMIC_SEQ_CST 5
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_CONSUME 1
#define __OPTIMIZE__ 1
#define __FINITE_MATH_ONLY__ 0
#define __SIZEOF_INT__ 4
#define __SIZEOF_LONG__ 4
#define __SIZEOF_LONG_LONG__ 8
#define __SIZEOF_SHORT__ 2
#define __SIZEOF_FLOAT__ 4
#define __SIZEOF_DOUBLE__ 8
#define __SIZEOF_LONG_DOUBLE__ 8
#define __SIZEOF_SIZE_T__ 4
#define __CHAR_BIT__ 8
#define __BIGGEST_ALIGNMENT__ 8
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_PDP_ENDIAN__ 3412
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __SIZEOF_POINTER__ 4
#define __SIZE_TYPE__ unsigned int
#define __PTRDIFF_TYPE__ int
#define __WCHAR_TYPE__ unsigned int
#define __WINT_TYPE__ unsigned int
#define __INTMAX_TYPE__ long long int
#define __UINTMAX_TYPE__ long long unsigned int
#define __CHAR16_TYPE__ short unsigned int
#define __CHAR32_TYPE__ long unsigned int
#define __SIG_ATOMIC_TYPE__ int
#define __INT8_TYPE__ signed char
#define __INT16_TYPE__ short int
#define __INT32_TYPE__ long int
#define __INT64_TYPE__ long long int
#define __UINT8_TYPE__ unsigned char
#define __UINT16_TYPE__ short unsigned int
#define __UINT32_TYPE__ long unsigned int
#define __UINT64_TYPE__ long long unsigned int
#define __INT_LEAST8_TYPE__ signed char
#define __INT_LEAST16_TYPE__ short int
#define __INT_LEAST32_TYPE__ long int
#define __INT_LEAST64_TYPE__ long long int
#define __UINT_LEAST8_TYPE__ unsigned char
#define __UINT_LEAST16_TYPE__ short unsigned int
#define __UINT_LEAST32_TYPE__ long unsigned int
#define __UINT_LEAST64_TYPE__ long long unsigned int
#define __INT_FAST8_TYPE__ int
#define __INT_FAST16_TYPE__ int
#define __INT_FAST32_TYPE__ int
#define __INT_FAST64_TYPE__ long long int
#define __UINT_FAST8_TYPE__ unsigned int
#define __UINT_FAST16_TYPE__ unsigned int
#define __UINT_FAST32_TYPE__ unsigned int
#define __UINT_FAST64_TYPE__ long long unsigned int
#define __INTPTR_TYPE__ int
#define __UINTPTR_TYPE__ unsigned int
#define __has_include(STR) __has_include__(STR)
#define __has_include_next(STR) __has_include_next__(STR)
#define __GXX_ABI_VERSION 1011
#define __SCHAR_MAX__ 0x7f
#define __SHRT_MAX__ 0x7fff
#define __INT_MAX__ 0x7fffffff
#define __LONG_MAX__ 0x7fffffffL
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
#define __WCHAR_MAX__ 0xffffffffU
#define __WCHAR_MIN__ 0U
#define __WINT_MAX__ 0xffffffffU
#define __WINT_MIN__ 0U
#define __PTRDIFF_MAX__ 0x7fffffff
#define __SIZE_MAX__ 0xffffffffU
#define __SCHAR_WIDTH__ 8
#define __SHRT_WIDTH__ 16
#define __INT_WIDTH__ 32
#define __LONG_WIDTH__ 32
#define __LONG_LONG_WIDTH__ 64
#define __WCHAR_WIDTH__ 32
#define __WINT_WIDTH__ 32
#define __PTRDIFF_WIDTH__ 32
#define __SIZE_WIDTH__ 32
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
#define __INTMAX_C(c) c ## LL
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
#define __UINTMAX_C(c) c ## ULL
#define __INTMAX_WIDTH__ 64
#define __SIG_ATOMIC_MAX__ 0x7fffffff
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
#define __SIG_ATOMIC_WIDTH__ 32
#define __INT8_MAX__ 0x7f
#define __INT16_MAX__ 0x7fff
#define __INT32_MAX__ 0x7fffffffL
#define __INT64_MAX__ 0x7fffffffffffffffLL
#define __UINT8_MAX__ 0xff
#define __UINT16_MAX__ 0xffff
#define __UINT32_MAX__ 0xffffffffUL
#define __UINT64_MAX__ 0xffffffffffffffffULL
#define __INT_LEAST8_MAX__ 0x7f
#define __INT8_C(c) c
#define __INT_LEAST8_WIDTH__ 8
#define __INT_LEAST16_MAX__ 0x7fff
#define __INT16_C(c) c
#define __INT_LEAST16_WIDTH__ 16
#define __INT_LEAST32_MAX__ 0x7fffffffL
#define __INT32_C(c) c ## L
#define __INT_LEAST32_WIDTH__ 32
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
#define __INT64_C(c) c ## LL
#define __INT_LEAST64_WIDTH__ 64
#define __UINT_LEAST8_MAX__ 0xff
#define __UINT8_C(c) c
#define __UINT_LEAST16_MAX__ 0xffff
#define __UINT16_C(c) c
#define __UINT_LEAST32_MAX__ 0xffffffffUL
#define __UINT32_C(c) c ## UL
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
#define __UINT64_C(c) c ## ULL
#define __INT_FAST8_MAX__ 0x7fffffff
#define __INT_FAST8_WIDTH__ 32
#define __INT_FAST16_MAX__ 0x7fffffff
#define __INT_FAST16_WIDTH__ 32
#define __INT_FAST32_MAX__ 0x7fffffff
#define __INT_FAST32_WIDTH__ 32
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
#define __INT_FAST64_WIDTH__ 64
#define __UINT_FAST8_MAX__ 0xffffffffU
#define __UINT_FAST16_MAX__ 0xffffffffU
#define __UINT_FAST32_MAX__ 0xffffffffU
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
#define __INTPTR_MAX__ 0x7fffffff
#define __INTPTR_WIDTH__ 32
#define __UINTPTR_MAX__ 0xffffffffU
#define __GCC_IEC_559 0
#define __GCC_IEC_559_COMPLEX 0
#define __FLT_EVAL_METHOD__ 0
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
#define __DEC_EVAL_METHOD__ 2
#define __FLT_RADIX__ 2
#define __FLT_MANT_DIG__ 24
#define __FLT_DIG__ 6
#define __FLT_MIN_EXP__ (-125)
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MAX_EXP__ 128
#define __FLT_MAX_10_EXP__ 38
#define __FLT_DECIMAL_DIG__ 9
#define __FLT_MAX__ 3.4028234663852886e+38F
#define __FLT_MIN__ 1.1754943508222875e-38F
#define __FLT_EPSILON__ 1.1920928955078125e-7F
#define __FLT_DENORM_MIN__ 1.4012984643248171e-45F
#define __FLT_HAS_DENORM__ 1
#define __FLT_HAS_INFINITY__ 1
#define __FLT_HAS_QUIET_NAN__ 1
#define __DBL_MANT_DIG__ 53
#define __DBL_DIG__ 15
#define __DBL_MIN_EXP__ (-1021)
#define __DBL_MIN_10_EXP__ (-307)
#define __DBL_MAX_EXP__ 1024
#define __DBL_MAX_10_EXP__ 308
#define __DBL_DECIMAL_DIG__ 17
#define __DBL_MAX__ ((double)1.7976931348623157e+308L)
#define __DBL_MIN__ ((double)2.2250738585072014e-308L)
#define __DBL_EPSILON__ ((double)2.2204460492503131e-16L)
#define __DBL_DENORM_MIN__ ((double)4.9406564584124654e-324L)
#define __DBL_HAS_DENORM__ 1
#define __DBL_HAS_INFINITY__ 1
#define __DBL_HAS_QUIET_NAN__ 1
#define __LDBL_MANT_DIG__ 53
#define __LDBL_DIG__ 15
#define __LDBL_MIN_EXP__ (-1021)
#define __LDBL_MIN_10_EXP__ (-307)
#define __LDBL_MAX_EXP__ 1024
#define __LDBL_MAX_10_EXP__ 308
#define __DECIMAL_DIG__ 17
#define __LDBL_DECIMAL_DIG__ 17
#define __LDBL_MAX__ 1.7976931348623157e+308L
#define __LDBL_MIN__ 2.2250738585072014e-308L
#define __LDBL_EPSILON__ 2.2204460492503131e-16L
#define __LDBL_DENORM_MIN__ 4.9406564584124654e-324L
#define __LDBL_HAS_DENORM__ 1
#define __LDBL_HAS_INFINITY__ 1
#define __LDBL_HAS_QUIET_NAN__ 1
#define __FLT32_MANT_DIG__ 24
#define __FLT32_DIG__ 6
#define __FLT32_MIN_EXP__ (-125)
#define __FLT32_MIN_10_EXP__ (-37)
#define __FLT32_MAX_EXP__ 128
#define __FLT32_MAX_10_EXP__ 38
#define __FLT32_DECIMAL_DIG__ 9
#define __FLT32_MAX__ 3.4028234663852886e+38F32
#define __FLT32_MIN__ 1.1754943508222875e-38F32
#define __FLT32_EPSILON__ 1.1920928955078125e-7F32
#define __FLT32_DENORM_MIN__ 1.4012984643248171e-45F32
#define __FLT32_HAS_DENORM__ 1
#define __FLT32_HAS_INFINITY__ 1
#define __FLT32_HAS_QUIET_NAN__ 1
#define __FLT64_MANT_DIG__ 53
#define __FLT64_DIG__ 15
#define __FLT64_MIN_EXP__ (-1021)
#define __FLT64_MIN_10_EXP__ (-307)
#define __FLT64_MAX_EXP__ 1024
#define __FLT64_MAX_10_EXP__ 308
#define __FLT64_DECIMAL_DIG__ 17
#define __FLT64_MAX__ 1.7976931348623157e+308F64
#define __FLT64_MIN__ 2.2250738585072014e-308F64
#define __FLT64_EPSILON__ 2.2204460492503131e-16F64
#define __FLT64_DENORM_MIN__ 4.9406564584124654e-324F64
#define __FLT64_HAS_DENORM__ 1
#define __FLT64_HAS_INFINITY__ 1
#define __FLT64_HAS_QUIET_NAN__ 1
#define __FLT32X_MANT_DIG__ 53
#define __FLT32X_DIG__ 15
#define __FLT32X_MIN_EXP__ (-1021)
#define __FLT32X_MIN_10_EXP__ (-307)
#define __FLT32X_MAX_EXP__ 1024
#define __FLT32X_MAX_10_EXP__ 308
#define __FLT32X_DECIMAL_DIG__ 17
#define __FLT32X_MAX__ 1.7976931348623157e+308F32x
#define __FLT32X_MIN__ 2.2250738585072014e-308F32x
#define __FLT32X_EPSILON__ 2.2204460492503131e-16F32x
#define __FLT32X_DENORM_MIN__ 4.9406564584124654e-324F32x
#define __FLT32X_HAS_DENORM__ 1
#define __FLT32X_HAS_INFINITY__ 1
#define __FLT32X_HAS_QUIET_NAN__ 1
#define __DEC32_MANT_DIG__ 7
#define __DEC32_MIN_EXP__ (-94)
#define __DEC32_MAX_EXP__ 97
#define __DEC32_MIN__ 1E-95DF
#define __DEC32_MAX__ 9.999999E96DF
#define __DEC32_EPSILON__ 1E-6DF
#define __DEC32_SUBNORMAL_MIN__ 0.000001E-95DF
#define __DEC64_MANT_DIG__ 16
#define __DEC64_MIN_EXP__ (-382)
#define __DEC64_MAX_EXP__ 385
#define __DEC64_MIN__ 1E-383DD
#define __DEC64_MAX__ 9.999999999999999E384DD
#define __DEC64_EPSILON__ 1E-15DD
#define __DEC64_SUBNORMAL_MIN__ 0.000000000000001E-383DD
#define __DEC128_MANT_DIG__ 34
#define __DEC128_MIN_EXP__ (-6142)
#define __DEC128_MAX_EXP__ 6145
#define __DEC128_MIN__ 1E-6143DL
#define __DEC128_MAX__ 9.999999999999999999999999999999999E6144DL
#define __DEC128_EPSILON__ 1E-33DL
#define __DEC128_SUBNORMAL_MIN__ 0.000000000000000000000000000000001E-6143DL
#define __SFRACT_FBIT__ 7
#define __SFRACT_IBIT__ 0
#define __SFRACT_MIN__ (-0.5HR-0.5HR)
#define __SFRACT_MAX__ 0X7FP-7HR
#define __SFRACT_EPSILON__ 0x1P-7HR
#define __USFRACT_FBIT__ 8
#define __USFRACT_IBIT__ 0
#define __USFRACT_MIN__ 0.0UHR
#define __USFRACT_MAX__ 0XFFP-8UHR
#define __USFRACT_EPSILON__ 0x1P-8UHR
#define __FRACT_FBIT__ 15
#define __FRACT_IBIT__ 0
#define __FRACT_MIN__ (-0.5R-0.5R)
#define __FRACT_MAX__ 0X7FFFP-15R
#define __FRACT_EPSILON__ 0x1P-15R
#define __UFRACT_FBIT__ 16
#define __UFRACT_IBIT__ 0
#define __UFRACT_MIN__ 0.0UR
#define __UFRACT_MAX__ 0XFFFFP-16UR
#define __UFRACT_EPSILON__ 0x1P-16UR
#define __LFRACT_FBIT__ 31
#define __LFRACT_IBIT__ 0
#define __LFRACT_MIN__ (-0.5LR-0.5LR)
#define __LFRACT_MAX__ 0X7FFFFFFFP-31LR
#define __LFRACT_EPSILON__ 0x1P-31LR
#define __ULFRACT_FBIT__ 32
#define __ULFRACT_IBIT__ 0
#define __ULFRACT_MIN__ 0.0ULR
#define __ULFRACT_MAX__ 0XFFFFFFFFP-32ULR
#define __ULFRACT_EPSILON__ 0x1P-32ULR
#define __LLFRACT_FBIT__ 63
#define __LLFRACT_IBIT__ 0
#define __LLFRACT_MIN__ (-0.5LLR-0.5LLR)
#define __LLFRACT_MAX__ 0X7FFFFFFFFFFFFFFFP-63LLR
#define __LLFRACT_EPSILON__ 0x1P-63LLR
#define __ULLFRACT_FBIT__ 64
#define __ULLFRACT_IBIT__ 0
#define __ULLFRACT_MIN__ 0.0ULLR
#define __ULLFRACT_MAX__ 0XFFFFFFFFFFFFFFFFP-64ULLR
#define __ULLFRACT_EPSILON__ 0x1P-64ULLR
#define __SACCUM_FBIT__ 7
#define __SACCUM_IBIT__ 8
#define __SACCUM_MIN__ (-0X1P7HK-0X1P7HK)
#define __SACCUM_MAX__ 0X7FFFP-7HK
#define __SACCUM_EPSILON__ 0x1P-7HK
#define __USACCUM_FBIT__ 8
#define __USACCUM_IBIT__ 8
#define __USACCUM_MIN__ 0.0UHK
#define __USACCUM_MAX__ 0XFFFFP-8UHK
#define __USACCUM_EPSILON__ 0x1P-8UHK
#define __ACCUM_FBIT__ 15
#define __ACCUM_IBIT__ 16
#define __ACCUM_MIN__ (-0X1P15K-0X1P15K)
#define __ACCUM_MAX__ 0X7FFFFFFFP-15K
#define __ACCUM_EPSILON__ 0x1P-15K
#define __UACCUM_FBIT__ 16
#define __UACCUM_IBIT__ 16
#define __UACCUM_MIN__ 0.0UK
#define __UACCUM_MAX__ 0XFFFFFFFFP-16UK
#define __UACCUM_EPSILON__ 0x1P-16UK
#define __LACCUM_FBIT__ 31
#define __LACCUM_IBIT__ 32
#define __LACCUM_MIN__ (-0X1P31LK-0X1P31LK)
#define __LACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LK
#define __LACCUM_EPSILON__ 0x1P-31LK
#define __ULACCUM_FBIT__ 32
#define __ULACCUM_IBIT__ 32
#define __ULACCUM_MIN__ 0.0ULK
#define __ULACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULK
#define __ULACCUM_EPSILON__ 0x1P-32ULK
#define __LLACCUM_FBIT__ 31
#define __LLACCUM_IBIT__ 32
#define __LLACCUM_MIN__ (-0X1P31LLK-0X1P31LLK)
#define __LLACCUM_MAX__ 0X7FFFFFFFFFFFFFFFP-31LLK
#define __LLACCUM_EPSILON__ 0x1P-31LLK
#define __ULLACCUM_FBIT__ 32
#define __ULLACCUM_IBIT__ 32
#define __ULLACCUM_MIN__ 0.0ULLK
#define __ULLACCUM_MAX__ 0XFFFFFFFFFFFFFFFFP-32ULLK
#define __ULLACCUM_EPSILON__ 0x1P-32ULLK
#define __QQ_FBIT__ 7
#define __QQ_IBIT__ 0
#define __HQ_FBIT__ 15
#define __HQ_IBIT__ 0
#define __SQ_FBIT__ 31
#define __SQ_IBIT__ 0
#define __DQ_FBIT__ 63
#define __DQ_IBIT__ 0
#define __TQ_FBIT__ 127
#define __TQ_IBIT__ 0
#define __UQQ_FBIT__ 8
#define __UQQ_IBIT__ 0
#define __UHQ_FBIT__ 16
#define __UHQ_IBIT__ 0
#define __USQ_FBIT__ 32
#define __USQ_IBIT__ 0
#define __UDQ_FBIT__ 64
#define __UDQ_IBIT__ 0
#define __UTQ_FBIT__ 128
#define __UTQ_IBIT__ 0
#define __HA_FBIT__ 7
#define __HA_IBIT__ 8
#define __SA_FBIT__ 15
#define __SA_IBIT__ 16
#define __DA_FBIT__ 31
#define __DA_IBIT__ 32
#define __TA_FBIT__ 63
#define __TA_IBIT__ 64
#define __UHA_FBIT__ 8
#define __UHA_IBIT__ 8
#define __USA_FBIT__ 16
#define __USA_IBIT__ 16
#define __UDA_FBIT__ 32
#define __UDA_IBIT__ 32
#define __UTA_FBIT__ 64
#define __UTA_IBIT__ 64
#define __REGISTER_PREFIX__ 
#define __USER_LABEL_PREFIX__ 
#define __GNUC_STDC_INLINE__ 1
#define __CHAR_UNSIGNED__ 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
#define __GCC_ATOMIC_INT_LOCK_FREE 2
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
#define __GCC_HAVE_DWARF2_CFI_ASM 1
#define __PRAGMA_REDEFINE_EXTNAME 1
#define __SIZEOF_WCHAR_T__ 4
#define __SIZEOF_WINT_T__ 4
#define __SIZEOF_PTRDIFF_T__ 4
#undef __ARM_FEATURE_DSP
# 1 "<built-in>"
#define __ARM_FEATURE_QBIT 1
#define __ARM_FEATURE_SAT 1
#undef __ARM_FEATURE_CRYPTO
# 1 "<built-in>"
#define __ARM_FEATURE_UNALIGNED 1
#undef __ARM_FEATURE_QRDMX
# 1 "<built-in>"
#define __ARM_32BIT_STATE 1
#define __ARM_FEATURE_LDREX 7
#define __ARM_FEATURE_CLZ 1
#undef __ARM_FEATURE_NUMERIC_MAXMIN
# 1 "<built-in>"
#undef __ARM_FEATURE_SIMD32
# 1 "<built-in>"
#define __ARM_SIZEOF_MINIMAL_ENUM 1
#define __ARM_SIZEOF_WCHAR_T 4
#define __ARM_ARCH_PROFILE 77
#define __arm__ 1
#define __ARM_ARCH 7
#define __APCS_32__ 1
#define __thumb__ 1
#define __thumb2__ 1
#define __THUMBEL__ 1
#define __ARM_ARCH_ISA_THUMB 2
#define __ARMEL__ 1
#define __SOFTFP__ 1
#define __VFP_FP__ 1
#undef __ARM_FP
# 1 "<built-in>"
#undef __ARM_FP16_FORMAT_IEEE
# 1 "<built-in>"
#undef __ARM_FP16_FORMAT_ALTERNATIVE
# 1 "<built-in>"
#undef __ARM_FP16_ARGS
# 1 "<built-in>"
#undef __ARM_FEATURE_FP16_SCALAR_ARITHMETIC
# 1 "<built-in>"
#undef __ARM_FEATURE_FP16_VECTOR_ARITHMETIC
# 1 "<built-in>"
#undef __ARM_FEATURE_FMA
# 1 "<built-in>"
#undef __ARM_NEON__
# 1 "<built-in>"
#undef __ARM_NEON
# 1 "<built-in>"
#undef __ARM_NEON_FP
# 1 "<built-in>"
#define __THUMB_INTERWORK__ 1
#define __ARM_ARCH_7M__ 1
#define __ARM_PCS 1
#define __ARM_EABI__ 1
#define __ARM_ARCH_EXT_IDIV__ 1
#define __ARM_FEATURE_IDIV 1
#define __ARM_ASM_SYNTAX_UNIFIED__ 1
#define __ARM_FEATURE_COPROC 15
#define __GXX_TYPEINFO_EQUALITY_INLINE 0
#define __ELF__ 1
# 1 "<command-line>"
#define __USES_INITFINI__ 1
#define APP_NAME my_sensor_app
#define APP_my_sensor_app 1
#define ARCH_NAME cortex_m3
#define ARCH_cortex_m3 1
#define BSP_NAME bluepill-64kb
#define BSP_bluepill_64kb 1
#define FLOAT_SUPPORT 1
#define MYNEWT 1
#define STM32F103xB 1
# 1 "libs/sensor_coap/src/sensor_coap.c"
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
//  Post sensor data to CoAP Server or Collector Node with JSON or CBOR encoding.  We call the Mynewt OIC
//  interface to encode and transmit CoAP messages.  For ESP8266 and nRF24L01, the OIC interface
//  is implemented by esp8266/transport.h and nrf24l01/transport.h.  This is a simpler version of oc_client_api 
//  that supports sensors and JSON.  Original version: repos\apache-mynewt-core\net\oic\src\api\oc_client_api.c

# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_OS_MYNEWT_ 

# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */


#define H_MYNEWT_SYSCFG_ 

/**
 * This macro exists to ensure code includes this header when needed.  If code
 * checks the existence of a setting directly via ifdef without including this
 * header, the setting macro will silently evaluate to 0.  In contrast, an
 * attempt to use these macros without including this header will result in a
 * compiler error.
 */
#define MYNEWT_VAL(_name) MYNEWT_VAL_ ## _name
#define MYNEWT_VAL_CHOICE(_name,_val) MYNEWT_VAL_ ## _name ## __ ## _val



/*** @apache-mynewt-core/crypto/tinycrypt */

#define MYNEWT_VAL_TINYCRYPT_SYSINIT_STAGE (200)



#define MYNEWT_VAL_TINYCRYPT_UECC_RNG_TRNG_DEV_NAME ("trng")



#define MYNEWT_VAL_TINYCRYPT_UECC_RNG_USE_TRNG (0)


/*** @apache-mynewt-core/encoding/cborattr */

#define MYNEWT_VAL_CBORATTR_MAX_SIZE (512)


/*** @apache-mynewt-core/hw/hal */

#define MYNEWT_VAL_HAL_FLASH_VERIFY_BUF_SZ (16)



#define MYNEWT_VAL_HAL_FLASH_VERIFY_ERASES (0)



#define MYNEWT_VAL_HAL_FLASH_VERIFY_WRITES (0)


/*** @apache-mynewt-core/hw/mcu/stm/stm32f1xx */

#define MYNEWT_VAL_I2C_0 (0)



#define MYNEWT_VAL_MCU_FLASH_ERASED_VAL (0xff)



#define MYNEWT_VAL_MCU_FLASH_MIN_WRITE_SIZE (2)



#define MYNEWT_VAL_MCU_STM32F1 (1)



#define MYNEWT_VAL_SPI_0 (MYNEWT_VAL_SPI_0_MASTER || MYNEWT_VAL_SPI_0_SLAVE)



#define MYNEWT_VAL_SPI_0_MASTER (0)



#define MYNEWT_VAL_SPI_0_SLAVE (0)



#define MYNEWT_VAL_SPI_1 (MYNEWT_VAL_SPI_1_MASTER || MYNEWT_VAL_SPI_1_SLAVE)



#define MYNEWT_VAL_SPI_1_MASTER (0)



#define MYNEWT_VAL_SPI_1_SLAVE (0)



#define MYNEWT_VAL_STM32_FLASH_IS_LINEAR (1)



#define MYNEWT_VAL_STM32_FLASH_SECTOR_SIZE (1024)



#define MYNEWT_VAL_STM32_HAL_I2C_HAS_CLOCKSPEED (1)



#define MYNEWT_VAL_STM32_HAL_SPI_HAS_FIFO (0)



#define MYNEWT_VAL_STM32_HAL_UART_HAS_SR (1)


/*** @apache-mynewt-core/hw/sensor */

#define MYNEWT_VAL_MATHLIB_SUPPORT (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/hw/sensor) */

#define MYNEWT_VAL_SENSOR_CLI (0)



#define MYNEWT_VAL_SENSOR_MAX_INTERRUPTS_PINS (2)


#undef MYNEWT_VAL_SENSOR_MGR_EVQ


#define MYNEWT_VAL_SENSOR_NOTIF_EVENTS_MAX (5)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/hw/sensor) */

#define MYNEWT_VAL_SENSOR_OIC (0)



#define MYNEWT_VAL_SENSOR_OIC_OBS_RATE (1000)



#define MYNEWT_VAL_SENSOR_OIC_PERIODIC (0)



#define MYNEWT_VAL_SENSOR_POLL_TEST_LOG (0)



#define MYNEWT_VAL_SENSOR_SYSINIT_STAGE (501)


/*** @apache-mynewt-core/hw/sensor/creator */

#define MYNEWT_VAL_ADXL345_OFB (0)



#define MYNEWT_VAL_BMA253_OFB (0)



#define MYNEWT_VAL_BMA2XX_OFB (0)



#define MYNEWT_VAL_BME280_OFB (0)



#define MYNEWT_VAL_BME680_OFB (0)



#define MYNEWT_VAL_BMP280_OFB (0)



#define MYNEWT_VAL_BNO055_OFB (0)



#define MYNEWT_VAL_DRV2605_OFB (0)



#define MYNEWT_VAL_LIS2DS12_OFB (0)



#define MYNEWT_VAL_LIS2DW12_OFB (0)



#define MYNEWT_VAL_LPS33HW_OFB (0)



#define MYNEWT_VAL_LPS33THW_OFB (0)



#define MYNEWT_VAL_LSM303DLHC_OFB (0)



#define MYNEWT_VAL_MPU6050_OFB (0)



#define MYNEWT_VAL_MS5837_OFB (0)



#define MYNEWT_VAL_MS5840_OFB (0)



#define MYNEWT_VAL_SENSOR_CREATOR_SYSINIT_STAGE (500)



#define MYNEWT_VAL_TCS34725_OFB (0)



#define MYNEWT_VAL_TSL2561_OFB (0)



#define MYNEWT_VAL_TSL2591_OFB (0)


/*** @apache-mynewt-core/kernel/os */

#define MYNEWT_VAL_FLOAT_USER (0)



#define MYNEWT_VAL_MSYS_1_BLOCK_COUNT (12)



#define MYNEWT_VAL_MSYS_1_BLOCK_SIZE (292)



#define MYNEWT_VAL_MSYS_1_SANITY_MIN_COUNT (0)



#define MYNEWT_VAL_MSYS_2_BLOCK_COUNT (0)



#define MYNEWT_VAL_MSYS_2_BLOCK_SIZE (0)



#define MYNEWT_VAL_MSYS_2_SANITY_MIN_COUNT (0)



#define MYNEWT_VAL_MSYS_SANITY_TIMEOUT (60000)



#define MYNEWT_VAL_OS_CLI (0)



#define MYNEWT_VAL_OS_COREDUMP (0)



#define MYNEWT_VAL_OS_CPUTIME_FREQ (1000000)



#define MYNEWT_VAL_OS_CPUTIME_TIMER_NUM (0)



#define MYNEWT_VAL_OS_CRASH_FILE_LINE (0)



#define MYNEWT_VAL_OS_CRASH_LOG (0)



#define MYNEWT_VAL_OS_CRASH_RESTORE_REGS (0)



#define MYNEWT_VAL_OS_CRASH_STACKTRACE (0)



#define MYNEWT_VAL_OS_CTX_SW_STACK_CHECK (0)



#define MYNEWT_VAL_OS_CTX_SW_STACK_GUARD (4)



#define MYNEWT_VAL_OS_DEBUG_MODE (0)



#define MYNEWT_VAL_OS_EVENTQ_DEBUG (0)



#define MYNEWT_VAL_OS_EVENTQ_MONITOR (0)



#define MYNEWT_VAL_OS_IDLE_TICKLESS_MS_MAX (600000)



#define MYNEWT_VAL_OS_IDLE_TICKLESS_MS_MIN (100)



#define MYNEWT_VAL_OS_MAIN_STACK_SIZE (1024)



#define MYNEWT_VAL_OS_MAIN_TASK_PRIO (127)



#define MYNEWT_VAL_OS_MEMPOOL_CHECK (0)



#define MYNEWT_VAL_OS_MEMPOOL_GUARD (0)



#define MYNEWT_VAL_OS_MEMPOOL_POISON (0)



#define MYNEWT_VAL_OS_SCHEDULING (1)



#define MYNEWT_VAL_OS_SYSINIT_STAGE (0)



#define MYNEWT_VAL_OS_SYSVIEW (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/kernel/os) */

#define MYNEWT_VAL_OS_SYSVIEW_TRACE_CALLOUT (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/kernel/os) */

#define MYNEWT_VAL_OS_SYSVIEW_TRACE_EVENTQ (0)



#define MYNEWT_VAL_OS_SYSVIEW_TRACE_MBUF (0)



#define MYNEWT_VAL_OS_SYSVIEW_TRACE_MEMPOOL (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/kernel/os) */

#define MYNEWT_VAL_OS_SYSVIEW_TRACE_MUTEX (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/kernel/os) */

#define MYNEWT_VAL_OS_SYSVIEW_TRACE_SEM (0)



#define MYNEWT_VAL_OS_TIME_DEBUG (0)



#define MYNEWT_VAL_OS_WATCHDOG_MONITOR (0)



#define MYNEWT_VAL_SANITY_INTERVAL (15000)



#define MYNEWT_VAL_WATCHDOG_INTERVAL (30000)


/*** @apache-mynewt-core/libc/baselibc */

#define MYNEWT_VAL_BASELIBC_ASSERT_FILE_LINE (0)



#define MYNEWT_VAL_BASELIBC_PRESENT (1)


/*** @apache-mynewt-core/net/oic */
/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_APP_RESOURCES (2)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_CLIENT (1)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_CLIENT_DISCOVERY_ENABLE (0)



#define MYNEWT_VAL_OC_COAP_RESPONSE_TIMEOUT (4)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_CONCURRENT_REQUESTS (2)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_CONN_EV_CB_CNT (2)



#define MYNEWT_VAL_OC_DEBUG (0)



#define MYNEWT_VAL_OC_LOGGING (0)



#define MYNEWT_VAL_OC_LORA_PORT (0xbb)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_MAX_PAYLOAD (400)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_MAX_PAYLOAD_SIZE (400)



#define MYNEWT_VAL_OC_NUM_DEVICES (1)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_NUM_REP_OBJECTS (2)



#define MYNEWT_VAL_OC_SEPARATE_RESPONSES (1)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_SERVER (0)



#define MYNEWT_VAL_OC_SYSINIT_STAGE_GATT (301)



#define MYNEWT_VAL_OC_SYSINIT_STAGE_IP4 (301)



#define MYNEWT_VAL_OC_SYSINIT_STAGE_IP6 (301)



#define MYNEWT_VAL_OC_SYSINIT_STAGE_LORA (301)



#define MYNEWT_VAL_OC_SYSINIT_STAGE_MAIN (300)



#define MYNEWT_VAL_OC_SYSINIT_STAGE_SERIAL (301)



#define MYNEWT_VAL_OC_TRANSPORT_GATT (0)



#define MYNEWT_VAL_OC_TRANSPORT_IP (0)



#define MYNEWT_VAL_OC_TRANSPORT_IPV4 (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_TRANSPORT_IPV6 (0)



#define MYNEWT_VAL_OC_TRANSPORT_LORA (0)



#define MYNEWT_VAL_OC_TRANSPORT_SERIAL (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/net/oic) */

#define MYNEWT_VAL_OC_TRANS_SECURITY (0)


/*** @apache-mynewt-core/sys/flash_map */

#define MYNEWT_VAL_FLASH_MAP_MAX_AREAS (10)



#define MYNEWT_VAL_FLASH_MAP_SYSINIT_STAGE (2)


/*** @apache-mynewt-core/sys/log/modlog */

#define MYNEWT_VAL_MODLOG_CONSOLE_DFLT (1)



#define MYNEWT_VAL_MODLOG_LOG_MACROS (0)



#define MYNEWT_VAL_MODLOG_MAX_MAPPINGS (16)



#define MYNEWT_VAL_MODLOG_MAX_PRINTF_LEN (128)



#define MYNEWT_VAL_MODLOG_SYSINIT_STAGE (100)


/*** @apache-mynewt-core/sys/log/stub */

#define MYNEWT_VAL_LOG_CONSOLE (1)



#define MYNEWT_VAL_LOG_FCB (0)



#define MYNEWT_VAL_LOG_FCB_SLOT1 (0)


/* Overridden by apps/my_sensor_app (defined by @apache-mynewt-core/sys/log/stub) */

#define MYNEWT_VAL_LOG_LEVEL (255)


/*** @apache-mynewt-core/sys/mfg */

#define MYNEWT_VAL_MFG_LOG_MODULE (128)



#define MYNEWT_VAL_MFG_MAX_MMRS (2)



#define MYNEWT_VAL_MFG_SYSINIT_STAGE (100)


/*** @apache-mynewt-core/sys/sys */

#define MYNEWT_VAL_DEBUG_PANIC_ENABLED (1)


/*** @apache-mynewt-core/sys/sysdown */

#define MYNEWT_VAL_SYSDOWN_CONSTRAIN_DOWN (1)



#define MYNEWT_VAL_SYSDOWN_PANIC_FILE_LINE (0)



#define MYNEWT_VAL_SYSDOWN_PANIC_MESSAGE (0)



#define MYNEWT_VAL_SYSDOWN_TIMEOUT_MS (10000)


/*** @apache-mynewt-core/sys/sysinit */

#define MYNEWT_VAL_SYSINIT_CONSTRAIN_INIT (1)



#define MYNEWT_VAL_SYSINIT_PANIC_FILE_LINE (0)



#define MYNEWT_VAL_SYSINIT_PANIC_MESSAGE (0)


/*** @apache-mynewt-core/util/rwlock */

#define MYNEWT_VAL_RWLOCK_DEBUG (0)


/*** apps/my_sensor_app */
/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_ADC_1 (1)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_BC95G (1)



#define MYNEWT_VAL_ESP8266 (0)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_HMAC_PRNG (1)



#define MYNEWT_VAL_NRF24L01 (0)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_RAW_TEMP (1)



#define MYNEWT_VAL_REMOTE_SENSOR (0)



#define MYNEWT_VAL_SEMIHOSTING_CONSOLE (1)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_SENSOR_COAP (1)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */
/* Value copied from TEMP_STM32_DEVICE */

#define MYNEWT_VAL_SENSOR_DEVICE ("temp_stm32_0")


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_SENSOR_KEY ("t")


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_SENSOR_NETWORK (1)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_SENSOR_POLL_TIME (10 * 1000)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_SENSOR_TYPE (SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_SENSOR_VALUE_TYPE (SENSOR_VALUE_TYPE_INT32)


/* Overridden by targets/bluepill_my_sensor (defined by apps/my_sensor_app) */

#define MYNEWT_VAL_TEMP_STM32 (1)



#define MYNEWT_VAL_TEMP_STUB (0)



#define MYNEWT_VAL_WIFI_GEOLOCATION (0)


/*** hw/bsp/bluepill-64kb */

#define MYNEWT_VAL_STM32_FLASH_SIZE_KB (128)



#define MYNEWT_VAL_TIMER_0 (1)



#define MYNEWT_VAL_TIMER_1 (0)



#define MYNEWT_VAL_TIMER_2 (0)



#define MYNEWT_VAL_UART_0 (1)


/*** libs/bc95g */
/* Overridden by targets/bluepill_my_sensor (defined by libs/bc95g) */

#define MYNEWT_VAL_NBIOT_BAND (8)


/*** libs/semihosting_console */

#define MYNEWT_VAL_CONSOLE_COMPAT (1)



#define MYNEWT_VAL_CONSOLE_DEFAULT_LOCK_TIMEOUT (1000)



#define MYNEWT_VAL_CONSOLE_ECHO (0)



#define MYNEWT_VAL_CONSOLE_HISTORY_SIZE (0)



#define MYNEWT_VAL_CONSOLE_INPUT (0)



#define MYNEWT_VAL_CONSOLE_MAX_INPUT_LEN (256)



#define MYNEWT_VAL_CONSOLE_SEMIHOSTING (1)



#define MYNEWT_VAL_CONSOLE_SEMIHOSTING_INPUT_POLL_INTERVAL_MAX (250)



#define MYNEWT_VAL_CONSOLE_SEMIHOSTING_RETRY_COUNT (2)



#define MYNEWT_VAL_CONSOLE_SEMIHOSTING_RETRY_DELAY_MS (2)



#define MYNEWT_VAL_CONSOLE_SEMIHOSTING_RETRY_IN_ISR (0)



#define MYNEWT_VAL_CONSOLE_SYSINIT_STAGE (20)



#define MYNEWT_VAL_CONSOLE_TICKS (0)


/*** libs/sensor_coap */
/* Overridden by targets/bluepill_my_sensor (defined by libs/sensor_coap) */

#define MYNEWT_VAL_COAP_CBOR_ENCODING (1)


/* Overridden by apps/my_sensor_app (defined by libs/sensor_coap) */

#define MYNEWT_VAL_COAP_JSON_ENCODING (1)


/*** libs/sensor_network */
/* Overridden by targets/bluepill_my_sensor (defined by libs/sensor_network) */

#define MYNEWT_VAL_COAP_HOST ("104.199.85.211")


/* Overridden by targets/bluepill_my_sensor (defined by libs/sensor_network) */

#define MYNEWT_VAL_COAP_PORT (5683)


/* Overridden by targets/bluepill_my_sensor (defined by libs/sensor_network) */

#define MYNEWT_VAL_COAP_URI ("v2/things/IVRiBCcR6HPp_CcZIFfOZFxz_izni5xc_KO-kgSA2Y8?cbor=true")



#define MYNEWT_VAL_COLLECTOR_NODE_ADDRESS (0x7878787878ull)



#define MYNEWT_VAL_COLLECTOR_NODE_HW_ID (0x57, 0xff, 0x6a, 0x06, 0x78, 0x78, 0x54, 0x50, 0x49, 0x29, 0x24, 0x67)



#define MYNEWT_VAL_SENSOR_NETWORK_ADDRESS (0xb3b4b5b6ull)



#define MYNEWT_VAL_SENSOR_NODE_HW_ID_1 (0x38, 0xff, 0x6d, 0x06, 0x4e, 0x57, 0x34, 0x36, 0x25, 0x58, 0x08, 0x43)



#define MYNEWT_VAL_SENSOR_NODE_HW_ID_2 (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x02)



#define MYNEWT_VAL_SENSOR_NODE_HW_ID_3 (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x03)



#define MYNEWT_VAL_SENSOR_NODE_HW_ID_4 (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x04)



#define MYNEWT_VAL_SENSOR_NODE_HW_ID_5 (0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x05)



#define MYNEWT_VAL_SENSOR_NODE_OFFSET_1 (0xf1)



#define MYNEWT_VAL_SENSOR_NODE_OFFSET_2 (0xcd)



#define MYNEWT_VAL_SENSOR_NODE_OFFSET_3 (0xa3)



#define MYNEWT_VAL_SENSOR_NODE_OFFSET_4 (0x0f)



#define MYNEWT_VAL_SENSOR_NODE_OFFSET_5 (0x05)


/*** libs/temp_stm32 */

#define MYNEWT_VAL_TEMP_STM32_DEVICE ("temp_stm32_0")


/*** newt */

#define MYNEWT_VAL_APP_NAME ("my_sensor_app")



#define MYNEWT_VAL_APP_my_sensor_app (1)



#define MYNEWT_VAL_ARCH_NAME ("cortex_m3")



#define MYNEWT_VAL_ARCH_cortex_m3 (1)



#define MYNEWT_VAL_BSP_NAME ("bluepill-64kb")



#define MYNEWT_VAL_BSP_bluepill_64kb (1)



#define MYNEWT_VAL_NEWT_FEATURE_LOGCFG (1)



#define MYNEWT_VAL_NEWT_FEATURE_SYSDOWN (1)



#define MYNEWT_VAL_TARGET_NAME ("bluepill_my_sensor")



#define MYNEWT_VAL_TARGET_bluepill_my_sensor (1)
# 24 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 1 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_SYSDOWN_ 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */


#define _INTTYPES_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/extern.h" 1
/*
 * klibc/extern.h
 */


#define _KLIBC_EXTERN_H 
# 15 "repos/apache-mynewt-core/libc/baselibc/include/klibc/extern.h"
#define __extern extern


#define __alias(x) __attribute__((weak, alias(x)))
# 9 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdint.h" 1 3 4
# 9 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdint.h" 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */


#define _STDINT_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 1 3 4
/*
 *  $Id$
 */


#define _MACHINE__DEFAULT_TYPES_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 1 3 4
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */


#define _SYS_FEATURES_H 





# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_newlib_version.h" 1 3 4
/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
/* Version macros for internal and downstream use. */

#define _NEWLIB_VERSION_H__ 1

#define _NEWLIB_VERSION "3.0.0"
#define __NEWLIB__ 3
#define __NEWLIB_MINOR__ 0
#define __NEWLIB_PATCHLEVEL__ 0
# 29 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 2 3 4

/* Macro to test version of GCC.  Returns 0 for non-GCC or too old GCC. */


#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))





/* Version with trailing underscores for BSD compatibility. */
#define __GNUC_PREREQ__(ma,mi) __GNUC_PREREQ(ma, mi)


/*
 * Feature test macros control which symbols are exposed by the system
 * headers.  Any of these must be defined before including any headers.
 *
 * __STRICT_ANSI__ (defined by gcc -ansi, -std=c90, -std=c99, or -std=c11)
 *	ISO C
 *
 * _POSIX_SOURCE (deprecated by _POSIX_C_SOURCE=1)
 * _POSIX_C_SOURCE >= 1
 * 	POSIX.1-1990
 *
 * _POSIX_C_SOURCE >= 2
 * 	POSIX.2-1992
 *
 * _POSIX_C_SOURCE >= 199309L
 * 	POSIX.1b-1993 Real-time extensions
 *
 * _POSIX_C_SOURCE >= 199506L
 * 	POSIX.1c-1995 Threads extensions
 *
 * _POSIX_C_SOURCE >= 200112L
 * 	POSIX.1-2001 and C99
 *
 * _POSIX_C_SOURCE >= 200809L
 * 	POSIX.1-2008
 *
 * _XOPEN_SOURCE
 *	POSIX.1-1990 and XPG4
 *
 * _XOPEN_SOURCE_EXTENDED
 *	SUSv1 (POSIX.2-1992 plus XPG4v2)
 *
 * _XOPEN_SOURCE >= 500
 *	SUSv2 (POSIX.1c-1995 plus XSI)
 *
 * _XOPEN_SOURCE >= 600
 *	SUSv3 (POSIX.1-2001 plus XSI) and C99
 *
 * _XOPEN_SOURCE >= 700
 *	SUSv4 (POSIX.1-2008 plus XSI)
 *
 * _ISOC99_SOURCE or gcc -std=c99 or g++
 * 	ISO C99
 *
 * _ISOC11_SOURCE or gcc -std=c11 or g++ -std=c++11
 * 	ISO C11
 *
 * _ATFILE_SOURCE (implied by _POSIX_C_SOURCE >= 200809L)
 *	"at" functions
 *
 * _LARGEFILE_SOURCE (deprecated by _XOPEN_SOURCE >= 500)
 *	fseeko, ftello
 *
 * _GNU_SOURCE
 * 	All of the above plus GNU extensions
 *
 * _BSD_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _SVID_SOURCE (deprecated by _DEFAULT_SOURCE)
 * _DEFAULT_SOURCE (or none of the above)
 * 	POSIX-1.2008 with BSD and SVr4 extensions
 *
 * _FORTIFY_SOURCE = 1 or 2
 * 	Object Size Checking function wrappers
 */
# 131 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
#undef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE 1



#undef _POSIX_SOURCE
#define _POSIX_SOURCE 1
#undef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
# 158 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
#undef _ATFILE_SOURCE
#define _ATFILE_SOURCE 1


/*
 * The following private macros are used throughout the headers to control
 * which symbols should be exposed.  They are for internal use only, as
 * indicated by the leading double underscore, and must never be used outside
 * of these headers.
 *
 * __POSIX_VISIBLE
 * 	any version of POSIX.1; enabled by default, or with _POSIX_SOURCE,
 * 	any value of _POSIX_C_SOURCE, or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 2
 * 	POSIX.2-1992; enabled by default, with _POSIX_C_SOURCE >= 2,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199309
 * 	POSIX.1b-1993; enabled by default, with _POSIX_C_SOURCE >= 199309L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 199506
 * 	POSIX.1c-1995; enabled by default, with _POSIX_C_SOURCE >= 199506L,
 * 	or _XOPEN_SOURCE >= 500.
 *
 * __POSIX_VISIBLE >= 200112
 * 	POSIX.1-2001; enabled by default, with _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __POSIX_VISIBLE >= 200809
 * 	POSIX.1-2008; enabled by default, with _POSIX_C_SOURCE >= 200809L,
 * 	or _XOPEN_SOURCE >= 700.
 *
 * __XSI_VISIBLE
 *	XPG4 XSI extensions; enabled with any version of _XOPEN_SOURCE.
 *
 * __XSI_VISIBLE >= 4
 *	SUSv1 XSI extensions; enabled with both _XOPEN_SOURCE and
 * 	_XOPEN_SOURCE_EXTENDED together.
 *
 * __XSI_VISIBLE >= 500
 *	SUSv2 XSI extensions; enabled with _XOPEN_SOURCE >= 500.
 *
 * __XSI_VISIBLE >= 600
 *	SUSv3 XSI extensions; enabled with _XOPEN_SOURCE >= 600.
 *
 * __XSI_VISIBLE >= 700
 *	SUSv4 XSI extensions; enabled with _XOPEN_SOURCE >= 700.
 *
 * __ISO_C_VISIBLE >= 1999
 * 	ISO C99; enabled with gcc -std=c99 or newer (on by default since GCC 5),
 * 	any version of C++, or with _ISOC99_SOURCE, _POSIX_C_SOURCE >= 200112L,
 * 	or _XOPEN_SOURCE >= 600.
 *
 * __ISO_C_VISIBLE >= 2011
 * 	ISO C11; enabled with gcc -std=c11 or newer (on by default since GCC 5),
 * 	g++ -std=c++11 or newer (on by default since GCC 6), or with
 * 	_ISOC11_SOURCE.
 *
 * __ATFILE_VISIBLE
 *	"at" functions; enabled by default, with _ATFILE_SOURCE,
 * 	_POSIX_C_SOURCE >= 200809L, or _XOPEN_SOURCE >= 700.
 *
 * __LARGEFILE_VISIBLE
 *	fseeko, ftello; enabled with _LARGEFILE_SOURCE or _XOPEN_SOURCE >= 500.
 *
 * __BSD_VISIBLE
 * 	BSD extensions; enabled by default, or with _BSD_SOURCE.
 *
 * __SVID_VISIBLE
 * 	SVr4 extensions; enabled by default, or with _SVID_SOURCE.
 *
 * __MISC_VISIBLE
 * 	Extensions found in both BSD and SVr4 (shorthand for
 * 	(__BSD_VISIBLE || __SVID_VISIBLE)), or newlib-specific
 * 	extensions; enabled by default.
 *
 * __GNU_VISIBLE
 * 	GNU extensions; enabled with _GNU_SOURCE.
 *
 * __SSP_FORTIFY_LEVEL
 * 	Object Size Checking; defined to 0 (off), 1, or 2.
 *
 * In all cases above, "enabled by default" means either by defining
 * _DEFAULT_SOURCE, or by not defining any of the public feature test macros.
 */


#define __ATFILE_VISIBLE 1





#define __BSD_VISIBLE 1







#define __GNU_VISIBLE 0




#define __ISO_C_VISIBLE 2011
# 277 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
#define __LARGEFILE_VISIBLE 0



#define __MISC_VISIBLE 1





#define __POSIX_VISIBLE 200809
# 303 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
#define __SVID_VISIBLE 1
# 319 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
#define __XSI_VISIBLE 0
# 330 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
#define __SSP_FORTIFY_LEVEL 0


/* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
# 390 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 3 4
/* XMK loosely adheres to POSIX -- 1003.1 */
# 9 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 2 3 4

/*
 * Guess on types by examining *_MIN / *_MAX defines.
 */

/* GCC >= 3.3.0 has __<val>__ implicitly defined. */
#define __EXP(x) __ ##x ##__






/* Check if "long long" is 64bit wide */
/* Modern GCCs provide __LONG_LONG_MAX__, SUSv3 wants LLONG_MAX */


#define __have_longlong64 1


/* Check if "long" is 64bit or 32bit wide */



#define __have_long32 1







typedef signed char __int8_t;

typedef unsigned char __uint8_t;



#define ___int8_t_defined 1







typedef short int __int16_t;

typedef short unsigned int __uint16_t;



#define ___int16_t_defined 1
# 77 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long int __int32_t;

typedef long unsigned int __uint32_t;



#define ___int32_t_defined 1
# 103 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;



#define ___int64_t_defined 1
# 134 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;



#define ___int_least8_t_defined 1
# 160 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;



#define ___int_least16_t_defined 1
# 182 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;



#define ___int_least32_t_defined 1
# 200 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;



#define ___int_least64_t_defined 1







typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 244 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 3 4
#undef __EXP
# 13 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 2 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 1 3 4
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */


#define _SYS__INTSUP_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 1 3 4
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
# 13 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 2 3 4


/* gcc > 3.2 implicitly defines the values we are interested */
#define __STDINT_EXP(x) __ ##x ##__





/* Determine how intptr_t and intN_t fastN_t and leastN_t are defined by gcc
   for this target.  This is used to determine the correct printf() constant in
   inttypes.h and other  constants in stdint.h.
   So we end up with
   ?(signed|unsigned) char == 0
   ?(signed|unsigned) short == 1
   ?(signed|unsigned) int == 2
   ?(signed|unsigned) short int == 3
   ?(signed|unsigned) long == 4
   ?(signed|unsigned) long int == 6
   ?(signed|unsigned) long long == 8
   ?(signed|unsigned) long long int == 10
 */
       
       
       
       
       
       
       
#undef signed
#undef unsigned
#undef char
#undef short
#undef int
#undef __int20
#undef long
#define signed +0
#define unsigned +0
#define char +0
#define short +1
#define __int20 +2
#define int +2
#define long +4
# 64 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define _INTPTR_EQ_INT 






#define _INT32_EQ_LONG 







#define __INT8 "hh"
# 90 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __INT16 "h"
# 101 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __INT32 "l"
# 110 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __INT64 "ll"






#define __FAST8 
# 126 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __FAST16 






#define __FAST32 
# 144 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __FAST64 "ll"



#define __LEAST8 "hh"
# 159 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __LEAST16 "h"
# 170 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __LEAST32 "l"
# 179 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#define __LEAST64 "ll"

#undef signed
#undef unsigned
#undef char
#undef short
#undef int
#undef long
       
       
       
       
       
# 191 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_intsup.h" 3 4
#undef __int20
       
       
# 14 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 2 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_stdint.h" 1 3 4
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */


#define _SYS__STDINT_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 1 3 4
/*
 *  $Id$
 */
# 13 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_stdint.h" 2 3 4







typedef __int8_t int8_t ;
#define _INT8_T_DECLARED 


typedef __uint8_t uint8_t ;
#define _UINT8_T_DECLARED 

#define __int8_t_defined 1




typedef __int16_t int16_t ;
#define _INT16_T_DECLARED 


typedef __uint16_t uint16_t ;
#define _UINT16_T_DECLARED 

#define __int16_t_defined 1




typedef __int32_t int32_t ;
#define _INT32_T_DECLARED 


typedef __uint32_t uint32_t ;
#define _UINT32_T_DECLARED 

#define __int32_t_defined 1




typedef __int64_t int64_t ;
#define _INT64_T_DECLARED 


typedef __uint64_t uint64_t ;
#define _UINT64_T_DECLARED 

#define __int64_t_defined 1



typedef __intmax_t intmax_t;
#define _INTMAX_T_DECLARED 



typedef __uintmax_t uintmax_t;
#define _UINTMAX_T_DECLARED 



typedef __intptr_t intptr_t;
#define _INTPTR_T_DECLARED 



typedef __uintptr_t uintptr_t;
#define _UINTPTR_T_DECLARED 
# 15 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 2 3 4






typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;
#define __int_least8_t_defined 1



typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;
#define __int_least16_t_defined 1



typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;
#define __int_least32_t_defined 1



typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
#define __int_least64_t_defined 1


/*
 * Fastest minimum-width integer types
 *
 * Assume int to be the fastest type for all types with a width 
 * less than __INT_MAX__ rsp. INT_MAX
 */

  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
#define __int_fast8_t_defined 1







  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
#define __int_fast16_t_defined 1







  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
#define __int_fast32_t_defined 1







  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
#define __int_fast64_t_defined 1






/*
 * Fall back to [u]int_least<N>_t for [u]int_fast<N>_t types
 * not having been defined, yet.
 * Leave undefined, if [u]int_least<N>_t should not be available.
 */
# 128 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INTPTR_MIN (-__INTPTR_MAX__ - 1)
#define INTPTR_MAX (__INTPTR_MAX__)
#define UINTPTR_MAX (__UINTPTR_MAX__)
# 149 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
/* Limits of Specified-Width Integer Types */


#define INT8_MIN (-__INT8_MAX__ - 1)
#define INT8_MAX (__INT8_MAX__)
#define UINT8_MAX (__UINT8_MAX__)







#define INT_LEAST8_MIN (-__INT_LEAST8_MAX__ - 1)
#define INT_LEAST8_MAX (__INT_LEAST8_MAX__)
#define UINT_LEAST8_MAX (__UINT_LEAST8_MAX__)
# 174 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT16_MIN (-__INT16_MAX__ - 1)
#define INT16_MAX (__INT16_MAX__)
#define UINT16_MAX (__UINT16_MAX__)







#define INT_LEAST16_MIN (-__INT_LEAST16_MAX__ - 1)
#define INT_LEAST16_MAX (__INT_LEAST16_MAX__)
#define UINT_LEAST16_MAX (__UINT_LEAST16_MAX__)
# 196 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT32_MIN (-__INT32_MAX__ - 1)
#define INT32_MAX (__INT32_MAX__)
#define UINT32_MAX (__UINT32_MAX__)
# 212 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT_LEAST32_MIN (-__INT_LEAST32_MAX__ - 1)
#define INT_LEAST32_MAX (__INT_LEAST32_MAX__)
#define UINT_LEAST32_MAX (__UINT_LEAST32_MAX__)
# 230 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT64_MIN (-__INT64_MAX__ - 1)
#define INT64_MAX (__INT64_MAX__)
#define UINT64_MAX (__UINT64_MAX__)
# 246 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT_LEAST64_MIN (-__INT_LEAST64_MAX__ - 1)
#define INT_LEAST64_MAX (__INT_LEAST64_MAX__)
#define UINT_LEAST64_MAX (__UINT_LEAST64_MAX__)
# 262 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST8_MIN (-__INT_FAST8_MAX__ - 1)
#define INT_FAST8_MAX (__INT_FAST8_MAX__)
#define UINT_FAST8_MAX (__UINT_FAST8_MAX__)
# 278 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST16_MIN (-__INT_FAST16_MAX__ - 1)
#define INT_FAST16_MAX (__INT_FAST16_MAX__)
#define UINT_FAST16_MAX (__UINT_FAST16_MAX__)
# 294 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST32_MIN (-__INT_FAST32_MAX__ - 1)
#define INT_FAST32_MAX (__INT_FAST32_MAX__)
#define UINT_FAST32_MAX (__UINT_FAST32_MAX__)
# 310 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT_FAST64_MIN (-__INT_FAST64_MAX__ - 1)
#define INT_FAST64_MAX (__INT_FAST64_MAX__)
#define UINT_FAST64_MAX (__UINT_FAST64_MAX__)
# 326 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INTMAX_MAX (__INTMAX_MAX__)
#define INTMAX_MIN (-INTMAX_MAX - 1)







#define UINTMAX_MAX (__UINTMAX_MAX__)





/* This must match size_t in stddef.h, currently long unsigned int */

#define SIZE_MAX (__SIZE_MAX__)




/* This must match sig_atomic_t in <signal.h> (currently int) */
#define SIG_ATOMIC_MIN (-__STDINT_EXP(INT_MAX) - 1)
#define SIG_ATOMIC_MAX (__STDINT_EXP(INT_MAX))

/* This must match ptrdiff_t  in <stddef.h> (currently long int) */

#define PTRDIFF_MAX (__PTRDIFF_MAX__)



#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)

/* This must match definition in <wchar.h> */


#define WCHAR_MIN (__WCHAR_MIN__)







/* This must match definition in <wchar.h> */


#define WCHAR_MAX (__WCHAR_MAX__)







/* wint_t is unsigned int on almost all GCC targets.  */

#define WINT_MAX (__WINT_MAX__)




#define WINT_MIN (__WINT_MIN__)




/** Macros for minimum-width integer constant expressions */

#define INT8_C(x) __INT8_C(x)
#define UINT8_C(x) __UINT8_C(x)
# 408 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT16_C(x) __INT16_C(x)
#define UINT16_C(x) __UINT16_C(x)
# 420 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT32_C(x) __INT32_C(x)
#define UINT32_C(x) __UINT32_C(x)
# 433 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
#define INT64_C(x) __INT64_C(x)
#define UINT64_C(x) __UINT64_C(x)
# 447 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdint.h" 3 4
/** Macros for greatest-width integer constant expression */

#define INTMAX_C(x) __INTMAX_C(x)
#define UINTMAX_C(x) __UINTMAX_C(x)
# 10 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdint.h" 2 3 4



#define _GCC_WRAP_STDINT_H 
# 10 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */



#define _STDDEF_H 
#define _STDDEF_H_ 
/* snaroff@next.com says the NeXT needs this.  */
#define _ANSI_STDDEF_H 



/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 137 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 



typedef int ptrdiff_t;
# 160 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 187 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#define __size_t__ /* BeOS */
#define __SIZE_T__ /* Cray Unicos/Mk */
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ /* Darwin */
#define _SIZE_T_DECLARED /* FreeBSD 5 */
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 







#define __size_t 





typedef unsigned int size_t;
# 238 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 267 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#define __wchar_t__ /* BeOS */
#define __WCHAR_T__ /* Cray Unicos/Mk */
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 

/* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." */

#undef _BSD_WCHAR_T_
# 310 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... */
# 328 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 347 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#undef __need_wchar_t
# 362 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 
/* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  */
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
  /* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  */



} max_align_t;
# 11 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 2






# 16 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h"
static __inline__ intmax_t imaxabs(intmax_t __n)
{
 return (__n < (intmax_t) 0) ? -__n : __n;
}

extern intmax_t strtoimax(const char *, char **, int);
extern uintmax_t strtoumax(const char *, char **, int);

/* extensions */
extern intmax_t strntoimax(const char *, char **, int, size_t);
extern uintmax_t strntoumax(const char *, char **, int, size_t);



#define __PRI64_RANK "ll"
#define __PRI32_RANK "l"

#define PRId8 "d"
#define PRId16 "d"
#define PRId32 "d"
#define PRId64 __PRI64_RANK "d"

#define PRIdLEAST8 "d"
#define PRIdLEAST16 "d"
#define PRIdLEAST32 "d"
#define PRIdLEAST64 __PRI64_RANK "d"

#define PRIdFAST8 "d"
#define PRIdFAST16 __PRIFAST_RANK "d"
#define PRIdFAST32 __PRIFAST_RANK "d"
#define PRIdFAST64 __PRI64_RANK "d"

#define PRIdMAX __PRI64_RANK "d"
#define PRIdPTR __PRIPTR_RANK "d"

#define PRIi8 "i"
#define PRIi16 "i"
#define PRIi32 "i"
#define PRIi64 __PRI64_RANK "i"

#define PRIiLEAST8 "i"
#define PRIiLEAST16 "i"
#define PRIiLEAST32 "i"
#define PRIiLEAST64 __PRI64_RANK "i"

#define PRIiFAST8 "i"
#define PRIiFAST16 __PRIFAST_RANK "i"
#define PRIiFAST32 __PRIFAST_RANK "i"
#define PRIiFAST64 __PRI64_RANK "i"

#define PRIiMAX __PRI64_RANK "i"
#define PRIiPTR __PRIPTR_RANK "i"

#define PRIo8 "o"
#define PRIo16 "o"
#define PRIo32 "o"
#define PRIo64 __PRI64_RANK "o"

#define PRIoLEAST8 "o"
#define PRIoLEAST16 "o"
#define PRIoLEAST32 "o"
#define PRIoLEAST64 __PRI64_RANK "o"

#define PRIoFAST8 "o"
#define PRIoFAST16 __PRIFAST_RANK "o"
#define PRIoFAST32 __PRIFAST_RANK "o"
#define PRIoFAST64 __PRI64_RANK "o"

#define PRIoMAX __PRI64_RANK "o"
#define PRIoPTR __PRIPTR_RANK "o"

#define PRIu8 "u"
#define PRIu16 "u"
#define PRIu32 "u"
#define PRIu64 __PRI64_RANK "u"

#define PRIuLEAST8 "u"
#define PRIuLEAST16 "u"
#define PRIuLEAST32 "u"
#define PRIuLEAST64 __PRI64_RANK "u"

#define PRIuFAST8 "u"
#define PRIuFAST16 __PRIFAST_RANK "u"
#define PRIuFAST32 __PRIFAST_RANK "u"
#define PRIuFAST64 __PRI64_RANK "u"

#define PRIuMAX __PRI64_RANK "u"
#define PRIuPTR __PRIPTR_RANK "u"

#define PRIx8 "x"
#define PRIx16 "x"
#define PRIx32 __PRI32_RANK "x"
#define PRIx64 __PRI64_RANK "x"

#define PRIxLEAST8 "x"
#define PRIxLEAST16 "x"
#define PRIxLEAST32 "x"
#define PRIxLEAST64 __PRI64_RANK "x"

#define PRIxFAST8 "x"
#define PRIxFAST16 __PRIFAST_RANK "x"
#define PRIxFAST32 __PRIFAST_RANK "x"
#define PRIxFAST64 __PRI64_RANK "x"

#define PRIxMAX __PRI64_RANK "x"
#define PRIxPTR __PRIPTR_RANK "x"

#define PRIX8 "X"
#define PRIX16 "X"
#define PRIX32 __PRI32_RANK "X"
#define PRIX64 __PRI64_RANK "X"

#define PRIXLEAST8 "X"
#define PRIXLEAST16 "X"
#define PRIXLEAST32 "X"
#define PRIXLEAST64 __PRI64_RANK "X"

#define PRIXFAST8 "X"
#define PRIXFAST16 __PRIFAST_RANK "X"
#define PRIXFAST32 __PRIFAST_RANK "X"
#define PRIXFAST64 __PRI64_RANK "X"

#define PRIXMAX __PRI64_RANK "X"
#define PRIXPTR __PRIPTR_RANK "X"

#define SCNd8 "hhd"
#define SCNd16 "hd"
#define SCNd32 "d"
#define SCNd64 __PRI64_RANK "d"

#define SCNdLEAST8 "hhd"
#define SCNdLEAST16 "hd"
#define SCNdLEAST32 "d"
#define SCNdLEAST64 __PRI64_RANK "d"

#define SCNdFAST8 "hhd"
#define SCNdFAST16 __PRIFAST_RANK "d"
#define SCNdFAST32 __PRIFAST_RANK "d"
#define SCNdFAST64 __PRI64_RANK "d"

#define SCNdMAX __PRI64_RANK "d"
#define SCNdPTR __PRIPTR_RANK "d"

#define SCNi8 "hhi"
#define SCNi16 "hi"
#define SCNi32 "i"
#define SCNi64 __PRI64_RANK "i"

#define SCNiLEAST8 "hhi"
#define SCNiLEAST16 "hi"
#define SCNiLEAST32 "i"
#define SCNiLEAST64 __PRI64_RANK "i"

#define SCNiFAST8 "hhi"
#define SCNiFAST16 __PRIFAST_RANK "i"
#define SCNiFAST32 __PRIFAST_RANK "i"
#define SCNiFAST64 __PRI64_RANK "i"

#define SCNiMAX __PRI64_RANK "i"
#define SCNiPTR __PRIPTR_RANK "i"

#define SCNo8 "hho"
#define SCNo16 "ho"
#define SCNo32 "o"
#define SCNo64 __PRI64_RANK "o"

#define SCNoLEAST8 "hho"
#define SCNoLEAST16 "ho"
#define SCNoLEAST32 "o"
#define SCNoLEAST64 __PRI64_RANK "o"

#define SCNoFAST8 "hho"
#define SCNoFAST16 __PRIFAST_RANK "o"
#define SCNoFAST32 __PRIFAST_RANK "o"
#define SCNoFAST64 __PRI64_RANK "o"

#define SCNoMAX __PRI64_RANK "o"
#define SCNoPTR __PRIPTR_RANK "o"

#define SCNu8 "hhu"
#define SCNu16 "hu"
#define SCNu32 "u"
#define SCNu64 __PRI64_RANK "u"

#define SCNuLEAST8 "hhu"
#define SCNuLEAST16 "hu"
#define SCNuLEAST32 "u"
#define SCNuLEAST64 __PRI64_RANK "u"

#define SCNuFAST8 "hhu"
#define SCNuFAST16 __PRIFAST_RANK "u"
#define SCNuFAST32 __PRIFAST_RANK "u"
#define SCNuFAST64 __PRI64_RANK "u"

#define SCNuMAX __PRI64_RANK "u"
#define SCNuPTR __PRIPTR_RANK "u"

#define SCNx8 "hhx"
#define SCNx16 "hx"
#define SCNx32 "x"
#define SCNx64 __PRI64_RANK "x"

#define SCNxLEAST8 "hhx"
#define SCNxLEAST16 "hx"
#define SCNxLEAST32 "x"
#define SCNxLEAST64 __PRI64_RANK "x"

#define SCNxFAST8 "hhx"
#define SCNxFAST16 __PRIFAST_RANK "x"
#define SCNxFAST32 __PRIFAST_RANK "x"
#define SCNxFAST64 __PRI64_RANK "x"

#define SCNxMAX __PRI64_RANK "x"
#define SCNxPTR __PRIPTR_RANK "x"
# 24 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/assert.h" 1
/*
 * assert.h
 */


#define _ASSERT_H 
# 23 "repos/apache-mynewt-core/libc/baselibc/include/assert.h"
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 24 "repos/apache-mynewt-core/libc/baselibc/include/assert.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_fault.h" 1

# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_fault.h"
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _OS_FAULT_H 

# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 24 "repos/apache-mynewt-core/kernel/os/include/os/os_fault.h" 2





void __assert_func(const char *file, int line, const char *func, const char *e)
    __attribute((noreturn));




#define OS_CRASH() __assert_func(NULL, 0, NULL, NULL)
# 25 "repos/apache-mynewt-core/libc/baselibc/include/assert.h" 2

#define assert(x) ((x) ? (void)0 : OS_CRASH())
# 25 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */


#define _STDBOOL_H 



#define bool _Bool
#define true 1
#define false 0
# 51 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined 1
# 26 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h" 2
# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1

# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h"
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 27 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h" 2





#define SYSDOWN_COMPLETE 0
#define SYSDOWN_IN_PROGRESS 1

/**
 * Whether the system is currently shutting down
 */
extern 
# 38 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h" 3 4
      _Bool 
# 38 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h"
           sysdown_active;

typedef int sysdown_fn(int reason);
typedef void sysdown_panic_fn(const char *file, int line, const char *func,
                              const char *expr, const char *msg);
typedef void sysdown_complete_fn(int status, void *arg);

extern sysdown_fn * const sysdown_cbs[];
extern sysdown_panic_fn *sysdown_panic_cb;

void sysdown_panic_set(sysdown_panic_fn *panic_fn);
# 63 "repos/apache-mynewt-core/sys/sysdown/include/sysdown/sysdown.h"
#define SYSDOWN_PANIC_MSG(msg) sysdown_panic_cb(0, 0, 0, 0, 0)




#define SYSDOWN_PANIC() SYSDOWN_PANIC_MSG(NULL)

#define SYSDOWN_ASSERT_MSG(rc,msg) do { if (!(rc)) { SYSDOWN_PANIC_MSG(msg); } } while (0)






#define SYSDOWN_ASSERT(rc) SYSDOWN_ASSERT_MSG(rc, NULL)

/**
 * Asserts that system shutdown is in progress.  This macro is used to ensure
 * packages don't get shut down a second time after system shutdown has
 * completed.
 */

#define SYSDOWN_ASSERT_ACTIVE() assert(sysdown_active)




/**
 * @brief Performs a controlled shutdown and reset of the system.
 *
 * This function executes each package's shutdown sequence, then triggers a
 * reboot.
 *
 * @param reason                The reason for the shutdown.  One of the
 *                                  HAL_RESET_[...] codes or an
 *                                  implementation-defined value.
 *
 * @return
 */
int sysdown(int reason);

/**
 * @brief Signals completion of an in-progress sysdown subprocedure.
 *
 * If a sysdown subprocedure needs to perform additional work after its
 * callback finishes, it returns SYSDOWN_IN_PROGRESS.  Later, when the
 * subprocedure completes, it signals its completion asynchronously with a call
 * to this function.
 */
void sysdown_release(void);
# 25 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 1 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_SYSINIT_ 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 24 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/assert.h" 1
/*
 * assert.h
 */
# 25 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h" 2
# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 26 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h" 2
# 35 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h"
extern uint8_t sysinit_active;

void sysinit_start(void);
void sysinit_end(void);

typedef void sysinit_panic_fn(const char *file, int line, const char *func,
                              const char *expr, const char *msg);

extern sysinit_panic_fn *sysinit_panic_cb;

void sysinit_panic_set(sysinit_panic_fn *panic_fn);
# 60 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h"
#define SYSINIT_PANIC_MSG(msg) sysinit_panic_cb(0, 0, 0, 0, 0)




#define SYSINIT_PANIC() SYSINIT_PANIC_MSG(NULL)

#define SYSINIT_PANIC_ASSERT_MSG(rc,msg) do { if (!(rc)) { SYSINIT_PANIC_MSG(msg); } } while (0)






#define SYSINIT_PANIC_ASSERT(rc) SYSINIT_PANIC_ASSERT_MSG(rc, NULL)

/**
 * Asserts that system initialization is in progress.  This macro is used to
 * ensure packages don't get initialized a second time after system
 * initialization has completed.
 */

#define SYSINIT_ASSERT_ACTIVE() assert(sysinit_active)
# 113 "repos/apache-mynewt-core/sys/sysinit/include/sysinit/sysinit.h"
/*** System initialization for a unified image (no split). */
void sysinit_app(void);
#define sysinit() do { sysinit_start(); sysinit_app(); sysinit_end(); } while (0)
# 26 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 1 "bin/targets/bluepill_my_sensor/generated/include/sysflash/sysflash.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */


#define H_MYNEWT_SYSFLASH_ 

# 1 "repos/apache-mynewt-core/sys/flash_map/include/flash_map/flash_map.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_UTIL_FLASH_MAP_ 





/**
 *
 * Provides abstraction of flash regions for type of use.
 * I.e. dude where's my image?
 *
 * System will contain a map which contains flash areas. Every
 * region will contain flash identifier, offset within flash and length.
 *
 * 1. This system map could be in a file within filesystem (Initializer
 * must know/figure out where the filesystem is at).
 * 2. Map could be at fixed location for project (compiled to code)
 * 3. Map could be at specific place in flash (put in place at mfg time).
 *
 * Note that the map you use must be valid for BSP it's for,
 * match the linker scripts when platform executes from flash,
 * and match the target offset specified in download script.
 */
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 45 "repos/apache-mynewt-core/sys/flash_map/include/flash_map/flash_map.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h"
/*
 * inttypes.h
 */
# 46 "repos/apache-mynewt-core/sys/flash_map/include/flash_map/flash_map.h" 2

struct flash_area {
    uint8_t fa_id;
    uint8_t fa_device_id;
    uint16_t pad16;
    uint32_t fa_off;
    uint32_t fa_size;
};

struct flash_sector_range {
    struct flash_area fsr_flash_area;
    uint32_t fsr_range_start;
    uint16_t fsr_first_sector;
    uint16_t fsr_sector_count;
    uint32_t fsr_sector_size;
    uint8_t fsr_align;
};

extern const struct flash_area *flash_map;
extern int flash_map_entries;

/*
 * Initializes flash map. Memory will be referenced by flash_map code
 * from this on.
 */
void flash_map_init(void);

/*
 * Start using flash area.
 */
int flash_area_open(uint8_t id, const struct flash_area **);

/** nothing to do for now */
#define flash_area_close(flash_area) 

/*
 * Read/write/erase. Offset is relative from beginning of flash area.
 */
int flash_area_read(const struct flash_area *, uint32_t off, void *dst,
  uint32_t len);
int flash_area_write(const struct flash_area *, uint32_t off, const void *src,
  uint32_t len);
int flash_area_erase(const struct flash_area *, uint32_t off, uint32_t len);

/*
 * Whether the whole area is empty.
 */
int flash_area_is_empty(const struct flash_area *, 
# 93 "repos/apache-mynewt-core/sys/flash_map/include/flash_map/flash_map.h" 3 4
                                                  _Bool 
# 93 "repos/apache-mynewt-core/sys/flash_map/include/flash_map/flash_map.h"
                                                       *);

/*
 * Reads data. Return code indicates whether it thinks that
 * underlying area is in erased state.
 *
 * Returns 1 if empty, 0 if not. <0 in case of an error.
 */
int flash_area_read_is_empty(const struct flash_area *, uint32_t off, void *dst,
  uint32_t len);

/*
 * Alignment restriction for flash writes.
 */
uint8_t flash_area_align(const struct flash_area *);

/*
 * Value read from flash when it is erased.
 */
uint32_t flash_area_erased_val(const struct flash_area *fa);

/*
 * Given flash map index, return info about sectors within the area.
 */
int flash_area_to_sectors(int idx, int *cnt, struct flash_area *ret);

/*
 * Given flash map area id, return info about sectors within the area.
 */
int flash_area_to_sector_ranges(int id, int *cnt,
  struct flash_sector_range *ret);

/*
 * Get-next interface for obtaining info about sectors.
 * To start the get-next walk, call with *sec_id set to -1.
 */
int flash_area_getnext_sector(int id, int *sec_id, struct flash_area *ret);

int flash_area_id_from_image_slot(int slot);
int flash_area_id_to_image_slot(int area_id);
# 9 "bin/targets/bluepill_my_sensor/generated/include/sysflash/sysflash.h" 2

/**
 * This flash map definition is used for two purposes:
 * 1. To locate the meta area, which contains the true flash map definition.
 * 2. As a fallback in case the meta area cannot be read from flash.
 */
extern const struct flash_area sysflash_map_dflt[6];

#define FLASH_AREA_BOOTLOADER 0
#define FLASH_AREA_IMAGE_0 1
#define FLASH_AREA_IMAGE_1 2
#define FLASH_AREA_IMAGE_SCRATCH 3
#define FLASH_AREA_REBOOT_LOG 16
#define FLASH_AREA_NFFS 17
# 27 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _OS_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 1
/*
 * stdlib.h
 */


#define _STDLIB_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/extern.h" 1
/*
 * klibc/extern.h
 */
# 9 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/inline.h" 1
/*
 * klibc/inline.h
 */


#define _KLIBC_INLINE_H 






#define __extern_inline extern inline __attribute__((gnu_inline))
# 10 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 11 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 12 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 2






# 17 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h"
extern inline __attribute__((gnu_inline)) int abs(int __n)
{
 return (__n < 0) ? -__n : __n;
}

extern int atoi(const char *);
extern long atol(const char *);
extern long long atoll(const char *);

extern double atof(const char *str);
extern double strtod(const char *nptr, char **endptr);

extern inline __attribute__((gnu_inline)) long labs(long __n)
{
 return (__n < 0L) ? -__n : __n;
}

extern inline __attribute__((gnu_inline)) long long llabs(long long __n)
{
 return (__n < 0LL) ? -__n : __n;
}

extern void free(void *);
extern void *malloc(size_t);
extern void *calloc(size_t, size_t);
extern void *realloc(void *, size_t);

/* Giving malloc some memory from which to allocate */
extern void add_malloc_block(void *, size_t);
extern void get_malloc_memory_status(size_t *, size_t *);

/* Malloc locking
 * Until the callbacks are set, malloc doesn't do any locking.
 * malloc_lock() *may* timeout, in which case malloc() will return NULL.
 */
typedef 
# 52 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 3 4
       _Bool 
# 52 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h"
            (*malloc_lock_t)();
typedef void (*malloc_unlock_t)();
extern void set_malloc_locking(malloc_lock_t, malloc_unlock_t);

extern long strtol(const char *, char **, int);
extern long long strtoll(const char *, char **, int);
extern unsigned long strtoul(const char *, char **, int);
extern unsigned long long strtoull(const char *, char **, int);

typedef int (*__comparefunc_t) (const void *, const void *);
extern void *bsearch(const void *, const void *, size_t, size_t,
         __comparefunc_t);
extern void qsort(void *, size_t, size_t, __comparefunc_t);

extern long jrand48(unsigned short *);
extern long mrand48(void);
extern long nrand48(unsigned short *);
extern long lrand48(void);
extern unsigned short *seed48(const unsigned short *);
extern void srand48(long);

extern inline __attribute__((gnu_inline)) char *getenv(const char *name)
{
 return 
# 75 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h" 3 4
       ((void *)0)
# 75 "repos/apache-mynewt-core/libc/baselibc/include/stdlib.h"
           ;
}

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
extern void _exit(int s);
extern inline __attribute__((gnu_inline)) void exit(int err)
{
 _exit(err);
}

#define RAND_MAX 0x7fffffff
extern inline __attribute__((gnu_inline)) int rand(void)
{
 return (int)lrand48();
}
extern inline __attribute__((gnu_inline)) void srand(unsigned int __s)
{
 srand48(__s);
}
extern inline __attribute__((gnu_inline)) long random(void)
{
 return lrand48();
}
extern inline __attribute__((gnu_inline)) void srandom(unsigned int __s)
{
 srand48(__s);
}
# 24 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 25 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2

# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 27 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2






#define min(a,b) ((a)<(b)?(a):(b))



#define max(a,b) ((a)>(b)?(a):(b))


#define os_get_return_addr() (__builtin_return_address(0))

#define OS_ALIGN(__n,__a) ( (((__n) & ((__a) - 1)) == 0) ? (__n) : ((__n) + ((__a) - ((__n) & ((__a) - 1)))) )






#define CTASSERT(x) typedef int __ctasssert ## __LINE__[(x) ? 1 : -1]


/**
 * @cond INTERNAL_HIDDEN
 */
/**
 * Whether or not the operating system has been started.  Set to
 * 1 right before first task is run.
 */
extern int g_os_started;

int os_info_init(void);

/* XXX: Not sure if this should go here; I want to differentiate API that
 * should be called by application developers as those that should not. */
void os_init_idle_task(void);
/**
 * @endcond
 */

/**
 * Check whether or not the OS has been started.
 *
 * @return 1 if the OS has been started and 0 if it has not yet been started.
 */
int os_started(void);

/**
 * Definition used for functions that take timeouts to specify
 * waiting indefinitely.
 */
#define OS_WAIT_FOREVER (-1)

/**
 * Priority of the IDLE task.  Always the lowest priority task in teh system.
 */
#define OS_IDLE_PRIO (0xff)

/**
 * Main task priority, defined by sysconfig.
 */
#define OS_MAIN_TASK_PRIO MYNEWT_VAL(OS_MAIN_TASK_PRIO)
/**
 * Main task stack size, defined by sysconfig.
 */
#define OS_MAIN_STACK_SIZE MYNEWT_VAL(OS_MAIN_STACK_SIZE)

/**
 * Initialize the OS, including memory areas and housekeeping functions.
 * This calls into the architecture specific OS initialization.
 *
 * @param fn The system "main" function to start the main task with.
 */
void os_init(int (*fn)(int argc, char **argv));

/**
 * Start the OS and begin processing.
 */
void os_start(void);

/**
 * Reboots the system.
 */
void os_reboot(int reason);

/**
 * Performs a system reset.  This is typically done at the end of a reboot
 * procedure.
 */
void os_system_reset(void);

# 1 "repos/apache-mynewt-core/kernel/os/include/os/endian.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_ENDIAN_ 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 24 "repos/apache-mynewt-core/kernel/os/include/os/endian.h" 2





/* Internal helpers */

#define os_bswap_64(x) ((uint64_t) ((((x) & 0xff00000000000000ull) >> 56) | (((x) & 0x00ff000000000000ull) >> 40) | (((x) & 0x0000ff0000000000ull) >> 24) | (((x) & 0x000000ff00000000ull) >> 8) | (((x) & 0x00000000ff000000ull) << 8) | (((x) & 0x0000000000ff0000ull) << 24) | (((x) & 0x000000000000ff00ull) << 40) | (((x) & 0x00000000000000ffull) << 56)))
# 43 "repos/apache-mynewt-core/kernel/os/include/os/endian.h"
#define os_bswap_32(x) ((uint32_t) ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | (((x) & 0x0000ff00) << 8) | (((x) & 0x000000ff) << 24)))







#define os_bswap_16(x) ((uint16_t) ((((x) & 0xff00) >> 8) | (((x) & 0x00ff) << 8)))
# 133 "repos/apache-mynewt-core/kernel/os/include/os/endian.h"
#define ntohll(x) os_bswap_64(x)



#define htonll ntohll



#define ntohl(x) os_bswap_32(x)



#define htonl ntohl



#define htons(x) os_bswap_16(x)



#define ntohs htons



#define htobe16(x) os_bswap_16(x)



#define htole16(x) ((uint16_t)(x))



#define be16toh(x) os_bswap_16(x)



#define le16toh(x) ((uint16_t)(x))



#define htobe32(x) os_bswap_32(x)



#define htole32(x) ((uint32_t)(x))



#define be32toh(x) os_bswap_32(x)



#define le32toh(x) ((uint32_t)(x))



#define htobe64(x) os_bswap_64(x)



#define htole64(x) ((uint64_t)(x))



#define be64toh(x) os_bswap_64(x)



#define le64toh(x) ((uint64_t)(x))




void put_le16(void *buf, uint16_t x);
void put_le32(void *buf, uint32_t x);
void put_le64(void *buf, uint64_t x);
uint16_t get_le16(const void *buf);
uint32_t get_le32(const void *buf);
uint64_t get_le64(const void *buf);
void put_be16(void *buf, uint16_t x);
void put_be32(void *buf, uint32_t x);
void put_be64(void *buf, uint64_t x);
uint16_t get_be16(const void *buf);
uint32_t get_be32(const void *buf);
uint64_t get_be64(const void *buf);
void swap_in_place(void *buf, int len);
void swap_buf(uint8_t *dst, const uint8_t *src, int len);
# 122 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_callout.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#define _OS_CALLOUT_H 

/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSCallouts 
 *   @{
 */






# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSEvent Event Queues
 *   @{
 */


#define _OS_EVENTQ_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 32 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 2
# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*-
 * Copyright (c) 1982, 1986, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)time.h      8.5 (Berkeley) 5/4/95
 * $FreeBSD$
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSTime Time
 *   @{
 */


#define _OS_TIME_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 64 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 2

# 1 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h" 1

# 1 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h"
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _OS_ARCH_ARM_H 


# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 25 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h" 2
# 1 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/include/mcu/cmsis_nvic.h" 1
/* mbed Microcontroller Library - cmsis_nvic
 * Copyright (c) 2009-2011 ARM Limited. All rights reserved.
 *
 * CMSIS-style functionality to support dynamic vectors
 */


#define MBED_CMSIS_NVIC_H 



#define NVIC_USER_IRQ_OFFSET 16
#define NVIC_NUM_VECTORS (NVIC_USER_IRQ_OFFSET + 43)

# 1 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h" 1
/**

  ******************************************************************************

  * @file    stm32f1xx.h

  * @author  MCD Application Team

  * @version V4.2.0

  * @date    31-March-2017

  * @brief   CMSIS STM32F1xx Device Peripheral Access Layer Header File. 

  *

  *          The file is the unique include file that the application programmer

  *          is using in the C source code, usually in main.c. This file contains:

  *            - Configuration section that allows to select:

  *              - The STM32F1xx device used in the target application

  *              - To use or not the peripherals drivers in application code(i.e. 

  *                code will be based on direct access to peripherals registers 

  *                rather than drivers API), this option is controlled by 

  *                "#define USE_HAL_DRIVER"

  *  

  ******************************************************************************

  * @attention

  *

  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>

  *

  * Redistribution and use in source and binary forms, with or without modification,

  * are permitted provided that the following conditions are met:

  *   1. Redistributions of source code must retain the above copyright notice,

  *      this list of conditions and the following disclaimer.

  *   2. Redistributions in binary form must reproduce the above copyright notice,

  *      this list of conditions and the following disclaimer in the documentation

  *      and/or other materials provided with the distribution.

  *   3. Neither the name of STMicroelectronics nor the names of its contributors

  *      may be used to endorse or promote products derived from this software

  *      without specific prior written permission.

  *

  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE

  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR

  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER

  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,

  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  *

  ******************************************************************************

  */
# 48 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/** @addtogroup CMSIS

  * @{

  */
# 52 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/** @addtogroup stm32f1xx

  * @{

  */
#define __STM32F1XX_H 





/** @addtogroup Library_configuration_section

  * @{

  */
# 67 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/**

  * @brief STM32 Family

  */
# 71 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
#define STM32F1 


/* Uncomment the line below according to the target STM32L device used in your 

   application 

  */
# 97 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/*  Tip: To avoid modifying this file each time you need to switch between these

        devices, you can define the device in your toolchain compiler preprocessor.

  */
/**

 * @brief Comment the line below if you will not use the peripherals drivers.

   In this case, these drivers will not be included and the application code will 

   be based on direct access to peripherals registers 

   */
# 107 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
  /*#define USE_HAL_DRIVER */


/**

  * @brief CMSIS Device version number V4.2.0

  */
# 113 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
#define __STM32F1_CMSIS_VERSION_MAIN (0x04) /*!< [31:24] main version */
#define __STM32F1_CMSIS_VERSION_SUB1 (0x02) /*!< [23:16] sub1 version */
#define __STM32F1_CMSIS_VERSION_SUB2 (0x00) /*!< [15:8]  sub2 version */
#define __STM32F1_CMSIS_VERSION_RC (0x00) /*!< [7:0]  release candidate */
#define __STM32F1_CMSIS_VERSION ((__STM32F1_CMSIS_VERSION_MAIN << 24) |(__STM32F1_CMSIS_VERSION_SUB1 << 16) |(__STM32F1_CMSIS_VERSION_SUB2 << 8 ) |(__STM32F1_CMSIS_VERSION_RC))




/**

  * @}

  */
# 126 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/** @addtogroup Device_Included

  * @{

  */
# 149 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
# 1 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h" 1
/**

  ******************************************************************************

  * @file    stm32f103xb.h

  * @author  MCD Application Team

  * @version V4.2.0

  * @date    31-March-2017

  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File. 

  *          This file contains all the peripheral register's definitions, bits 

  *          definitions and memory mapping for STM32F1xx devices.            

  *            

  *          This file contains:

  *           - Data structures and the address mapping for all peripherals

  *           - Peripheral's registers declarations and bits definition

  *           - Macros to access peripherals registers hardware

  *  

  ******************************************************************************

  * @attention

  *

  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>

  *

  * Redistribution and use in source and binary forms, with or without modification,

  * are permitted provided that the following conditions are met:

  *   1. Redistributions of source code must retain the above copyright notice,

  *      this list of conditions and the following disclaimer.

  *   2. Redistributions in binary form must reproduce the above copyright notice,

  *      this list of conditions and the following disclaimer in the documentation

  *      and/or other materials provided with the distribution.

  *   3. Neither the name of STMicroelectronics nor the names of its contributors

  *      may be used to endorse or promote products derived from this software

  *      without specific prior written permission.

  *

  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE

  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR

  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER

  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,

  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  *

  ******************************************************************************

  */
# 47 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup CMSIS

  * @{

  */
# 51 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup stm32f103xb

  * @{

  */
#define __STM32F103xB_H 





/** @addtogroup Configuration_section_for_CMSIS

  * @{

  */
# 65 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/**

  * @brief Configuration of the Cortex-M3 Processor and Core Peripherals 

 */
# 68 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
#define __CM3_REV 0x0200U /*!< Core Revision r2p0                           */
#define __MPU_PRESENT 0U /*!< Other STM32 devices does not provide an MPU  */
#define __NVIC_PRIO_BITS 4U /*!< STM32 uses 4 Bits for the Priority Levels    */
#define __Vendor_SysTickConfig 0U /*!< Set to 1 if different SysTick Config is used */

/**

  * @}

  */
# 77 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup Peripheral_interrupt_number_definition

  * @{

  */
# 81 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/**

 * @brief STM32F10x Interrupt Number Definition, according to the selected device 

 *        in @ref Library_configuration_section 

 */
# 86 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 /*!< Interrupt Number Definition */
typedef enum
{
/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
  NonMaskableInt_IRQn = -14, /*!< 2 Non Maskable Interrupt                             */
  HardFault_IRQn = -13, /*!< 3 Cortex-M3 Hard Fault Interrupt                     */
  MemoryManagement_IRQn = -12, /*!< 4 Cortex-M3 Memory Management Interrupt              */
  BusFault_IRQn = -11, /*!< 5 Cortex-M3 Bus Fault Interrupt                      */
  UsageFault_IRQn = -10, /*!< 6 Cortex-M3 Usage Fault Interrupt                    */
  SVCall_IRQn = -5, /*!< 11 Cortex-M3 SV Call Interrupt                       */
  DebugMonitor_IRQn = -4, /*!< 12 Cortex-M3 Debug Monitor Interrupt                 */
  PendSV_IRQn = -2, /*!< 14 Cortex-M3 Pend SV Interrupt                       */
  SysTick_IRQn = -1, /*!< 15 Cortex-M3 System Tick Interrupt                   */

/******  STM32 specific Interrupt Numbers *********************************************************/
  WWDG_IRQn = 0, /*!< Window WatchDog Interrupt                            */
  PVD_IRQn = 1, /*!< PVD through EXTI Line detection Interrupt            */
  TAMPER_IRQn = 2, /*!< Tamper Interrupt                                     */
  RTC_IRQn = 3, /*!< RTC global Interrupt                                 */
  FLASH_IRQn = 4, /*!< FLASH global Interrupt                               */
  RCC_IRQn = 5, /*!< RCC global Interrupt                                 */
  EXTI0_IRQn = 6, /*!< EXTI Line0 Interrupt                                 */
  EXTI1_IRQn = 7, /*!< EXTI Line1 Interrupt                                 */
  EXTI2_IRQn = 8, /*!< EXTI Line2 Interrupt                                 */
  EXTI3_IRQn = 9, /*!< EXTI Line3 Interrupt                                 */
  EXTI4_IRQn = 10, /*!< EXTI Line4 Interrupt                                 */
  DMA1_Channel1_IRQn = 11, /*!< DMA1 Channel 1 global Interrupt                      */
  DMA1_Channel2_IRQn = 12, /*!< DMA1 Channel 2 global Interrupt                      */
  DMA1_Channel3_IRQn = 13, /*!< DMA1 Channel 3 global Interrupt                      */
  DMA1_Channel4_IRQn = 14, /*!< DMA1 Channel 4 global Interrupt                      */
  DMA1_Channel5_IRQn = 15, /*!< DMA1 Channel 5 global Interrupt                      */
  DMA1_Channel6_IRQn = 16, /*!< DMA1 Channel 6 global Interrupt                      */
  DMA1_Channel7_IRQn = 17, /*!< DMA1 Channel 7 global Interrupt                      */
  ADC1_2_IRQn = 18, /*!< ADC1 and ADC2 global Interrupt                       */
  USB_HP_CAN1_TX_IRQn = 19, /*!< USB Device High Priority or CAN1 TX Interrupts       */
  USB_LP_CAN1_RX0_IRQn = 20, /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
  CAN1_RX1_IRQn = 21, /*!< CAN1 RX1 Interrupt                                   */
  CAN1_SCE_IRQn = 22, /*!< CAN1 SCE Interrupt                                   */
  EXTI9_5_IRQn = 23, /*!< External Line[9:5] Interrupts                        */
  TIM1_BRK_IRQn = 24, /*!< TIM1 Break Interrupt                                 */
  TIM1_UP_IRQn = 25, /*!< TIM1 Update Interrupt                                */
  TIM1_TRG_COM_IRQn = 26, /*!< TIM1 Trigger and Commutation Interrupt               */
  TIM1_CC_IRQn = 27, /*!< TIM1 Capture Compare Interrupt                       */
  TIM2_IRQn = 28, /*!< TIM2 global Interrupt                                */
  TIM3_IRQn = 29, /*!< TIM3 global Interrupt                                */
  TIM4_IRQn = 30, /*!< TIM4 global Interrupt                                */
  I2C1_EV_IRQn = 31, /*!< I2C1 Event Interrupt                                 */
  I2C1_ER_IRQn = 32, /*!< I2C1 Error Interrupt                                 */
  I2C2_EV_IRQn = 33, /*!< I2C2 Event Interrupt                                 */
  I2C2_ER_IRQn = 34, /*!< I2C2 Error Interrupt                                 */
  SPI1_IRQn = 35, /*!< SPI1 global Interrupt                                */
  SPI2_IRQn = 36, /*!< SPI2 global Interrupt                                */
  USART1_IRQn = 37, /*!< USART1 global Interrupt                              */
  USART2_IRQn = 38, /*!< USART2 global Interrupt                              */
  USART3_IRQn = 39, /*!< USART3 global Interrupt                              */
  EXTI15_10_IRQn = 40, /*!< External Line[15:10] Interrupts                      */
  RTC_Alarm_IRQn = 41, /*!< RTC Alarm through EXTI Line Interrupt                */
  USBWakeUp_IRQn = 42, /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */
} IRQn_Type;

/**

  * @}

  */
# 150 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
# 1 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h" 1
/**************************************************************************//**
 * @file     core_cm3.h
 * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
 * @version  V5.1.0
 * @date     13. March 2019
 ******************************************************************************/
/*
 * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
# 32 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
#define __CORE_CM3_H_GENERIC 







/**
  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  CMSIS violates the following MISRA-C:2004 rules:

   \li Required Rule 8.5, object/function definition in header file.<br>
     Function definitions in header files are used to allow 'inlining'.

   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
     Unions are used for effective representation of core registers.

   \li Advisory Rule 19.7, Function-like macro defined.<br>
     Function-like macros are used to allow more efficient code.
 */


/*******************************************************************************
 *                 CMSIS definitions
 ******************************************************************************/
/**
  \ingroup Cortex_M3
  @{
 */

# 1 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_version.h" 1
/**************************************************************************//**
 * @file     cmsis_version.h
 * @brief    CMSIS Core(M) Version definitions
 * @version  V5.0.2
 * @date     19. April 2017
 ******************************************************************************/
/*
 * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
# 32 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_version.h"
#define __CMSIS_VERSION_H 

/*  CMSIS Version definitions */
#define __CM_CMSIS_VERSION_MAIN ( 5U) /*!< [31:16] CMSIS Core(M) main version */
#define __CM_CMSIS_VERSION_SUB ( 1U) /*!< [15:0]  CMSIS Core(M) sub version */
#define __CM_CMSIS_VERSION ((__CM_CMSIS_VERSION_MAIN << 16U) | __CM_CMSIS_VERSION_SUB ) /*!< CMSIS Core(M) version number */
# 64 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h" 2

/*  CMSIS CM3 definitions */
#define __CM3_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN) /*!< \deprecated [31:16] CMSIS HAL main version */
#define __CM3_CMSIS_VERSION_SUB (__CM_CMSIS_VERSION_SUB) /*!< \deprecated [15:0]  CMSIS HAL sub version */
#define __CM3_CMSIS_VERSION ((__CM3_CMSIS_VERSION_MAIN << 16U) | __CM3_CMSIS_VERSION_SUB ) /*!< \deprecated CMSIS HAL version number */


#define __CORTEX_M (3U) /*!< Cortex-M Core */

/** __FPU_USED indicates whether an FPU is used or not.
    This core does not support an FPU at all
*/
#define __FPU_USED 0U
# 115 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
# 1 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_compiler.h" 1
/**************************************************************************//**
 * @file     cmsis_compiler.h
 * @brief    CMSIS compiler generic header file
 * @version  V5.1.0
 * @date     09. October 2018
 ******************************************************************************/
/*
 * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#define __CMSIS_COMPILER_H 



/*
 * Arm Compiler 4/5
 */
# 54 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_compiler.h"
# 1 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h" 1
/**************************************************************************//**
 * @file     cmsis_gcc.h
 * @brief    CMSIS compiler GCC header file
 * @version  V5.1.0
 * @date     20. December 2018
 ******************************************************************************/
/*
 * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#define __CMSIS_GCC_H 

/* ignore some GCC warnings */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-conversion"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wunused-parameter"

/* Fallback for __has_builtin */

#define __has_builtin(x) (0)


/* CMSIS compiler specific defines */

#define __ASM __asm


#define __INLINE inline


#define __STATIC_INLINE static inline


#define __STATIC_FORCEINLINE __attribute__((always_inline)) static inline


#define __NO_RETURN __attribute__((__noreturn__))


#define __USED __attribute__((used))


#define __WEAK __attribute__((weak))


#define __PACKED __attribute__((packed, aligned(1)))


#define __PACKED_STRUCT struct __attribute__((packed, aligned(1)))


#define __PACKED_UNION union __attribute__((packed, aligned(1)))


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpacked"
#pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed)) T_UINT32 { uint32_t v; };
#pragma GCC diagnostic pop
#define __UNALIGNED_UINT32(x) (((struct T_UINT32 *)(x))->v)


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpacked"
#pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed, aligned(1))) T_UINT16_WRITE { uint16_t v; };
#pragma GCC diagnostic pop
#define __UNALIGNED_UINT16_WRITE(addr,val) (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpacked"
#pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed, aligned(1))) T_UINT16_READ { uint16_t v; };
#pragma GCC diagnostic pop
#define __UNALIGNED_UINT16_READ(addr) (((const struct T_UINT16_READ *)(const void *)(addr))->v)


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpacked"
#pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed, aligned(1))) T_UINT32_WRITE { uint32_t v; };
#pragma GCC diagnostic pop
#define __UNALIGNED_UINT32_WRITE(addr,val) (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpacked"
#pragma GCC diagnostic ignored "-Wattributes"
  struct __attribute__((packed, aligned(1))) T_UINT32_READ { uint32_t v; };
#pragma GCC diagnostic pop
#define __UNALIGNED_UINT32_READ(addr) (((const struct T_UINT32_READ *)(const void *)(addr))->v)


#define __ALIGNED(x) __attribute__((aligned(x)))


#define __RESTRICT __restrict



/* ###########################  Core Function Access  ########################### */
/** \ingroup  CMSIS_Core_FunctionInterface
    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  @{
 */

/**
  \brief   Enable IRQ Interrupts
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) static inline void __enable_irq(void)
{
  __asm volatile ("cpsie i" : : : "memory");
}


/**
  \brief   Disable IRQ Interrupts
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) static inline void __disable_irq(void)
{
  __asm volatile ("cpsid i" : : : "memory");
}


/**
  \brief   Get Control Register
  \details Returns the content of the Control Register.
  \return               Control Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, control" : "=r" (result) );
  return(result);
}
# 176 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Control Register
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__attribute__((always_inline)) static inline void __set_CONTROL(uint32_t control)
{
  __asm volatile ("MSR control, %0" : : "r" (control) : "memory");
}
# 200 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Get IPSR Register
  \details Returns the content of the IPSR Register.
  \return               IPSR Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_IPSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, ipsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get APSR Register
  \details Returns the content of the APSR Register.
  \return               APSR Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_APSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, apsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get xPSR Register
  \details Returns the content of the xPSR Register.
  \return               xPSR Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_xPSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, xpsr" : "=r" (result) );
  return(result);
}


/**
  \brief   Get Process Stack Pointer
  \details Returns the current value of the Process Stack Pointer (PSP).
  \return               PSP Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_PSP(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, psp" : "=r" (result) );
  return(result);
}
# 272 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Process Stack Pointer
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__((always_inline)) static inline void __set_PSP(uint32_t topOfProcStack)
{
  __asm volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
}
# 296 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Get Main Stack Pointer
  \details Returns the current value of the Main Stack Pointer (MSP).
  \return               MSP Register value
 */
__attribute__((always_inline)) static inline uint32_t __get_MSP(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, msp" : "=r" (result) );
  return(result);
}
# 326 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Main Stack Pointer
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__((always_inline)) static inline void __set_MSP(uint32_t topOfMainStack)
{
  __asm volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
}
# 377 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Get Priority Mask
  \details Returns the current state of the priority mask bit from the Priority Mask Register.
  \return               Priority Mask value
 */
__attribute__((always_inline)) static inline uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  return(result);
}
# 407 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Priority Mask
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__attribute__((always_inline)) static inline void __set_PRIMASK(uint32_t priMask)
{
  __asm volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
}
# 434 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Enable FIQ
  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) static inline void __enable_fault_irq(void)
{
  __asm volatile ("cpsie f" : : : "memory");
}


/**
  \brief   Disable FIQ
  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) static inline void __disable_fault_irq(void)
{
  __asm volatile ("cpsid f" : : : "memory");
}


/**
  \brief   Get Base Priority
  \details Returns the current value of the Base Priority register.
  \return               Base Priority register value
 */
__attribute__((always_inline)) static inline uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, basepri" : "=r" (result) );
  return(result);
}
# 486 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Base Priority
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) static inline void __set_BASEPRI(uint32_t basePri)
{
  __asm volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
}
# 510 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Base Priority with condition
  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
           or the new value increases the BASEPRI priority level.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__((always_inline)) static inline void __set_BASEPRI_MAX(uint32_t basePri)
{
  __asm volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
}


/**
  \brief   Get Fault Mask
  \details Returns the current value of the Fault Mask register.
  \return               Fault Mask register value
 */
__attribute__((always_inline)) static inline uint32_t __get_FAULTMASK(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, faultmask" : "=r" (result) );
  return(result);
}
# 552 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Set Fault Mask
  \details Assigns the given value to the Fault Mask register.
  \param [in]    faultMask  Fault Mask value to set
 */
__attribute__((always_inline)) static inline void __set_FAULTMASK(uint32_t faultMask)
{
  __asm volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
}
# 761 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Get FPSCR
  \details Returns the current value of the Floating Point Status/Control register.
  \return               Floating Point Status/Control register value
 */
__attribute__((always_inline)) static inline uint32_t __get_FPSCR(void)
{
# 782 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
  return(0U);

}


/**
  \brief   Set FPSCR
  \details Assigns the given value to the Floating Point Status/Control register.
  \param [in]    fpscr  Floating Point Status/Control value to set
 */
__attribute__((always_inline)) static inline void __set_FPSCR(uint32_t fpscr)
{
# 805 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
  (void)fpscr;

}


/*@} end of CMSIS_Core_RegAccFunctions */


/* ##########################  Core Instruction Access  ######################### */
/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  Access to dedicated instructions
  @{
*/

/* Define macros for porting to both thumb1 and thumb2.
 * For thumb1, use low register (r0-r7), specified by constraint "l"
 * Otherwise, use general registers, specified by constraint "r" */





#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
#define __CMSIS_GCC_RW_REG(r) "+r" (r)
#define __CMSIS_GCC_USE_REG(r) "r" (r)


/**
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
#define __NOP() __ASM volatile ("nop")

/**
  \brief   Wait For Interrupt
  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
 */
#define __WFI() __ASM volatile ("wfi")


/**
  \brief   Wait For Event
  \details Wait For Event is a hint instruction that permits the processor to enter
           a low-power state until one of a number of events occurs.
 */
#define __WFE() __ASM volatile ("wfe")


/**
  \brief   Send Event
  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 */
#define __SEV() __ASM volatile ("sev")


/**
  \brief   Instruction Synchronization Barrier
  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) static inline void __ISB(void)
{
  __asm volatile ("isb 0xF":::"memory");
}


/**
  \brief   Data Synchronization Barrier
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) static inline void __DSB(void)
{
  __asm volatile ("dsb 0xF":::"memory");
}


/**
  \brief   Data Memory Barrier
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) static inline void __DMB(void)
{
  __asm volatile ("dmb 0xF":::"memory");
}


/**
  \brief   Reverse byte order (32 bit)
  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline uint32_t __REV(uint32_t value)
{

  return __builtin_bswap32(value);






}


/**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline uint32_t __REV16(uint32_t value)
{
  uint32_t result;

  __asm volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
  return result;
}


/**
  \brief   Reverse byte order (16 bit)
  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline int16_t __REVSH(int16_t value)
{

  return (int16_t)__builtin_bswap16(value);






}


/**
  \brief   Rotate Right in unsigned value (32 bit)
  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
  \param [in]    op1  Value to rotate
  \param [in]    op2  Number of Bits to rotate
  \return               Rotated value
 */
__attribute__((always_inline)) static inline uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  op2 %= 32U;
  if (op2 == 0U)
  {
    return op1;
  }
  return (op1 >> op2) | (op1 << (32U - op2));
}


/**
  \brief   Breakpoint
  \details Causes the processor to enter Debug state.
           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
  \param [in]    value  is ignored by the processor.
                 If required, a debugger can use it to store additional information about the breakpoint.
 */
#define __BKPT(value) __ASM volatile ("bkpt "#value)


/**
  \brief   Reverse bit order of value
  \details Reverses the bit order of the given value.
  \param [in]    value  Value to reverse
  \return               Reversed value
 */
__attribute__((always_inline)) static inline uint32_t __RBIT(uint32_t value)
{
  uint32_t result;




   __asm volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
# 1001 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
  return result;
}


/**
  \brief   Count leading zeros
  \details Counts the number of leading zeros of a data value.
  \param [in]  value  Value to count the leading zeros
  \return             number of leading zeros in value
 */
__attribute__((always_inline)) static inline uint8_t __CLZ(uint32_t value)
{
  /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
     __builtin_clz(0) is undefined behaviour, so handle this case specially.
     This guarantees ARM-compatible results if happening to compile on a non-ARM
     target, and ensures the compiler doesn't decide to activate any
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
}






/**
  \brief   LDR Exclusive (8 bit)
  \details Executes a exclusive LDR instruction for 8 bit value.
  \param [in]    ptr  Pointer to data
  \return             value of type uint8_t at (*ptr)
 */
__attribute__((always_inline)) static inline uint8_t __LDREXB(volatile uint8_t *addr)
{
    uint32_t result;


   __asm volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );






   return ((uint8_t) result); /* Add explicit type cast here */
}


/**
  \brief   LDR Exclusive (16 bit)
  \details Executes a exclusive LDR instruction for 16 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint16_t at (*ptr)
 */
__attribute__((always_inline)) static inline uint16_t __LDREXH(volatile uint16_t *addr)
{
    uint32_t result;


   __asm volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );






   return ((uint16_t) result); /* Add explicit type cast here */
}


/**
  \brief   LDR Exclusive (32 bit)
  \details Executes a exclusive LDR instruction for 32 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint32_t at (*ptr)
 */
__attribute__((always_inline)) static inline uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __asm volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
   return(result);
}


/**
  \brief   STR Exclusive (8 bit)
  \details Executes a exclusive STR instruction for 8 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 */
__attribute__((always_inline)) static inline uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
{
   uint32_t result;

   __asm volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
   return(result);
}


/**
  \brief   STR Exclusive (16 bit)
  \details Executes a exclusive STR instruction for 16 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 */
__attribute__((always_inline)) static inline uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
{
   uint32_t result;

   __asm volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
   return(result);
}


/**
  \brief   STR Exclusive (32 bit)
  \details Executes a exclusive STR instruction for 32 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
  \return          0  Function succeeded
  \return          1  Function failed
 */
__attribute__((always_inline)) static inline uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __asm volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
   return(result);
}


/**
  \brief   Remove the exclusive lock
  \details Removes the exclusive lock which is created by LDREX.
 */
__attribute__((always_inline)) static inline void __CLREX(void)
{
  __asm volatile ("clrex" ::: "memory");
}
# 1162 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Signed Saturate
  \details Saturates a signed value.
  \param [in]  ARG1  Value to be saturated
  \param [in]  ARG2  Bit position to saturate to (1..32)
  \return             Saturated value
 */
#define __SSAT(ARG1,ARG2) __extension__ ({ int32_t __RES, __ARG1 = (ARG1); __ASM ("ssat %0, %1, %2" : "=r" (__RES) : "I" (ARG2), "r" (__ARG1) ); __RES; })
# 1178 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Unsigned Saturate
  \details Saturates an unsigned value.
  \param [in]  ARG1  Value to be saturated
  \param [in]  ARG2  Bit position to saturate to (0..31)
  \return             Saturated value
 */
#define __USAT(ARG1,ARG2) __extension__ ({ uint32_t __RES, __ARG1 = (ARG1); __ASM ("usat %0, %1, %2" : "=r" (__RES) : "I" (ARG2), "r" (__ARG1) ); __RES; })
# 1194 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/**
  \brief   Rotate Right with Extend (32 bit)
  \details Moves each bit of a bitstring right by one bit.
           The carry input is shifted in at the left end of the bitstring.
  \param [in]    value  Value to rotate
  \return               Rotated value
 */
__attribute__((always_inline)) static inline uint32_t __RRX(uint32_t value)
{
  uint32_t result;

  __asm volatile ("rrx %0, %1" : "=r" (result) : "r" (value) );
  return(result);
}


/**
  \brief   LDRT Unprivileged (8 bit)
  \details Executes a Unprivileged LDRT instruction for 8 bit value.
  \param [in]    ptr  Pointer to data
  \return             value of type uint8_t at (*ptr)
 */
__attribute__((always_inline)) static inline uint8_t __LDRBT(volatile uint8_t *ptr)
{
    uint32_t result;


   __asm volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*ptr) );






   return ((uint8_t) result); /* Add explicit type cast here */
}


/**
  \brief   LDRT Unprivileged (16 bit)
  \details Executes a Unprivileged LDRT instruction for 16 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint16_t at (*ptr)
 */
__attribute__((always_inline)) static inline uint16_t __LDRHT(volatile uint16_t *ptr)
{
    uint32_t result;


   __asm volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*ptr) );






   return ((uint16_t) result); /* Add explicit type cast here */
}


/**
  \brief   LDRT Unprivileged (32 bit)
  \details Executes a Unprivileged LDRT instruction for 32 bit values.
  \param [in]    ptr  Pointer to data
  \return        value of type uint32_t at (*ptr)
 */
__attribute__((always_inline)) static inline uint32_t __LDRT(volatile uint32_t *ptr)
{
    uint32_t result;

   __asm volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*ptr) );
   return(result);
}


/**
  \brief   STRT Unprivileged (8 bit)
  \details Executes a Unprivileged STRT instruction for 8 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 */
__attribute__((always_inline)) static inline void __STRBT(uint8_t value, volatile uint8_t *ptr)
{
   __asm volatile ("strbt %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
}


/**
  \brief   STRT Unprivileged (16 bit)
  \details Executes a Unprivileged STRT instruction for 16 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 */
__attribute__((always_inline)) static inline void __STRHT(uint16_t value, volatile uint16_t *ptr)
{
   __asm volatile ("strht %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
}


/**
  \brief   STRT Unprivileged (32 bit)
  \details Executes a Unprivileged STRT instruction for 32 bit values.
  \param [in]  value  Value to store
  \param [in]    ptr  Pointer to location
 */
__attribute__((always_inline)) static inline void __STRT(uint32_t value, volatile uint32_t *ptr)
{
   __asm volatile ("strt %1, %0" : "=Q" (*ptr) : "r" (value) );
}
# 1543 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/*@}*/ /* end of group CMSIS_Core_InstructionInterface */


/* ###################  Compiler specific Intrinsics  ########################### */
/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
  Access to dedicated SIMD instructions
  @{
*/
# 2096 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_gcc.h"
/*@} end of group CMSIS_SIMD_intrinsics */


#pragma GCC diagnostic pop
# 55 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/cmsis_compiler.h" 2


/*
 * IAR Compiler
 */
# 116 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h" 2
# 127 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
#define __CORE_CM3_H_DEPENDANT 





/* check device defines and use defaults */
# 156 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
/* IO definitions (access restrictions to peripheral registers) */
/**
    \defgroup CMSIS_glob_defs CMSIS Global Defines

    <strong>IO Type Qualifiers</strong> are used
    \li to specify the access to peripheral variables.
    \li for automatic generation of peripheral register debug information.
*/



#define __I volatile const /*!< Defines 'read only' permissions */

#define __O volatile /*!< Defines 'write only' permissions */
#define __IO volatile /*!< Defines 'read / write' permissions */

/* following defines should be used for structure members */
#define __IM volatile const /*! Defines 'read only' structure member permissions */
#define __OM volatile /*! Defines 'write only' structure member permissions */
#define __IOM volatile /*! Defines 'read / write' structure member permissions */

/*@} end of group Cortex_M3 */



/*******************************************************************************
 *                 Register Abstraction
  Core Register contain:
  - Core Register
  - Core NVIC Register
  - Core SCB Register
  - Core SysTick Register
  - Core Debug Register
  - Core MPU Register
 ******************************************************************************/
/**
  \defgroup CMSIS_core_register Defines and Type Definitions
  \brief Type definitions and defines for Cortex-M processor based devices.
*/

/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_CORE  Status and Control Registers
  \brief      Core Register type definitions.
  @{
 */

/**
  \brief  Union type to access the Application Program Status Register (APSR).
 */
typedef union
{
  struct
  {
    uint32_t _reserved0:27; /*!< bit:  0..26  Reserved */
    uint32_t Q:1; /*!< bit:     27  Saturation condition flag */
    uint32_t V:1; /*!< bit:     28  Overflow condition code flag */
    uint32_t C:1; /*!< bit:     29  Carry condition code flag */
    uint32_t Z:1; /*!< bit:     30  Zero condition code flag */
    uint32_t N:1; /*!< bit:     31  Negative condition code flag */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} APSR_Type;

/* APSR Register Definitions */
#define APSR_N_Pos 31U /*!< APSR: N Position */
#define APSR_N_Msk (1UL << APSR_N_Pos) /*!< APSR: N Mask */

#define APSR_Z_Pos 30U /*!< APSR: Z Position */
#define APSR_Z_Msk (1UL << APSR_Z_Pos) /*!< APSR: Z Mask */

#define APSR_C_Pos 29U /*!< APSR: C Position */
#define APSR_C_Msk (1UL << APSR_C_Pos) /*!< APSR: C Mask */

#define APSR_V_Pos 28U /*!< APSR: V Position */
#define APSR_V_Msk (1UL << APSR_V_Pos) /*!< APSR: V Mask */

#define APSR_Q_Pos 27U /*!< APSR: Q Position */
#define APSR_Q_Msk (1UL << APSR_Q_Pos) /*!< APSR: Q Mask */


/**
  \brief  Union type to access the Interrupt Program Status Register (IPSR).
 */
typedef union
{
  struct
  {
    uint32_t ISR:9; /*!< bit:  0.. 8  Exception number */
    uint32_t _reserved0:23; /*!< bit:  9..31  Reserved */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} IPSR_Type;

/* IPSR Register Definitions */
#define IPSR_ISR_Pos 0U /*!< IPSR: ISR Position */
#define IPSR_ISR_Msk (0x1FFUL /*<< IPSR_ISR_Pos*/) /*!< IPSR: ISR Mask */


/**
  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 */
typedef union
{
  struct
  {
    uint32_t ISR:9; /*!< bit:  0.. 8  Exception number */
    uint32_t _reserved0:1; /*!< bit:      9  Reserved */
    uint32_t ICI_IT_1:6; /*!< bit: 10..15  ICI/IT part 1 */
    uint32_t _reserved1:8; /*!< bit: 16..23  Reserved */
    uint32_t T:1; /*!< bit:     24  Thumb bit */
    uint32_t ICI_IT_2:2; /*!< bit: 25..26  ICI/IT part 2 */
    uint32_t Q:1; /*!< bit:     27  Saturation condition flag */
    uint32_t V:1; /*!< bit:     28  Overflow condition code flag */
    uint32_t C:1; /*!< bit:     29  Carry condition code flag */
    uint32_t Z:1; /*!< bit:     30  Zero condition code flag */
    uint32_t N:1; /*!< bit:     31  Negative condition code flag */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} xPSR_Type;

/* xPSR Register Definitions */
#define xPSR_N_Pos 31U /*!< xPSR: N Position */
#define xPSR_N_Msk (1UL << xPSR_N_Pos) /*!< xPSR: N Mask */

#define xPSR_Z_Pos 30U /*!< xPSR: Z Position */
#define xPSR_Z_Msk (1UL << xPSR_Z_Pos) /*!< xPSR: Z Mask */

#define xPSR_C_Pos 29U /*!< xPSR: C Position */
#define xPSR_C_Msk (1UL << xPSR_C_Pos) /*!< xPSR: C Mask */

#define xPSR_V_Pos 28U /*!< xPSR: V Position */
#define xPSR_V_Msk (1UL << xPSR_V_Pos) /*!< xPSR: V Mask */

#define xPSR_Q_Pos 27U /*!< xPSR: Q Position */
#define xPSR_Q_Msk (1UL << xPSR_Q_Pos) /*!< xPSR: Q Mask */

#define xPSR_ICI_IT_2_Pos 25U /*!< xPSR: ICI/IT part 2 Position */
#define xPSR_ICI_IT_2_Msk (3UL << xPSR_ICI_IT_2_Pos) /*!< xPSR: ICI/IT part 2 Mask */

#define xPSR_T_Pos 24U /*!< xPSR: T Position */
#define xPSR_T_Msk (1UL << xPSR_T_Pos) /*!< xPSR: T Mask */

#define xPSR_ICI_IT_1_Pos 10U /*!< xPSR: ICI/IT part 1 Position */
#define xPSR_ICI_IT_1_Msk (0x3FUL << xPSR_ICI_IT_1_Pos) /*!< xPSR: ICI/IT part 1 Mask */

#define xPSR_ISR_Pos 0U /*!< xPSR: ISR Position */
#define xPSR_ISR_Msk (0x1FFUL /*<< xPSR_ISR_Pos*/) /*!< xPSR: ISR Mask */


/**
  \brief  Union type to access the Control Registers (CONTROL).
 */
typedef union
{
  struct
  {
    uint32_t nPRIV:1; /*!< bit:      0  Execution privilege in Thread mode */
    uint32_t SPSEL:1; /*!< bit:      1  Stack to be used */
    uint32_t _reserved1:30; /*!< bit:  2..31  Reserved */
  } b; /*!< Structure used for bit  access */
  uint32_t w; /*!< Type      used for word access */
} CONTROL_Type;

/* CONTROL Register Definitions */
#define CONTROL_SPSEL_Pos 1U /*!< CONTROL: SPSEL Position */
#define CONTROL_SPSEL_Msk (1UL << CONTROL_SPSEL_Pos) /*!< CONTROL: SPSEL Mask */

#define CONTROL_nPRIV_Pos 0U /*!< CONTROL: nPRIV Position */
#define CONTROL_nPRIV_Msk (1UL /*<< CONTROL_nPRIV_Pos*/) /*!< CONTROL: nPRIV Mask */

/*@} end of group CMSIS_CORE */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
  \brief      Type definitions for the NVIC Registers
  @{
 */

/**
  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 */
typedef struct
{
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ISER[8U]; /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
        uint32_t RESERVED0[24U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ICER[8U]; /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
        uint32_t RESERVED1[24U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ISPR[8U]; /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
        uint32_t RESERVED2[24U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ICPR[8U]; /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
        uint32_t RESERVED3[24U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t IABR[8U]; /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
        uint32_t RESERVED4[56U];
  volatile /*! Defines 'read / write' structure member permissions */ uint8_t IP[240U]; /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
        uint32_t RESERVED5[644U];
  volatile /*! Defines 'write only' structure member permissions */ uint32_t STIR; /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
} NVIC_Type;

/* Software Triggered Interrupt Register Definitions */
#define NVIC_STIR_INTID_Pos 0U /*!< STIR: INTLINESNUM Position */
#define NVIC_STIR_INTID_Msk (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/) /*!< STIR: INTLINESNUM Mask */

/*@} end of group CMSIS_NVIC */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCB     System Control Block (SCB)
  \brief    Type definitions for the System Control Block Registers
  @{
 */

/**
  \brief  Structure type to access the System Control Block (SCB).
 */
typedef struct
{
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t CPUID; /*!< Offset: 0x000 (R/ )  CPUID Base Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ICSR; /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t VTOR; /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t AIRCR; /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t SCR; /*!< Offset: 0x010 (R/W)  System Control Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CCR; /*!< Offset: 0x014 (R/W)  Configuration Control Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint8_t SHP[12U]; /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t SHCSR; /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CFSR; /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t HFSR; /*!< Offset: 0x02C (R/W)  HardFault Status Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t DFSR; /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t MMFAR; /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t BFAR; /*!< Offset: 0x038 (R/W)  BusFault Address Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t AFSR; /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PFR[2U]; /*!< Offset: 0x040 (R/ )  Processor Feature Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t DFR; /*!< Offset: 0x048 (R/ )  Debug Feature Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t ADR; /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t MMFR[4U]; /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t ISAR[5U]; /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
        uint32_t RESERVED0[5U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CPACR; /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
} SCB_Type;

/* SCB CPUID Register Definitions */
#define SCB_CPUID_IMPLEMENTER_Pos 24U /*!< SCB CPUID: IMPLEMENTER Position */
#define SCB_CPUID_IMPLEMENTER_Msk (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos) /*!< SCB CPUID: IMPLEMENTER Mask */

#define SCB_CPUID_VARIANT_Pos 20U /*!< SCB CPUID: VARIANT Position */
#define SCB_CPUID_VARIANT_Msk (0xFUL << SCB_CPUID_VARIANT_Pos) /*!< SCB CPUID: VARIANT Mask */

#define SCB_CPUID_ARCHITECTURE_Pos 16U /*!< SCB CPUID: ARCHITECTURE Position */
#define SCB_CPUID_ARCHITECTURE_Msk (0xFUL << SCB_CPUID_ARCHITECTURE_Pos) /*!< SCB CPUID: ARCHITECTURE Mask */

#define SCB_CPUID_PARTNO_Pos 4U /*!< SCB CPUID: PARTNO Position */
#define SCB_CPUID_PARTNO_Msk (0xFFFUL << SCB_CPUID_PARTNO_Pos) /*!< SCB CPUID: PARTNO Mask */

#define SCB_CPUID_REVISION_Pos 0U /*!< SCB CPUID: REVISION Position */
#define SCB_CPUID_REVISION_Msk (0xFUL /*<< SCB_CPUID_REVISION_Pos*/) /*!< SCB CPUID: REVISION Mask */

/* SCB Interrupt Control State Register Definitions */
#define SCB_ICSR_NMIPENDSET_Pos 31U /*!< SCB ICSR: NMIPENDSET Position */
#define SCB_ICSR_NMIPENDSET_Msk (1UL << SCB_ICSR_NMIPENDSET_Pos) /*!< SCB ICSR: NMIPENDSET Mask */

#define SCB_ICSR_PENDSVSET_Pos 28U /*!< SCB ICSR: PENDSVSET Position */
#define SCB_ICSR_PENDSVSET_Msk (1UL << SCB_ICSR_PENDSVSET_Pos) /*!< SCB ICSR: PENDSVSET Mask */

#define SCB_ICSR_PENDSVCLR_Pos 27U /*!< SCB ICSR: PENDSVCLR Position */
#define SCB_ICSR_PENDSVCLR_Msk (1UL << SCB_ICSR_PENDSVCLR_Pos) /*!< SCB ICSR: PENDSVCLR Mask */

#define SCB_ICSR_PENDSTSET_Pos 26U /*!< SCB ICSR: PENDSTSET Position */
#define SCB_ICSR_PENDSTSET_Msk (1UL << SCB_ICSR_PENDSTSET_Pos) /*!< SCB ICSR: PENDSTSET Mask */

#define SCB_ICSR_PENDSTCLR_Pos 25U /*!< SCB ICSR: PENDSTCLR Position */
#define SCB_ICSR_PENDSTCLR_Msk (1UL << SCB_ICSR_PENDSTCLR_Pos) /*!< SCB ICSR: PENDSTCLR Mask */

#define SCB_ICSR_ISRPREEMPT_Pos 23U /*!< SCB ICSR: ISRPREEMPT Position */
#define SCB_ICSR_ISRPREEMPT_Msk (1UL << SCB_ICSR_ISRPREEMPT_Pos) /*!< SCB ICSR: ISRPREEMPT Mask */

#define SCB_ICSR_ISRPENDING_Pos 22U /*!< SCB ICSR: ISRPENDING Position */
#define SCB_ICSR_ISRPENDING_Msk (1UL << SCB_ICSR_ISRPENDING_Pos) /*!< SCB ICSR: ISRPENDING Mask */

#define SCB_ICSR_VECTPENDING_Pos 12U /*!< SCB ICSR: VECTPENDING Position */
#define SCB_ICSR_VECTPENDING_Msk (0x1FFUL << SCB_ICSR_VECTPENDING_Pos) /*!< SCB ICSR: VECTPENDING Mask */

#define SCB_ICSR_RETTOBASE_Pos 11U /*!< SCB ICSR: RETTOBASE Position */
#define SCB_ICSR_RETTOBASE_Msk (1UL << SCB_ICSR_RETTOBASE_Pos) /*!< SCB ICSR: RETTOBASE Mask */

#define SCB_ICSR_VECTACTIVE_Pos 0U /*!< SCB ICSR: VECTACTIVE Position */
#define SCB_ICSR_VECTACTIVE_Msk (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/) /*!< SCB ICSR: VECTACTIVE Mask */

/* SCB Vector Table Offset Register Definitions */

#define SCB_VTOR_TBLBASE_Pos 29U /*!< SCB VTOR: TBLBASE Position */
#define SCB_VTOR_TBLBASE_Msk (1UL << SCB_VTOR_TBLBASE_Pos) /*!< SCB VTOR: TBLBASE Mask */

#define SCB_VTOR_TBLOFF_Pos 7U /*!< SCB VTOR: TBLOFF Position */
#define SCB_VTOR_TBLOFF_Msk (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos) /*!< SCB VTOR: TBLOFF Mask */





/* SCB Application Interrupt and Reset Control Register Definitions */
#define SCB_AIRCR_VECTKEY_Pos 16U /*!< SCB AIRCR: VECTKEY Position */
#define SCB_AIRCR_VECTKEY_Msk (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos) /*!< SCB AIRCR: VECTKEY Mask */

#define SCB_AIRCR_VECTKEYSTAT_Pos 16U /*!< SCB AIRCR: VECTKEYSTAT Position */
#define SCB_AIRCR_VECTKEYSTAT_Msk (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos) /*!< SCB AIRCR: VECTKEYSTAT Mask */

#define SCB_AIRCR_ENDIANESS_Pos 15U /*!< SCB AIRCR: ENDIANESS Position */
#define SCB_AIRCR_ENDIANESS_Msk (1UL << SCB_AIRCR_ENDIANESS_Pos) /*!< SCB AIRCR: ENDIANESS Mask */

#define SCB_AIRCR_PRIGROUP_Pos 8U /*!< SCB AIRCR: PRIGROUP Position */
#define SCB_AIRCR_PRIGROUP_Msk (7UL << SCB_AIRCR_PRIGROUP_Pos) /*!< SCB AIRCR: PRIGROUP Mask */

#define SCB_AIRCR_SYSRESETREQ_Pos 2U /*!< SCB AIRCR: SYSRESETREQ Position */
#define SCB_AIRCR_SYSRESETREQ_Msk (1UL << SCB_AIRCR_SYSRESETREQ_Pos) /*!< SCB AIRCR: SYSRESETREQ Mask */

#define SCB_AIRCR_VECTCLRACTIVE_Pos 1U /*!< SCB AIRCR: VECTCLRACTIVE Position */
#define SCB_AIRCR_VECTCLRACTIVE_Msk (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos) /*!< SCB AIRCR: VECTCLRACTIVE Mask */

#define SCB_AIRCR_VECTRESET_Pos 0U /*!< SCB AIRCR: VECTRESET Position */
#define SCB_AIRCR_VECTRESET_Msk (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/) /*!< SCB AIRCR: VECTRESET Mask */

/* SCB System Control Register Definitions */
#define SCB_SCR_SEVONPEND_Pos 4U /*!< SCB SCR: SEVONPEND Position */
#define SCB_SCR_SEVONPEND_Msk (1UL << SCB_SCR_SEVONPEND_Pos) /*!< SCB SCR: SEVONPEND Mask */

#define SCB_SCR_SLEEPDEEP_Pos 2U /*!< SCB SCR: SLEEPDEEP Position */
#define SCB_SCR_SLEEPDEEP_Msk (1UL << SCB_SCR_SLEEPDEEP_Pos) /*!< SCB SCR: SLEEPDEEP Mask */

#define SCB_SCR_SLEEPONEXIT_Pos 1U /*!< SCB SCR: SLEEPONEXIT Position */
#define SCB_SCR_SLEEPONEXIT_Msk (1UL << SCB_SCR_SLEEPONEXIT_Pos) /*!< SCB SCR: SLEEPONEXIT Mask */

/* SCB Configuration Control Register Definitions */
#define SCB_CCR_STKALIGN_Pos 9U /*!< SCB CCR: STKALIGN Position */
#define SCB_CCR_STKALIGN_Msk (1UL << SCB_CCR_STKALIGN_Pos) /*!< SCB CCR: STKALIGN Mask */

#define SCB_CCR_BFHFNMIGN_Pos 8U /*!< SCB CCR: BFHFNMIGN Position */
#define SCB_CCR_BFHFNMIGN_Msk (1UL << SCB_CCR_BFHFNMIGN_Pos) /*!< SCB CCR: BFHFNMIGN Mask */

#define SCB_CCR_DIV_0_TRP_Pos 4U /*!< SCB CCR: DIV_0_TRP Position */
#define SCB_CCR_DIV_0_TRP_Msk (1UL << SCB_CCR_DIV_0_TRP_Pos) /*!< SCB CCR: DIV_0_TRP Mask */

#define SCB_CCR_UNALIGN_TRP_Pos 3U /*!< SCB CCR: UNALIGN_TRP Position */
#define SCB_CCR_UNALIGN_TRP_Msk (1UL << SCB_CCR_UNALIGN_TRP_Pos) /*!< SCB CCR: UNALIGN_TRP Mask */

#define SCB_CCR_USERSETMPEND_Pos 1U /*!< SCB CCR: USERSETMPEND Position */
#define SCB_CCR_USERSETMPEND_Msk (1UL << SCB_CCR_USERSETMPEND_Pos) /*!< SCB CCR: USERSETMPEND Mask */

#define SCB_CCR_NONBASETHRDENA_Pos 0U /*!< SCB CCR: NONBASETHRDENA Position */
#define SCB_CCR_NONBASETHRDENA_Msk (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/) /*!< SCB CCR: NONBASETHRDENA Mask */

/* SCB System Handler Control and State Register Definitions */
#define SCB_SHCSR_USGFAULTENA_Pos 18U /*!< SCB SHCSR: USGFAULTENA Position */
#define SCB_SHCSR_USGFAULTENA_Msk (1UL << SCB_SHCSR_USGFAULTENA_Pos) /*!< SCB SHCSR: USGFAULTENA Mask */

#define SCB_SHCSR_BUSFAULTENA_Pos 17U /*!< SCB SHCSR: BUSFAULTENA Position */
#define SCB_SHCSR_BUSFAULTENA_Msk (1UL << SCB_SHCSR_BUSFAULTENA_Pos) /*!< SCB SHCSR: BUSFAULTENA Mask */

#define SCB_SHCSR_MEMFAULTENA_Pos 16U /*!< SCB SHCSR: MEMFAULTENA Position */
#define SCB_SHCSR_MEMFAULTENA_Msk (1UL << SCB_SHCSR_MEMFAULTENA_Pos) /*!< SCB SHCSR: MEMFAULTENA Mask */

#define SCB_SHCSR_SVCALLPENDED_Pos 15U /*!< SCB SHCSR: SVCALLPENDED Position */
#define SCB_SHCSR_SVCALLPENDED_Msk (1UL << SCB_SHCSR_SVCALLPENDED_Pos) /*!< SCB SHCSR: SVCALLPENDED Mask */

#define SCB_SHCSR_BUSFAULTPENDED_Pos 14U /*!< SCB SHCSR: BUSFAULTPENDED Position */
#define SCB_SHCSR_BUSFAULTPENDED_Msk (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos) /*!< SCB SHCSR: BUSFAULTPENDED Mask */

#define SCB_SHCSR_MEMFAULTPENDED_Pos 13U /*!< SCB SHCSR: MEMFAULTPENDED Position */
#define SCB_SHCSR_MEMFAULTPENDED_Msk (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos) /*!< SCB SHCSR: MEMFAULTPENDED Mask */

#define SCB_SHCSR_USGFAULTPENDED_Pos 12U /*!< SCB SHCSR: USGFAULTPENDED Position */
#define SCB_SHCSR_USGFAULTPENDED_Msk (1UL << SCB_SHCSR_USGFAULTPENDED_Pos) /*!< SCB SHCSR: USGFAULTPENDED Mask */

#define SCB_SHCSR_SYSTICKACT_Pos 11U /*!< SCB SHCSR: SYSTICKACT Position */
#define SCB_SHCSR_SYSTICKACT_Msk (1UL << SCB_SHCSR_SYSTICKACT_Pos) /*!< SCB SHCSR: SYSTICKACT Mask */

#define SCB_SHCSR_PENDSVACT_Pos 10U /*!< SCB SHCSR: PENDSVACT Position */
#define SCB_SHCSR_PENDSVACT_Msk (1UL << SCB_SHCSR_PENDSVACT_Pos) /*!< SCB SHCSR: PENDSVACT Mask */

#define SCB_SHCSR_MONITORACT_Pos 8U /*!< SCB SHCSR: MONITORACT Position */
#define SCB_SHCSR_MONITORACT_Msk (1UL << SCB_SHCSR_MONITORACT_Pos) /*!< SCB SHCSR: MONITORACT Mask */

#define SCB_SHCSR_SVCALLACT_Pos 7U /*!< SCB SHCSR: SVCALLACT Position */
#define SCB_SHCSR_SVCALLACT_Msk (1UL << SCB_SHCSR_SVCALLACT_Pos) /*!< SCB SHCSR: SVCALLACT Mask */

#define SCB_SHCSR_USGFAULTACT_Pos 3U /*!< SCB SHCSR: USGFAULTACT Position */
#define SCB_SHCSR_USGFAULTACT_Msk (1UL << SCB_SHCSR_USGFAULTACT_Pos) /*!< SCB SHCSR: USGFAULTACT Mask */

#define SCB_SHCSR_BUSFAULTACT_Pos 1U /*!< SCB SHCSR: BUSFAULTACT Position */
#define SCB_SHCSR_BUSFAULTACT_Msk (1UL << SCB_SHCSR_BUSFAULTACT_Pos) /*!< SCB SHCSR: BUSFAULTACT Mask */

#define SCB_SHCSR_MEMFAULTACT_Pos 0U /*!< SCB SHCSR: MEMFAULTACT Position */
#define SCB_SHCSR_MEMFAULTACT_Msk (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/) /*!< SCB SHCSR: MEMFAULTACT Mask */

/* SCB Configurable Fault Status Register Definitions */
#define SCB_CFSR_USGFAULTSR_Pos 16U /*!< SCB CFSR: Usage Fault Status Register Position */
#define SCB_CFSR_USGFAULTSR_Msk (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos) /*!< SCB CFSR: Usage Fault Status Register Mask */

#define SCB_CFSR_BUSFAULTSR_Pos 8U /*!< SCB CFSR: Bus Fault Status Register Position */
#define SCB_CFSR_BUSFAULTSR_Msk (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos) /*!< SCB CFSR: Bus Fault Status Register Mask */

#define SCB_CFSR_MEMFAULTSR_Pos 0U /*!< SCB CFSR: Memory Manage Fault Status Register Position */
#define SCB_CFSR_MEMFAULTSR_Msk (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/) /*!< SCB CFSR: Memory Manage Fault Status Register Mask */

/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
#define SCB_CFSR_MMARVALID_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 7U) /*!< SCB CFSR (MMFSR): MMARVALID Position */
#define SCB_CFSR_MMARVALID_Msk (1UL << SCB_CFSR_MMARVALID_Pos) /*!< SCB CFSR (MMFSR): MMARVALID Mask */

#define SCB_CFSR_MSTKERR_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 4U) /*!< SCB CFSR (MMFSR): MSTKERR Position */
#define SCB_CFSR_MSTKERR_Msk (1UL << SCB_CFSR_MSTKERR_Pos) /*!< SCB CFSR (MMFSR): MSTKERR Mask */

#define SCB_CFSR_MUNSTKERR_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 3U) /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
#define SCB_CFSR_MUNSTKERR_Msk (1UL << SCB_CFSR_MUNSTKERR_Pos) /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */

#define SCB_CFSR_DACCVIOL_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 1U) /*!< SCB CFSR (MMFSR): DACCVIOL Position */
#define SCB_CFSR_DACCVIOL_Msk (1UL << SCB_CFSR_DACCVIOL_Pos) /*!< SCB CFSR (MMFSR): DACCVIOL Mask */

#define SCB_CFSR_IACCVIOL_Pos (SCB_SHCSR_MEMFAULTACT_Pos + 0U) /*!< SCB CFSR (MMFSR): IACCVIOL Position */
#define SCB_CFSR_IACCVIOL_Msk (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/) /*!< SCB CFSR (MMFSR): IACCVIOL Mask */

/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
#define SCB_CFSR_BFARVALID_Pos (SCB_CFSR_BUSFAULTSR_Pos + 7U) /*!< SCB CFSR (BFSR): BFARVALID Position */
#define SCB_CFSR_BFARVALID_Msk (1UL << SCB_CFSR_BFARVALID_Pos) /*!< SCB CFSR (BFSR): BFARVALID Mask */

#define SCB_CFSR_STKERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 4U) /*!< SCB CFSR (BFSR): STKERR Position */
#define SCB_CFSR_STKERR_Msk (1UL << SCB_CFSR_STKERR_Pos) /*!< SCB CFSR (BFSR): STKERR Mask */

#define SCB_CFSR_UNSTKERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 3U) /*!< SCB CFSR (BFSR): UNSTKERR Position */
#define SCB_CFSR_UNSTKERR_Msk (1UL << SCB_CFSR_UNSTKERR_Pos) /*!< SCB CFSR (BFSR): UNSTKERR Mask */

#define SCB_CFSR_IMPRECISERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 2U) /*!< SCB CFSR (BFSR): IMPRECISERR Position */
#define SCB_CFSR_IMPRECISERR_Msk (1UL << SCB_CFSR_IMPRECISERR_Pos) /*!< SCB CFSR (BFSR): IMPRECISERR Mask */

#define SCB_CFSR_PRECISERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 1U) /*!< SCB CFSR (BFSR): PRECISERR Position */
#define SCB_CFSR_PRECISERR_Msk (1UL << SCB_CFSR_PRECISERR_Pos) /*!< SCB CFSR (BFSR): PRECISERR Mask */

#define SCB_CFSR_IBUSERR_Pos (SCB_CFSR_BUSFAULTSR_Pos + 0U) /*!< SCB CFSR (BFSR): IBUSERR Position */
#define SCB_CFSR_IBUSERR_Msk (1UL << SCB_CFSR_IBUSERR_Pos) /*!< SCB CFSR (BFSR): IBUSERR Mask */

/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
#define SCB_CFSR_DIVBYZERO_Pos (SCB_CFSR_USGFAULTSR_Pos + 9U) /*!< SCB CFSR (UFSR): DIVBYZERO Position */
#define SCB_CFSR_DIVBYZERO_Msk (1UL << SCB_CFSR_DIVBYZERO_Pos) /*!< SCB CFSR (UFSR): DIVBYZERO Mask */

#define SCB_CFSR_UNALIGNED_Pos (SCB_CFSR_USGFAULTSR_Pos + 8U) /*!< SCB CFSR (UFSR): UNALIGNED Position */
#define SCB_CFSR_UNALIGNED_Msk (1UL << SCB_CFSR_UNALIGNED_Pos) /*!< SCB CFSR (UFSR): UNALIGNED Mask */

#define SCB_CFSR_NOCP_Pos (SCB_CFSR_USGFAULTSR_Pos + 3U) /*!< SCB CFSR (UFSR): NOCP Position */
#define SCB_CFSR_NOCP_Msk (1UL << SCB_CFSR_NOCP_Pos) /*!< SCB CFSR (UFSR): NOCP Mask */

#define SCB_CFSR_INVPC_Pos (SCB_CFSR_USGFAULTSR_Pos + 2U) /*!< SCB CFSR (UFSR): INVPC Position */
#define SCB_CFSR_INVPC_Msk (1UL << SCB_CFSR_INVPC_Pos) /*!< SCB CFSR (UFSR): INVPC Mask */

#define SCB_CFSR_INVSTATE_Pos (SCB_CFSR_USGFAULTSR_Pos + 1U) /*!< SCB CFSR (UFSR): INVSTATE Position */
#define SCB_CFSR_INVSTATE_Msk (1UL << SCB_CFSR_INVSTATE_Pos) /*!< SCB CFSR (UFSR): INVSTATE Mask */

#define SCB_CFSR_UNDEFINSTR_Pos (SCB_CFSR_USGFAULTSR_Pos + 0U) /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
#define SCB_CFSR_UNDEFINSTR_Msk (1UL << SCB_CFSR_UNDEFINSTR_Pos) /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */

/* SCB Hard Fault Status Register Definitions */
#define SCB_HFSR_DEBUGEVT_Pos 31U /*!< SCB HFSR: DEBUGEVT Position */
#define SCB_HFSR_DEBUGEVT_Msk (1UL << SCB_HFSR_DEBUGEVT_Pos) /*!< SCB HFSR: DEBUGEVT Mask */

#define SCB_HFSR_FORCED_Pos 30U /*!< SCB HFSR: FORCED Position */
#define SCB_HFSR_FORCED_Msk (1UL << SCB_HFSR_FORCED_Pos) /*!< SCB HFSR: FORCED Mask */

#define SCB_HFSR_VECTTBL_Pos 1U /*!< SCB HFSR: VECTTBL Position */
#define SCB_HFSR_VECTTBL_Msk (1UL << SCB_HFSR_VECTTBL_Pos) /*!< SCB HFSR: VECTTBL Mask */

/* SCB Debug Fault Status Register Definitions */
#define SCB_DFSR_EXTERNAL_Pos 4U /*!< SCB DFSR: EXTERNAL Position */
#define SCB_DFSR_EXTERNAL_Msk (1UL << SCB_DFSR_EXTERNAL_Pos) /*!< SCB DFSR: EXTERNAL Mask */

#define SCB_DFSR_VCATCH_Pos 3U /*!< SCB DFSR: VCATCH Position */
#define SCB_DFSR_VCATCH_Msk (1UL << SCB_DFSR_VCATCH_Pos) /*!< SCB DFSR: VCATCH Mask */

#define SCB_DFSR_DWTTRAP_Pos 2U /*!< SCB DFSR: DWTTRAP Position */
#define SCB_DFSR_DWTTRAP_Msk (1UL << SCB_DFSR_DWTTRAP_Pos) /*!< SCB DFSR: DWTTRAP Mask */

#define SCB_DFSR_BKPT_Pos 1U /*!< SCB DFSR: BKPT Position */
#define SCB_DFSR_BKPT_Msk (1UL << SCB_DFSR_BKPT_Pos) /*!< SCB DFSR: BKPT Mask */

#define SCB_DFSR_HALTED_Pos 0U /*!< SCB DFSR: HALTED Position */
#define SCB_DFSR_HALTED_Msk (1UL /*<< SCB_DFSR_HALTED_Pos*/) /*!< SCB DFSR: HALTED Mask */

/*@} end of group CMSIS_SCB */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
  \brief    Type definitions for the System Control and ID Register not in the SCB
  @{
 */

/**
  \brief  Structure type to access the System Control and ID Register not in the SCB.
 */
typedef struct
{
        uint32_t RESERVED0[1U];
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t ICTR; /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */

  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ACTLR; /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */



} SCnSCB_Type;

/* Interrupt Controller Type Register Definitions */
#define SCnSCB_ICTR_INTLINESNUM_Pos 0U /*!< ICTR: INTLINESNUM Position */
#define SCnSCB_ICTR_INTLINESNUM_Msk (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/) /*!< ICTR: INTLINESNUM Mask */

/* Auxiliary Control Register Definitions */

#define SCnSCB_ACTLR_DISOOFP_Pos 9U /*!< ACTLR: DISOOFP Position */
#define SCnSCB_ACTLR_DISOOFP_Msk (1UL << SCnSCB_ACTLR_DISOOFP_Pos) /*!< ACTLR: DISOOFP Mask */

#define SCnSCB_ACTLR_DISFPCA_Pos 8U /*!< ACTLR: DISFPCA Position */
#define SCnSCB_ACTLR_DISFPCA_Msk (1UL << SCnSCB_ACTLR_DISFPCA_Pos) /*!< ACTLR: DISFPCA Mask */

#define SCnSCB_ACTLR_DISFOLD_Pos 2U /*!< ACTLR: DISFOLD Position */
#define SCnSCB_ACTLR_DISFOLD_Msk (1UL << SCnSCB_ACTLR_DISFOLD_Pos) /*!< ACTLR: DISFOLD Mask */

#define SCnSCB_ACTLR_DISDEFWBUF_Pos 1U /*!< ACTLR: DISDEFWBUF Position */
#define SCnSCB_ACTLR_DISDEFWBUF_Msk (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos) /*!< ACTLR: DISDEFWBUF Mask */

#define SCnSCB_ACTLR_DISMCYCINT_Pos 0U /*!< ACTLR: DISMCYCINT Position */
#define SCnSCB_ACTLR_DISMCYCINT_Msk (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/) /*!< ACTLR: DISMCYCINT Mask */


/*@} end of group CMSIS_SCnotSCB */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
  \brief    Type definitions for the System Timer Registers.
  @{
 */

/**
  \brief  Structure type to access the System Timer (SysTick).
 */
typedef struct
{
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CTRL; /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t LOAD; /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t VAL; /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t CALIB; /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
} SysTick_Type;

/* SysTick Control / Status Register Definitions */
#define SysTick_CTRL_COUNTFLAG_Pos 16U /*!< SysTick CTRL: COUNTFLAG Position */
#define SysTick_CTRL_COUNTFLAG_Msk (1UL << SysTick_CTRL_COUNTFLAG_Pos) /*!< SysTick CTRL: COUNTFLAG Mask */

#define SysTick_CTRL_CLKSOURCE_Pos 2U /*!< SysTick CTRL: CLKSOURCE Position */
#define SysTick_CTRL_CLKSOURCE_Msk (1UL << SysTick_CTRL_CLKSOURCE_Pos) /*!< SysTick CTRL: CLKSOURCE Mask */

#define SysTick_CTRL_TICKINT_Pos 1U /*!< SysTick CTRL: TICKINT Position */
#define SysTick_CTRL_TICKINT_Msk (1UL << SysTick_CTRL_TICKINT_Pos) /*!< SysTick CTRL: TICKINT Mask */

#define SysTick_CTRL_ENABLE_Pos 0U /*!< SysTick CTRL: ENABLE Position */
#define SysTick_CTRL_ENABLE_Msk (1UL /*<< SysTick_CTRL_ENABLE_Pos*/) /*!< SysTick CTRL: ENABLE Mask */

/* SysTick Reload Register Definitions */
#define SysTick_LOAD_RELOAD_Pos 0U /*!< SysTick LOAD: RELOAD Position */
#define SysTick_LOAD_RELOAD_Msk (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/) /*!< SysTick LOAD: RELOAD Mask */

/* SysTick Current Register Definitions */
#define SysTick_VAL_CURRENT_Pos 0U /*!< SysTick VAL: CURRENT Position */
#define SysTick_VAL_CURRENT_Msk (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/) /*!< SysTick VAL: CURRENT Mask */

/* SysTick Calibration Register Definitions */
#define SysTick_CALIB_NOREF_Pos 31U /*!< SysTick CALIB: NOREF Position */
#define SysTick_CALIB_NOREF_Msk (1UL << SysTick_CALIB_NOREF_Pos) /*!< SysTick CALIB: NOREF Mask */

#define SysTick_CALIB_SKEW_Pos 30U /*!< SysTick CALIB: SKEW Position */
#define SysTick_CALIB_SKEW_Msk (1UL << SysTick_CALIB_SKEW_Pos) /*!< SysTick CALIB: SKEW Mask */

#define SysTick_CALIB_TENMS_Pos 0U /*!< SysTick CALIB: TENMS Position */
#define SysTick_CALIB_TENMS_Msk (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/) /*!< SysTick CALIB: TENMS Mask */

/*@} end of group CMSIS_SysTick */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
  @{
 */

/**
  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
 */
typedef struct
{
  volatile /*! Defines 'write only' structure member permissions */ union
  {
    volatile /*! Defines 'write only' structure member permissions */ uint8_t u8; /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
    volatile /*! Defines 'write only' structure member permissions */ uint16_t u16; /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
    volatile /*! Defines 'write only' structure member permissions */ uint32_t u32; /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
  } PORT [32U]; /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
        uint32_t RESERVED0[864U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t TER; /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
        uint32_t RESERVED1[15U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t TPR; /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
        uint32_t RESERVED2[15U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t TCR; /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
        uint32_t RESERVED3[32U];
        uint32_t RESERVED4[43U];
  volatile /*! Defines 'write only' structure member permissions */ uint32_t LAR; /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t LSR; /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
        uint32_t RESERVED5[6U];
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID4; /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID5; /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID6; /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID7; /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID0; /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID1; /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID2; /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PID3; /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t CID0; /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t CID1; /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t CID2; /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t CID3; /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
} ITM_Type;

/* ITM Trace Privilege Register Definitions */
#define ITM_TPR_PRIVMASK_Pos 0U /*!< ITM TPR: PRIVMASK Position */
#define ITM_TPR_PRIVMASK_Msk (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/) /*!< ITM TPR: PRIVMASK Mask */

/* ITM Trace Control Register Definitions */
#define ITM_TCR_BUSY_Pos 23U /*!< ITM TCR: BUSY Position */
#define ITM_TCR_BUSY_Msk (1UL << ITM_TCR_BUSY_Pos) /*!< ITM TCR: BUSY Mask */

#define ITM_TCR_TraceBusID_Pos 16U /*!< ITM TCR: ATBID Position */
#define ITM_TCR_TraceBusID_Msk (0x7FUL << ITM_TCR_TraceBusID_Pos) /*!< ITM TCR: ATBID Mask */

#define ITM_TCR_GTSFREQ_Pos 10U /*!< ITM TCR: Global timestamp frequency Position */
#define ITM_TCR_GTSFREQ_Msk (3UL << ITM_TCR_GTSFREQ_Pos) /*!< ITM TCR: Global timestamp frequency Mask */

#define ITM_TCR_TSPrescale_Pos 8U /*!< ITM TCR: TSPrescale Position */
#define ITM_TCR_TSPrescale_Msk (3UL << ITM_TCR_TSPrescale_Pos) /*!< ITM TCR: TSPrescale Mask */

#define ITM_TCR_SWOENA_Pos 4U /*!< ITM TCR: SWOENA Position */
#define ITM_TCR_SWOENA_Msk (1UL << ITM_TCR_SWOENA_Pos) /*!< ITM TCR: SWOENA Mask */

#define ITM_TCR_DWTENA_Pos 3U /*!< ITM TCR: DWTENA Position */
#define ITM_TCR_DWTENA_Msk (1UL << ITM_TCR_DWTENA_Pos) /*!< ITM TCR: DWTENA Mask */

#define ITM_TCR_SYNCENA_Pos 2U /*!< ITM TCR: SYNCENA Position */
#define ITM_TCR_SYNCENA_Msk (1UL << ITM_TCR_SYNCENA_Pos) /*!< ITM TCR: SYNCENA Mask */

#define ITM_TCR_TSENA_Pos 1U /*!< ITM TCR: TSENA Position */
#define ITM_TCR_TSENA_Msk (1UL << ITM_TCR_TSENA_Pos) /*!< ITM TCR: TSENA Mask */

#define ITM_TCR_ITMENA_Pos 0U /*!< ITM TCR: ITM Enable bit Position */
#define ITM_TCR_ITMENA_Msk (1UL /*<< ITM_TCR_ITMENA_Pos*/) /*!< ITM TCR: ITM Enable bit Mask */

/* ITM Lock Status Register Definitions */
#define ITM_LSR_ByteAcc_Pos 2U /*!< ITM LSR: ByteAcc Position */
#define ITM_LSR_ByteAcc_Msk (1UL << ITM_LSR_ByteAcc_Pos) /*!< ITM LSR: ByteAcc Mask */

#define ITM_LSR_Access_Pos 1U /*!< ITM LSR: Access Position */
#define ITM_LSR_Access_Msk (1UL << ITM_LSR_Access_Pos) /*!< ITM LSR: Access Mask */

#define ITM_LSR_Present_Pos 0U /*!< ITM LSR: Present Position */
#define ITM_LSR_Present_Msk (1UL /*<< ITM_LSR_Present_Pos*/) /*!< ITM LSR: Present Mask */

/*@}*/ /* end of group CMSIS_ITM */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
  @{
 */

/**
  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
 */
typedef struct
{
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CTRL; /*!< Offset: 0x000 (R/W)  Control Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CYCCNT; /*!< Offset: 0x004 (R/W)  Cycle Count Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CPICNT; /*!< Offset: 0x008 (R/W)  CPI Count Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t EXCCNT; /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t SLEEPCNT; /*!< Offset: 0x010 (R/W)  Sleep Count Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t LSUCNT; /*!< Offset: 0x014 (R/W)  LSU Count Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t FOLDCNT; /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t PCSR; /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t COMP0; /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t MASK0; /*!< Offset: 0x024 (R/W)  Mask Register 0 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t FUNCTION0; /*!< Offset: 0x028 (R/W)  Function Register 0 */
        uint32_t RESERVED0[1U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t COMP1; /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t MASK1; /*!< Offset: 0x034 (R/W)  Mask Register 1 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t FUNCTION1; /*!< Offset: 0x038 (R/W)  Function Register 1 */
        uint32_t RESERVED1[1U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t COMP2; /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t MASK2; /*!< Offset: 0x044 (R/W)  Mask Register 2 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t FUNCTION2; /*!< Offset: 0x048 (R/W)  Function Register 2 */
        uint32_t RESERVED2[1U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t COMP3; /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t MASK3; /*!< Offset: 0x054 (R/W)  Mask Register 3 */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t FUNCTION3; /*!< Offset: 0x058 (R/W)  Function Register 3 */
} DWT_Type;

/* DWT Control Register Definitions */
#define DWT_CTRL_NUMCOMP_Pos 28U /*!< DWT CTRL: NUMCOMP Position */
#define DWT_CTRL_NUMCOMP_Msk (0xFUL << DWT_CTRL_NUMCOMP_Pos) /*!< DWT CTRL: NUMCOMP Mask */

#define DWT_CTRL_NOTRCPKT_Pos 27U /*!< DWT CTRL: NOTRCPKT Position */
#define DWT_CTRL_NOTRCPKT_Msk (0x1UL << DWT_CTRL_NOTRCPKT_Pos) /*!< DWT CTRL: NOTRCPKT Mask */

#define DWT_CTRL_NOEXTTRIG_Pos 26U /*!< DWT CTRL: NOEXTTRIG Position */
#define DWT_CTRL_NOEXTTRIG_Msk (0x1UL << DWT_CTRL_NOEXTTRIG_Pos) /*!< DWT CTRL: NOEXTTRIG Mask */

#define DWT_CTRL_NOCYCCNT_Pos 25U /*!< DWT CTRL: NOCYCCNT Position */
#define DWT_CTRL_NOCYCCNT_Msk (0x1UL << DWT_CTRL_NOCYCCNT_Pos) /*!< DWT CTRL: NOCYCCNT Mask */

#define DWT_CTRL_NOPRFCNT_Pos 24U /*!< DWT CTRL: NOPRFCNT Position */
#define DWT_CTRL_NOPRFCNT_Msk (0x1UL << DWT_CTRL_NOPRFCNT_Pos) /*!< DWT CTRL: NOPRFCNT Mask */

#define DWT_CTRL_CYCEVTENA_Pos 22U /*!< DWT CTRL: CYCEVTENA Position */
#define DWT_CTRL_CYCEVTENA_Msk (0x1UL << DWT_CTRL_CYCEVTENA_Pos) /*!< DWT CTRL: CYCEVTENA Mask */

#define DWT_CTRL_FOLDEVTENA_Pos 21U /*!< DWT CTRL: FOLDEVTENA Position */
#define DWT_CTRL_FOLDEVTENA_Msk (0x1UL << DWT_CTRL_FOLDEVTENA_Pos) /*!< DWT CTRL: FOLDEVTENA Mask */

#define DWT_CTRL_LSUEVTENA_Pos 20U /*!< DWT CTRL: LSUEVTENA Position */
#define DWT_CTRL_LSUEVTENA_Msk (0x1UL << DWT_CTRL_LSUEVTENA_Pos) /*!< DWT CTRL: LSUEVTENA Mask */

#define DWT_CTRL_SLEEPEVTENA_Pos 19U /*!< DWT CTRL: SLEEPEVTENA Position */
#define DWT_CTRL_SLEEPEVTENA_Msk (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos) /*!< DWT CTRL: SLEEPEVTENA Mask */

#define DWT_CTRL_EXCEVTENA_Pos 18U /*!< DWT CTRL: EXCEVTENA Position */
#define DWT_CTRL_EXCEVTENA_Msk (0x1UL << DWT_CTRL_EXCEVTENA_Pos) /*!< DWT CTRL: EXCEVTENA Mask */

#define DWT_CTRL_CPIEVTENA_Pos 17U /*!< DWT CTRL: CPIEVTENA Position */
#define DWT_CTRL_CPIEVTENA_Msk (0x1UL << DWT_CTRL_CPIEVTENA_Pos) /*!< DWT CTRL: CPIEVTENA Mask */

#define DWT_CTRL_EXCTRCENA_Pos 16U /*!< DWT CTRL: EXCTRCENA Position */
#define DWT_CTRL_EXCTRCENA_Msk (0x1UL << DWT_CTRL_EXCTRCENA_Pos) /*!< DWT CTRL: EXCTRCENA Mask */

#define DWT_CTRL_PCSAMPLENA_Pos 12U /*!< DWT CTRL: PCSAMPLENA Position */
#define DWT_CTRL_PCSAMPLENA_Msk (0x1UL << DWT_CTRL_PCSAMPLENA_Pos) /*!< DWT CTRL: PCSAMPLENA Mask */

#define DWT_CTRL_SYNCTAP_Pos 10U /*!< DWT CTRL: SYNCTAP Position */
#define DWT_CTRL_SYNCTAP_Msk (0x3UL << DWT_CTRL_SYNCTAP_Pos) /*!< DWT CTRL: SYNCTAP Mask */

#define DWT_CTRL_CYCTAP_Pos 9U /*!< DWT CTRL: CYCTAP Position */
#define DWT_CTRL_CYCTAP_Msk (0x1UL << DWT_CTRL_CYCTAP_Pos) /*!< DWT CTRL: CYCTAP Mask */

#define DWT_CTRL_POSTINIT_Pos 5U /*!< DWT CTRL: POSTINIT Position */
#define DWT_CTRL_POSTINIT_Msk (0xFUL << DWT_CTRL_POSTINIT_Pos) /*!< DWT CTRL: POSTINIT Mask */

#define DWT_CTRL_POSTPRESET_Pos 1U /*!< DWT CTRL: POSTPRESET Position */
#define DWT_CTRL_POSTPRESET_Msk (0xFUL << DWT_CTRL_POSTPRESET_Pos) /*!< DWT CTRL: POSTPRESET Mask */

#define DWT_CTRL_CYCCNTENA_Pos 0U /*!< DWT CTRL: CYCCNTENA Position */
#define DWT_CTRL_CYCCNTENA_Msk (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/) /*!< DWT CTRL: CYCCNTENA Mask */

/* DWT CPI Count Register Definitions */
#define DWT_CPICNT_CPICNT_Pos 0U /*!< DWT CPICNT: CPICNT Position */
#define DWT_CPICNT_CPICNT_Msk (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/) /*!< DWT CPICNT: CPICNT Mask */

/* DWT Exception Overhead Count Register Definitions */
#define DWT_EXCCNT_EXCCNT_Pos 0U /*!< DWT EXCCNT: EXCCNT Position */
#define DWT_EXCCNT_EXCCNT_Msk (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/) /*!< DWT EXCCNT: EXCCNT Mask */

/* DWT Sleep Count Register Definitions */
#define DWT_SLEEPCNT_SLEEPCNT_Pos 0U /*!< DWT SLEEPCNT: SLEEPCNT Position */
#define DWT_SLEEPCNT_SLEEPCNT_Msk (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/) /*!< DWT SLEEPCNT: SLEEPCNT Mask */

/* DWT LSU Count Register Definitions */
#define DWT_LSUCNT_LSUCNT_Pos 0U /*!< DWT LSUCNT: LSUCNT Position */
#define DWT_LSUCNT_LSUCNT_Msk (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/) /*!< DWT LSUCNT: LSUCNT Mask */

/* DWT Folded-instruction Count Register Definitions */
#define DWT_FOLDCNT_FOLDCNT_Pos 0U /*!< DWT FOLDCNT: FOLDCNT Position */
#define DWT_FOLDCNT_FOLDCNT_Msk (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/) /*!< DWT FOLDCNT: FOLDCNT Mask */

/* DWT Comparator Mask Register Definitions */
#define DWT_MASK_MASK_Pos 0U /*!< DWT MASK: MASK Position */
#define DWT_MASK_MASK_Msk (0x1FUL /*<< DWT_MASK_MASK_Pos*/) /*!< DWT MASK: MASK Mask */

/* DWT Comparator Function Register Definitions */
#define DWT_FUNCTION_MATCHED_Pos 24U /*!< DWT FUNCTION: MATCHED Position */
#define DWT_FUNCTION_MATCHED_Msk (0x1UL << DWT_FUNCTION_MATCHED_Pos) /*!< DWT FUNCTION: MATCHED Mask */

#define DWT_FUNCTION_DATAVADDR1_Pos 16U /*!< DWT FUNCTION: DATAVADDR1 Position */
#define DWT_FUNCTION_DATAVADDR1_Msk (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos) /*!< DWT FUNCTION: DATAVADDR1 Mask */

#define DWT_FUNCTION_DATAVADDR0_Pos 12U /*!< DWT FUNCTION: DATAVADDR0 Position */
#define DWT_FUNCTION_DATAVADDR0_Msk (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos) /*!< DWT FUNCTION: DATAVADDR0 Mask */

#define DWT_FUNCTION_DATAVSIZE_Pos 10U /*!< DWT FUNCTION: DATAVSIZE Position */
#define DWT_FUNCTION_DATAVSIZE_Msk (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos) /*!< DWT FUNCTION: DATAVSIZE Mask */

#define DWT_FUNCTION_LNK1ENA_Pos 9U /*!< DWT FUNCTION: LNK1ENA Position */
#define DWT_FUNCTION_LNK1ENA_Msk (0x1UL << DWT_FUNCTION_LNK1ENA_Pos) /*!< DWT FUNCTION: LNK1ENA Mask */

#define DWT_FUNCTION_DATAVMATCH_Pos 8U /*!< DWT FUNCTION: DATAVMATCH Position */
#define DWT_FUNCTION_DATAVMATCH_Msk (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos) /*!< DWT FUNCTION: DATAVMATCH Mask */

#define DWT_FUNCTION_CYCMATCH_Pos 7U /*!< DWT FUNCTION: CYCMATCH Position */
#define DWT_FUNCTION_CYCMATCH_Msk (0x1UL << DWT_FUNCTION_CYCMATCH_Pos) /*!< DWT FUNCTION: CYCMATCH Mask */

#define DWT_FUNCTION_EMITRANGE_Pos 5U /*!< DWT FUNCTION: EMITRANGE Position */
#define DWT_FUNCTION_EMITRANGE_Msk (0x1UL << DWT_FUNCTION_EMITRANGE_Pos) /*!< DWT FUNCTION: EMITRANGE Mask */

#define DWT_FUNCTION_FUNCTION_Pos 0U /*!< DWT FUNCTION: FUNCTION Position */
#define DWT_FUNCTION_FUNCTION_Msk (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/) /*!< DWT FUNCTION: FUNCTION Mask */

/*@}*/ /* end of group CMSIS_DWT */


/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
  \brief    Type definitions for the Trace Port Interface (TPI)
  @{
 */

/**
  \brief  Structure type to access the Trace Port Interface Register (TPI).
 */
typedef struct
{
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t SSPSR; /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CSPSR; /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
        uint32_t RESERVED0[2U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ACPR; /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
        uint32_t RESERVED1[55U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t SPPR; /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
        uint32_t RESERVED2[131U];
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t FFSR; /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t FFCR; /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t FSCR; /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
        uint32_t RESERVED3[759U];
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t TRIGGER; /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t FIFO0; /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t ITATBCTR2; /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
        uint32_t RESERVED4[1U];
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t ITATBCTR0; /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t FIFO1; /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t ITCTRL; /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
        uint32_t RESERVED5[39U];
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CLAIMSET; /*!< Offset: 0xFA0 (R/W)  Claim tag set */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t CLAIMCLR; /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
        uint32_t RESERVED7[8U];
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t DEVID; /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
  volatile const /*! Defines 'read only' structure member permissions */ uint32_t DEVTYPE; /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
} TPI_Type;

/* TPI Asynchronous Clock Prescaler Register Definitions */
#define TPI_ACPR_PRESCALER_Pos 0U /*!< TPI ACPR: PRESCALER Position */
#define TPI_ACPR_PRESCALER_Msk (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/) /*!< TPI ACPR: PRESCALER Mask */

/* TPI Selected Pin Protocol Register Definitions */
#define TPI_SPPR_TXMODE_Pos 0U /*!< TPI SPPR: TXMODE Position */
#define TPI_SPPR_TXMODE_Msk (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/) /*!< TPI SPPR: TXMODE Mask */

/* TPI Formatter and Flush Status Register Definitions */
#define TPI_FFSR_FtNonStop_Pos 3U /*!< TPI FFSR: FtNonStop Position */
#define TPI_FFSR_FtNonStop_Msk (0x1UL << TPI_FFSR_FtNonStop_Pos) /*!< TPI FFSR: FtNonStop Mask */

#define TPI_FFSR_TCPresent_Pos 2U /*!< TPI FFSR: TCPresent Position */
#define TPI_FFSR_TCPresent_Msk (0x1UL << TPI_FFSR_TCPresent_Pos) /*!< TPI FFSR: TCPresent Mask */

#define TPI_FFSR_FtStopped_Pos 1U /*!< TPI FFSR: FtStopped Position */
#define TPI_FFSR_FtStopped_Msk (0x1UL << TPI_FFSR_FtStopped_Pos) /*!< TPI FFSR: FtStopped Mask */

#define TPI_FFSR_FlInProg_Pos 0U /*!< TPI FFSR: FlInProg Position */
#define TPI_FFSR_FlInProg_Msk (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/) /*!< TPI FFSR: FlInProg Mask */

/* TPI Formatter and Flush Control Register Definitions */
#define TPI_FFCR_TrigIn_Pos 8U /*!< TPI FFCR: TrigIn Position */
#define TPI_FFCR_TrigIn_Msk (0x1UL << TPI_FFCR_TrigIn_Pos) /*!< TPI FFCR: TrigIn Mask */

#define TPI_FFCR_EnFCont_Pos 1U /*!< TPI FFCR: EnFCont Position */
#define TPI_FFCR_EnFCont_Msk (0x1UL << TPI_FFCR_EnFCont_Pos) /*!< TPI FFCR: EnFCont Mask */

/* TPI TRIGGER Register Definitions */
#define TPI_TRIGGER_TRIGGER_Pos 0U /*!< TPI TRIGGER: TRIGGER Position */
#define TPI_TRIGGER_TRIGGER_Msk (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/) /*!< TPI TRIGGER: TRIGGER Mask */

/* TPI Integration ETM Data Register Definitions (FIFO0) */
#define TPI_FIFO0_ITM_ATVALID_Pos 29U /*!< TPI FIFO0: ITM_ATVALID Position */
#define TPI_FIFO0_ITM_ATVALID_Msk (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos) /*!< TPI FIFO0: ITM_ATVALID Mask */

#define TPI_FIFO0_ITM_bytecount_Pos 27U /*!< TPI FIFO0: ITM_bytecount Position */
#define TPI_FIFO0_ITM_bytecount_Msk (0x3UL << TPI_FIFO0_ITM_bytecount_Pos) /*!< TPI FIFO0: ITM_bytecount Mask */

#define TPI_FIFO0_ETM_ATVALID_Pos 26U /*!< TPI FIFO0: ETM_ATVALID Position */
#define TPI_FIFO0_ETM_ATVALID_Msk (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos) /*!< TPI FIFO0: ETM_ATVALID Mask */

#define TPI_FIFO0_ETM_bytecount_Pos 24U /*!< TPI FIFO0: ETM_bytecount Position */
#define TPI_FIFO0_ETM_bytecount_Msk (0x3UL << TPI_FIFO0_ETM_bytecount_Pos) /*!< TPI FIFO0: ETM_bytecount Mask */

#define TPI_FIFO0_ETM2_Pos 16U /*!< TPI FIFO0: ETM2 Position */
#define TPI_FIFO0_ETM2_Msk (0xFFUL << TPI_FIFO0_ETM2_Pos) /*!< TPI FIFO0: ETM2 Mask */

#define TPI_FIFO0_ETM1_Pos 8U /*!< TPI FIFO0: ETM1 Position */
#define TPI_FIFO0_ETM1_Msk (0xFFUL << TPI_FIFO0_ETM1_Pos) /*!< TPI FIFO0: ETM1 Mask */

#define TPI_FIFO0_ETM0_Pos 0U /*!< TPI FIFO0: ETM0 Position */
#define TPI_FIFO0_ETM0_Msk (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/) /*!< TPI FIFO0: ETM0 Mask */

/* TPI ITATBCTR2 Register Definitions */
#define TPI_ITATBCTR2_ATREADY2_Pos 0U /*!< TPI ITATBCTR2: ATREADY2 Position */
#define TPI_ITATBCTR2_ATREADY2_Msk (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/) /*!< TPI ITATBCTR2: ATREADY2 Mask */

#define TPI_ITATBCTR2_ATREADY1_Pos 0U /*!< TPI ITATBCTR2: ATREADY1 Position */
#define TPI_ITATBCTR2_ATREADY1_Msk (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/) /*!< TPI ITATBCTR2: ATREADY1 Mask */

/* TPI Integration ITM Data Register Definitions (FIFO1) */
#define TPI_FIFO1_ITM_ATVALID_Pos 29U /*!< TPI FIFO1: ITM_ATVALID Position */
#define TPI_FIFO1_ITM_ATVALID_Msk (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos) /*!< TPI FIFO1: ITM_ATVALID Mask */

#define TPI_FIFO1_ITM_bytecount_Pos 27U /*!< TPI FIFO1: ITM_bytecount Position */
#define TPI_FIFO1_ITM_bytecount_Msk (0x3UL << TPI_FIFO1_ITM_bytecount_Pos) /*!< TPI FIFO1: ITM_bytecount Mask */

#define TPI_FIFO1_ETM_ATVALID_Pos 26U /*!< TPI FIFO1: ETM_ATVALID Position */
#define TPI_FIFO1_ETM_ATVALID_Msk (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos) /*!< TPI FIFO1: ETM_ATVALID Mask */

#define TPI_FIFO1_ETM_bytecount_Pos 24U /*!< TPI FIFO1: ETM_bytecount Position */
#define TPI_FIFO1_ETM_bytecount_Msk (0x3UL << TPI_FIFO1_ETM_bytecount_Pos) /*!< TPI FIFO1: ETM_bytecount Mask */

#define TPI_FIFO1_ITM2_Pos 16U /*!< TPI FIFO1: ITM2 Position */
#define TPI_FIFO1_ITM2_Msk (0xFFUL << TPI_FIFO1_ITM2_Pos) /*!< TPI FIFO1: ITM2 Mask */

#define TPI_FIFO1_ITM1_Pos 8U /*!< TPI FIFO1: ITM1 Position */
#define TPI_FIFO1_ITM1_Msk (0xFFUL << TPI_FIFO1_ITM1_Pos) /*!< TPI FIFO1: ITM1 Mask */

#define TPI_FIFO1_ITM0_Pos 0U /*!< TPI FIFO1: ITM0 Position */
#define TPI_FIFO1_ITM0_Msk (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/) /*!< TPI FIFO1: ITM0 Mask */

/* TPI ITATBCTR0 Register Definitions */
#define TPI_ITATBCTR0_ATREADY2_Pos 0U /*!< TPI ITATBCTR0: ATREADY2 Position */
#define TPI_ITATBCTR0_ATREADY2_Msk (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/) /*!< TPI ITATBCTR0: ATREADY2 Mask */

#define TPI_ITATBCTR0_ATREADY1_Pos 0U /*!< TPI ITATBCTR0: ATREADY1 Position */
#define TPI_ITATBCTR0_ATREADY1_Msk (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/) /*!< TPI ITATBCTR0: ATREADY1 Mask */

/* TPI Integration Mode Control Register Definitions */
#define TPI_ITCTRL_Mode_Pos 0U /*!< TPI ITCTRL: Mode Position */
#define TPI_ITCTRL_Mode_Msk (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/) /*!< TPI ITCTRL: Mode Mask */

/* TPI DEVID Register Definitions */
#define TPI_DEVID_NRZVALID_Pos 11U /*!< TPI DEVID: NRZVALID Position */
#define TPI_DEVID_NRZVALID_Msk (0x1UL << TPI_DEVID_NRZVALID_Pos) /*!< TPI DEVID: NRZVALID Mask */

#define TPI_DEVID_MANCVALID_Pos 10U /*!< TPI DEVID: MANCVALID Position */
#define TPI_DEVID_MANCVALID_Msk (0x1UL << TPI_DEVID_MANCVALID_Pos) /*!< TPI DEVID: MANCVALID Mask */

#define TPI_DEVID_PTINVALID_Pos 9U /*!< TPI DEVID: PTINVALID Position */
#define TPI_DEVID_PTINVALID_Msk (0x1UL << TPI_DEVID_PTINVALID_Pos) /*!< TPI DEVID: PTINVALID Mask */

#define TPI_DEVID_MinBufSz_Pos 6U /*!< TPI DEVID: MinBufSz Position */
#define TPI_DEVID_MinBufSz_Msk (0x7UL << TPI_DEVID_MinBufSz_Pos) /*!< TPI DEVID: MinBufSz Mask */

#define TPI_DEVID_AsynClkIn_Pos 5U /*!< TPI DEVID: AsynClkIn Position */
#define TPI_DEVID_AsynClkIn_Msk (0x1UL << TPI_DEVID_AsynClkIn_Pos) /*!< TPI DEVID: AsynClkIn Mask */

#define TPI_DEVID_NrTraceInput_Pos 0U /*!< TPI DEVID: NrTraceInput Position */
#define TPI_DEVID_NrTraceInput_Msk (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/) /*!< TPI DEVID: NrTraceInput Mask */

/* TPI DEVTYPE Register Definitions */
#define TPI_DEVTYPE_SubType_Pos 4U /*!< TPI DEVTYPE: SubType Position */
#define TPI_DEVTYPE_SubType_Msk (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/) /*!< TPI DEVTYPE: SubType Mask */

#define TPI_DEVTYPE_MajorType_Pos 0U /*!< TPI DEVTYPE: MajorType Position */
#define TPI_DEVTYPE_MajorType_Msk (0xFUL << TPI_DEVTYPE_MajorType_Pos) /*!< TPI DEVTYPE: MajorType Mask */

/*@}*/ /* end of group CMSIS_TPI */
# 1236 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
/**
  \ingroup  CMSIS_core_register
  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
  \brief    Type definitions for the Core Debug Registers
  @{
 */

/**
  \brief  Structure type to access the Core Debug Register (CoreDebug).
 */
typedef struct
{
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t DHCSR; /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
  volatile /*! Defines 'write only' structure member permissions */ uint32_t DCRSR; /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t DCRDR; /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
  volatile /*! Defines 'read / write' structure member permissions */ uint32_t DEMCR; /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
} CoreDebug_Type;

/* Debug Halting Control and Status Register Definitions */
#define CoreDebug_DHCSR_DBGKEY_Pos 16U /*!< CoreDebug DHCSR: DBGKEY Position */
#define CoreDebug_DHCSR_DBGKEY_Msk (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos) /*!< CoreDebug DHCSR: DBGKEY Mask */

#define CoreDebug_DHCSR_S_RESET_ST_Pos 25U /*!< CoreDebug DHCSR: S_RESET_ST Position */
#define CoreDebug_DHCSR_S_RESET_ST_Msk (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos) /*!< CoreDebug DHCSR: S_RESET_ST Mask */

#define CoreDebug_DHCSR_S_RETIRE_ST_Pos 24U /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
#define CoreDebug_DHCSR_S_RETIRE_ST_Msk (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos) /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */

#define CoreDebug_DHCSR_S_LOCKUP_Pos 19U /*!< CoreDebug DHCSR: S_LOCKUP Position */
#define CoreDebug_DHCSR_S_LOCKUP_Msk (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos) /*!< CoreDebug DHCSR: S_LOCKUP Mask */

#define CoreDebug_DHCSR_S_SLEEP_Pos 18U /*!< CoreDebug DHCSR: S_SLEEP Position */
#define CoreDebug_DHCSR_S_SLEEP_Msk (1UL << CoreDebug_DHCSR_S_SLEEP_Pos) /*!< CoreDebug DHCSR: S_SLEEP Mask */

#define CoreDebug_DHCSR_S_HALT_Pos 17U /*!< CoreDebug DHCSR: S_HALT Position */
#define CoreDebug_DHCSR_S_HALT_Msk (1UL << CoreDebug_DHCSR_S_HALT_Pos) /*!< CoreDebug DHCSR: S_HALT Mask */

#define CoreDebug_DHCSR_S_REGRDY_Pos 16U /*!< CoreDebug DHCSR: S_REGRDY Position */
#define CoreDebug_DHCSR_S_REGRDY_Msk (1UL << CoreDebug_DHCSR_S_REGRDY_Pos) /*!< CoreDebug DHCSR: S_REGRDY Mask */

#define CoreDebug_DHCSR_C_SNAPSTALL_Pos 5U /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
#define CoreDebug_DHCSR_C_SNAPSTALL_Msk (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos) /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */

#define CoreDebug_DHCSR_C_MASKINTS_Pos 3U /*!< CoreDebug DHCSR: C_MASKINTS Position */
#define CoreDebug_DHCSR_C_MASKINTS_Msk (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos) /*!< CoreDebug DHCSR: C_MASKINTS Mask */

#define CoreDebug_DHCSR_C_STEP_Pos 2U /*!< CoreDebug DHCSR: C_STEP Position */
#define CoreDebug_DHCSR_C_STEP_Msk (1UL << CoreDebug_DHCSR_C_STEP_Pos) /*!< CoreDebug DHCSR: C_STEP Mask */

#define CoreDebug_DHCSR_C_HALT_Pos 1U /*!< CoreDebug DHCSR: C_HALT Position */
#define CoreDebug_DHCSR_C_HALT_Msk (1UL << CoreDebug_DHCSR_C_HALT_Pos) /*!< CoreDebug DHCSR: C_HALT Mask */

#define CoreDebug_DHCSR_C_DEBUGEN_Pos 0U /*!< CoreDebug DHCSR: C_DEBUGEN Position */
#define CoreDebug_DHCSR_C_DEBUGEN_Msk (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/) /*!< CoreDebug DHCSR: C_DEBUGEN Mask */

/* Debug Core Register Selector Register Definitions */
#define CoreDebug_DCRSR_REGWnR_Pos 16U /*!< CoreDebug DCRSR: REGWnR Position */
#define CoreDebug_DCRSR_REGWnR_Msk (1UL << CoreDebug_DCRSR_REGWnR_Pos) /*!< CoreDebug DCRSR: REGWnR Mask */

#define CoreDebug_DCRSR_REGSEL_Pos 0U /*!< CoreDebug DCRSR: REGSEL Position */
#define CoreDebug_DCRSR_REGSEL_Msk (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/) /*!< CoreDebug DCRSR: REGSEL Mask */

/* Debug Exception and Monitor Control Register Definitions */
#define CoreDebug_DEMCR_TRCENA_Pos 24U /*!< CoreDebug DEMCR: TRCENA Position */
#define CoreDebug_DEMCR_TRCENA_Msk (1UL << CoreDebug_DEMCR_TRCENA_Pos) /*!< CoreDebug DEMCR: TRCENA Mask */

#define CoreDebug_DEMCR_MON_REQ_Pos 19U /*!< CoreDebug DEMCR: MON_REQ Position */
#define CoreDebug_DEMCR_MON_REQ_Msk (1UL << CoreDebug_DEMCR_MON_REQ_Pos) /*!< CoreDebug DEMCR: MON_REQ Mask */

#define CoreDebug_DEMCR_MON_STEP_Pos 18U /*!< CoreDebug DEMCR: MON_STEP Position */
#define CoreDebug_DEMCR_MON_STEP_Msk (1UL << CoreDebug_DEMCR_MON_STEP_Pos) /*!< CoreDebug DEMCR: MON_STEP Mask */

#define CoreDebug_DEMCR_MON_PEND_Pos 17U /*!< CoreDebug DEMCR: MON_PEND Position */
#define CoreDebug_DEMCR_MON_PEND_Msk (1UL << CoreDebug_DEMCR_MON_PEND_Pos) /*!< CoreDebug DEMCR: MON_PEND Mask */

#define CoreDebug_DEMCR_MON_EN_Pos 16U /*!< CoreDebug DEMCR: MON_EN Position */
#define CoreDebug_DEMCR_MON_EN_Msk (1UL << CoreDebug_DEMCR_MON_EN_Pos) /*!< CoreDebug DEMCR: MON_EN Mask */

#define CoreDebug_DEMCR_VC_HARDERR_Pos 10U /*!< CoreDebug DEMCR: VC_HARDERR Position */
#define CoreDebug_DEMCR_VC_HARDERR_Msk (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos) /*!< CoreDebug DEMCR: VC_HARDERR Mask */

#define CoreDebug_DEMCR_VC_INTERR_Pos 9U /*!< CoreDebug DEMCR: VC_INTERR Position */
#define CoreDebug_DEMCR_VC_INTERR_Msk (1UL << CoreDebug_DEMCR_VC_INTERR_Pos) /*!< CoreDebug DEMCR: VC_INTERR Mask */

#define CoreDebug_DEMCR_VC_BUSERR_Pos 8U /*!< CoreDebug DEMCR: VC_BUSERR Position */
#define CoreDebug_DEMCR_VC_BUSERR_Msk (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos) /*!< CoreDebug DEMCR: VC_BUSERR Mask */

#define CoreDebug_DEMCR_VC_STATERR_Pos 7U /*!< CoreDebug DEMCR: VC_STATERR Position */
#define CoreDebug_DEMCR_VC_STATERR_Msk (1UL << CoreDebug_DEMCR_VC_STATERR_Pos) /*!< CoreDebug DEMCR: VC_STATERR Mask */

#define CoreDebug_DEMCR_VC_CHKERR_Pos 6U /*!< CoreDebug DEMCR: VC_CHKERR Position */
#define CoreDebug_DEMCR_VC_CHKERR_Msk (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos) /*!< CoreDebug DEMCR: VC_CHKERR Mask */

#define CoreDebug_DEMCR_VC_NOCPERR_Pos 5U /*!< CoreDebug DEMCR: VC_NOCPERR Position */
#define CoreDebug_DEMCR_VC_NOCPERR_Msk (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos) /*!< CoreDebug DEMCR: VC_NOCPERR Mask */

#define CoreDebug_DEMCR_VC_MMERR_Pos 4U /*!< CoreDebug DEMCR: VC_MMERR Position */
#define CoreDebug_DEMCR_VC_MMERR_Msk (1UL << CoreDebug_DEMCR_VC_MMERR_Pos) /*!< CoreDebug DEMCR: VC_MMERR Mask */

#define CoreDebug_DEMCR_VC_CORERESET_Pos 0U /*!< CoreDebug DEMCR: VC_CORERESET Position */
#define CoreDebug_DEMCR_VC_CORERESET_Msk (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/) /*!< CoreDebug DEMCR: VC_CORERESET Mask */

/*@} end of group CMSIS_CoreDebug */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_bitfield     Core register bit field macros
  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
  @{
 */

/**
  \brief   Mask and shift a bit field value for use in a register bit range.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted value.
*/
#define _VAL2FLD(field,value) (((uint32_t)(value) << field ## _Pos) & field ## _Msk)

/**
  \brief     Mask and shift a register value to extract a bit filed value.
  \param[in] field  Name of the register bit field.
  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
  \return           Masked and shifted bit field value.
*/
#define _FLD2VAL(field,value) (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)

/*@} end of group CMSIS_core_bitfield */


/**
  \ingroup    CMSIS_core_register
  \defgroup   CMSIS_core_base     Core Definitions
  \brief      Definitions for base addresses, unions, and structures.
  @{
 */

/* Memory mapping of Core Hardware */
#define SCS_BASE (0xE000E000UL) /*!< System Control Space Base Address */
#define ITM_BASE (0xE0000000UL) /*!< ITM Base Address */
#define DWT_BASE (0xE0001000UL) /*!< DWT Base Address */
#define TPI_BASE (0xE0040000UL) /*!< TPI Base Address */
#define CoreDebug_BASE (0xE000EDF0UL) /*!< Core Debug Base Address */
#define SysTick_BASE (SCS_BASE + 0x0010UL) /*!< SysTick Base Address */
#define NVIC_BASE (SCS_BASE + 0x0100UL) /*!< NVIC Base Address */
#define SCB_BASE (SCS_BASE + 0x0D00UL) /*!< System Control Block Base Address */

#define SCnSCB ((SCnSCB_Type *) SCS_BASE ) /*!< System control Register not in SCB */
#define SCB ((SCB_Type *) SCB_BASE ) /*!< SCB configuration struct */
#define SysTick ((SysTick_Type *) SysTick_BASE ) /*!< SysTick configuration struct */
#define NVIC ((NVIC_Type *) NVIC_BASE ) /*!< NVIC configuration struct */
#define ITM ((ITM_Type *) ITM_BASE ) /*!< ITM configuration struct */
#define DWT ((DWT_Type *) DWT_BASE ) /*!< DWT configuration struct */
#define TPI ((TPI_Type *) TPI_BASE ) /*!< TPI configuration struct */
#define CoreDebug ((CoreDebug_Type *) CoreDebug_BASE) /*!< Core Debug configuration struct */






/*@} */



/*******************************************************************************
 *                Hardware Abstraction Layer
  Core Function Interface contains:
  - Core NVIC Functions
  - Core SysTick Functions
  - Core Debug Functions
  - Core Register Access Functions
 ******************************************************************************/
/**
  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
*/



/* ##########################   NVIC functions  #################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
  \brief    Functions that manage interrupts and exceptions via the NVIC.
  @{
 */







#define NVIC_SetPriorityGrouping __NVIC_SetPriorityGrouping
#define NVIC_GetPriorityGrouping __NVIC_GetPriorityGrouping
#define NVIC_EnableIRQ __NVIC_EnableIRQ
#define NVIC_GetEnableIRQ __NVIC_GetEnableIRQ
#define NVIC_DisableIRQ __NVIC_DisableIRQ
#define NVIC_GetPendingIRQ __NVIC_GetPendingIRQ
#define NVIC_SetPendingIRQ __NVIC_SetPendingIRQ
#define NVIC_ClearPendingIRQ __NVIC_ClearPendingIRQ
#define NVIC_GetActive __NVIC_GetActive
#define NVIC_SetPriority __NVIC_SetPriority
#define NVIC_GetPriority __NVIC_GetPriority
#define NVIC_SystemReset __NVIC_SystemReset
# 1450 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
#define NVIC_SetVector __NVIC_SetVector
#define NVIC_GetVector __NVIC_GetVector


#define NVIC_USER_IRQ_OFFSET 16


/* The following EXC_RETURN values are saved the LR on exception entry */
#define EXC_RETURN_HANDLER (0xFFFFFFF1UL) /* return to Handler mode, uses MSP after return                               */
#define EXC_RETURN_THREAD_MSP (0xFFFFFFF9UL) /* return to Thread mode, uses MSP after return                                */
#define EXC_RETURN_THREAD_PSP (0xFFFFFFFDUL) /* return to Thread mode, uses PSP after return                                */


/**
  \brief   Set Priority Grouping
  \details Sets the priority grouping field using the required unlock sequence.
           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
           Only values from 0..7 are used.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
static inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL); /* only values 0..7 are used          */

  reg_value = ((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->AIRCR; /* read old register configuration    */
  reg_value &= ~((uint32_t)((0xFFFFUL << 16U /*!< SCB AIRCR: VECTKEY Position */) /*!< SCB AIRCR: VECTKEY Mask */ | (7UL << 8U /*!< SCB AIRCR: PRIGROUP Position */) /*!< SCB AIRCR: PRIGROUP Mask */)); /* clear bits to change               */
  reg_value = (reg_value |
                ((uint32_t)0x5FAUL << 16U /*!< SCB AIRCR: VECTKEY Position */) |
                (PriorityGroupTmp << 8U /*!< SCB AIRCR: PRIGROUP Position */) ); /* Insert write key and priority group */
  ((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->AIRCR = reg_value;
}


/**
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
static inline uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->AIRCR & (7UL << 8U /*!< SCB AIRCR: PRIGROUP Position */) /*!< SCB AIRCR: PRIGROUP Mask */) >> 8U /*!< SCB AIRCR: PRIGROUP Position */));
}


/**
  \brief   Enable Interrupt
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Get Interrupt Enable status
  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt is not enabled.
  \return             1  Interrupt is enabled.
  \note    IRQn must not be negative.
 */
static inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Disable Interrupt
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    __DSB();
    __ISB();
  }
}


/**
  \brief   Get Pending Interrupt
  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not pending.
  \return             1  Interrupt status is pending.
  \note    IRQn must not be negative.
 */
static inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Set Pending Interrupt
  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Clear Pending Interrupt
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
static inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  }
}


/**
  \brief   Get Active Interrupt
  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
  \param [in]      IRQn  Device specific interrupt number.
  \return             0  Interrupt status is not active.
  \return             1  Interrupt status is active.
  \note    IRQn must not be negative.
 */
static inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
  }
  else
  {
    return(0U);
  }
}


/**
  \brief   Set Interrupt Priority
  \details Sets the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
static inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    ((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->IP[((uint32_t)IRQn)] = (uint8_t)((priority << (8U - 4U /*!< STM32 uses 4 Bits for the Priority Levels    */)) & (uint32_t)0xFFUL);
  }
  else
  {
    ((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 4U /*!< STM32 uses 4 Bits for the Priority Levels    */)) & (uint32_t)0xFFUL);
  }
}


/**
  \brief   Get Interrupt Priority
  \details Reads the priority of a device specific interrupt or a processor exception.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn  Interrupt number.
  \return             Interrupt Priority.
                      Value is aligned automatically to the implemented priority bits of the microcontroller.
 */
static inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
{

  if ((int32_t)(IRQn) >= 0)
  {
    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0100UL) /*!< NVIC Base Address */ ) /*!< NVIC configuration struct */->IP[((uint32_t)IRQn)] >> (8U - 4U /*!< STM32 uses 4 Bits for the Priority Levels    */)));
  }
  else
  {
    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - 4U /*!< STM32 uses 4 Bits for the Priority Levels    */)));
  }
}


/**
  \brief   Encode Priority
  \details Encodes the priority for an interrupt with the given priority group,
           preemptive priority value, and subpriority value.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]     PriorityGroup  Used priority group.
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
static inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL); /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */)) ? (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits = ((PriorityGroupTmp + (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority & (uint32_t)((1UL << (SubPriorityBits )) - 1UL)))
         );
}


/**
  \brief   Decode Priority
  \details Decodes an interrupt priority value with a given priority group to
           preemptive priority value and subpriority value.
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
  \param [in]     PriorityGroup  Used priority group.
  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
  \param [out]     pSubPriority  Subpriority value (starting from 0).
 */
static inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL); /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */)) ? (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits = ((PriorityGroupTmp + (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4U /*!< STM32 uses 4 Bits for the Priority Levels    */));

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
  *pSubPriority = (Priority ) & (uint32_t)((1UL << (SubPriorityBits )) - 1UL);
}


/**
  \brief   Set Interrupt Vector
  \details Sets an interrupt vector in SRAM based interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
           VTOR must been relocated to SRAM before.
  \param [in]   IRQn      Interrupt number
  \param [in]   vector    Address of interrupt handler function
 */
static inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
{
  uint32_t vectors = (uint32_t )((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->VTOR;
  (* (int *) (vectors + ((int32_t)IRQn + 16) * 4)) = vector;
}


/**
  \brief   Get Interrupt Vector
  \details Reads an interrupt vector from interrupt vector table.
           The interrupt number can be positive to specify a device specific interrupt,
           or negative to specify a processor exception.
  \param [in]   IRQn      Interrupt number.
  \return                 Address of interrupt handler function
 */
static inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
{
  uint32_t vectors = (uint32_t )((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->VTOR;
  return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + 16) * 4));
}


/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__attribute__((__noreturn__)) static inline void __NVIC_SystemReset(void)
{
  __DSB(); /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  ((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->AIRCR = (uint32_t)((0x5FAUL << 16U /*!< SCB AIRCR: VECTKEY Position */) |
                           (((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->AIRCR & (7UL << 8U /*!< SCB AIRCR: PRIGROUP Position */) /*!< SCB AIRCR: PRIGROUP Mask */) |
                            (1UL << 2U /*!< SCB AIRCR: SYSRESETREQ Position */) /*!< SCB AIRCR: SYSRESETREQ Mask */ ); /* Keep priority group unchanged */
  __DSB(); /* Ensure completion of memory access */

  for(;;) /* wait until reset */
  {
    __asm volatile ("nop");
  }
}

/*@} end of CMSIS_Core_NVICFunctions */

/* ##########################  MPU functions  #################################### */
# 1780 "repos/apache-mynewt-core/hw/cmsis-core/src/ext/core_cm3.h"
/* ##########################  FPU functions  #################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_FpuFunctions FPU Functions
  \brief    Function that provides FPU type.
  @{
 */

/**
  \brief   get FPU type
  \details returns the FPU type
  \returns
   - \b  0: No FPU
   - \b  1: Single precision FPU
   - \b  2: Double + Single precision FPU
 */
static inline uint32_t SCB_GetFPUType(void)
{
    return 0U; /* No FPU */
}


/*@} end of CMSIS_Core_FpuFunctions */



/* ##################################    SysTick function  ############################################ */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
  \brief    Functions that configure the System.
  @{
 */



/**
  \brief   System Tick Configuration
  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
           Counter is in free running mode to generate periodic interrupts.
  \param [in]  ticks  Number of ticks between two interrupts.
  \return          0  Function succeeded.
  \return          1  Function failed.
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
static inline uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/) /*!< SysTick LOAD: RELOAD Mask */)
  {
    return (1UL); /* Reload value impossible */
  }

  ((SysTick_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0010UL) /*!< SysTick Base Address */ ) /*!< SysTick configuration struct */->LOAD = (uint32_t)(ticks - 1UL); /* set reload register */
  __NVIC_SetPriority (SysTick_IRQn, (1UL << 4U /*!< STM32 uses 4 Bits for the Priority Levels    */) - 1UL); /* set Priority for Systick Interrupt */
  ((SysTick_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0010UL) /*!< SysTick Base Address */ ) /*!< SysTick configuration struct */->VAL = 0UL; /* Load the SysTick Counter Value */
  ((SysTick_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0010UL) /*!< SysTick Base Address */ ) /*!< SysTick configuration struct */->CTRL = (1UL << 2U /*!< SysTick CTRL: CLKSOURCE Position */) /*!< SysTick CTRL: CLKSOURCE Mask */ |
                   (1UL << 1U /*!< SysTick CTRL: TICKINT Position */) /*!< SysTick CTRL: TICKINT Mask */ |
                   (1UL /*<< SysTick_CTRL_ENABLE_Pos*/) /*!< SysTick CTRL: ENABLE Mask */; /* Enable SysTick IRQ and SysTick Timer */
  return (0UL); /* Function successful */
}



/*@} end of CMSIS_Core_SysTickFunctions */



/* ##################################### Debug In/Output function ########################################### */
/**
  \ingroup  CMSIS_Core_FunctionInterface
  \defgroup CMSIS_core_DebugFunctions ITM Functions
  \brief    Functions that access the ITM debug interface.
  @{
 */

extern volatile int32_t ITM_RxBuffer; /*!< External variable to receive characters. */
#define ITM_RXBUFFER_EMPTY ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */


/**
  \brief   ITM Send Character
  \details Transmits a character via the ITM channel 0, and
           \li Just returns when no debugger is connected that has booked the output.
           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
  \param [in]     ch  Character to transmit.
  \returns            Character to transmit.
 */
static inline uint32_t ITM_SendChar (uint32_t ch)
{
  if (((((ITM_Type *) (0xE0000000UL) /*!< ITM Base Address */ ) /*!< ITM configuration struct */->TCR & (1UL /*<< ITM_TCR_ITMENA_Pos*/) /*!< ITM TCR: ITM Enable bit Mask */) != 0UL) && /* ITM enabled */
      ((((ITM_Type *) (0xE0000000UL) /*!< ITM Base Address */ ) /*!< ITM configuration struct */->TER & 1UL ) != 0UL) ) /* ITM Port #0 enabled */
  {
    while (((ITM_Type *) (0xE0000000UL) /*!< ITM Base Address */ ) /*!< ITM configuration struct */->PORT[0U].u32 == 0UL)
    {
      __asm volatile ("nop");
    }
    ((ITM_Type *) (0xE0000000UL) /*!< ITM Base Address */ ) /*!< ITM configuration struct */->PORT[0U].u8 = (uint8_t)ch;
  }
  return (ch);
}


/**
  \brief   ITM Receive Character
  \details Inputs a character via the external variable \ref ITM_RxBuffer.
  \return             Received character.
  \return         -1  No character pending.
 */
static inline int32_t ITM_ReceiveChar (void)
{
  int32_t ch = -1; /* no character available */

  if (ITM_RxBuffer != ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */)
  {
    ch = ITM_RxBuffer;
    ITM_RxBuffer = ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */; /* ready for next character */
  }

  return (ch);
}


/**
  \brief   ITM Check Character
  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
  \return          0  No character available.
  \return          1  Character available.
 */
static inline int32_t ITM_CheckChar (void)
{

  if (ITM_RxBuffer == ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */)
  {
    return (0); /* no character available */
  }
  else
  {
    return (1); /*    character available */
  }
}

/*@} end of CMSIS_core_DebugFunctions */
# 151 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h" 2
# 1 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h" 1
/**

  ******************************************************************************

  * @file    system_stm32f10x.h

  * @author  MCD Application Team

  * @version V4.2.0

  * @date    31-March-2017

  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.

  ******************************************************************************

  * @attention

  *

  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>

  *

  * Redistribution and use in source and binary forms, with or without modification,

  * are permitted provided that the following conditions are met:

  *   1. Redistributions of source code must retain the above copyright notice,

  *      this list of conditions and the following disclaimer.

  *   2. Redistributions in binary form must reproduce the above copyright notice,

  *      this list of conditions and the following disclaimer in the documentation

  *      and/or other materials provided with the distribution.

  *   3. Neither the name of STMicroelectronics nor the names of its contributors

  *      may be used to endorse or promote products derived from this software

  *      without specific prior written permission.

  *

  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE

  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR

  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER

  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,

  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  *

  ******************************************************************************

  */
# 38 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/** @addtogroup CMSIS

  * @{

  */
# 42 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/** @addtogroup stm32f10x_system

  * @{

  */
# 46 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/**

  * @brief Define to prevent recursive inclusion

  */
# 50 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
#define __SYSTEM_STM32F10X_H 





/** @addtogroup STM32F10x_System_Includes

  * @{

  */
# 60 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/**

  * @}

  */
/** @addtogroup STM32F10x_System_Exported_types

  * @{

  */
# 69 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
extern uint32_t SystemCoreClock; /*!< System Clock Frequency (Core Clock) */
extern const uint8_t AHBPrescTable[16U]; /*!< AHB prescalers table values */
extern const uint8_t APBPrescTable[8U]; /*!< APB prescalers table values */

/**

  * @}

  */
# 77 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/** @addtogroup STM32F10x_System_Exported_Constants

  * @{

  */
# 81 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/**

  * @}

  */
# 85 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/** @addtogroup STM32F10x_System_Exported_Macros

  * @{

  */
# 89 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/**

  * @}

  */
# 93 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/** @addtogroup STM32F10x_System_Exported_Functions

  * @{

  */
# 97 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
extern void SystemInit(void);
extern void SystemCoreClockUpdate(void);
/**

  * @}

  */





/**

  * @}

  */
# 113 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/**

  * @}

  */
# 116 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
# 152 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h" 2


/** @addtogroup Peripheral_registers_structures

  * @{

  */
# 158 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** 

  * @brief Analog to Digital Converter  

  */
# 162 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SMPR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SMPR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JOFR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JOFR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JOFR3;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JOFR4;
  volatile /*!< Defines 'read / write' permissions */ uint32_t HTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t LTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SQR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SQR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SQR3;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JSQR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JDR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JDR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JDR3;
  volatile /*!< Defines 'read / write' permissions */ uint32_t JDR4;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR;
} ADC_TypeDef;

typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR; /*!< ADC status register,    used for ADC multimode (bits common to several ADC instances). Address offset: ADC1 base address         */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR1; /*!< ADC control register 1, used for ADC multimode (bits common to several ADC instances). Address offset: ADC1 base address + 0x04  */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR2; /*!< ADC control register 2, used for ADC multimode (bits common to several ADC instances). Address offset: ADC1 base address + 0x08  */
  uint32_t RESERVED[16];
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR; /*!< ADC data register,      used for ADC multimode (bits common to several ADC instances). Address offset: ADC1 base address + 0x4C  */
} ADC_Common_TypeDef;

/** 

  * @brief Backup Registers  

  */
# 199 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  uint32_t RESERVED0;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR3;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR4;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR5;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR6;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR7;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR8;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR9;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR10;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RTCCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CSR;
} BKP_TypeDef;

/** 

  * @brief Controller Area Network TxMailBox 

  */
# 221 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t TIR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t TDTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t TDLR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t TDHR;
} CAN_TxMailBox_TypeDef;

/** 

  * @brief Controller Area Network FIFOMailBox 

  */
# 233 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t RIR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RDTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RDLR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RDHR;
} CAN_FIFOMailBox_TypeDef;

/** 

  * @brief Controller Area Network FilterRegister 

  */
# 245 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t FR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t FR2;
} CAN_FilterRegister_TypeDef;

/** 

  * @brief Controller Area Network 

  */
# 255 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t MCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t MSR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t TSR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RF0R;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RF1R;
  volatile /*!< Defines 'read / write' permissions */ uint32_t IER;
  volatile /*!< Defines 'read / write' permissions */ uint32_t ESR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t BTR;
  uint32_t RESERVED0[88];
  CAN_TxMailBox_TypeDef sTxMailBox[3];
  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
  uint32_t RESERVED1[12];
  volatile /*!< Defines 'read / write' permissions */ uint32_t FMR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t FM1R;
  uint32_t RESERVED2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t FS1R;
  uint32_t RESERVED3;
  volatile /*!< Defines 'read / write' permissions */ uint32_t FFA1R;
  uint32_t RESERVED4;
  volatile /*!< Defines 'read / write' permissions */ uint32_t FA1R;
  uint32_t RESERVED5[8];
  CAN_FilterRegister_TypeDef sFilterRegister[14];
} CAN_TypeDef;

/** 

  * @brief CRC calculation unit 

  */
# 285 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR; /*!< CRC Data register,                           Address offset: 0x00 */
  volatile /*!< Defines 'read / write' permissions */ uint8_t IDR; /*!< CRC Independent data register,               Address offset: 0x04 */
  uint8_t RESERVED0; /*!< Reserved,                                    Address offset: 0x05 */
  uint16_t RESERVED1; /*!< Reserved,                                    Address offset: 0x06 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR; /*!< CRC Control register,                        Address offset: 0x08 */
} CRC_TypeDef;


/** 

  * @brief Debug MCU

  */
# 299 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t IDCODE;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR;
}DBGMCU_TypeDef;

/** 

  * @brief DMA Controller

  */
# 309 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CNDTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CPAR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CMAR;
} DMA_Channel_TypeDef;

typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t ISR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t IFCR;
} DMA_TypeDef;



/** 

  * @brief External Interrupt/Event Controller

  */
# 329 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t IMR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t EMR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RTSR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t FTSR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SWIER;
  volatile /*!< Defines 'read / write' permissions */ uint32_t PR;
} EXTI_TypeDef;

/** 

  * @brief FLASH Registers

  */
# 343 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t ACR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t KEYR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t OPTKEYR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t AR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RESERVED;
  volatile /*!< Defines 'read / write' permissions */ uint32_t OBR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t WRPR;
} FLASH_TypeDef;

/** 

  * @brief Option Bytes Registers

  */
# 360 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint16_t RDP;
  volatile /*!< Defines 'read / write' permissions */ uint16_t USER;
  volatile /*!< Defines 'read / write' permissions */ uint16_t Data0;
  volatile /*!< Defines 'read / write' permissions */ uint16_t Data1;
  volatile /*!< Defines 'read / write' permissions */ uint16_t WRP0;
  volatile /*!< Defines 'read / write' permissions */ uint16_t WRP1;
  volatile /*!< Defines 'read / write' permissions */ uint16_t WRP2;
  volatile /*!< Defines 'read / write' permissions */ uint16_t WRP3;
} OB_TypeDef;

/** 

  * @brief General Purpose I/O

  */
# 376 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CRL;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CRH;
  volatile /*!< Defines 'read / write' permissions */ uint32_t IDR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t ODR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t BSRR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t BRR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t LCKR;
} GPIO_TypeDef;

/** 

  * @brief Alternate Function I/O

  */
# 391 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t EVCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t MAPR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t EXTICR[4];
  uint32_t RESERVED0;
  volatile /*!< Defines 'read / write' permissions */ uint32_t MAPR2;
} AFIO_TypeDef;
/** 

  * @brief Inter Integrated Circuit Interface

  */
# 403 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t OAR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t OAR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t TRISE;
} I2C_TypeDef;

/** 

  * @brief Independent WATCHDOG

  */
# 420 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t KR; /*!< Key register,                                Address offset: 0x00 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t PR; /*!< Prescaler register,                          Address offset: 0x04 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t RLR; /*!< Reload register,                             Address offset: 0x08 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR; /*!< Status register,                             Address offset: 0x0C */
} IWDG_TypeDef;

/** 

  * @brief Power Control

  */
# 432 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CSR;
} PWR_TypeDef;

/** 

  * @brief Reset and Clock Control

  */
# 442 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CFGR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CIR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t APB2RSTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t APB1RSTR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t AHBENR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t APB2ENR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t APB1ENR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t BDCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CSR;


} RCC_TypeDef;

/** 

  * @brief Real-Time Clock

  */
# 462 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CRH;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CRL;
  volatile /*!< Defines 'read / write' permissions */ uint32_t PRLH;
  volatile /*!< Defines 'read / write' permissions */ uint32_t PRLL;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DIVH;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DIVL;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CNTH;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CNTL;
  volatile /*!< Defines 'read / write' permissions */ uint32_t ALRH;
  volatile /*!< Defines 'read / write' permissions */ uint32_t ALRL;
} RTC_TypeDef;

/** 

  * @brief SD host Interface

  */
# 480 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t POWER;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CLKCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t ARG;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CMD;
  volatile const /*!< Defines 'read only' permissions */ uint32_t RESPCMD;
  volatile const /*!< Defines 'read only' permissions */ uint32_t RESP1;
  volatile const /*!< Defines 'read only' permissions */ uint32_t RESP2;
  volatile const /*!< Defines 'read only' permissions */ uint32_t RESP3;
  volatile const /*!< Defines 'read only' permissions */ uint32_t RESP4;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DTIMER;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DLEN;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DCTRL;
  volatile const /*!< Defines 'read only' permissions */ uint32_t DCOUNT;
  volatile const /*!< Defines 'read only' permissions */ uint32_t STA;
  volatile /*!< Defines 'read / write' permissions */ uint32_t ICR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t MASK;
  uint32_t RESERVED0[2];
  volatile const /*!< Defines 'read only' permissions */ uint32_t FIFOCNT;
  uint32_t RESERVED1[13];
  volatile /*!< Defines 'read / write' permissions */ uint32_t FIFO;
} SDIO_TypeDef;

/** 

  * @brief Serial Peripheral Interface

  */
# 508 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR1;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR2;
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t CRCPR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t RXCRCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t TXCRCR;
  volatile /*!< Defines 'read / write' permissions */ uint32_t I2SCFGR;
} SPI_TypeDef;

/**

  * @brief TIM Timers

  */
# 523 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR1; /*!< TIM control register 1,                      Address offset: 0x00 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR2; /*!< TIM control register 2,                      Address offset: 0x04 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t SMCR; /*!< TIM slave Mode Control register,             Address offset: 0x08 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t DIER; /*!< TIM DMA/interrupt enable register,           Address offset: 0x0C */
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR; /*!< TIM status register,                         Address offset: 0x10 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t EGR; /*!< TIM event generation register,               Address offset: 0x14 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCMR1; /*!< TIM  capture/compare mode register 1,        Address offset: 0x18 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCMR2; /*!< TIM  capture/compare mode register 2,        Address offset: 0x1C */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCER; /*!< TIM capture/compare enable register,         Address offset: 0x20 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CNT; /*!< TIM counter register,                        Address offset: 0x24 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t PSC; /*!< TIM prescaler register,                      Address offset: 0x28 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t ARR; /*!< TIM auto-reload register,                    Address offset: 0x2C */
  volatile /*!< Defines 'read / write' permissions */ uint32_t RCR; /*!< TIM  repetition counter register,            Address offset: 0x30 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCR1; /*!< TIM capture/compare register 1,              Address offset: 0x34 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCR2; /*!< TIM capture/compare register 2,              Address offset: 0x38 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCR3; /*!< TIM capture/compare register 3,              Address offset: 0x3C */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CCR4; /*!< TIM capture/compare register 4,              Address offset: 0x40 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t BDTR; /*!< TIM break and dead-time register,            Address offset: 0x44 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t DCR; /*!< TIM DMA control register,                    Address offset: 0x48 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t DMAR; /*!< TIM DMA address for full transfer register,  Address offset: 0x4C */
  volatile /*!< Defines 'read / write' permissions */ uint32_t OR; /*!< TIM option register,                         Address offset: 0x50 */
}TIM_TypeDef;


/** 

  * @brief Universal Synchronous Asynchronous Receiver Transmitter

  */
# 553 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR; /*!< USART Status register,                   Address offset: 0x00 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t DR; /*!< USART Data register,                     Address offset: 0x04 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t BRR; /*!< USART Baud rate register,                Address offset: 0x08 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR1; /*!< USART Control register 1,                Address offset: 0x0C */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR2; /*!< USART Control register 2,                Address offset: 0x10 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR3; /*!< USART Control register 3,                Address offset: 0x14 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t GTPR; /*!< USART Guard time and prescaler register, Address offset: 0x18 */
} USART_TypeDef;

/** 

  * @brief Universal Serial Bus Full Speed Device

  */
# 568 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP0R; /*!< USB Endpoint 0 register,                   Address offset: 0x00 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED0; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP1R; /*!< USB Endpoint 1 register,                   Address offset: 0x04 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED1; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP2R; /*!< USB Endpoint 2 register,                   Address offset: 0x08 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED2; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP3R; /*!< USB Endpoint 3 register,                   Address offset: 0x0C */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED3; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP4R; /*!< USB Endpoint 4 register,                   Address offset: 0x10 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED4; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP5R; /*!< USB Endpoint 5 register,                   Address offset: 0x14 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED5; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP6R; /*!< USB Endpoint 6 register,                   Address offset: 0x18 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED6; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t EP7R; /*!< USB Endpoint 7 register,                   Address offset: 0x1C */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED7[17]; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t CNTR; /*!< Control register,                          Address offset: 0x40 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED8; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t ISTR; /*!< Interrupt status register,                 Address offset: 0x44 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVED9; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t FNR; /*!< Frame number register,                     Address offset: 0x48 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVEDA; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t DADDR; /*!< Device address register,                   Address offset: 0x4C */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVEDB; /*!< Reserved */
  volatile /*!< Defines 'read / write' permissions */ uint16_t BTABLE; /*!< Buffer Table address register,             Address offset: 0x50 */
  volatile /*!< Defines 'read / write' permissions */ uint16_t RESERVEDC; /*!< Reserved */
} USB_TypeDef;


/** 

  * @brief Window WATCHDOG

  */
# 603 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
typedef struct
{
  volatile /*!< Defines 'read / write' permissions */ uint32_t CR; /*!< WWDG Control register,       Address offset: 0x00 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t CFR; /*!< WWDG Configuration register, Address offset: 0x04 */
  volatile /*!< Defines 'read / write' permissions */ uint32_t SR; /*!< WWDG Status register,        Address offset: 0x08 */
} WWDG_TypeDef;

/**

  * @}

  */
# 614 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup Peripheral_memory_map

  * @{

  */
#define FLASH_BASE 0x08000000U /*!< FLASH base address in the alias region */
#define FLASH_BANK1_END 0x0801FFFFU /*!< FLASH END address of bank1 */
#define SRAM_BASE 0x20000000U /*!< SRAM base address in the alias region */
#define PERIPH_BASE 0x40000000U /*!< Peripheral base address in the alias region */

#define SRAM_BB_BASE 0x22000000U /*!< SRAM base address in the bit-band region */
#define PERIPH_BB_BASE 0x42000000U /*!< Peripheral base address in the bit-band region */


/*!< Peripheral memory map */
#define APB1PERIPH_BASE PERIPH_BASE
#define APB2PERIPH_BASE (PERIPH_BASE + 0x00010000U)
#define AHBPERIPH_BASE (PERIPH_BASE + 0x00020000U)

#define TIM2_BASE (APB1PERIPH_BASE + 0x00000000U)
#define TIM3_BASE (APB1PERIPH_BASE + 0x00000400U)
#define TIM4_BASE (APB1PERIPH_BASE + 0x00000800U)
#define RTC_BASE (APB1PERIPH_BASE + 0x00002800U)
#define WWDG_BASE (APB1PERIPH_BASE + 0x00002C00U)
#define IWDG_BASE (APB1PERIPH_BASE + 0x00003000U)
#define SPI2_BASE (APB1PERIPH_BASE + 0x00003800U)
#define USART2_BASE (APB1PERIPH_BASE + 0x00004400U)
#define USART3_BASE (APB1PERIPH_BASE + 0x00004800U)
#define I2C1_BASE (APB1PERIPH_BASE + 0x00005400U)
#define I2C2_BASE (APB1PERIPH_BASE + 0x5800)
#define CAN1_BASE (APB1PERIPH_BASE + 0x00006400U)
#define BKP_BASE (APB1PERIPH_BASE + 0x00006C00U)
#define PWR_BASE (APB1PERIPH_BASE + 0x00007000U)
#define AFIO_BASE (APB2PERIPH_BASE + 0x00000000U)
#define EXTI_BASE (APB2PERIPH_BASE + 0x00000400U)
#define GPIOA_BASE (APB2PERIPH_BASE + 0x00000800U)
#define GPIOB_BASE (APB2PERIPH_BASE + 0x00000C00U)
#define GPIOC_BASE (APB2PERIPH_BASE + 0x00001000U)
#define GPIOD_BASE (APB2PERIPH_BASE + 0x00001400U)
#define GPIOE_BASE (APB2PERIPH_BASE + 0x00001800U)
#define ADC1_BASE (APB2PERIPH_BASE + 0x00002400U)
#define ADC2_BASE (APB2PERIPH_BASE + 0x00002800U)
#define TIM1_BASE (APB2PERIPH_BASE + 0x00002C00U)
#define SPI1_BASE (APB2PERIPH_BASE + 0x00003000U)
#define USART1_BASE (APB2PERIPH_BASE + 0x00003800U)

#define SDIO_BASE (PERIPH_BASE + 0x00018000U)

#define DMA1_BASE (AHBPERIPH_BASE + 0x00000000U)
#define DMA1_Channel1_BASE (AHBPERIPH_BASE + 0x00000008U)
#define DMA1_Channel2_BASE (AHBPERIPH_BASE + 0x0000001CU)
#define DMA1_Channel3_BASE (AHBPERIPH_BASE + 0x00000030U)
#define DMA1_Channel4_BASE (AHBPERIPH_BASE + 0x00000044U)
#define DMA1_Channel5_BASE (AHBPERIPH_BASE + 0x00000058U)
#define DMA1_Channel6_BASE (AHBPERIPH_BASE + 0x0000006CU)
#define DMA1_Channel7_BASE (AHBPERIPH_BASE + 0x00000080U)
#define RCC_BASE (AHBPERIPH_BASE + 0x00001000U)
#define CRC_BASE (AHBPERIPH_BASE + 0x00003000U)

#define FLASH_R_BASE (AHBPERIPH_BASE + 0x00002000U) /*!< Flash registers base address */
#define FLASHSIZE_BASE 0x1FFFF7E0U /*!< FLASH Size register base address */
#define UID_BASE 0x1FFFF7E8U /*!< Unique device ID register base address */
#define OB_BASE 0x1FFFF800U /*!< Flash Option Bytes base address */



#define DBGMCU_BASE 0xE0042000U /*!< Debug MCU registers base address */

/* USB device FS */
#define USB_BASE (APB1PERIPH_BASE + 0x00005C00U) /*!< USB_IP Peripheral Registers base address */
#define USB_PMAADDR (APB1PERIPH_BASE + 0x00006000U) /*!< USB_IP Packet Memory Area base address */


/**

  * @}

  */
# 691 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup Peripheral_declaration

  * @{

  */
# 695 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
#define TIM2 ((TIM_TypeDef *)TIM2_BASE)
#define TIM3 ((TIM_TypeDef *)TIM3_BASE)
#define TIM4 ((TIM_TypeDef *)TIM4_BASE)
#define RTC ((RTC_TypeDef *)RTC_BASE)
#define WWDG ((WWDG_TypeDef *)WWDG_BASE)
#define IWDG ((IWDG_TypeDef *)IWDG_BASE)
#define SPI2 ((SPI_TypeDef *)SPI2_BASE)
#define USART2 ((USART_TypeDef *)USART2_BASE)
#define USART3 ((USART_TypeDef *)USART3_BASE)
#define I2C1 ((I2C_TypeDef *)I2C1_BASE)
#define I2C2 ((I2C_TypeDef *)I2C2_BASE)
#define USB ((USB_TypeDef *)USB_BASE)
#define CAN1 ((CAN_TypeDef *)CAN1_BASE)
#define BKP ((BKP_TypeDef *)BKP_BASE)
#define PWR ((PWR_TypeDef *)PWR_BASE)
#define AFIO ((AFIO_TypeDef *)AFIO_BASE)
#define EXTI ((EXTI_TypeDef *)EXTI_BASE)
#define GPIOA ((GPIO_TypeDef *)GPIOA_BASE)
#define GPIOB ((GPIO_TypeDef *)GPIOB_BASE)
#define GPIOC ((GPIO_TypeDef *)GPIOC_BASE)
#define GPIOD ((GPIO_TypeDef *)GPIOD_BASE)
#define GPIOE ((GPIO_TypeDef *)GPIOE_BASE)
#define ADC1 ((ADC_TypeDef *)ADC1_BASE)
#define ADC2 ((ADC_TypeDef *)ADC2_BASE)
#define ADC12_COMMON ((ADC_Common_TypeDef *)ADC1_BASE)
#define TIM1 ((TIM_TypeDef *)TIM1_BASE)
#define SPI1 ((SPI_TypeDef *)SPI1_BASE)
#define USART1 ((USART_TypeDef *)USART1_BASE)
#define SDIO ((SDIO_TypeDef *)SDIO_BASE)
#define DMA1 ((DMA_TypeDef *)DMA1_BASE)
#define DMA1_Channel1 ((DMA_Channel_TypeDef *)DMA1_Channel1_BASE)
#define DMA1_Channel2 ((DMA_Channel_TypeDef *)DMA1_Channel2_BASE)
#define DMA1_Channel3 ((DMA_Channel_TypeDef *)DMA1_Channel3_BASE)
#define DMA1_Channel4 ((DMA_Channel_TypeDef *)DMA1_Channel4_BASE)
#define DMA1_Channel5 ((DMA_Channel_TypeDef *)DMA1_Channel5_BASE)
#define DMA1_Channel6 ((DMA_Channel_TypeDef *)DMA1_Channel6_BASE)
#define DMA1_Channel7 ((DMA_Channel_TypeDef *)DMA1_Channel7_BASE)
#define RCC ((RCC_TypeDef *)RCC_BASE)
#define CRC ((CRC_TypeDef *)CRC_BASE)
#define FLASH ((FLASH_TypeDef *)FLASH_R_BASE)
#define OB ((OB_TypeDef *)OB_BASE)
#define DBGMCU ((DBGMCU_TypeDef *)DBGMCU_BASE)


/**

  * @}

  */
# 743 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup Exported_constants

  * @{

  */
# 747 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
  /** @addtogroup Peripheral_Registers_Bits_Definition

  * @{

  */
# 751 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/******************************************************************************/
/*                         Peripheral Registers_Bits_Definition               */
/******************************************************************************/

/******************************************************************************/
/*                                                                            */
/*                       CRC calculation unit (CRC)                           */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for CRC_DR register  *********************/
#define CRC_DR_DR_Pos (0U)
#define CRC_DR_DR_Msk (0xFFFFFFFFU << CRC_DR_DR_Pos) /*!< 0xFFFFFFFF */
#define CRC_DR_DR CRC_DR_DR_Msk /*!< Data register bits */

/*******************  Bit definition for CRC_IDR register  ********************/
#define CRC_IDR_IDR_Pos (0U)
#define CRC_IDR_IDR_Msk (0xFFU << CRC_IDR_IDR_Pos) /*!< 0x000000FF */
#define CRC_IDR_IDR CRC_IDR_IDR_Msk /*!< General-purpose 8-bit data register bits */

/********************  Bit definition for CRC_CR register  ********************/
#define CRC_CR_RESET_Pos (0U)
#define CRC_CR_RESET_Msk (0x1U << CRC_CR_RESET_Pos) /*!< 0x00000001 */
#define CRC_CR_RESET CRC_CR_RESET_Msk /*!< RESET bit */

/******************************************************************************/
/*                                                                            */
/*                             Power Control                                  */
/*                                                                            */
/******************************************************************************/

/********************  Bit definition for PWR_CR register  ********************/
#define PWR_CR_LPDS_Pos (0U)
#define PWR_CR_LPDS_Msk (0x1U << PWR_CR_LPDS_Pos) /*!< 0x00000001 */
#define PWR_CR_LPDS PWR_CR_LPDS_Msk /*!< Low-Power Deepsleep */
#define PWR_CR_PDDS_Pos (1U)
#define PWR_CR_PDDS_Msk (0x1U << PWR_CR_PDDS_Pos) /*!< 0x00000002 */
#define PWR_CR_PDDS PWR_CR_PDDS_Msk /*!< Power Down Deepsleep */
#define PWR_CR_CWUF_Pos (2U)
#define PWR_CR_CWUF_Msk (0x1U << PWR_CR_CWUF_Pos) /*!< 0x00000004 */
#define PWR_CR_CWUF PWR_CR_CWUF_Msk /*!< Clear Wakeup Flag */
#define PWR_CR_CSBF_Pos (3U)
#define PWR_CR_CSBF_Msk (0x1U << PWR_CR_CSBF_Pos) /*!< 0x00000008 */
#define PWR_CR_CSBF PWR_CR_CSBF_Msk /*!< Clear Standby Flag */
#define PWR_CR_PVDE_Pos (4U)
#define PWR_CR_PVDE_Msk (0x1U << PWR_CR_PVDE_Pos) /*!< 0x00000010 */
#define PWR_CR_PVDE PWR_CR_PVDE_Msk /*!< Power Voltage Detector Enable */

#define PWR_CR_PLS_Pos (5U)
#define PWR_CR_PLS_Msk (0x7U << PWR_CR_PLS_Pos) /*!< 0x000000E0 */
#define PWR_CR_PLS PWR_CR_PLS_Msk /*!< PLS[2:0] bits (PVD Level Selection) */
#define PWR_CR_PLS_0 (0x1U << PWR_CR_PLS_Pos) /*!< 0x00000020 */
#define PWR_CR_PLS_1 (0x2U << PWR_CR_PLS_Pos) /*!< 0x00000040 */
#define PWR_CR_PLS_2 (0x4U << PWR_CR_PLS_Pos) /*!< 0x00000080 */

/*!< PVD level configuration */
#define PWR_CR_PLS_LEV0 0x00000000U /*!< PVD level 2.2V */
#define PWR_CR_PLS_LEV1 0x00000020U /*!< PVD level 2.3V */
#define PWR_CR_PLS_LEV2 0x00000040U /*!< PVD level 2.4V */
#define PWR_CR_PLS_LEV3 0x00000060U /*!< PVD level 2.5V */
#define PWR_CR_PLS_LEV4 0x00000080U /*!< PVD level 2.6V */
#define PWR_CR_PLS_LEV5 0x000000A0U /*!< PVD level 2.7V */
#define PWR_CR_PLS_LEV6 0x000000C0U /*!< PVD level 2.8V */
#define PWR_CR_PLS_LEV7 0x000000E0U /*!< PVD level 2.9V */

/* Legacy defines */
#define PWR_CR_PLS_2V2 PWR_CR_PLS_LEV0
#define PWR_CR_PLS_2V3 PWR_CR_PLS_LEV1
#define PWR_CR_PLS_2V4 PWR_CR_PLS_LEV2
#define PWR_CR_PLS_2V5 PWR_CR_PLS_LEV3
#define PWR_CR_PLS_2V6 PWR_CR_PLS_LEV4
#define PWR_CR_PLS_2V7 PWR_CR_PLS_LEV5
#define PWR_CR_PLS_2V8 PWR_CR_PLS_LEV6
#define PWR_CR_PLS_2V9 PWR_CR_PLS_LEV7

#define PWR_CR_DBP_Pos (8U)
#define PWR_CR_DBP_Msk (0x1U << PWR_CR_DBP_Pos) /*!< 0x00000100 */
#define PWR_CR_DBP PWR_CR_DBP_Msk /*!< Disable Backup Domain write protection */


/*******************  Bit definition for PWR_CSR register  ********************/
#define PWR_CSR_WUF_Pos (0U)
#define PWR_CSR_WUF_Msk (0x1U << PWR_CSR_WUF_Pos) /*!< 0x00000001 */
#define PWR_CSR_WUF PWR_CSR_WUF_Msk /*!< Wakeup Flag */
#define PWR_CSR_SBF_Pos (1U)
#define PWR_CSR_SBF_Msk (0x1U << PWR_CSR_SBF_Pos) /*!< 0x00000002 */
#define PWR_CSR_SBF PWR_CSR_SBF_Msk /*!< Standby Flag */
#define PWR_CSR_PVDO_Pos (2U)
#define PWR_CSR_PVDO_Msk (0x1U << PWR_CSR_PVDO_Pos) /*!< 0x00000004 */
#define PWR_CSR_PVDO PWR_CSR_PVDO_Msk /*!< PVD Output */
#define PWR_CSR_EWUP_Pos (8U)
#define PWR_CSR_EWUP_Msk (0x1U << PWR_CSR_EWUP_Pos) /*!< 0x00000100 */
#define PWR_CSR_EWUP PWR_CSR_EWUP_Msk /*!< Enable WKUP pin */

/******************************************************************************/
/*                                                                            */
/*                            Backup registers                                */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for BKP_DR1 register  ********************/
#define BKP_DR1_D_Pos (0U)
#define BKP_DR1_D_Msk (0xFFFFU << BKP_DR1_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR1_D BKP_DR1_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR2 register  ********************/
#define BKP_DR2_D_Pos (0U)
#define BKP_DR2_D_Msk (0xFFFFU << BKP_DR2_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR2_D BKP_DR2_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR3 register  ********************/
#define BKP_DR3_D_Pos (0U)
#define BKP_DR3_D_Msk (0xFFFFU << BKP_DR3_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR3_D BKP_DR3_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR4 register  ********************/
#define BKP_DR4_D_Pos (0U)
#define BKP_DR4_D_Msk (0xFFFFU << BKP_DR4_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR4_D BKP_DR4_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR5 register  ********************/
#define BKP_DR5_D_Pos (0U)
#define BKP_DR5_D_Msk (0xFFFFU << BKP_DR5_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR5_D BKP_DR5_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR6 register  ********************/
#define BKP_DR6_D_Pos (0U)
#define BKP_DR6_D_Msk (0xFFFFU << BKP_DR6_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR6_D BKP_DR6_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR7 register  ********************/
#define BKP_DR7_D_Pos (0U)
#define BKP_DR7_D_Msk (0xFFFFU << BKP_DR7_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR7_D BKP_DR7_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR8 register  ********************/
#define BKP_DR8_D_Pos (0U)
#define BKP_DR8_D_Msk (0xFFFFU << BKP_DR8_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR8_D BKP_DR8_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR9 register  ********************/
#define BKP_DR9_D_Pos (0U)
#define BKP_DR9_D_Msk (0xFFFFU << BKP_DR9_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR9_D BKP_DR9_D_Msk /*!< Backup data */

/*******************  Bit definition for BKP_DR10 register  *******************/
#define BKP_DR10_D_Pos (0U)
#define BKP_DR10_D_Msk (0xFFFFU << BKP_DR10_D_Pos) /*!< 0x0000FFFF */
#define BKP_DR10_D BKP_DR10_D_Msk /*!< Backup data */

#define RTC_BKP_NUMBER 10

/******************  Bit definition for BKP_RTCCR register  *******************/
#define BKP_RTCCR_CAL_Pos (0U)
#define BKP_RTCCR_CAL_Msk (0x7FU << BKP_RTCCR_CAL_Pos) /*!< 0x0000007F */
#define BKP_RTCCR_CAL BKP_RTCCR_CAL_Msk /*!< Calibration value */
#define BKP_RTCCR_CCO_Pos (7U)
#define BKP_RTCCR_CCO_Msk (0x1U << BKP_RTCCR_CCO_Pos) /*!< 0x00000080 */
#define BKP_RTCCR_CCO BKP_RTCCR_CCO_Msk /*!< Calibration Clock Output */
#define BKP_RTCCR_ASOE_Pos (8U)
#define BKP_RTCCR_ASOE_Msk (0x1U << BKP_RTCCR_ASOE_Pos) /*!< 0x00000100 */
#define BKP_RTCCR_ASOE BKP_RTCCR_ASOE_Msk /*!< Alarm or Second Output Enable */
#define BKP_RTCCR_ASOS_Pos (9U)
#define BKP_RTCCR_ASOS_Msk (0x1U << BKP_RTCCR_ASOS_Pos) /*!< 0x00000200 */
#define BKP_RTCCR_ASOS BKP_RTCCR_ASOS_Msk /*!< Alarm or Second Output Selection */

/********************  Bit definition for BKP_CR register  ********************/
#define BKP_CR_TPE_Pos (0U)
#define BKP_CR_TPE_Msk (0x1U << BKP_CR_TPE_Pos) /*!< 0x00000001 */
#define BKP_CR_TPE BKP_CR_TPE_Msk /*!< TAMPER pin enable */
#define BKP_CR_TPAL_Pos (1U)
#define BKP_CR_TPAL_Msk (0x1U << BKP_CR_TPAL_Pos) /*!< 0x00000002 */
#define BKP_CR_TPAL BKP_CR_TPAL_Msk /*!< TAMPER pin active level */

/*******************  Bit definition for BKP_CSR register  ********************/
#define BKP_CSR_CTE_Pos (0U)
#define BKP_CSR_CTE_Msk (0x1U << BKP_CSR_CTE_Pos) /*!< 0x00000001 */
#define BKP_CSR_CTE BKP_CSR_CTE_Msk /*!< Clear Tamper event */
#define BKP_CSR_CTI_Pos (1U)
#define BKP_CSR_CTI_Msk (0x1U << BKP_CSR_CTI_Pos) /*!< 0x00000002 */
#define BKP_CSR_CTI BKP_CSR_CTI_Msk /*!< Clear Tamper Interrupt */
#define BKP_CSR_TPIE_Pos (2U)
#define BKP_CSR_TPIE_Msk (0x1U << BKP_CSR_TPIE_Pos) /*!< 0x00000004 */
#define BKP_CSR_TPIE BKP_CSR_TPIE_Msk /*!< TAMPER Pin interrupt enable */
#define BKP_CSR_TEF_Pos (8U)
#define BKP_CSR_TEF_Msk (0x1U << BKP_CSR_TEF_Pos) /*!< 0x00000100 */
#define BKP_CSR_TEF BKP_CSR_TEF_Msk /*!< Tamper Event Flag */
#define BKP_CSR_TIF_Pos (9U)
#define BKP_CSR_TIF_Msk (0x1U << BKP_CSR_TIF_Pos) /*!< 0x00000200 */
#define BKP_CSR_TIF BKP_CSR_TIF_Msk /*!< Tamper Interrupt Flag */

/******************************************************************************/
/*                                                                            */
/*                         Reset and Clock Control                            */
/*                                                                            */
/******************************************************************************/

/********************  Bit definition for RCC_CR register  ********************/
#define RCC_CR_HSION_Pos (0U)
#define RCC_CR_HSION_Msk (0x1U << RCC_CR_HSION_Pos) /*!< 0x00000001 */
#define RCC_CR_HSION RCC_CR_HSION_Msk /*!< Internal High Speed clock enable */
#define RCC_CR_HSIRDY_Pos (1U)
#define RCC_CR_HSIRDY_Msk (0x1U << RCC_CR_HSIRDY_Pos) /*!< 0x00000002 */
#define RCC_CR_HSIRDY RCC_CR_HSIRDY_Msk /*!< Internal High Speed clock ready flag */
#define RCC_CR_HSITRIM_Pos (3U)
#define RCC_CR_HSITRIM_Msk (0x1FU << RCC_CR_HSITRIM_Pos) /*!< 0x000000F8 */
#define RCC_CR_HSITRIM RCC_CR_HSITRIM_Msk /*!< Internal High Speed clock trimming */
#define RCC_CR_HSICAL_Pos (8U)
#define RCC_CR_HSICAL_Msk (0xFFU << RCC_CR_HSICAL_Pos) /*!< 0x0000FF00 */
#define RCC_CR_HSICAL RCC_CR_HSICAL_Msk /*!< Internal High Speed clock Calibration */
#define RCC_CR_HSEON_Pos (16U)
#define RCC_CR_HSEON_Msk (0x1U << RCC_CR_HSEON_Pos) /*!< 0x00010000 */
#define RCC_CR_HSEON RCC_CR_HSEON_Msk /*!< External High Speed clock enable */
#define RCC_CR_HSERDY_Pos (17U)
#define RCC_CR_HSERDY_Msk (0x1U << RCC_CR_HSERDY_Pos) /*!< 0x00020000 */
#define RCC_CR_HSERDY RCC_CR_HSERDY_Msk /*!< External High Speed clock ready flag */
#define RCC_CR_HSEBYP_Pos (18U)
#define RCC_CR_HSEBYP_Msk (0x1U << RCC_CR_HSEBYP_Pos) /*!< 0x00040000 */
#define RCC_CR_HSEBYP RCC_CR_HSEBYP_Msk /*!< External High Speed clock Bypass */
#define RCC_CR_CSSON_Pos (19U)
#define RCC_CR_CSSON_Msk (0x1U << RCC_CR_CSSON_Pos) /*!< 0x00080000 */
#define RCC_CR_CSSON RCC_CR_CSSON_Msk /*!< Clock Security System enable */
#define RCC_CR_PLLON_Pos (24U)
#define RCC_CR_PLLON_Msk (0x1U << RCC_CR_PLLON_Pos) /*!< 0x01000000 */
#define RCC_CR_PLLON RCC_CR_PLLON_Msk /*!< PLL enable */
#define RCC_CR_PLLRDY_Pos (25U)
#define RCC_CR_PLLRDY_Msk (0x1U << RCC_CR_PLLRDY_Pos) /*!< 0x02000000 */
#define RCC_CR_PLLRDY RCC_CR_PLLRDY_Msk /*!< PLL clock ready flag */


/*******************  Bit definition for RCC_CFGR register  *******************/
/*!< SW configuration */
#define RCC_CFGR_SW_Pos (0U)
#define RCC_CFGR_SW_Msk (0x3U << RCC_CFGR_SW_Pos) /*!< 0x00000003 */
#define RCC_CFGR_SW RCC_CFGR_SW_Msk /*!< SW[1:0] bits (System clock Switch) */
#define RCC_CFGR_SW_0 (0x1U << RCC_CFGR_SW_Pos) /*!< 0x00000001 */
#define RCC_CFGR_SW_1 (0x2U << RCC_CFGR_SW_Pos) /*!< 0x00000002 */

#define RCC_CFGR_SW_HSI 0x00000000U /*!< HSI selected as system clock */
#define RCC_CFGR_SW_HSE 0x00000001U /*!< HSE selected as system clock */
#define RCC_CFGR_SW_PLL 0x00000002U /*!< PLL selected as system clock */

/*!< SWS configuration */
#define RCC_CFGR_SWS_Pos (2U)
#define RCC_CFGR_SWS_Msk (0x3U << RCC_CFGR_SWS_Pos) /*!< 0x0000000C */
#define RCC_CFGR_SWS RCC_CFGR_SWS_Msk /*!< SWS[1:0] bits (System Clock Switch Status) */
#define RCC_CFGR_SWS_0 (0x1U << RCC_CFGR_SWS_Pos) /*!< 0x00000004 */
#define RCC_CFGR_SWS_1 (0x2U << RCC_CFGR_SWS_Pos) /*!< 0x00000008 */

#define RCC_CFGR_SWS_HSI 0x00000000U /*!< HSI oscillator used as system clock */
#define RCC_CFGR_SWS_HSE 0x00000004U /*!< HSE oscillator used as system clock */
#define RCC_CFGR_SWS_PLL 0x00000008U /*!< PLL used as system clock */

/*!< HPRE configuration */
#define RCC_CFGR_HPRE_Pos (4U)
#define RCC_CFGR_HPRE_Msk (0xFU << RCC_CFGR_HPRE_Pos) /*!< 0x000000F0 */
#define RCC_CFGR_HPRE RCC_CFGR_HPRE_Msk /*!< HPRE[3:0] bits (AHB prescaler) */
#define RCC_CFGR_HPRE_0 (0x1U << RCC_CFGR_HPRE_Pos) /*!< 0x00000010 */
#define RCC_CFGR_HPRE_1 (0x2U << RCC_CFGR_HPRE_Pos) /*!< 0x00000020 */
#define RCC_CFGR_HPRE_2 (0x4U << RCC_CFGR_HPRE_Pos) /*!< 0x00000040 */
#define RCC_CFGR_HPRE_3 (0x8U << RCC_CFGR_HPRE_Pos) /*!< 0x00000080 */

#define RCC_CFGR_HPRE_DIV1 0x00000000U /*!< SYSCLK not divided */
#define RCC_CFGR_HPRE_DIV2 0x00000080U /*!< SYSCLK divided by 2 */
#define RCC_CFGR_HPRE_DIV4 0x00000090U /*!< SYSCLK divided by 4 */
#define RCC_CFGR_HPRE_DIV8 0x000000A0U /*!< SYSCLK divided by 8 */
#define RCC_CFGR_HPRE_DIV16 0x000000B0U /*!< SYSCLK divided by 16 */
#define RCC_CFGR_HPRE_DIV64 0x000000C0U /*!< SYSCLK divided by 64 */
#define RCC_CFGR_HPRE_DIV128 0x000000D0U /*!< SYSCLK divided by 128 */
#define RCC_CFGR_HPRE_DIV256 0x000000E0U /*!< SYSCLK divided by 256 */
#define RCC_CFGR_HPRE_DIV512 0x000000F0U /*!< SYSCLK divided by 512 */

/*!< PPRE1 configuration */
#define RCC_CFGR_PPRE1_Pos (8U)
#define RCC_CFGR_PPRE1_Msk (0x7U << RCC_CFGR_PPRE1_Pos) /*!< 0x00000700 */
#define RCC_CFGR_PPRE1 RCC_CFGR_PPRE1_Msk /*!< PRE1[2:0] bits (APB1 prescaler) */
#define RCC_CFGR_PPRE1_0 (0x1U << RCC_CFGR_PPRE1_Pos) /*!< 0x00000100 */
#define RCC_CFGR_PPRE1_1 (0x2U << RCC_CFGR_PPRE1_Pos) /*!< 0x00000200 */
#define RCC_CFGR_PPRE1_2 (0x4U << RCC_CFGR_PPRE1_Pos) /*!< 0x00000400 */

#define RCC_CFGR_PPRE1_DIV1 0x00000000U /*!< HCLK not divided */
#define RCC_CFGR_PPRE1_DIV2 0x00000400U /*!< HCLK divided by 2 */
#define RCC_CFGR_PPRE1_DIV4 0x00000500U /*!< HCLK divided by 4 */
#define RCC_CFGR_PPRE1_DIV8 0x00000600U /*!< HCLK divided by 8 */
#define RCC_CFGR_PPRE1_DIV16 0x00000700U /*!< HCLK divided by 16 */

/*!< PPRE2 configuration */
#define RCC_CFGR_PPRE2_Pos (11U)
#define RCC_CFGR_PPRE2_Msk (0x7U << RCC_CFGR_PPRE2_Pos) /*!< 0x00003800 */
#define RCC_CFGR_PPRE2 RCC_CFGR_PPRE2_Msk /*!< PRE2[2:0] bits (APB2 prescaler) */
#define RCC_CFGR_PPRE2_0 (0x1U << RCC_CFGR_PPRE2_Pos) /*!< 0x00000800 */
#define RCC_CFGR_PPRE2_1 (0x2U << RCC_CFGR_PPRE2_Pos) /*!< 0x00001000 */
#define RCC_CFGR_PPRE2_2 (0x4U << RCC_CFGR_PPRE2_Pos) /*!< 0x00002000 */

#define RCC_CFGR_PPRE2_DIV1 0x00000000U /*!< HCLK not divided */
#define RCC_CFGR_PPRE2_DIV2 0x00002000U /*!< HCLK divided by 2 */
#define RCC_CFGR_PPRE2_DIV4 0x00002800U /*!< HCLK divided by 4 */
#define RCC_CFGR_PPRE2_DIV8 0x00003000U /*!< HCLK divided by 8 */
#define RCC_CFGR_PPRE2_DIV16 0x00003800U /*!< HCLK divided by 16 */

/*!< ADCPPRE configuration */
#define RCC_CFGR_ADCPRE_Pos (14U)
#define RCC_CFGR_ADCPRE_Msk (0x3U << RCC_CFGR_ADCPRE_Pos) /*!< 0x0000C000 */
#define RCC_CFGR_ADCPRE RCC_CFGR_ADCPRE_Msk /*!< ADCPRE[1:0] bits (ADC prescaler) */
#define RCC_CFGR_ADCPRE_0 (0x1U << RCC_CFGR_ADCPRE_Pos) /*!< 0x00004000 */
#define RCC_CFGR_ADCPRE_1 (0x2U << RCC_CFGR_ADCPRE_Pos) /*!< 0x00008000 */

#define RCC_CFGR_ADCPRE_DIV2 0x00000000U /*!< PCLK2 divided by 2 */
#define RCC_CFGR_ADCPRE_DIV4 0x00004000U /*!< PCLK2 divided by 4 */
#define RCC_CFGR_ADCPRE_DIV6 0x00008000U /*!< PCLK2 divided by 6 */
#define RCC_CFGR_ADCPRE_DIV8 0x0000C000U /*!< PCLK2 divided by 8 */

#define RCC_CFGR_PLLSRC_Pos (16U)
#define RCC_CFGR_PLLSRC_Msk (0x1U << RCC_CFGR_PLLSRC_Pos) /*!< 0x00010000 */
#define RCC_CFGR_PLLSRC RCC_CFGR_PLLSRC_Msk /*!< PLL entry clock source */

#define RCC_CFGR_PLLXTPRE_Pos (17U)
#define RCC_CFGR_PLLXTPRE_Msk (0x1U << RCC_CFGR_PLLXTPRE_Pos) /*!< 0x00020000 */
#define RCC_CFGR_PLLXTPRE RCC_CFGR_PLLXTPRE_Msk /*!< HSE divider for PLL entry */

/*!< PLLMUL configuration */
#define RCC_CFGR_PLLMULL_Pos (18U)
#define RCC_CFGR_PLLMULL_Msk (0xFU << RCC_CFGR_PLLMULL_Pos) /*!< 0x003C0000 */
#define RCC_CFGR_PLLMULL RCC_CFGR_PLLMULL_Msk /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
#define RCC_CFGR_PLLMULL_0 (0x1U << RCC_CFGR_PLLMULL_Pos) /*!< 0x00040000 */
#define RCC_CFGR_PLLMULL_1 (0x2U << RCC_CFGR_PLLMULL_Pos) /*!< 0x00080000 */
#define RCC_CFGR_PLLMULL_2 (0x4U << RCC_CFGR_PLLMULL_Pos) /*!< 0x00100000 */
#define RCC_CFGR_PLLMULL_3 (0x8U << RCC_CFGR_PLLMULL_Pos) /*!< 0x00200000 */

#define RCC_CFGR_PLLXTPRE_HSE 0x00000000U /*!< HSE clock not divided for PLL entry */
#define RCC_CFGR_PLLXTPRE_HSE_DIV2 0x00020000U /*!< HSE clock divided by 2 for PLL entry */

#define RCC_CFGR_PLLMULL2 0x00000000U /*!< PLL input clock*2 */
#define RCC_CFGR_PLLMULL3_Pos (18U)
#define RCC_CFGR_PLLMULL3_Msk (0x1U << RCC_CFGR_PLLMULL3_Pos) /*!< 0x00040000 */
#define RCC_CFGR_PLLMULL3 RCC_CFGR_PLLMULL3_Msk /*!< PLL input clock*3 */
#define RCC_CFGR_PLLMULL4_Pos (19U)
#define RCC_CFGR_PLLMULL4_Msk (0x1U << RCC_CFGR_PLLMULL4_Pos) /*!< 0x00080000 */
#define RCC_CFGR_PLLMULL4 RCC_CFGR_PLLMULL4_Msk /*!< PLL input clock*4 */
#define RCC_CFGR_PLLMULL5_Pos (18U)
#define RCC_CFGR_PLLMULL5_Msk (0x3U << RCC_CFGR_PLLMULL5_Pos) /*!< 0x000C0000 */
#define RCC_CFGR_PLLMULL5 RCC_CFGR_PLLMULL5_Msk /*!< PLL input clock*5 */
#define RCC_CFGR_PLLMULL6_Pos (20U)
#define RCC_CFGR_PLLMULL6_Msk (0x1U << RCC_CFGR_PLLMULL6_Pos) /*!< 0x00100000 */
#define RCC_CFGR_PLLMULL6 RCC_CFGR_PLLMULL6_Msk /*!< PLL input clock*6 */
#define RCC_CFGR_PLLMULL7_Pos (18U)
#define RCC_CFGR_PLLMULL7_Msk (0x5U << RCC_CFGR_PLLMULL7_Pos) /*!< 0x00140000 */
#define RCC_CFGR_PLLMULL7 RCC_CFGR_PLLMULL7_Msk /*!< PLL input clock*7 */
#define RCC_CFGR_PLLMULL8_Pos (19U)
#define RCC_CFGR_PLLMULL8_Msk (0x3U << RCC_CFGR_PLLMULL8_Pos) /*!< 0x00180000 */
#define RCC_CFGR_PLLMULL8 RCC_CFGR_PLLMULL8_Msk /*!< PLL input clock*8 */
#define RCC_CFGR_PLLMULL9_Pos (18U)
#define RCC_CFGR_PLLMULL9_Msk (0x7U << RCC_CFGR_PLLMULL9_Pos) /*!< 0x001C0000 */
#define RCC_CFGR_PLLMULL9 RCC_CFGR_PLLMULL9_Msk /*!< PLL input clock*9 */
#define RCC_CFGR_PLLMULL10_Pos (21U)
#define RCC_CFGR_PLLMULL10_Msk (0x1U << RCC_CFGR_PLLMULL10_Pos) /*!< 0x00200000 */
#define RCC_CFGR_PLLMULL10 RCC_CFGR_PLLMULL10_Msk /*!< PLL input clock10 */
#define RCC_CFGR_PLLMULL11_Pos (18U)
#define RCC_CFGR_PLLMULL11_Msk (0x9U << RCC_CFGR_PLLMULL11_Pos) /*!< 0x00240000 */
#define RCC_CFGR_PLLMULL11 RCC_CFGR_PLLMULL11_Msk /*!< PLL input clock*11 */
#define RCC_CFGR_PLLMULL12_Pos (19U)
#define RCC_CFGR_PLLMULL12_Msk (0x5U << RCC_CFGR_PLLMULL12_Pos) /*!< 0x00280000 */
#define RCC_CFGR_PLLMULL12 RCC_CFGR_PLLMULL12_Msk /*!< PLL input clock*12 */
#define RCC_CFGR_PLLMULL13_Pos (18U)
#define RCC_CFGR_PLLMULL13_Msk (0xBU << RCC_CFGR_PLLMULL13_Pos) /*!< 0x002C0000 */
#define RCC_CFGR_PLLMULL13 RCC_CFGR_PLLMULL13_Msk /*!< PLL input clock*13 */
#define RCC_CFGR_PLLMULL14_Pos (20U)
#define RCC_CFGR_PLLMULL14_Msk (0x3U << RCC_CFGR_PLLMULL14_Pos) /*!< 0x00300000 */
#define RCC_CFGR_PLLMULL14 RCC_CFGR_PLLMULL14_Msk /*!< PLL input clock*14 */
#define RCC_CFGR_PLLMULL15_Pos (18U)
#define RCC_CFGR_PLLMULL15_Msk (0xDU << RCC_CFGR_PLLMULL15_Pos) /*!< 0x00340000 */
#define RCC_CFGR_PLLMULL15 RCC_CFGR_PLLMULL15_Msk /*!< PLL input clock*15 */
#define RCC_CFGR_PLLMULL16_Pos (19U)
#define RCC_CFGR_PLLMULL16_Msk (0x7U << RCC_CFGR_PLLMULL16_Pos) /*!< 0x00380000 */
#define RCC_CFGR_PLLMULL16 RCC_CFGR_PLLMULL16_Msk /*!< PLL input clock*16 */
#define RCC_CFGR_USBPRE_Pos (22U)
#define RCC_CFGR_USBPRE_Msk (0x1U << RCC_CFGR_USBPRE_Pos) /*!< 0x00400000 */
#define RCC_CFGR_USBPRE RCC_CFGR_USBPRE_Msk /*!< USB Device prescaler */

/*!< MCO configuration */
#define RCC_CFGR_MCO_Pos (24U)
#define RCC_CFGR_MCO_Msk (0x7U << RCC_CFGR_MCO_Pos) /*!< 0x07000000 */
#define RCC_CFGR_MCO RCC_CFGR_MCO_Msk /*!< MCO[2:0] bits (Microcontroller Clock Output) */
#define RCC_CFGR_MCO_0 (0x1U << RCC_CFGR_MCO_Pos) /*!< 0x01000000 */
#define RCC_CFGR_MCO_1 (0x2U << RCC_CFGR_MCO_Pos) /*!< 0x02000000 */
#define RCC_CFGR_MCO_2 (0x4U << RCC_CFGR_MCO_Pos) /*!< 0x04000000 */

#define RCC_CFGR_MCO_NOCLOCK 0x00000000U /*!< No clock */
#define RCC_CFGR_MCO_SYSCLK 0x04000000U /*!< System clock selected as MCO source */
#define RCC_CFGR_MCO_HSI 0x05000000U /*!< HSI clock selected as MCO source */
#define RCC_CFGR_MCO_HSE 0x06000000U /*!< HSE clock selected as MCO source  */
#define RCC_CFGR_MCO_PLLCLK_DIV2 0x07000000U /*!< PLL clock divided by 2 selected as MCO source */

 /* Reference defines */
#define RCC_CFGR_MCOSEL RCC_CFGR_MCO
#define RCC_CFGR_MCOSEL_0 RCC_CFGR_MCO_0
#define RCC_CFGR_MCOSEL_1 RCC_CFGR_MCO_1
#define RCC_CFGR_MCOSEL_2 RCC_CFGR_MCO_2
#define RCC_CFGR_MCOSEL_NOCLOCK RCC_CFGR_MCO_NOCLOCK
#define RCC_CFGR_MCOSEL_SYSCLK RCC_CFGR_MCO_SYSCLK
#define RCC_CFGR_MCOSEL_HSI RCC_CFGR_MCO_HSI
#define RCC_CFGR_MCOSEL_HSE RCC_CFGR_MCO_HSE
#define RCC_CFGR_MCOSEL_PLL_DIV2 RCC_CFGR_MCO_PLLCLK_DIV2

/*!<******************  Bit definition for RCC_CIR register  ********************/
#define RCC_CIR_LSIRDYF_Pos (0U)
#define RCC_CIR_LSIRDYF_Msk (0x1U << RCC_CIR_LSIRDYF_Pos) /*!< 0x00000001 */
#define RCC_CIR_LSIRDYF RCC_CIR_LSIRDYF_Msk /*!< LSI Ready Interrupt flag */
#define RCC_CIR_LSERDYF_Pos (1U)
#define RCC_CIR_LSERDYF_Msk (0x1U << RCC_CIR_LSERDYF_Pos) /*!< 0x00000002 */
#define RCC_CIR_LSERDYF RCC_CIR_LSERDYF_Msk /*!< LSE Ready Interrupt flag */
#define RCC_CIR_HSIRDYF_Pos (2U)
#define RCC_CIR_HSIRDYF_Msk (0x1U << RCC_CIR_HSIRDYF_Pos) /*!< 0x00000004 */
#define RCC_CIR_HSIRDYF RCC_CIR_HSIRDYF_Msk /*!< HSI Ready Interrupt flag */
#define RCC_CIR_HSERDYF_Pos (3U)
#define RCC_CIR_HSERDYF_Msk (0x1U << RCC_CIR_HSERDYF_Pos) /*!< 0x00000008 */
#define RCC_CIR_HSERDYF RCC_CIR_HSERDYF_Msk /*!< HSE Ready Interrupt flag */
#define RCC_CIR_PLLRDYF_Pos (4U)
#define RCC_CIR_PLLRDYF_Msk (0x1U << RCC_CIR_PLLRDYF_Pos) /*!< 0x00000010 */
#define RCC_CIR_PLLRDYF RCC_CIR_PLLRDYF_Msk /*!< PLL Ready Interrupt flag */
#define RCC_CIR_CSSF_Pos (7U)
#define RCC_CIR_CSSF_Msk (0x1U << RCC_CIR_CSSF_Pos) /*!< 0x00000080 */
#define RCC_CIR_CSSF RCC_CIR_CSSF_Msk /*!< Clock Security System Interrupt flag */
#define RCC_CIR_LSIRDYIE_Pos (8U)
#define RCC_CIR_LSIRDYIE_Msk (0x1U << RCC_CIR_LSIRDYIE_Pos) /*!< 0x00000100 */
#define RCC_CIR_LSIRDYIE RCC_CIR_LSIRDYIE_Msk /*!< LSI Ready Interrupt Enable */
#define RCC_CIR_LSERDYIE_Pos (9U)
#define RCC_CIR_LSERDYIE_Msk (0x1U << RCC_CIR_LSERDYIE_Pos) /*!< 0x00000200 */
#define RCC_CIR_LSERDYIE RCC_CIR_LSERDYIE_Msk /*!< LSE Ready Interrupt Enable */
#define RCC_CIR_HSIRDYIE_Pos (10U)
#define RCC_CIR_HSIRDYIE_Msk (0x1U << RCC_CIR_HSIRDYIE_Pos) /*!< 0x00000400 */
#define RCC_CIR_HSIRDYIE RCC_CIR_HSIRDYIE_Msk /*!< HSI Ready Interrupt Enable */
#define RCC_CIR_HSERDYIE_Pos (11U)
#define RCC_CIR_HSERDYIE_Msk (0x1U << RCC_CIR_HSERDYIE_Pos) /*!< 0x00000800 */
#define RCC_CIR_HSERDYIE RCC_CIR_HSERDYIE_Msk /*!< HSE Ready Interrupt Enable */
#define RCC_CIR_PLLRDYIE_Pos (12U)
#define RCC_CIR_PLLRDYIE_Msk (0x1U << RCC_CIR_PLLRDYIE_Pos) /*!< 0x00001000 */
#define RCC_CIR_PLLRDYIE RCC_CIR_PLLRDYIE_Msk /*!< PLL Ready Interrupt Enable */
#define RCC_CIR_LSIRDYC_Pos (16U)
#define RCC_CIR_LSIRDYC_Msk (0x1U << RCC_CIR_LSIRDYC_Pos) /*!< 0x00010000 */
#define RCC_CIR_LSIRDYC RCC_CIR_LSIRDYC_Msk /*!< LSI Ready Interrupt Clear */
#define RCC_CIR_LSERDYC_Pos (17U)
#define RCC_CIR_LSERDYC_Msk (0x1U << RCC_CIR_LSERDYC_Pos) /*!< 0x00020000 */
#define RCC_CIR_LSERDYC RCC_CIR_LSERDYC_Msk /*!< LSE Ready Interrupt Clear */
#define RCC_CIR_HSIRDYC_Pos (18U)
#define RCC_CIR_HSIRDYC_Msk (0x1U << RCC_CIR_HSIRDYC_Pos) /*!< 0x00040000 */
#define RCC_CIR_HSIRDYC RCC_CIR_HSIRDYC_Msk /*!< HSI Ready Interrupt Clear */
#define RCC_CIR_HSERDYC_Pos (19U)
#define RCC_CIR_HSERDYC_Msk (0x1U << RCC_CIR_HSERDYC_Pos) /*!< 0x00080000 */
#define RCC_CIR_HSERDYC RCC_CIR_HSERDYC_Msk /*!< HSE Ready Interrupt Clear */
#define RCC_CIR_PLLRDYC_Pos (20U)
#define RCC_CIR_PLLRDYC_Msk (0x1U << RCC_CIR_PLLRDYC_Pos) /*!< 0x00100000 */
#define RCC_CIR_PLLRDYC RCC_CIR_PLLRDYC_Msk /*!< PLL Ready Interrupt Clear */
#define RCC_CIR_CSSC_Pos (23U)
#define RCC_CIR_CSSC_Msk (0x1U << RCC_CIR_CSSC_Pos) /*!< 0x00800000 */
#define RCC_CIR_CSSC RCC_CIR_CSSC_Msk /*!< Clock Security System Interrupt Clear */


/*****************  Bit definition for RCC_APB2RSTR register  *****************/
#define RCC_APB2RSTR_AFIORST_Pos (0U)
#define RCC_APB2RSTR_AFIORST_Msk (0x1U << RCC_APB2RSTR_AFIORST_Pos) /*!< 0x00000001 */
#define RCC_APB2RSTR_AFIORST RCC_APB2RSTR_AFIORST_Msk /*!< Alternate Function I/O reset */
#define RCC_APB2RSTR_IOPARST_Pos (2U)
#define RCC_APB2RSTR_IOPARST_Msk (0x1U << RCC_APB2RSTR_IOPARST_Pos) /*!< 0x00000004 */
#define RCC_APB2RSTR_IOPARST RCC_APB2RSTR_IOPARST_Msk /*!< I/O port A reset */
#define RCC_APB2RSTR_IOPBRST_Pos (3U)
#define RCC_APB2RSTR_IOPBRST_Msk (0x1U << RCC_APB2RSTR_IOPBRST_Pos) /*!< 0x00000008 */
#define RCC_APB2RSTR_IOPBRST RCC_APB2RSTR_IOPBRST_Msk /*!< I/O port B reset */
#define RCC_APB2RSTR_IOPCRST_Pos (4U)
#define RCC_APB2RSTR_IOPCRST_Msk (0x1U << RCC_APB2RSTR_IOPCRST_Pos) /*!< 0x00000010 */
#define RCC_APB2RSTR_IOPCRST RCC_APB2RSTR_IOPCRST_Msk /*!< I/O port C reset */
#define RCC_APB2RSTR_IOPDRST_Pos (5U)
#define RCC_APB2RSTR_IOPDRST_Msk (0x1U << RCC_APB2RSTR_IOPDRST_Pos) /*!< 0x00000020 */
#define RCC_APB2RSTR_IOPDRST RCC_APB2RSTR_IOPDRST_Msk /*!< I/O port D reset */
#define RCC_APB2RSTR_ADC1RST_Pos (9U)
#define RCC_APB2RSTR_ADC1RST_Msk (0x1U << RCC_APB2RSTR_ADC1RST_Pos) /*!< 0x00000200 */
#define RCC_APB2RSTR_ADC1RST RCC_APB2RSTR_ADC1RST_Msk /*!< ADC 1 interface reset */

#define RCC_APB2RSTR_ADC2RST_Pos (10U)
#define RCC_APB2RSTR_ADC2RST_Msk (0x1U << RCC_APB2RSTR_ADC2RST_Pos) /*!< 0x00000400 */
#define RCC_APB2RSTR_ADC2RST RCC_APB2RSTR_ADC2RST_Msk /*!< ADC 2 interface reset */

#define RCC_APB2RSTR_TIM1RST_Pos (11U)
#define RCC_APB2RSTR_TIM1RST_Msk (0x1U << RCC_APB2RSTR_TIM1RST_Pos) /*!< 0x00000800 */
#define RCC_APB2RSTR_TIM1RST RCC_APB2RSTR_TIM1RST_Msk /*!< TIM1 Timer reset */
#define RCC_APB2RSTR_SPI1RST_Pos (12U)
#define RCC_APB2RSTR_SPI1RST_Msk (0x1U << RCC_APB2RSTR_SPI1RST_Pos) /*!< 0x00001000 */
#define RCC_APB2RSTR_SPI1RST RCC_APB2RSTR_SPI1RST_Msk /*!< SPI 1 reset */
#define RCC_APB2RSTR_USART1RST_Pos (14U)
#define RCC_APB2RSTR_USART1RST_Msk (0x1U << RCC_APB2RSTR_USART1RST_Pos) /*!< 0x00004000 */
#define RCC_APB2RSTR_USART1RST RCC_APB2RSTR_USART1RST_Msk /*!< USART1 reset */


#define RCC_APB2RSTR_IOPERST_Pos (6U)
#define RCC_APB2RSTR_IOPERST_Msk (0x1U << RCC_APB2RSTR_IOPERST_Pos) /*!< 0x00000040 */
#define RCC_APB2RSTR_IOPERST RCC_APB2RSTR_IOPERST_Msk /*!< I/O port E reset */




/*****************  Bit definition for RCC_APB1RSTR register  *****************/
#define RCC_APB1RSTR_TIM2RST_Pos (0U)
#define RCC_APB1RSTR_TIM2RST_Msk (0x1U << RCC_APB1RSTR_TIM2RST_Pos) /*!< 0x00000001 */
#define RCC_APB1RSTR_TIM2RST RCC_APB1RSTR_TIM2RST_Msk /*!< Timer 2 reset */
#define RCC_APB1RSTR_TIM3RST_Pos (1U)
#define RCC_APB1RSTR_TIM3RST_Msk (0x1U << RCC_APB1RSTR_TIM3RST_Pos) /*!< 0x00000002 */
#define RCC_APB1RSTR_TIM3RST RCC_APB1RSTR_TIM3RST_Msk /*!< Timer 3 reset */
#define RCC_APB1RSTR_WWDGRST_Pos (11U)
#define RCC_APB1RSTR_WWDGRST_Msk (0x1U << RCC_APB1RSTR_WWDGRST_Pos) /*!< 0x00000800 */
#define RCC_APB1RSTR_WWDGRST RCC_APB1RSTR_WWDGRST_Msk /*!< Window Watchdog reset */
#define RCC_APB1RSTR_USART2RST_Pos (17U)
#define RCC_APB1RSTR_USART2RST_Msk (0x1U << RCC_APB1RSTR_USART2RST_Pos) /*!< 0x00020000 */
#define RCC_APB1RSTR_USART2RST RCC_APB1RSTR_USART2RST_Msk /*!< USART 2 reset */
#define RCC_APB1RSTR_I2C1RST_Pos (21U)
#define RCC_APB1RSTR_I2C1RST_Msk (0x1U << RCC_APB1RSTR_I2C1RST_Pos) /*!< 0x00200000 */
#define RCC_APB1RSTR_I2C1RST RCC_APB1RSTR_I2C1RST_Msk /*!< I2C 1 reset */

#define RCC_APB1RSTR_CAN1RST_Pos (25U)
#define RCC_APB1RSTR_CAN1RST_Msk (0x1U << RCC_APB1RSTR_CAN1RST_Pos) /*!< 0x02000000 */
#define RCC_APB1RSTR_CAN1RST RCC_APB1RSTR_CAN1RST_Msk /*!< CAN1 reset */

#define RCC_APB1RSTR_BKPRST_Pos (27U)
#define RCC_APB1RSTR_BKPRST_Msk (0x1U << RCC_APB1RSTR_BKPRST_Pos) /*!< 0x08000000 */
#define RCC_APB1RSTR_BKPRST RCC_APB1RSTR_BKPRST_Msk /*!< Backup interface reset */
#define RCC_APB1RSTR_PWRRST_Pos (28U)
#define RCC_APB1RSTR_PWRRST_Msk (0x1U << RCC_APB1RSTR_PWRRST_Pos) /*!< 0x10000000 */
#define RCC_APB1RSTR_PWRRST RCC_APB1RSTR_PWRRST_Msk /*!< Power interface reset */

#define RCC_APB1RSTR_TIM4RST_Pos (2U)
#define RCC_APB1RSTR_TIM4RST_Msk (0x1U << RCC_APB1RSTR_TIM4RST_Pos) /*!< 0x00000004 */
#define RCC_APB1RSTR_TIM4RST RCC_APB1RSTR_TIM4RST_Msk /*!< Timer 4 reset */
#define RCC_APB1RSTR_SPI2RST_Pos (14U)
#define RCC_APB1RSTR_SPI2RST_Msk (0x1U << RCC_APB1RSTR_SPI2RST_Pos) /*!< 0x00004000 */
#define RCC_APB1RSTR_SPI2RST RCC_APB1RSTR_SPI2RST_Msk /*!< SPI 2 reset */
#define RCC_APB1RSTR_USART3RST_Pos (18U)
#define RCC_APB1RSTR_USART3RST_Msk (0x1U << RCC_APB1RSTR_USART3RST_Pos) /*!< 0x00040000 */
#define RCC_APB1RSTR_USART3RST RCC_APB1RSTR_USART3RST_Msk /*!< USART 3 reset */
#define RCC_APB1RSTR_I2C2RST_Pos (22U)
#define RCC_APB1RSTR_I2C2RST_Msk (0x1U << RCC_APB1RSTR_I2C2RST_Pos) /*!< 0x00400000 */
#define RCC_APB1RSTR_I2C2RST RCC_APB1RSTR_I2C2RST_Msk /*!< I2C 2 reset */

#define RCC_APB1RSTR_USBRST_Pos (23U)
#define RCC_APB1RSTR_USBRST_Msk (0x1U << RCC_APB1RSTR_USBRST_Pos) /*!< 0x00800000 */
#define RCC_APB1RSTR_USBRST RCC_APB1RSTR_USBRST_Msk /*!< USB Device reset */






/******************  Bit definition for RCC_AHBENR register  ******************/
#define RCC_AHBENR_DMA1EN_Pos (0U)
#define RCC_AHBENR_DMA1EN_Msk (0x1U << RCC_AHBENR_DMA1EN_Pos) /*!< 0x00000001 */
#define RCC_AHBENR_DMA1EN RCC_AHBENR_DMA1EN_Msk /*!< DMA1 clock enable */
#define RCC_AHBENR_SRAMEN_Pos (2U)
#define RCC_AHBENR_SRAMEN_Msk (0x1U << RCC_AHBENR_SRAMEN_Pos) /*!< 0x00000004 */
#define RCC_AHBENR_SRAMEN RCC_AHBENR_SRAMEN_Msk /*!< SRAM interface clock enable */
#define RCC_AHBENR_FLITFEN_Pos (4U)
#define RCC_AHBENR_FLITFEN_Msk (0x1U << RCC_AHBENR_FLITFEN_Pos) /*!< 0x00000010 */
#define RCC_AHBENR_FLITFEN RCC_AHBENR_FLITFEN_Msk /*!< FLITF clock enable */
#define RCC_AHBENR_CRCEN_Pos (6U)
#define RCC_AHBENR_CRCEN_Msk (0x1U << RCC_AHBENR_CRCEN_Pos) /*!< 0x00000040 */
#define RCC_AHBENR_CRCEN RCC_AHBENR_CRCEN_Msk /*!< CRC clock enable */




/******************  Bit definition for RCC_APB2ENR register  *****************/
#define RCC_APB2ENR_AFIOEN_Pos (0U)
#define RCC_APB2ENR_AFIOEN_Msk (0x1U << RCC_APB2ENR_AFIOEN_Pos) /*!< 0x00000001 */
#define RCC_APB2ENR_AFIOEN RCC_APB2ENR_AFIOEN_Msk /*!< Alternate Function I/O clock enable */
#define RCC_APB2ENR_IOPAEN_Pos (2U)
#define RCC_APB2ENR_IOPAEN_Msk (0x1U << RCC_APB2ENR_IOPAEN_Pos) /*!< 0x00000004 */
#define RCC_APB2ENR_IOPAEN RCC_APB2ENR_IOPAEN_Msk /*!< I/O port A clock enable */
#define RCC_APB2ENR_IOPBEN_Pos (3U)
#define RCC_APB2ENR_IOPBEN_Msk (0x1U << RCC_APB2ENR_IOPBEN_Pos) /*!< 0x00000008 */
#define RCC_APB2ENR_IOPBEN RCC_APB2ENR_IOPBEN_Msk /*!< I/O port B clock enable */
#define RCC_APB2ENR_IOPCEN_Pos (4U)
#define RCC_APB2ENR_IOPCEN_Msk (0x1U << RCC_APB2ENR_IOPCEN_Pos) /*!< 0x00000010 */
#define RCC_APB2ENR_IOPCEN RCC_APB2ENR_IOPCEN_Msk /*!< I/O port C clock enable */
#define RCC_APB2ENR_IOPDEN_Pos (5U)
#define RCC_APB2ENR_IOPDEN_Msk (0x1U << RCC_APB2ENR_IOPDEN_Pos) /*!< 0x00000020 */
#define RCC_APB2ENR_IOPDEN RCC_APB2ENR_IOPDEN_Msk /*!< I/O port D clock enable */
#define RCC_APB2ENR_ADC1EN_Pos (9U)
#define RCC_APB2ENR_ADC1EN_Msk (0x1U << RCC_APB2ENR_ADC1EN_Pos) /*!< 0x00000200 */
#define RCC_APB2ENR_ADC1EN RCC_APB2ENR_ADC1EN_Msk /*!< ADC 1 interface clock enable */

#define RCC_APB2ENR_ADC2EN_Pos (10U)
#define RCC_APB2ENR_ADC2EN_Msk (0x1U << RCC_APB2ENR_ADC2EN_Pos) /*!< 0x00000400 */
#define RCC_APB2ENR_ADC2EN RCC_APB2ENR_ADC2EN_Msk /*!< ADC 2 interface clock enable */

#define RCC_APB2ENR_TIM1EN_Pos (11U)
#define RCC_APB2ENR_TIM1EN_Msk (0x1U << RCC_APB2ENR_TIM1EN_Pos) /*!< 0x00000800 */
#define RCC_APB2ENR_TIM1EN RCC_APB2ENR_TIM1EN_Msk /*!< TIM1 Timer clock enable */
#define RCC_APB2ENR_SPI1EN_Pos (12U)
#define RCC_APB2ENR_SPI1EN_Msk (0x1U << RCC_APB2ENR_SPI1EN_Pos) /*!< 0x00001000 */
#define RCC_APB2ENR_SPI1EN RCC_APB2ENR_SPI1EN_Msk /*!< SPI 1 clock enable */
#define RCC_APB2ENR_USART1EN_Pos (14U)
#define RCC_APB2ENR_USART1EN_Msk (0x1U << RCC_APB2ENR_USART1EN_Pos) /*!< 0x00004000 */
#define RCC_APB2ENR_USART1EN RCC_APB2ENR_USART1EN_Msk /*!< USART1 clock enable */


#define RCC_APB2ENR_IOPEEN_Pos (6U)
#define RCC_APB2ENR_IOPEEN_Msk (0x1U << RCC_APB2ENR_IOPEEN_Pos) /*!< 0x00000040 */
#define RCC_APB2ENR_IOPEEN RCC_APB2ENR_IOPEEN_Msk /*!< I/O port E clock enable */




/*****************  Bit definition for RCC_APB1ENR register  ******************/
#define RCC_APB1ENR_TIM2EN_Pos (0U)
#define RCC_APB1ENR_TIM2EN_Msk (0x1U << RCC_APB1ENR_TIM2EN_Pos) /*!< 0x00000001 */
#define RCC_APB1ENR_TIM2EN RCC_APB1ENR_TIM2EN_Msk /*!< Timer 2 clock enabled*/
#define RCC_APB1ENR_TIM3EN_Pos (1U)
#define RCC_APB1ENR_TIM3EN_Msk (0x1U << RCC_APB1ENR_TIM3EN_Pos) /*!< 0x00000002 */
#define RCC_APB1ENR_TIM3EN RCC_APB1ENR_TIM3EN_Msk /*!< Timer 3 clock enable */
#define RCC_APB1ENR_WWDGEN_Pos (11U)
#define RCC_APB1ENR_WWDGEN_Msk (0x1U << RCC_APB1ENR_WWDGEN_Pos) /*!< 0x00000800 */
#define RCC_APB1ENR_WWDGEN RCC_APB1ENR_WWDGEN_Msk /*!< Window Watchdog clock enable */
#define RCC_APB1ENR_USART2EN_Pos (17U)
#define RCC_APB1ENR_USART2EN_Msk (0x1U << RCC_APB1ENR_USART2EN_Pos) /*!< 0x00020000 */
#define RCC_APB1ENR_USART2EN RCC_APB1ENR_USART2EN_Msk /*!< USART 2 clock enable */
#define RCC_APB1ENR_I2C1EN_Pos (21U)
#define RCC_APB1ENR_I2C1EN_Msk (0x1U << RCC_APB1ENR_I2C1EN_Pos) /*!< 0x00200000 */
#define RCC_APB1ENR_I2C1EN RCC_APB1ENR_I2C1EN_Msk /*!< I2C 1 clock enable */

#define RCC_APB1ENR_CAN1EN_Pos (25U)
#define RCC_APB1ENR_CAN1EN_Msk (0x1U << RCC_APB1ENR_CAN1EN_Pos) /*!< 0x02000000 */
#define RCC_APB1ENR_CAN1EN RCC_APB1ENR_CAN1EN_Msk /*!< CAN1 clock enable */

#define RCC_APB1ENR_BKPEN_Pos (27U)
#define RCC_APB1ENR_BKPEN_Msk (0x1U << RCC_APB1ENR_BKPEN_Pos) /*!< 0x08000000 */
#define RCC_APB1ENR_BKPEN RCC_APB1ENR_BKPEN_Msk /*!< Backup interface clock enable */
#define RCC_APB1ENR_PWREN_Pos (28U)
#define RCC_APB1ENR_PWREN_Msk (0x1U << RCC_APB1ENR_PWREN_Pos) /*!< 0x10000000 */
#define RCC_APB1ENR_PWREN RCC_APB1ENR_PWREN_Msk /*!< Power interface clock enable */

#define RCC_APB1ENR_TIM4EN_Pos (2U)
#define RCC_APB1ENR_TIM4EN_Msk (0x1U << RCC_APB1ENR_TIM4EN_Pos) /*!< 0x00000004 */
#define RCC_APB1ENR_TIM4EN RCC_APB1ENR_TIM4EN_Msk /*!< Timer 4 clock enable */
#define RCC_APB1ENR_SPI2EN_Pos (14U)
#define RCC_APB1ENR_SPI2EN_Msk (0x1U << RCC_APB1ENR_SPI2EN_Pos) /*!< 0x00004000 */
#define RCC_APB1ENR_SPI2EN RCC_APB1ENR_SPI2EN_Msk /*!< SPI 2 clock enable */
#define RCC_APB1ENR_USART3EN_Pos (18U)
#define RCC_APB1ENR_USART3EN_Msk (0x1U << RCC_APB1ENR_USART3EN_Pos) /*!< 0x00040000 */
#define RCC_APB1ENR_USART3EN RCC_APB1ENR_USART3EN_Msk /*!< USART 3 clock enable */
#define RCC_APB1ENR_I2C2EN_Pos (22U)
#define RCC_APB1ENR_I2C2EN_Msk (0x1U << RCC_APB1ENR_I2C2EN_Pos) /*!< 0x00400000 */
#define RCC_APB1ENR_I2C2EN RCC_APB1ENR_I2C2EN_Msk /*!< I2C 2 clock enable */

#define RCC_APB1ENR_USBEN_Pos (23U)
#define RCC_APB1ENR_USBEN_Msk (0x1U << RCC_APB1ENR_USBEN_Pos) /*!< 0x00800000 */
#define RCC_APB1ENR_USBEN RCC_APB1ENR_USBEN_Msk /*!< USB Device clock enable */






/*******************  Bit definition for RCC_BDCR register  *******************/
#define RCC_BDCR_LSEON_Pos (0U)
#define RCC_BDCR_LSEON_Msk (0x1U << RCC_BDCR_LSEON_Pos) /*!< 0x00000001 */
#define RCC_BDCR_LSEON RCC_BDCR_LSEON_Msk /*!< External Low Speed oscillator enable */
#define RCC_BDCR_LSERDY_Pos (1U)
#define RCC_BDCR_LSERDY_Msk (0x1U << RCC_BDCR_LSERDY_Pos) /*!< 0x00000002 */
#define RCC_BDCR_LSERDY RCC_BDCR_LSERDY_Msk /*!< External Low Speed oscillator Ready */
#define RCC_BDCR_LSEBYP_Pos (2U)
#define RCC_BDCR_LSEBYP_Msk (0x1U << RCC_BDCR_LSEBYP_Pos) /*!< 0x00000004 */
#define RCC_BDCR_LSEBYP RCC_BDCR_LSEBYP_Msk /*!< External Low Speed oscillator Bypass */

#define RCC_BDCR_RTCSEL_Pos (8U)
#define RCC_BDCR_RTCSEL_Msk (0x3U << RCC_BDCR_RTCSEL_Pos) /*!< 0x00000300 */
#define RCC_BDCR_RTCSEL RCC_BDCR_RTCSEL_Msk /*!< RTCSEL[1:0] bits (RTC clock source selection) */
#define RCC_BDCR_RTCSEL_0 (0x1U << RCC_BDCR_RTCSEL_Pos) /*!< 0x00000100 */
#define RCC_BDCR_RTCSEL_1 (0x2U << RCC_BDCR_RTCSEL_Pos) /*!< 0x00000200 */

/*!< RTC congiguration */
#define RCC_BDCR_RTCSEL_NOCLOCK 0x00000000U /*!< No clock */
#define RCC_BDCR_RTCSEL_LSE 0x00000100U /*!< LSE oscillator clock used as RTC clock */
#define RCC_BDCR_RTCSEL_LSI 0x00000200U /*!< LSI oscillator clock used as RTC clock */
#define RCC_BDCR_RTCSEL_HSE 0x00000300U /*!< HSE oscillator clock divided by 128 used as RTC clock */

#define RCC_BDCR_RTCEN_Pos (15U)
#define RCC_BDCR_RTCEN_Msk (0x1U << RCC_BDCR_RTCEN_Pos) /*!< 0x00008000 */
#define RCC_BDCR_RTCEN RCC_BDCR_RTCEN_Msk /*!< RTC clock enable */
#define RCC_BDCR_BDRST_Pos (16U)
#define RCC_BDCR_BDRST_Msk (0x1U << RCC_BDCR_BDRST_Pos) /*!< 0x00010000 */
#define RCC_BDCR_BDRST RCC_BDCR_BDRST_Msk /*!< Backup domain software reset  */

/*******************  Bit definition for RCC_CSR register  ********************/
#define RCC_CSR_LSION_Pos (0U)
#define RCC_CSR_LSION_Msk (0x1U << RCC_CSR_LSION_Pos) /*!< 0x00000001 */
#define RCC_CSR_LSION RCC_CSR_LSION_Msk /*!< Internal Low Speed oscillator enable */
#define RCC_CSR_LSIRDY_Pos (1U)
#define RCC_CSR_LSIRDY_Msk (0x1U << RCC_CSR_LSIRDY_Pos) /*!< 0x00000002 */
#define RCC_CSR_LSIRDY RCC_CSR_LSIRDY_Msk /*!< Internal Low Speed oscillator Ready */
#define RCC_CSR_RMVF_Pos (24U)
#define RCC_CSR_RMVF_Msk (0x1U << RCC_CSR_RMVF_Pos) /*!< 0x01000000 */
#define RCC_CSR_RMVF RCC_CSR_RMVF_Msk /*!< Remove reset flag */
#define RCC_CSR_PINRSTF_Pos (26U)
#define RCC_CSR_PINRSTF_Msk (0x1U << RCC_CSR_PINRSTF_Pos) /*!< 0x04000000 */
#define RCC_CSR_PINRSTF RCC_CSR_PINRSTF_Msk /*!< PIN reset flag */
#define RCC_CSR_PORRSTF_Pos (27U)
#define RCC_CSR_PORRSTF_Msk (0x1U << RCC_CSR_PORRSTF_Pos) /*!< 0x08000000 */
#define RCC_CSR_PORRSTF RCC_CSR_PORRSTF_Msk /*!< POR/PDR reset flag */
#define RCC_CSR_SFTRSTF_Pos (28U)
#define RCC_CSR_SFTRSTF_Msk (0x1U << RCC_CSR_SFTRSTF_Pos) /*!< 0x10000000 */
#define RCC_CSR_SFTRSTF RCC_CSR_SFTRSTF_Msk /*!< Software Reset flag */
#define RCC_CSR_IWDGRSTF_Pos (29U)
#define RCC_CSR_IWDGRSTF_Msk (0x1U << RCC_CSR_IWDGRSTF_Pos) /*!< 0x20000000 */
#define RCC_CSR_IWDGRSTF RCC_CSR_IWDGRSTF_Msk /*!< Independent Watchdog reset flag */
#define RCC_CSR_WWDGRSTF_Pos (30U)
#define RCC_CSR_WWDGRSTF_Msk (0x1U << RCC_CSR_WWDGRSTF_Pos) /*!< 0x40000000 */
#define RCC_CSR_WWDGRSTF RCC_CSR_WWDGRSTF_Msk /*!< Window watchdog reset flag */
#define RCC_CSR_LPWRRSTF_Pos (31U)
#define RCC_CSR_LPWRRSTF_Msk (0x1U << RCC_CSR_LPWRRSTF_Pos) /*!< 0x80000000 */
#define RCC_CSR_LPWRRSTF RCC_CSR_LPWRRSTF_Msk /*!< Low-Power reset flag */



/******************************************************************************/
/*                                                                            */
/*                General Purpose and Alternate Function I/O                  */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for GPIO_CRL register  *******************/
#define GPIO_CRL_MODE_Pos (0U)
#define GPIO_CRL_MODE_Msk (0x33333333U << GPIO_CRL_MODE_Pos) /*!< 0x33333333 */
#define GPIO_CRL_MODE GPIO_CRL_MODE_Msk /*!< Port x mode bits */

#define GPIO_CRL_MODE0_Pos (0U)
#define GPIO_CRL_MODE0_Msk (0x3U << GPIO_CRL_MODE0_Pos) /*!< 0x00000003 */
#define GPIO_CRL_MODE0 GPIO_CRL_MODE0_Msk /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */
#define GPIO_CRL_MODE0_0 (0x1U << GPIO_CRL_MODE0_Pos) /*!< 0x00000001 */
#define GPIO_CRL_MODE0_1 (0x2U << GPIO_CRL_MODE0_Pos) /*!< 0x00000002 */

#define GPIO_CRL_MODE1_Pos (4U)
#define GPIO_CRL_MODE1_Msk (0x3U << GPIO_CRL_MODE1_Pos) /*!< 0x00000030 */
#define GPIO_CRL_MODE1 GPIO_CRL_MODE1_Msk /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */
#define GPIO_CRL_MODE1_0 (0x1U << GPIO_CRL_MODE1_Pos) /*!< 0x00000010 */
#define GPIO_CRL_MODE1_1 (0x2U << GPIO_CRL_MODE1_Pos) /*!< 0x00000020 */

#define GPIO_CRL_MODE2_Pos (8U)
#define GPIO_CRL_MODE2_Msk (0x3U << GPIO_CRL_MODE2_Pos) /*!< 0x00000300 */
#define GPIO_CRL_MODE2 GPIO_CRL_MODE2_Msk /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */
#define GPIO_CRL_MODE2_0 (0x1U << GPIO_CRL_MODE2_Pos) /*!< 0x00000100 */
#define GPIO_CRL_MODE2_1 (0x2U << GPIO_CRL_MODE2_Pos) /*!< 0x00000200 */

#define GPIO_CRL_MODE3_Pos (12U)
#define GPIO_CRL_MODE3_Msk (0x3U << GPIO_CRL_MODE3_Pos) /*!< 0x00003000 */
#define GPIO_CRL_MODE3 GPIO_CRL_MODE3_Msk /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */
#define GPIO_CRL_MODE3_0 (0x1U << GPIO_CRL_MODE3_Pos) /*!< 0x00001000 */
#define GPIO_CRL_MODE3_1 (0x2U << GPIO_CRL_MODE3_Pos) /*!< 0x00002000 */

#define GPIO_CRL_MODE4_Pos (16U)
#define GPIO_CRL_MODE4_Msk (0x3U << GPIO_CRL_MODE4_Pos) /*!< 0x00030000 */
#define GPIO_CRL_MODE4 GPIO_CRL_MODE4_Msk /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */
#define GPIO_CRL_MODE4_0 (0x1U << GPIO_CRL_MODE4_Pos) /*!< 0x00010000 */
#define GPIO_CRL_MODE4_1 (0x2U << GPIO_CRL_MODE4_Pos) /*!< 0x00020000 */

#define GPIO_CRL_MODE5_Pos (20U)
#define GPIO_CRL_MODE5_Msk (0x3U << GPIO_CRL_MODE5_Pos) /*!< 0x00300000 */
#define GPIO_CRL_MODE5 GPIO_CRL_MODE5_Msk /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */
#define GPIO_CRL_MODE5_0 (0x1U << GPIO_CRL_MODE5_Pos) /*!< 0x00100000 */
#define GPIO_CRL_MODE5_1 (0x2U << GPIO_CRL_MODE5_Pos) /*!< 0x00200000 */

#define GPIO_CRL_MODE6_Pos (24U)
#define GPIO_CRL_MODE6_Msk (0x3U << GPIO_CRL_MODE6_Pos) /*!< 0x03000000 */
#define GPIO_CRL_MODE6 GPIO_CRL_MODE6_Msk /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */
#define GPIO_CRL_MODE6_0 (0x1U << GPIO_CRL_MODE6_Pos) /*!< 0x01000000 */
#define GPIO_CRL_MODE6_1 (0x2U << GPIO_CRL_MODE6_Pos) /*!< 0x02000000 */

#define GPIO_CRL_MODE7_Pos (28U)
#define GPIO_CRL_MODE7_Msk (0x3U << GPIO_CRL_MODE7_Pos) /*!< 0x30000000 */
#define GPIO_CRL_MODE7 GPIO_CRL_MODE7_Msk /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */
#define GPIO_CRL_MODE7_0 (0x1U << GPIO_CRL_MODE7_Pos) /*!< 0x10000000 */
#define GPIO_CRL_MODE7_1 (0x2U << GPIO_CRL_MODE7_Pos) /*!< 0x20000000 */

#define GPIO_CRL_CNF_Pos (2U)
#define GPIO_CRL_CNF_Msk (0x33333333U << GPIO_CRL_CNF_Pos) /*!< 0xCCCCCCCC */
#define GPIO_CRL_CNF GPIO_CRL_CNF_Msk /*!< Port x configuration bits */

#define GPIO_CRL_CNF0_Pos (2U)
#define GPIO_CRL_CNF0_Msk (0x3U << GPIO_CRL_CNF0_Pos) /*!< 0x0000000C */
#define GPIO_CRL_CNF0 GPIO_CRL_CNF0_Msk /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */
#define GPIO_CRL_CNF0_0 (0x1U << GPIO_CRL_CNF0_Pos) /*!< 0x00000004 */
#define GPIO_CRL_CNF0_1 (0x2U << GPIO_CRL_CNF0_Pos) /*!< 0x00000008 */

#define GPIO_CRL_CNF1_Pos (6U)
#define GPIO_CRL_CNF1_Msk (0x3U << GPIO_CRL_CNF1_Pos) /*!< 0x000000C0 */
#define GPIO_CRL_CNF1 GPIO_CRL_CNF1_Msk /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */
#define GPIO_CRL_CNF1_0 (0x1U << GPIO_CRL_CNF1_Pos) /*!< 0x00000040 */
#define GPIO_CRL_CNF1_1 (0x2U << GPIO_CRL_CNF1_Pos) /*!< 0x00000080 */

#define GPIO_CRL_CNF2_Pos (10U)
#define GPIO_CRL_CNF2_Msk (0x3U << GPIO_CRL_CNF2_Pos) /*!< 0x00000C00 */
#define GPIO_CRL_CNF2 GPIO_CRL_CNF2_Msk /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */
#define GPIO_CRL_CNF2_0 (0x1U << GPIO_CRL_CNF2_Pos) /*!< 0x00000400 */
#define GPIO_CRL_CNF2_1 (0x2U << GPIO_CRL_CNF2_Pos) /*!< 0x00000800 */

#define GPIO_CRL_CNF3_Pos (14U)
#define GPIO_CRL_CNF3_Msk (0x3U << GPIO_CRL_CNF3_Pos) /*!< 0x0000C000 */
#define GPIO_CRL_CNF3 GPIO_CRL_CNF3_Msk /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */
#define GPIO_CRL_CNF3_0 (0x1U << GPIO_CRL_CNF3_Pos) /*!< 0x00004000 */
#define GPIO_CRL_CNF3_1 (0x2U << GPIO_CRL_CNF3_Pos) /*!< 0x00008000 */

#define GPIO_CRL_CNF4_Pos (18U)
#define GPIO_CRL_CNF4_Msk (0x3U << GPIO_CRL_CNF4_Pos) /*!< 0x000C0000 */
#define GPIO_CRL_CNF4 GPIO_CRL_CNF4_Msk /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */
#define GPIO_CRL_CNF4_0 (0x1U << GPIO_CRL_CNF4_Pos) /*!< 0x00040000 */
#define GPIO_CRL_CNF4_1 (0x2U << GPIO_CRL_CNF4_Pos) /*!< 0x00080000 */

#define GPIO_CRL_CNF5_Pos (22U)
#define GPIO_CRL_CNF5_Msk (0x3U << GPIO_CRL_CNF5_Pos) /*!< 0x00C00000 */
#define GPIO_CRL_CNF5 GPIO_CRL_CNF5_Msk /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */
#define GPIO_CRL_CNF5_0 (0x1U << GPIO_CRL_CNF5_Pos) /*!< 0x00400000 */
#define GPIO_CRL_CNF5_1 (0x2U << GPIO_CRL_CNF5_Pos) /*!< 0x00800000 */

#define GPIO_CRL_CNF6_Pos (26U)
#define GPIO_CRL_CNF6_Msk (0x3U << GPIO_CRL_CNF6_Pos) /*!< 0x0C000000 */
#define GPIO_CRL_CNF6 GPIO_CRL_CNF6_Msk /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */
#define GPIO_CRL_CNF6_0 (0x1U << GPIO_CRL_CNF6_Pos) /*!< 0x04000000 */
#define GPIO_CRL_CNF6_1 (0x2U << GPIO_CRL_CNF6_Pos) /*!< 0x08000000 */

#define GPIO_CRL_CNF7_Pos (30U)
#define GPIO_CRL_CNF7_Msk (0x3U << GPIO_CRL_CNF7_Pos) /*!< 0xC0000000 */
#define GPIO_CRL_CNF7 GPIO_CRL_CNF7_Msk /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */
#define GPIO_CRL_CNF7_0 (0x1U << GPIO_CRL_CNF7_Pos) /*!< 0x40000000 */
#define GPIO_CRL_CNF7_1 (0x2U << GPIO_CRL_CNF7_Pos) /*!< 0x80000000 */

/*******************  Bit definition for GPIO_CRH register  *******************/
#define GPIO_CRH_MODE_Pos (0U)
#define GPIO_CRH_MODE_Msk (0x33333333U << GPIO_CRH_MODE_Pos) /*!< 0x33333333 */
#define GPIO_CRH_MODE GPIO_CRH_MODE_Msk /*!< Port x mode bits */

#define GPIO_CRH_MODE8_Pos (0U)
#define GPIO_CRH_MODE8_Msk (0x3U << GPIO_CRH_MODE8_Pos) /*!< 0x00000003 */
#define GPIO_CRH_MODE8 GPIO_CRH_MODE8_Msk /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */
#define GPIO_CRH_MODE8_0 (0x1U << GPIO_CRH_MODE8_Pos) /*!< 0x00000001 */
#define GPIO_CRH_MODE8_1 (0x2U << GPIO_CRH_MODE8_Pos) /*!< 0x00000002 */

#define GPIO_CRH_MODE9_Pos (4U)
#define GPIO_CRH_MODE9_Msk (0x3U << GPIO_CRH_MODE9_Pos) /*!< 0x00000030 */
#define GPIO_CRH_MODE9 GPIO_CRH_MODE9_Msk /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */
#define GPIO_CRH_MODE9_0 (0x1U << GPIO_CRH_MODE9_Pos) /*!< 0x00000010 */
#define GPIO_CRH_MODE9_1 (0x2U << GPIO_CRH_MODE9_Pos) /*!< 0x00000020 */

#define GPIO_CRH_MODE10_Pos (8U)
#define GPIO_CRH_MODE10_Msk (0x3U << GPIO_CRH_MODE10_Pos) /*!< 0x00000300 */
#define GPIO_CRH_MODE10 GPIO_CRH_MODE10_Msk /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */
#define GPIO_CRH_MODE10_0 (0x1U << GPIO_CRH_MODE10_Pos) /*!< 0x00000100 */
#define GPIO_CRH_MODE10_1 (0x2U << GPIO_CRH_MODE10_Pos) /*!< 0x00000200 */

#define GPIO_CRH_MODE11_Pos (12U)
#define GPIO_CRH_MODE11_Msk (0x3U << GPIO_CRH_MODE11_Pos) /*!< 0x00003000 */
#define GPIO_CRH_MODE11 GPIO_CRH_MODE11_Msk /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */
#define GPIO_CRH_MODE11_0 (0x1U << GPIO_CRH_MODE11_Pos) /*!< 0x00001000 */
#define GPIO_CRH_MODE11_1 (0x2U << GPIO_CRH_MODE11_Pos) /*!< 0x00002000 */

#define GPIO_CRH_MODE12_Pos (16U)
#define GPIO_CRH_MODE12_Msk (0x3U << GPIO_CRH_MODE12_Pos) /*!< 0x00030000 */
#define GPIO_CRH_MODE12 GPIO_CRH_MODE12_Msk /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */
#define GPIO_CRH_MODE12_0 (0x1U << GPIO_CRH_MODE12_Pos) /*!< 0x00010000 */
#define GPIO_CRH_MODE12_1 (0x2U << GPIO_CRH_MODE12_Pos) /*!< 0x00020000 */

#define GPIO_CRH_MODE13_Pos (20U)
#define GPIO_CRH_MODE13_Msk (0x3U << GPIO_CRH_MODE13_Pos) /*!< 0x00300000 */
#define GPIO_CRH_MODE13 GPIO_CRH_MODE13_Msk /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */
#define GPIO_CRH_MODE13_0 (0x1U << GPIO_CRH_MODE13_Pos) /*!< 0x00100000 */
#define GPIO_CRH_MODE13_1 (0x2U << GPIO_CRH_MODE13_Pos) /*!< 0x00200000 */

#define GPIO_CRH_MODE14_Pos (24U)
#define GPIO_CRH_MODE14_Msk (0x3U << GPIO_CRH_MODE14_Pos) /*!< 0x03000000 */
#define GPIO_CRH_MODE14 GPIO_CRH_MODE14_Msk /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */
#define GPIO_CRH_MODE14_0 (0x1U << GPIO_CRH_MODE14_Pos) /*!< 0x01000000 */
#define GPIO_CRH_MODE14_1 (0x2U << GPIO_CRH_MODE14_Pos) /*!< 0x02000000 */

#define GPIO_CRH_MODE15_Pos (28U)
#define GPIO_CRH_MODE15_Msk (0x3U << GPIO_CRH_MODE15_Pos) /*!< 0x30000000 */
#define GPIO_CRH_MODE15 GPIO_CRH_MODE15_Msk /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */
#define GPIO_CRH_MODE15_0 (0x1U << GPIO_CRH_MODE15_Pos) /*!< 0x10000000 */
#define GPIO_CRH_MODE15_1 (0x2U << GPIO_CRH_MODE15_Pos) /*!< 0x20000000 */

#define GPIO_CRH_CNF_Pos (2U)
#define GPIO_CRH_CNF_Msk (0x33333333U << GPIO_CRH_CNF_Pos) /*!< 0xCCCCCCCC */
#define GPIO_CRH_CNF GPIO_CRH_CNF_Msk /*!< Port x configuration bits */

#define GPIO_CRH_CNF8_Pos (2U)
#define GPIO_CRH_CNF8_Msk (0x3U << GPIO_CRH_CNF8_Pos) /*!< 0x0000000C */
#define GPIO_CRH_CNF8 GPIO_CRH_CNF8_Msk /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */
#define GPIO_CRH_CNF8_0 (0x1U << GPIO_CRH_CNF8_Pos) /*!< 0x00000004 */
#define GPIO_CRH_CNF8_1 (0x2U << GPIO_CRH_CNF8_Pos) /*!< 0x00000008 */

#define GPIO_CRH_CNF9_Pos (6U)
#define GPIO_CRH_CNF9_Msk (0x3U << GPIO_CRH_CNF9_Pos) /*!< 0x000000C0 */
#define GPIO_CRH_CNF9 GPIO_CRH_CNF9_Msk /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */
#define GPIO_CRH_CNF9_0 (0x1U << GPIO_CRH_CNF9_Pos) /*!< 0x00000040 */
#define GPIO_CRH_CNF9_1 (0x2U << GPIO_CRH_CNF9_Pos) /*!< 0x00000080 */

#define GPIO_CRH_CNF10_Pos (10U)
#define GPIO_CRH_CNF10_Msk (0x3U << GPIO_CRH_CNF10_Pos) /*!< 0x00000C00 */
#define GPIO_CRH_CNF10 GPIO_CRH_CNF10_Msk /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */
#define GPIO_CRH_CNF10_0 (0x1U << GPIO_CRH_CNF10_Pos) /*!< 0x00000400 */
#define GPIO_CRH_CNF10_1 (0x2U << GPIO_CRH_CNF10_Pos) /*!< 0x00000800 */

#define GPIO_CRH_CNF11_Pos (14U)
#define GPIO_CRH_CNF11_Msk (0x3U << GPIO_CRH_CNF11_Pos) /*!< 0x0000C000 */
#define GPIO_CRH_CNF11 GPIO_CRH_CNF11_Msk /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */
#define GPIO_CRH_CNF11_0 (0x1U << GPIO_CRH_CNF11_Pos) /*!< 0x00004000 */
#define GPIO_CRH_CNF11_1 (0x2U << GPIO_CRH_CNF11_Pos) /*!< 0x00008000 */

#define GPIO_CRH_CNF12_Pos (18U)
#define GPIO_CRH_CNF12_Msk (0x3U << GPIO_CRH_CNF12_Pos) /*!< 0x000C0000 */
#define GPIO_CRH_CNF12 GPIO_CRH_CNF12_Msk /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */
#define GPIO_CRH_CNF12_0 (0x1U << GPIO_CRH_CNF12_Pos) /*!< 0x00040000 */
#define GPIO_CRH_CNF12_1 (0x2U << GPIO_CRH_CNF12_Pos) /*!< 0x00080000 */

#define GPIO_CRH_CNF13_Pos (22U)
#define GPIO_CRH_CNF13_Msk (0x3U << GPIO_CRH_CNF13_Pos) /*!< 0x00C00000 */
#define GPIO_CRH_CNF13 GPIO_CRH_CNF13_Msk /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */
#define GPIO_CRH_CNF13_0 (0x1U << GPIO_CRH_CNF13_Pos) /*!< 0x00400000 */
#define GPIO_CRH_CNF13_1 (0x2U << GPIO_CRH_CNF13_Pos) /*!< 0x00800000 */

#define GPIO_CRH_CNF14_Pos (26U)
#define GPIO_CRH_CNF14_Msk (0x3U << GPIO_CRH_CNF14_Pos) /*!< 0x0C000000 */
#define GPIO_CRH_CNF14 GPIO_CRH_CNF14_Msk /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */
#define GPIO_CRH_CNF14_0 (0x1U << GPIO_CRH_CNF14_Pos) /*!< 0x04000000 */
#define GPIO_CRH_CNF14_1 (0x2U << GPIO_CRH_CNF14_Pos) /*!< 0x08000000 */

#define GPIO_CRH_CNF15_Pos (30U)
#define GPIO_CRH_CNF15_Msk (0x3U << GPIO_CRH_CNF15_Pos) /*!< 0xC0000000 */
#define GPIO_CRH_CNF15 GPIO_CRH_CNF15_Msk /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */
#define GPIO_CRH_CNF15_0 (0x1U << GPIO_CRH_CNF15_Pos) /*!< 0x40000000 */
#define GPIO_CRH_CNF15_1 (0x2U << GPIO_CRH_CNF15_Pos) /*!< 0x80000000 */

/*!<******************  Bit definition for GPIO_IDR register  *******************/
#define GPIO_IDR_IDR0_Pos (0U)
#define GPIO_IDR_IDR0_Msk (0x1U << GPIO_IDR_IDR0_Pos) /*!< 0x00000001 */
#define GPIO_IDR_IDR0 GPIO_IDR_IDR0_Msk /*!< Port input data, bit 0 */
#define GPIO_IDR_IDR1_Pos (1U)
#define GPIO_IDR_IDR1_Msk (0x1U << GPIO_IDR_IDR1_Pos) /*!< 0x00000002 */
#define GPIO_IDR_IDR1 GPIO_IDR_IDR1_Msk /*!< Port input data, bit 1 */
#define GPIO_IDR_IDR2_Pos (2U)
#define GPIO_IDR_IDR2_Msk (0x1U << GPIO_IDR_IDR2_Pos) /*!< 0x00000004 */
#define GPIO_IDR_IDR2 GPIO_IDR_IDR2_Msk /*!< Port input data, bit 2 */
#define GPIO_IDR_IDR3_Pos (3U)
#define GPIO_IDR_IDR3_Msk (0x1U << GPIO_IDR_IDR3_Pos) /*!< 0x00000008 */
#define GPIO_IDR_IDR3 GPIO_IDR_IDR3_Msk /*!< Port input data, bit 3 */
#define GPIO_IDR_IDR4_Pos (4U)
#define GPIO_IDR_IDR4_Msk (0x1U << GPIO_IDR_IDR4_Pos) /*!< 0x00000010 */
#define GPIO_IDR_IDR4 GPIO_IDR_IDR4_Msk /*!< Port input data, bit 4 */
#define GPIO_IDR_IDR5_Pos (5U)
#define GPIO_IDR_IDR5_Msk (0x1U << GPIO_IDR_IDR5_Pos) /*!< 0x00000020 */
#define GPIO_IDR_IDR5 GPIO_IDR_IDR5_Msk /*!< Port input data, bit 5 */
#define GPIO_IDR_IDR6_Pos (6U)
#define GPIO_IDR_IDR6_Msk (0x1U << GPIO_IDR_IDR6_Pos) /*!< 0x00000040 */
#define GPIO_IDR_IDR6 GPIO_IDR_IDR6_Msk /*!< Port input data, bit 6 */
#define GPIO_IDR_IDR7_Pos (7U)
#define GPIO_IDR_IDR7_Msk (0x1U << GPIO_IDR_IDR7_Pos) /*!< 0x00000080 */
#define GPIO_IDR_IDR7 GPIO_IDR_IDR7_Msk /*!< Port input data, bit 7 */
#define GPIO_IDR_IDR8_Pos (8U)
#define GPIO_IDR_IDR8_Msk (0x1U << GPIO_IDR_IDR8_Pos) /*!< 0x00000100 */
#define GPIO_IDR_IDR8 GPIO_IDR_IDR8_Msk /*!< Port input data, bit 8 */
#define GPIO_IDR_IDR9_Pos (9U)
#define GPIO_IDR_IDR9_Msk (0x1U << GPIO_IDR_IDR9_Pos) /*!< 0x00000200 */
#define GPIO_IDR_IDR9 GPIO_IDR_IDR9_Msk /*!< Port input data, bit 9 */
#define GPIO_IDR_IDR10_Pos (10U)
#define GPIO_IDR_IDR10_Msk (0x1U << GPIO_IDR_IDR10_Pos) /*!< 0x00000400 */
#define GPIO_IDR_IDR10 GPIO_IDR_IDR10_Msk /*!< Port input data, bit 10 */
#define GPIO_IDR_IDR11_Pos (11U)
#define GPIO_IDR_IDR11_Msk (0x1U << GPIO_IDR_IDR11_Pos) /*!< 0x00000800 */
#define GPIO_IDR_IDR11 GPIO_IDR_IDR11_Msk /*!< Port input data, bit 11 */
#define GPIO_IDR_IDR12_Pos (12U)
#define GPIO_IDR_IDR12_Msk (0x1U << GPIO_IDR_IDR12_Pos) /*!< 0x00001000 */
#define GPIO_IDR_IDR12 GPIO_IDR_IDR12_Msk /*!< Port input data, bit 12 */
#define GPIO_IDR_IDR13_Pos (13U)
#define GPIO_IDR_IDR13_Msk (0x1U << GPIO_IDR_IDR13_Pos) /*!< 0x00002000 */
#define GPIO_IDR_IDR13 GPIO_IDR_IDR13_Msk /*!< Port input data, bit 13 */
#define GPIO_IDR_IDR14_Pos (14U)
#define GPIO_IDR_IDR14_Msk (0x1U << GPIO_IDR_IDR14_Pos) /*!< 0x00004000 */
#define GPIO_IDR_IDR14 GPIO_IDR_IDR14_Msk /*!< Port input data, bit 14 */
#define GPIO_IDR_IDR15_Pos (15U)
#define GPIO_IDR_IDR15_Msk (0x1U << GPIO_IDR_IDR15_Pos) /*!< 0x00008000 */
#define GPIO_IDR_IDR15 GPIO_IDR_IDR15_Msk /*!< Port input data, bit 15 */

/*******************  Bit definition for GPIO_ODR register  *******************/
#define GPIO_ODR_ODR0_Pos (0U)
#define GPIO_ODR_ODR0_Msk (0x1U << GPIO_ODR_ODR0_Pos) /*!< 0x00000001 */
#define GPIO_ODR_ODR0 GPIO_ODR_ODR0_Msk /*!< Port output data, bit 0 */
#define GPIO_ODR_ODR1_Pos (1U)
#define GPIO_ODR_ODR1_Msk (0x1U << GPIO_ODR_ODR1_Pos) /*!< 0x00000002 */
#define GPIO_ODR_ODR1 GPIO_ODR_ODR1_Msk /*!< Port output data, bit 1 */
#define GPIO_ODR_ODR2_Pos (2U)
#define GPIO_ODR_ODR2_Msk (0x1U << GPIO_ODR_ODR2_Pos) /*!< 0x00000004 */
#define GPIO_ODR_ODR2 GPIO_ODR_ODR2_Msk /*!< Port output data, bit 2 */
#define GPIO_ODR_ODR3_Pos (3U)
#define GPIO_ODR_ODR3_Msk (0x1U << GPIO_ODR_ODR3_Pos) /*!< 0x00000008 */
#define GPIO_ODR_ODR3 GPIO_ODR_ODR3_Msk /*!< Port output data, bit 3 */
#define GPIO_ODR_ODR4_Pos (4U)
#define GPIO_ODR_ODR4_Msk (0x1U << GPIO_ODR_ODR4_Pos) /*!< 0x00000010 */
#define GPIO_ODR_ODR4 GPIO_ODR_ODR4_Msk /*!< Port output data, bit 4 */
#define GPIO_ODR_ODR5_Pos (5U)
#define GPIO_ODR_ODR5_Msk (0x1U << GPIO_ODR_ODR5_Pos) /*!< 0x00000020 */
#define GPIO_ODR_ODR5 GPIO_ODR_ODR5_Msk /*!< Port output data, bit 5 */
#define GPIO_ODR_ODR6_Pos (6U)
#define GPIO_ODR_ODR6_Msk (0x1U << GPIO_ODR_ODR6_Pos) /*!< 0x00000040 */
#define GPIO_ODR_ODR6 GPIO_ODR_ODR6_Msk /*!< Port output data, bit 6 */
#define GPIO_ODR_ODR7_Pos (7U)
#define GPIO_ODR_ODR7_Msk (0x1U << GPIO_ODR_ODR7_Pos) /*!< 0x00000080 */
#define GPIO_ODR_ODR7 GPIO_ODR_ODR7_Msk /*!< Port output data, bit 7 */
#define GPIO_ODR_ODR8_Pos (8U)
#define GPIO_ODR_ODR8_Msk (0x1U << GPIO_ODR_ODR8_Pos) /*!< 0x00000100 */
#define GPIO_ODR_ODR8 GPIO_ODR_ODR8_Msk /*!< Port output data, bit 8 */
#define GPIO_ODR_ODR9_Pos (9U)
#define GPIO_ODR_ODR9_Msk (0x1U << GPIO_ODR_ODR9_Pos) /*!< 0x00000200 */
#define GPIO_ODR_ODR9 GPIO_ODR_ODR9_Msk /*!< Port output data, bit 9 */
#define GPIO_ODR_ODR10_Pos (10U)
#define GPIO_ODR_ODR10_Msk (0x1U << GPIO_ODR_ODR10_Pos) /*!< 0x00000400 */
#define GPIO_ODR_ODR10 GPIO_ODR_ODR10_Msk /*!< Port output data, bit 10 */
#define GPIO_ODR_ODR11_Pos (11U)
#define GPIO_ODR_ODR11_Msk (0x1U << GPIO_ODR_ODR11_Pos) /*!< 0x00000800 */
#define GPIO_ODR_ODR11 GPIO_ODR_ODR11_Msk /*!< Port output data, bit 11 */
#define GPIO_ODR_ODR12_Pos (12U)
#define GPIO_ODR_ODR12_Msk (0x1U << GPIO_ODR_ODR12_Pos) /*!< 0x00001000 */
#define GPIO_ODR_ODR12 GPIO_ODR_ODR12_Msk /*!< Port output data, bit 12 */
#define GPIO_ODR_ODR13_Pos (13U)
#define GPIO_ODR_ODR13_Msk (0x1U << GPIO_ODR_ODR13_Pos) /*!< 0x00002000 */
#define GPIO_ODR_ODR13 GPIO_ODR_ODR13_Msk /*!< Port output data, bit 13 */
#define GPIO_ODR_ODR14_Pos (14U)
#define GPIO_ODR_ODR14_Msk (0x1U << GPIO_ODR_ODR14_Pos) /*!< 0x00004000 */
#define GPIO_ODR_ODR14 GPIO_ODR_ODR14_Msk /*!< Port output data, bit 14 */
#define GPIO_ODR_ODR15_Pos (15U)
#define GPIO_ODR_ODR15_Msk (0x1U << GPIO_ODR_ODR15_Pos) /*!< 0x00008000 */
#define GPIO_ODR_ODR15 GPIO_ODR_ODR15_Msk /*!< Port output data, bit 15 */

/******************  Bit definition for GPIO_BSRR register  *******************/
#define GPIO_BSRR_BS0_Pos (0U)
#define GPIO_BSRR_BS0_Msk (0x1U << GPIO_BSRR_BS0_Pos) /*!< 0x00000001 */
#define GPIO_BSRR_BS0 GPIO_BSRR_BS0_Msk /*!< Port x Set bit 0 */
#define GPIO_BSRR_BS1_Pos (1U)
#define GPIO_BSRR_BS1_Msk (0x1U << GPIO_BSRR_BS1_Pos) /*!< 0x00000002 */
#define GPIO_BSRR_BS1 GPIO_BSRR_BS1_Msk /*!< Port x Set bit 1 */
#define GPIO_BSRR_BS2_Pos (2U)
#define GPIO_BSRR_BS2_Msk (0x1U << GPIO_BSRR_BS2_Pos) /*!< 0x00000004 */
#define GPIO_BSRR_BS2 GPIO_BSRR_BS2_Msk /*!< Port x Set bit 2 */
#define GPIO_BSRR_BS3_Pos (3U)
#define GPIO_BSRR_BS3_Msk (0x1U << GPIO_BSRR_BS3_Pos) /*!< 0x00000008 */
#define GPIO_BSRR_BS3 GPIO_BSRR_BS3_Msk /*!< Port x Set bit 3 */
#define GPIO_BSRR_BS4_Pos (4U)
#define GPIO_BSRR_BS4_Msk (0x1U << GPIO_BSRR_BS4_Pos) /*!< 0x00000010 */
#define GPIO_BSRR_BS4 GPIO_BSRR_BS4_Msk /*!< Port x Set bit 4 */
#define GPIO_BSRR_BS5_Pos (5U)
#define GPIO_BSRR_BS5_Msk (0x1U << GPIO_BSRR_BS5_Pos) /*!< 0x00000020 */
#define GPIO_BSRR_BS5 GPIO_BSRR_BS5_Msk /*!< Port x Set bit 5 */
#define GPIO_BSRR_BS6_Pos (6U)
#define GPIO_BSRR_BS6_Msk (0x1U << GPIO_BSRR_BS6_Pos) /*!< 0x00000040 */
#define GPIO_BSRR_BS6 GPIO_BSRR_BS6_Msk /*!< Port x Set bit 6 */
#define GPIO_BSRR_BS7_Pos (7U)
#define GPIO_BSRR_BS7_Msk (0x1U << GPIO_BSRR_BS7_Pos) /*!< 0x00000080 */
#define GPIO_BSRR_BS7 GPIO_BSRR_BS7_Msk /*!< Port x Set bit 7 */
#define GPIO_BSRR_BS8_Pos (8U)
#define GPIO_BSRR_BS8_Msk (0x1U << GPIO_BSRR_BS8_Pos) /*!< 0x00000100 */
#define GPIO_BSRR_BS8 GPIO_BSRR_BS8_Msk /*!< Port x Set bit 8 */
#define GPIO_BSRR_BS9_Pos (9U)
#define GPIO_BSRR_BS9_Msk (0x1U << GPIO_BSRR_BS9_Pos) /*!< 0x00000200 */
#define GPIO_BSRR_BS9 GPIO_BSRR_BS9_Msk /*!< Port x Set bit 9 */
#define GPIO_BSRR_BS10_Pos (10U)
#define GPIO_BSRR_BS10_Msk (0x1U << GPIO_BSRR_BS10_Pos) /*!< 0x00000400 */
#define GPIO_BSRR_BS10 GPIO_BSRR_BS10_Msk /*!< Port x Set bit 10 */
#define GPIO_BSRR_BS11_Pos (11U)
#define GPIO_BSRR_BS11_Msk (0x1U << GPIO_BSRR_BS11_Pos) /*!< 0x00000800 */
#define GPIO_BSRR_BS11 GPIO_BSRR_BS11_Msk /*!< Port x Set bit 11 */
#define GPIO_BSRR_BS12_Pos (12U)
#define GPIO_BSRR_BS12_Msk (0x1U << GPIO_BSRR_BS12_Pos) /*!< 0x00001000 */
#define GPIO_BSRR_BS12 GPIO_BSRR_BS12_Msk /*!< Port x Set bit 12 */
#define GPIO_BSRR_BS13_Pos (13U)
#define GPIO_BSRR_BS13_Msk (0x1U << GPIO_BSRR_BS13_Pos) /*!< 0x00002000 */
#define GPIO_BSRR_BS13 GPIO_BSRR_BS13_Msk /*!< Port x Set bit 13 */
#define GPIO_BSRR_BS14_Pos (14U)
#define GPIO_BSRR_BS14_Msk (0x1U << GPIO_BSRR_BS14_Pos) /*!< 0x00004000 */
#define GPIO_BSRR_BS14 GPIO_BSRR_BS14_Msk /*!< Port x Set bit 14 */
#define GPIO_BSRR_BS15_Pos (15U)
#define GPIO_BSRR_BS15_Msk (0x1U << GPIO_BSRR_BS15_Pos) /*!< 0x00008000 */
#define GPIO_BSRR_BS15 GPIO_BSRR_BS15_Msk /*!< Port x Set bit 15 */

#define GPIO_BSRR_BR0_Pos (16U)
#define GPIO_BSRR_BR0_Msk (0x1U << GPIO_BSRR_BR0_Pos) /*!< 0x00010000 */
#define GPIO_BSRR_BR0 GPIO_BSRR_BR0_Msk /*!< Port x Reset bit 0 */
#define GPIO_BSRR_BR1_Pos (17U)
#define GPIO_BSRR_BR1_Msk (0x1U << GPIO_BSRR_BR1_Pos) /*!< 0x00020000 */
#define GPIO_BSRR_BR1 GPIO_BSRR_BR1_Msk /*!< Port x Reset bit 1 */
#define GPIO_BSRR_BR2_Pos (18U)
#define GPIO_BSRR_BR2_Msk (0x1U << GPIO_BSRR_BR2_Pos) /*!< 0x00040000 */
#define GPIO_BSRR_BR2 GPIO_BSRR_BR2_Msk /*!< Port x Reset bit 2 */
#define GPIO_BSRR_BR3_Pos (19U)
#define GPIO_BSRR_BR3_Msk (0x1U << GPIO_BSRR_BR3_Pos) /*!< 0x00080000 */
#define GPIO_BSRR_BR3 GPIO_BSRR_BR3_Msk /*!< Port x Reset bit 3 */
#define GPIO_BSRR_BR4_Pos (20U)
#define GPIO_BSRR_BR4_Msk (0x1U << GPIO_BSRR_BR4_Pos) /*!< 0x00100000 */
#define GPIO_BSRR_BR4 GPIO_BSRR_BR4_Msk /*!< Port x Reset bit 4 */
#define GPIO_BSRR_BR5_Pos (21U)
#define GPIO_BSRR_BR5_Msk (0x1U << GPIO_BSRR_BR5_Pos) /*!< 0x00200000 */
#define GPIO_BSRR_BR5 GPIO_BSRR_BR5_Msk /*!< Port x Reset bit 5 */
#define GPIO_BSRR_BR6_Pos (22U)
#define GPIO_BSRR_BR6_Msk (0x1U << GPIO_BSRR_BR6_Pos) /*!< 0x00400000 */
#define GPIO_BSRR_BR6 GPIO_BSRR_BR6_Msk /*!< Port x Reset bit 6 */
#define GPIO_BSRR_BR7_Pos (23U)
#define GPIO_BSRR_BR7_Msk (0x1U << GPIO_BSRR_BR7_Pos) /*!< 0x00800000 */
#define GPIO_BSRR_BR7 GPIO_BSRR_BR7_Msk /*!< Port x Reset bit 7 */
#define GPIO_BSRR_BR8_Pos (24U)
#define GPIO_BSRR_BR8_Msk (0x1U << GPIO_BSRR_BR8_Pos) /*!< 0x01000000 */
#define GPIO_BSRR_BR8 GPIO_BSRR_BR8_Msk /*!< Port x Reset bit 8 */
#define GPIO_BSRR_BR9_Pos (25U)
#define GPIO_BSRR_BR9_Msk (0x1U << GPIO_BSRR_BR9_Pos) /*!< 0x02000000 */
#define GPIO_BSRR_BR9 GPIO_BSRR_BR9_Msk /*!< Port x Reset bit 9 */
#define GPIO_BSRR_BR10_Pos (26U)
#define GPIO_BSRR_BR10_Msk (0x1U << GPIO_BSRR_BR10_Pos) /*!< 0x04000000 */
#define GPIO_BSRR_BR10 GPIO_BSRR_BR10_Msk /*!< Port x Reset bit 10 */
#define GPIO_BSRR_BR11_Pos (27U)
#define GPIO_BSRR_BR11_Msk (0x1U << GPIO_BSRR_BR11_Pos) /*!< 0x08000000 */
#define GPIO_BSRR_BR11 GPIO_BSRR_BR11_Msk /*!< Port x Reset bit 11 */
#define GPIO_BSRR_BR12_Pos (28U)
#define GPIO_BSRR_BR12_Msk (0x1U << GPIO_BSRR_BR12_Pos) /*!< 0x10000000 */
#define GPIO_BSRR_BR12 GPIO_BSRR_BR12_Msk /*!< Port x Reset bit 12 */
#define GPIO_BSRR_BR13_Pos (29U)
#define GPIO_BSRR_BR13_Msk (0x1U << GPIO_BSRR_BR13_Pos) /*!< 0x20000000 */
#define GPIO_BSRR_BR13 GPIO_BSRR_BR13_Msk /*!< Port x Reset bit 13 */
#define GPIO_BSRR_BR14_Pos (30U)
#define GPIO_BSRR_BR14_Msk (0x1U << GPIO_BSRR_BR14_Pos) /*!< 0x40000000 */
#define GPIO_BSRR_BR14 GPIO_BSRR_BR14_Msk /*!< Port x Reset bit 14 */
#define GPIO_BSRR_BR15_Pos (31U)
#define GPIO_BSRR_BR15_Msk (0x1U << GPIO_BSRR_BR15_Pos) /*!< 0x80000000 */
#define GPIO_BSRR_BR15 GPIO_BSRR_BR15_Msk /*!< Port x Reset bit 15 */

/*******************  Bit definition for GPIO_BRR register  *******************/
#define GPIO_BRR_BR0_Pos (0U)
#define GPIO_BRR_BR0_Msk (0x1U << GPIO_BRR_BR0_Pos) /*!< 0x00000001 */
#define GPIO_BRR_BR0 GPIO_BRR_BR0_Msk /*!< Port x Reset bit 0 */
#define GPIO_BRR_BR1_Pos (1U)
#define GPIO_BRR_BR1_Msk (0x1U << GPIO_BRR_BR1_Pos) /*!< 0x00000002 */
#define GPIO_BRR_BR1 GPIO_BRR_BR1_Msk /*!< Port x Reset bit 1 */
#define GPIO_BRR_BR2_Pos (2U)
#define GPIO_BRR_BR2_Msk (0x1U << GPIO_BRR_BR2_Pos) /*!< 0x00000004 */
#define GPIO_BRR_BR2 GPIO_BRR_BR2_Msk /*!< Port x Reset bit 2 */
#define GPIO_BRR_BR3_Pos (3U)
#define GPIO_BRR_BR3_Msk (0x1U << GPIO_BRR_BR3_Pos) /*!< 0x00000008 */
#define GPIO_BRR_BR3 GPIO_BRR_BR3_Msk /*!< Port x Reset bit 3 */
#define GPIO_BRR_BR4_Pos (4U)
#define GPIO_BRR_BR4_Msk (0x1U << GPIO_BRR_BR4_Pos) /*!< 0x00000010 */
#define GPIO_BRR_BR4 GPIO_BRR_BR4_Msk /*!< Port x Reset bit 4 */
#define GPIO_BRR_BR5_Pos (5U)
#define GPIO_BRR_BR5_Msk (0x1U << GPIO_BRR_BR5_Pos) /*!< 0x00000020 */
#define GPIO_BRR_BR5 GPIO_BRR_BR5_Msk /*!< Port x Reset bit 5 */
#define GPIO_BRR_BR6_Pos (6U)
#define GPIO_BRR_BR6_Msk (0x1U << GPIO_BRR_BR6_Pos) /*!< 0x00000040 */
#define GPIO_BRR_BR6 GPIO_BRR_BR6_Msk /*!< Port x Reset bit 6 */
#define GPIO_BRR_BR7_Pos (7U)
#define GPIO_BRR_BR7_Msk (0x1U << GPIO_BRR_BR7_Pos) /*!< 0x00000080 */
#define GPIO_BRR_BR7 GPIO_BRR_BR7_Msk /*!< Port x Reset bit 7 */
#define GPIO_BRR_BR8_Pos (8U)
#define GPIO_BRR_BR8_Msk (0x1U << GPIO_BRR_BR8_Pos) /*!< 0x00000100 */
#define GPIO_BRR_BR8 GPIO_BRR_BR8_Msk /*!< Port x Reset bit 8 */
#define GPIO_BRR_BR9_Pos (9U)
#define GPIO_BRR_BR9_Msk (0x1U << GPIO_BRR_BR9_Pos) /*!< 0x00000200 */
#define GPIO_BRR_BR9 GPIO_BRR_BR9_Msk /*!< Port x Reset bit 9 */
#define GPIO_BRR_BR10_Pos (10U)
#define GPIO_BRR_BR10_Msk (0x1U << GPIO_BRR_BR10_Pos) /*!< 0x00000400 */
#define GPIO_BRR_BR10 GPIO_BRR_BR10_Msk /*!< Port x Reset bit 10 */
#define GPIO_BRR_BR11_Pos (11U)
#define GPIO_BRR_BR11_Msk (0x1U << GPIO_BRR_BR11_Pos) /*!< 0x00000800 */
#define GPIO_BRR_BR11 GPIO_BRR_BR11_Msk /*!< Port x Reset bit 11 */
#define GPIO_BRR_BR12_Pos (12U)
#define GPIO_BRR_BR12_Msk (0x1U << GPIO_BRR_BR12_Pos) /*!< 0x00001000 */
#define GPIO_BRR_BR12 GPIO_BRR_BR12_Msk /*!< Port x Reset bit 12 */
#define GPIO_BRR_BR13_Pos (13U)
#define GPIO_BRR_BR13_Msk (0x1U << GPIO_BRR_BR13_Pos) /*!< 0x00002000 */
#define GPIO_BRR_BR13 GPIO_BRR_BR13_Msk /*!< Port x Reset bit 13 */
#define GPIO_BRR_BR14_Pos (14U)
#define GPIO_BRR_BR14_Msk (0x1U << GPIO_BRR_BR14_Pos) /*!< 0x00004000 */
#define GPIO_BRR_BR14 GPIO_BRR_BR14_Msk /*!< Port x Reset bit 14 */
#define GPIO_BRR_BR15_Pos (15U)
#define GPIO_BRR_BR15_Msk (0x1U << GPIO_BRR_BR15_Pos) /*!< 0x00008000 */
#define GPIO_BRR_BR15 GPIO_BRR_BR15_Msk /*!< Port x Reset bit 15 */

/******************  Bit definition for GPIO_LCKR register  *******************/
#define GPIO_LCKR_LCK0_Pos (0U)
#define GPIO_LCKR_LCK0_Msk (0x1U << GPIO_LCKR_LCK0_Pos) /*!< 0x00000001 */
#define GPIO_LCKR_LCK0 GPIO_LCKR_LCK0_Msk /*!< Port x Lock bit 0 */
#define GPIO_LCKR_LCK1_Pos (1U)
#define GPIO_LCKR_LCK1_Msk (0x1U << GPIO_LCKR_LCK1_Pos) /*!< 0x00000002 */
#define GPIO_LCKR_LCK1 GPIO_LCKR_LCK1_Msk /*!< Port x Lock bit 1 */
#define GPIO_LCKR_LCK2_Pos (2U)
#define GPIO_LCKR_LCK2_Msk (0x1U << GPIO_LCKR_LCK2_Pos) /*!< 0x00000004 */
#define GPIO_LCKR_LCK2 GPIO_LCKR_LCK2_Msk /*!< Port x Lock bit 2 */
#define GPIO_LCKR_LCK3_Pos (3U)
#define GPIO_LCKR_LCK3_Msk (0x1U << GPIO_LCKR_LCK3_Pos) /*!< 0x00000008 */
#define GPIO_LCKR_LCK3 GPIO_LCKR_LCK3_Msk /*!< Port x Lock bit 3 */
#define GPIO_LCKR_LCK4_Pos (4U)
#define GPIO_LCKR_LCK4_Msk (0x1U << GPIO_LCKR_LCK4_Pos) /*!< 0x00000010 */
#define GPIO_LCKR_LCK4 GPIO_LCKR_LCK4_Msk /*!< Port x Lock bit 4 */
#define GPIO_LCKR_LCK5_Pos (5U)
#define GPIO_LCKR_LCK5_Msk (0x1U << GPIO_LCKR_LCK5_Pos) /*!< 0x00000020 */
#define GPIO_LCKR_LCK5 GPIO_LCKR_LCK5_Msk /*!< Port x Lock bit 5 */
#define GPIO_LCKR_LCK6_Pos (6U)
#define GPIO_LCKR_LCK6_Msk (0x1U << GPIO_LCKR_LCK6_Pos) /*!< 0x00000040 */
#define GPIO_LCKR_LCK6 GPIO_LCKR_LCK6_Msk /*!< Port x Lock bit 6 */
#define GPIO_LCKR_LCK7_Pos (7U)
#define GPIO_LCKR_LCK7_Msk (0x1U << GPIO_LCKR_LCK7_Pos) /*!< 0x00000080 */
#define GPIO_LCKR_LCK7 GPIO_LCKR_LCK7_Msk /*!< Port x Lock bit 7 */
#define GPIO_LCKR_LCK8_Pos (8U)
#define GPIO_LCKR_LCK8_Msk (0x1U << GPIO_LCKR_LCK8_Pos) /*!< 0x00000100 */
#define GPIO_LCKR_LCK8 GPIO_LCKR_LCK8_Msk /*!< Port x Lock bit 8 */
#define GPIO_LCKR_LCK9_Pos (9U)
#define GPIO_LCKR_LCK9_Msk (0x1U << GPIO_LCKR_LCK9_Pos) /*!< 0x00000200 */
#define GPIO_LCKR_LCK9 GPIO_LCKR_LCK9_Msk /*!< Port x Lock bit 9 */
#define GPIO_LCKR_LCK10_Pos (10U)
#define GPIO_LCKR_LCK10_Msk (0x1U << GPIO_LCKR_LCK10_Pos) /*!< 0x00000400 */
#define GPIO_LCKR_LCK10 GPIO_LCKR_LCK10_Msk /*!< Port x Lock bit 10 */
#define GPIO_LCKR_LCK11_Pos (11U)
#define GPIO_LCKR_LCK11_Msk (0x1U << GPIO_LCKR_LCK11_Pos) /*!< 0x00000800 */
#define GPIO_LCKR_LCK11 GPIO_LCKR_LCK11_Msk /*!< Port x Lock bit 11 */
#define GPIO_LCKR_LCK12_Pos (12U)
#define GPIO_LCKR_LCK12_Msk (0x1U << GPIO_LCKR_LCK12_Pos) /*!< 0x00001000 */
#define GPIO_LCKR_LCK12 GPIO_LCKR_LCK12_Msk /*!< Port x Lock bit 12 */
#define GPIO_LCKR_LCK13_Pos (13U)
#define GPIO_LCKR_LCK13_Msk (0x1U << GPIO_LCKR_LCK13_Pos) /*!< 0x00002000 */
#define GPIO_LCKR_LCK13 GPIO_LCKR_LCK13_Msk /*!< Port x Lock bit 13 */
#define GPIO_LCKR_LCK14_Pos (14U)
#define GPIO_LCKR_LCK14_Msk (0x1U << GPIO_LCKR_LCK14_Pos) /*!< 0x00004000 */
#define GPIO_LCKR_LCK14 GPIO_LCKR_LCK14_Msk /*!< Port x Lock bit 14 */
#define GPIO_LCKR_LCK15_Pos (15U)
#define GPIO_LCKR_LCK15_Msk (0x1U << GPIO_LCKR_LCK15_Pos) /*!< 0x00008000 */
#define GPIO_LCKR_LCK15 GPIO_LCKR_LCK15_Msk /*!< Port x Lock bit 15 */
#define GPIO_LCKR_LCKK_Pos (16U)
#define GPIO_LCKR_LCKK_Msk (0x1U << GPIO_LCKR_LCKK_Pos) /*!< 0x00010000 */
#define GPIO_LCKR_LCKK GPIO_LCKR_LCKK_Msk /*!< Lock key */

/*----------------------------------------------------------------------------*/

/******************  Bit definition for AFIO_EVCR register  *******************/
#define AFIO_EVCR_PIN_Pos (0U)
#define AFIO_EVCR_PIN_Msk (0xFU << AFIO_EVCR_PIN_Pos) /*!< 0x0000000F */
#define AFIO_EVCR_PIN AFIO_EVCR_PIN_Msk /*!< PIN[3:0] bits (Pin selection) */
#define AFIO_EVCR_PIN_0 (0x1U << AFIO_EVCR_PIN_Pos) /*!< 0x00000001 */
#define AFIO_EVCR_PIN_1 (0x2U << AFIO_EVCR_PIN_Pos) /*!< 0x00000002 */
#define AFIO_EVCR_PIN_2 (0x4U << AFIO_EVCR_PIN_Pos) /*!< 0x00000004 */
#define AFIO_EVCR_PIN_3 (0x8U << AFIO_EVCR_PIN_Pos) /*!< 0x00000008 */

/*!< PIN configuration */
#define AFIO_EVCR_PIN_PX0 0x00000000U /*!< Pin 0 selected */
#define AFIO_EVCR_PIN_PX1_Pos (0U)
#define AFIO_EVCR_PIN_PX1_Msk (0x1U << AFIO_EVCR_PIN_PX1_Pos) /*!< 0x00000001 */
#define AFIO_EVCR_PIN_PX1 AFIO_EVCR_PIN_PX1_Msk /*!< Pin 1 selected */
#define AFIO_EVCR_PIN_PX2_Pos (1U)
#define AFIO_EVCR_PIN_PX2_Msk (0x1U << AFIO_EVCR_PIN_PX2_Pos) /*!< 0x00000002 */
#define AFIO_EVCR_PIN_PX2 AFIO_EVCR_PIN_PX2_Msk /*!< Pin 2 selected */
#define AFIO_EVCR_PIN_PX3_Pos (0U)
#define AFIO_EVCR_PIN_PX3_Msk (0x3U << AFIO_EVCR_PIN_PX3_Pos) /*!< 0x00000003 */
#define AFIO_EVCR_PIN_PX3 AFIO_EVCR_PIN_PX3_Msk /*!< Pin 3 selected */
#define AFIO_EVCR_PIN_PX4_Pos (2U)
#define AFIO_EVCR_PIN_PX4_Msk (0x1U << AFIO_EVCR_PIN_PX4_Pos) /*!< 0x00000004 */
#define AFIO_EVCR_PIN_PX4 AFIO_EVCR_PIN_PX4_Msk /*!< Pin 4 selected */
#define AFIO_EVCR_PIN_PX5_Pos (0U)
#define AFIO_EVCR_PIN_PX5_Msk (0x5U << AFIO_EVCR_PIN_PX5_Pos) /*!< 0x00000005 */
#define AFIO_EVCR_PIN_PX5 AFIO_EVCR_PIN_PX5_Msk /*!< Pin 5 selected */
#define AFIO_EVCR_PIN_PX6_Pos (1U)
#define AFIO_EVCR_PIN_PX6_Msk (0x3U << AFIO_EVCR_PIN_PX6_Pos) /*!< 0x00000006 */
#define AFIO_EVCR_PIN_PX6 AFIO_EVCR_PIN_PX6_Msk /*!< Pin 6 selected */
#define AFIO_EVCR_PIN_PX7_Pos (0U)
#define AFIO_EVCR_PIN_PX7_Msk (0x7U << AFIO_EVCR_PIN_PX7_Pos) /*!< 0x00000007 */
#define AFIO_EVCR_PIN_PX7 AFIO_EVCR_PIN_PX7_Msk /*!< Pin 7 selected */
#define AFIO_EVCR_PIN_PX8_Pos (3U)
#define AFIO_EVCR_PIN_PX8_Msk (0x1U << AFIO_EVCR_PIN_PX8_Pos) /*!< 0x00000008 */
#define AFIO_EVCR_PIN_PX8 AFIO_EVCR_PIN_PX8_Msk /*!< Pin 8 selected */
#define AFIO_EVCR_PIN_PX9_Pos (0U)
#define AFIO_EVCR_PIN_PX9_Msk (0x9U << AFIO_EVCR_PIN_PX9_Pos) /*!< 0x00000009 */
#define AFIO_EVCR_PIN_PX9 AFIO_EVCR_PIN_PX9_Msk /*!< Pin 9 selected */
#define AFIO_EVCR_PIN_PX10_Pos (1U)
#define AFIO_EVCR_PIN_PX10_Msk (0x5U << AFIO_EVCR_PIN_PX10_Pos) /*!< 0x0000000A */
#define AFIO_EVCR_PIN_PX10 AFIO_EVCR_PIN_PX10_Msk /*!< Pin 10 selected */
#define AFIO_EVCR_PIN_PX11_Pos (0U)
#define AFIO_EVCR_PIN_PX11_Msk (0xBU << AFIO_EVCR_PIN_PX11_Pos) /*!< 0x0000000B */
#define AFIO_EVCR_PIN_PX11 AFIO_EVCR_PIN_PX11_Msk /*!< Pin 11 selected */
#define AFIO_EVCR_PIN_PX12_Pos (2U)
#define AFIO_EVCR_PIN_PX12_Msk (0x3U << AFIO_EVCR_PIN_PX12_Pos) /*!< 0x0000000C */
#define AFIO_EVCR_PIN_PX12 AFIO_EVCR_PIN_PX12_Msk /*!< Pin 12 selected */
#define AFIO_EVCR_PIN_PX13_Pos (0U)
#define AFIO_EVCR_PIN_PX13_Msk (0xDU << AFIO_EVCR_PIN_PX13_Pos) /*!< 0x0000000D */
#define AFIO_EVCR_PIN_PX13 AFIO_EVCR_PIN_PX13_Msk /*!< Pin 13 selected */
#define AFIO_EVCR_PIN_PX14_Pos (1U)
#define AFIO_EVCR_PIN_PX14_Msk (0x7U << AFIO_EVCR_PIN_PX14_Pos) /*!< 0x0000000E */
#define AFIO_EVCR_PIN_PX14 AFIO_EVCR_PIN_PX14_Msk /*!< Pin 14 selected */
#define AFIO_EVCR_PIN_PX15_Pos (0U)
#define AFIO_EVCR_PIN_PX15_Msk (0xFU << AFIO_EVCR_PIN_PX15_Pos) /*!< 0x0000000F */
#define AFIO_EVCR_PIN_PX15 AFIO_EVCR_PIN_PX15_Msk /*!< Pin 15 selected */

#define AFIO_EVCR_PORT_Pos (4U)
#define AFIO_EVCR_PORT_Msk (0x7U << AFIO_EVCR_PORT_Pos) /*!< 0x00000070 */
#define AFIO_EVCR_PORT AFIO_EVCR_PORT_Msk /*!< PORT[2:0] bits (Port selection) */
#define AFIO_EVCR_PORT_0 (0x1U << AFIO_EVCR_PORT_Pos) /*!< 0x00000010 */
#define AFIO_EVCR_PORT_1 (0x2U << AFIO_EVCR_PORT_Pos) /*!< 0x00000020 */
#define AFIO_EVCR_PORT_2 (0x4U << AFIO_EVCR_PORT_Pos) /*!< 0x00000040 */

/*!< PORT configuration */
#define AFIO_EVCR_PORT_PA 0x00000000 /*!< Port A selected */
#define AFIO_EVCR_PORT_PB_Pos (4U)
#define AFIO_EVCR_PORT_PB_Msk (0x1U << AFIO_EVCR_PORT_PB_Pos) /*!< 0x00000010 */
#define AFIO_EVCR_PORT_PB AFIO_EVCR_PORT_PB_Msk /*!< Port B selected */
#define AFIO_EVCR_PORT_PC_Pos (5U)
#define AFIO_EVCR_PORT_PC_Msk (0x1U << AFIO_EVCR_PORT_PC_Pos) /*!< 0x00000020 */
#define AFIO_EVCR_PORT_PC AFIO_EVCR_PORT_PC_Msk /*!< Port C selected */
#define AFIO_EVCR_PORT_PD_Pos (4U)
#define AFIO_EVCR_PORT_PD_Msk (0x3U << AFIO_EVCR_PORT_PD_Pos) /*!< 0x00000030 */
#define AFIO_EVCR_PORT_PD AFIO_EVCR_PORT_PD_Msk /*!< Port D selected */
#define AFIO_EVCR_PORT_PE_Pos (6U)
#define AFIO_EVCR_PORT_PE_Msk (0x1U << AFIO_EVCR_PORT_PE_Pos) /*!< 0x00000040 */
#define AFIO_EVCR_PORT_PE AFIO_EVCR_PORT_PE_Msk /*!< Port E selected */

#define AFIO_EVCR_EVOE_Pos (7U)
#define AFIO_EVCR_EVOE_Msk (0x1U << AFIO_EVCR_EVOE_Pos) /*!< 0x00000080 */
#define AFIO_EVCR_EVOE AFIO_EVCR_EVOE_Msk /*!< Event Output Enable */

/******************  Bit definition for AFIO_MAPR register  *******************/
#define AFIO_MAPR_SPI1_REMAP_Pos (0U)
#define AFIO_MAPR_SPI1_REMAP_Msk (0x1U << AFIO_MAPR_SPI1_REMAP_Pos) /*!< 0x00000001 */
#define AFIO_MAPR_SPI1_REMAP AFIO_MAPR_SPI1_REMAP_Msk /*!< SPI1 remapping */
#define AFIO_MAPR_I2C1_REMAP_Pos (1U)
#define AFIO_MAPR_I2C1_REMAP_Msk (0x1U << AFIO_MAPR_I2C1_REMAP_Pos) /*!< 0x00000002 */
#define AFIO_MAPR_I2C1_REMAP AFIO_MAPR_I2C1_REMAP_Msk /*!< I2C1 remapping */
#define AFIO_MAPR_USART1_REMAP_Pos (2U)
#define AFIO_MAPR_USART1_REMAP_Msk (0x1U << AFIO_MAPR_USART1_REMAP_Pos) /*!< 0x00000004 */
#define AFIO_MAPR_USART1_REMAP AFIO_MAPR_USART1_REMAP_Msk /*!< USART1 remapping */
#define AFIO_MAPR_USART2_REMAP_Pos (3U)
#define AFIO_MAPR_USART2_REMAP_Msk (0x1U << AFIO_MAPR_USART2_REMAP_Pos) /*!< 0x00000008 */
#define AFIO_MAPR_USART2_REMAP AFIO_MAPR_USART2_REMAP_Msk /*!< USART2 remapping */

#define AFIO_MAPR_USART3_REMAP_Pos (4U)
#define AFIO_MAPR_USART3_REMAP_Msk (0x3U << AFIO_MAPR_USART3_REMAP_Pos) /*!< 0x00000030 */
#define AFIO_MAPR_USART3_REMAP AFIO_MAPR_USART3_REMAP_Msk /*!< USART3_REMAP[1:0] bits (USART3 remapping) */
#define AFIO_MAPR_USART3_REMAP_0 (0x1U << AFIO_MAPR_USART3_REMAP_Pos) /*!< 0x00000010 */
#define AFIO_MAPR_USART3_REMAP_1 (0x2U << AFIO_MAPR_USART3_REMAP_Pos) /*!< 0x00000020 */

/* USART3_REMAP configuration */
#define AFIO_MAPR_USART3_REMAP_NOREMAP 0x00000000U /*!< No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */
#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP_Pos (4U)
#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP_Msk (0x1U << AFIO_MAPR_USART3_REMAP_PARTIALREMAP_Pos) /*!< 0x00000010 */
#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP AFIO_MAPR_USART3_REMAP_PARTIALREMAP_Msk /*!< Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */
#define AFIO_MAPR_USART3_REMAP_FULLREMAP_Pos (4U)
#define AFIO_MAPR_USART3_REMAP_FULLREMAP_Msk (0x3U << AFIO_MAPR_USART3_REMAP_FULLREMAP_Pos) /*!< 0x00000030 */
#define AFIO_MAPR_USART3_REMAP_FULLREMAP AFIO_MAPR_USART3_REMAP_FULLREMAP_Msk /*!< Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */

#define AFIO_MAPR_TIM1_REMAP_Pos (6U)
#define AFIO_MAPR_TIM1_REMAP_Msk (0x3U << AFIO_MAPR_TIM1_REMAP_Pos) /*!< 0x000000C0 */
#define AFIO_MAPR_TIM1_REMAP AFIO_MAPR_TIM1_REMAP_Msk /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */
#define AFIO_MAPR_TIM1_REMAP_0 (0x1U << AFIO_MAPR_TIM1_REMAP_Pos) /*!< 0x00000040 */
#define AFIO_MAPR_TIM1_REMAP_1 (0x2U << AFIO_MAPR_TIM1_REMAP_Pos) /*!< 0x00000080 */

/*!< TIM1_REMAP configuration */
#define AFIO_MAPR_TIM1_REMAP_NOREMAP 0x00000000U /*!< No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */
#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP_Pos (6U)
#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP_Msk (0x1U << AFIO_MAPR_TIM1_REMAP_PARTIALREMAP_Pos) /*!< 0x00000040 */
#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP AFIO_MAPR_TIM1_REMAP_PARTIALREMAP_Msk /*!< Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */
#define AFIO_MAPR_TIM1_REMAP_FULLREMAP_Pos (6U)
#define AFIO_MAPR_TIM1_REMAP_FULLREMAP_Msk (0x3U << AFIO_MAPR_TIM1_REMAP_FULLREMAP_Pos) /*!< 0x000000C0 */
#define AFIO_MAPR_TIM1_REMAP_FULLREMAP AFIO_MAPR_TIM1_REMAP_FULLREMAP_Msk /*!< Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */

#define AFIO_MAPR_TIM2_REMAP_Pos (8U)
#define AFIO_MAPR_TIM2_REMAP_Msk (0x3U << AFIO_MAPR_TIM2_REMAP_Pos) /*!< 0x00000300 */
#define AFIO_MAPR_TIM2_REMAP AFIO_MAPR_TIM2_REMAP_Msk /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */
#define AFIO_MAPR_TIM2_REMAP_0 (0x1U << AFIO_MAPR_TIM2_REMAP_Pos) /*!< 0x00000100 */
#define AFIO_MAPR_TIM2_REMAP_1 (0x2U << AFIO_MAPR_TIM2_REMAP_Pos) /*!< 0x00000200 */

/*!< TIM2_REMAP configuration */
#define AFIO_MAPR_TIM2_REMAP_NOREMAP 0x00000000U /*!< No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */
#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1_Pos (8U)
#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1_Msk (0x1U << AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1_Pos) /*!< 0x00000100 */
#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1 AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1_Msk /*!< Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */
#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2_Pos (9U)
#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2_Msk (0x1U << AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2_Pos) /*!< 0x00000200 */
#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2 AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2_Msk /*!< Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */
#define AFIO_MAPR_TIM2_REMAP_FULLREMAP_Pos (8U)
#define AFIO_MAPR_TIM2_REMAP_FULLREMAP_Msk (0x3U << AFIO_MAPR_TIM2_REMAP_FULLREMAP_Pos) /*!< 0x00000300 */
#define AFIO_MAPR_TIM2_REMAP_FULLREMAP AFIO_MAPR_TIM2_REMAP_FULLREMAP_Msk /*!< Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */

#define AFIO_MAPR_TIM3_REMAP_Pos (10U)
#define AFIO_MAPR_TIM3_REMAP_Msk (0x3U << AFIO_MAPR_TIM3_REMAP_Pos) /*!< 0x00000C00 */
#define AFIO_MAPR_TIM3_REMAP AFIO_MAPR_TIM3_REMAP_Msk /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */
#define AFIO_MAPR_TIM3_REMAP_0 (0x1U << AFIO_MAPR_TIM3_REMAP_Pos) /*!< 0x00000400 */
#define AFIO_MAPR_TIM3_REMAP_1 (0x2U << AFIO_MAPR_TIM3_REMAP_Pos) /*!< 0x00000800 */

/*!< TIM3_REMAP configuration */
#define AFIO_MAPR_TIM3_REMAP_NOREMAP 0x00000000U /*!< No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */
#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP_Pos (11U)
#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP_Msk (0x1U << AFIO_MAPR_TIM3_REMAP_PARTIALREMAP_Pos) /*!< 0x00000800 */
#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP AFIO_MAPR_TIM3_REMAP_PARTIALREMAP_Msk /*!< Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */
#define AFIO_MAPR_TIM3_REMAP_FULLREMAP_Pos (10U)
#define AFIO_MAPR_TIM3_REMAP_FULLREMAP_Msk (0x3U << AFIO_MAPR_TIM3_REMAP_FULLREMAP_Pos) /*!< 0x00000C00 */
#define AFIO_MAPR_TIM3_REMAP_FULLREMAP AFIO_MAPR_TIM3_REMAP_FULLREMAP_Msk /*!< Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */

#define AFIO_MAPR_TIM4_REMAP_Pos (12U)
#define AFIO_MAPR_TIM4_REMAP_Msk (0x1U << AFIO_MAPR_TIM4_REMAP_Pos) /*!< 0x00001000 */
#define AFIO_MAPR_TIM4_REMAP AFIO_MAPR_TIM4_REMAP_Msk /*!< TIM4_REMAP bit (TIM4 remapping) */

#define AFIO_MAPR_CAN_REMAP_Pos (13U)
#define AFIO_MAPR_CAN_REMAP_Msk (0x3U << AFIO_MAPR_CAN_REMAP_Pos) /*!< 0x00006000 */
#define AFIO_MAPR_CAN_REMAP AFIO_MAPR_CAN_REMAP_Msk /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */
#define AFIO_MAPR_CAN_REMAP_0 (0x1U << AFIO_MAPR_CAN_REMAP_Pos) /*!< 0x00002000 */
#define AFIO_MAPR_CAN_REMAP_1 (0x2U << AFIO_MAPR_CAN_REMAP_Pos) /*!< 0x00004000 */

/*!< CAN_REMAP configuration */
#define AFIO_MAPR_CAN_REMAP_REMAP1 0x00000000U /*!< CANRX mapped to PA11, CANTX mapped to PA12 */
#define AFIO_MAPR_CAN_REMAP_REMAP2_Pos (14U)
#define AFIO_MAPR_CAN_REMAP_REMAP2_Msk (0x1U << AFIO_MAPR_CAN_REMAP_REMAP2_Pos) /*!< 0x00004000 */
#define AFIO_MAPR_CAN_REMAP_REMAP2 AFIO_MAPR_CAN_REMAP_REMAP2_Msk /*!< CANRX mapped to PB8, CANTX mapped to PB9 */
#define AFIO_MAPR_CAN_REMAP_REMAP3_Pos (13U)
#define AFIO_MAPR_CAN_REMAP_REMAP3_Msk (0x3U << AFIO_MAPR_CAN_REMAP_REMAP3_Pos) /*!< 0x00006000 */
#define AFIO_MAPR_CAN_REMAP_REMAP3 AFIO_MAPR_CAN_REMAP_REMAP3_Msk /*!< CANRX mapped to PD0, CANTX mapped to PD1 */

#define AFIO_MAPR_PD01_REMAP_Pos (15U)
#define AFIO_MAPR_PD01_REMAP_Msk (0x1U << AFIO_MAPR_PD01_REMAP_Pos) /*!< 0x00008000 */
#define AFIO_MAPR_PD01_REMAP AFIO_MAPR_PD01_REMAP_Msk /*!< Port D0/Port D1 mapping on OSC_IN/OSC_OUT */

/*!< SWJ_CFG configuration */
#define AFIO_MAPR_SWJ_CFG_Pos (24U)
#define AFIO_MAPR_SWJ_CFG_Msk (0x7U << AFIO_MAPR_SWJ_CFG_Pos) /*!< 0x07000000 */
#define AFIO_MAPR_SWJ_CFG AFIO_MAPR_SWJ_CFG_Msk /*!< SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */
#define AFIO_MAPR_SWJ_CFG_0 (0x1U << AFIO_MAPR_SWJ_CFG_Pos) /*!< 0x01000000 */
#define AFIO_MAPR_SWJ_CFG_1 (0x2U << AFIO_MAPR_SWJ_CFG_Pos) /*!< 0x02000000 */
#define AFIO_MAPR_SWJ_CFG_2 (0x4U << AFIO_MAPR_SWJ_CFG_Pos) /*!< 0x04000000 */

#define AFIO_MAPR_SWJ_CFG_RESET 0x00000000U /*!< Full SWJ (JTAG-DP + SW-DP) : Reset State */
#define AFIO_MAPR_SWJ_CFG_NOJNTRST_Pos (24U)
#define AFIO_MAPR_SWJ_CFG_NOJNTRST_Msk (0x1U << AFIO_MAPR_SWJ_CFG_NOJNTRST_Pos) /*!< 0x01000000 */
#define AFIO_MAPR_SWJ_CFG_NOJNTRST AFIO_MAPR_SWJ_CFG_NOJNTRST_Msk /*!< Full SWJ (JTAG-DP + SW-DP) but without JNTRST */
#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE_Pos (25U)
#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE_Msk (0x1U << AFIO_MAPR_SWJ_CFG_JTAGDISABLE_Pos) /*!< 0x02000000 */
#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE AFIO_MAPR_SWJ_CFG_JTAGDISABLE_Msk /*!< JTAG-DP Disabled and SW-DP Enabled */
#define AFIO_MAPR_SWJ_CFG_DISABLE_Pos (26U)
#define AFIO_MAPR_SWJ_CFG_DISABLE_Msk (0x1U << AFIO_MAPR_SWJ_CFG_DISABLE_Pos) /*!< 0x04000000 */
#define AFIO_MAPR_SWJ_CFG_DISABLE AFIO_MAPR_SWJ_CFG_DISABLE_Msk /*!< JTAG-DP Disabled and SW-DP Disabled */


/*****************  Bit definition for AFIO_EXTICR1 register  *****************/
#define AFIO_EXTICR1_EXTI0_Pos (0U)
#define AFIO_EXTICR1_EXTI0_Msk (0xFU << AFIO_EXTICR1_EXTI0_Pos) /*!< 0x0000000F */
#define AFIO_EXTICR1_EXTI0 AFIO_EXTICR1_EXTI0_Msk /*!< EXTI 0 configuration */
#define AFIO_EXTICR1_EXTI1_Pos (4U)
#define AFIO_EXTICR1_EXTI1_Msk (0xFU << AFIO_EXTICR1_EXTI1_Pos) /*!< 0x000000F0 */
#define AFIO_EXTICR1_EXTI1 AFIO_EXTICR1_EXTI1_Msk /*!< EXTI 1 configuration */
#define AFIO_EXTICR1_EXTI2_Pos (8U)
#define AFIO_EXTICR1_EXTI2_Msk (0xFU << AFIO_EXTICR1_EXTI2_Pos) /*!< 0x00000F00 */
#define AFIO_EXTICR1_EXTI2 AFIO_EXTICR1_EXTI2_Msk /*!< EXTI 2 configuration */
#define AFIO_EXTICR1_EXTI3_Pos (12U)
#define AFIO_EXTICR1_EXTI3_Msk (0xFU << AFIO_EXTICR1_EXTI3_Pos) /*!< 0x0000F000 */
#define AFIO_EXTICR1_EXTI3 AFIO_EXTICR1_EXTI3_Msk /*!< EXTI 3 configuration */

/*!< EXTI0 configuration */
#define AFIO_EXTICR1_EXTI0_PA 0x00000000U /*!< PA[0] pin */
#define AFIO_EXTICR1_EXTI0_PB_Pos (0U)
#define AFIO_EXTICR1_EXTI0_PB_Msk (0x1U << AFIO_EXTICR1_EXTI0_PB_Pos) /*!< 0x00000001 */
#define AFIO_EXTICR1_EXTI0_PB AFIO_EXTICR1_EXTI0_PB_Msk /*!< PB[0] pin */
#define AFIO_EXTICR1_EXTI0_PC_Pos (1U)
#define AFIO_EXTICR1_EXTI0_PC_Msk (0x1U << AFIO_EXTICR1_EXTI0_PC_Pos) /*!< 0x00000002 */
#define AFIO_EXTICR1_EXTI0_PC AFIO_EXTICR1_EXTI0_PC_Msk /*!< PC[0] pin */
#define AFIO_EXTICR1_EXTI0_PD_Pos (0U)
#define AFIO_EXTICR1_EXTI0_PD_Msk (0x3U << AFIO_EXTICR1_EXTI0_PD_Pos) /*!< 0x00000003 */
#define AFIO_EXTICR1_EXTI0_PD AFIO_EXTICR1_EXTI0_PD_Msk /*!< PD[0] pin */
#define AFIO_EXTICR1_EXTI0_PE_Pos (2U)
#define AFIO_EXTICR1_EXTI0_PE_Msk (0x1U << AFIO_EXTICR1_EXTI0_PE_Pos) /*!< 0x00000004 */
#define AFIO_EXTICR1_EXTI0_PE AFIO_EXTICR1_EXTI0_PE_Msk /*!< PE[0] pin */
#define AFIO_EXTICR1_EXTI0_PF_Pos (0U)
#define AFIO_EXTICR1_EXTI0_PF_Msk (0x5U << AFIO_EXTICR1_EXTI0_PF_Pos) /*!< 0x00000005 */
#define AFIO_EXTICR1_EXTI0_PF AFIO_EXTICR1_EXTI0_PF_Msk /*!< PF[0] pin */
#define AFIO_EXTICR1_EXTI0_PG_Pos (1U)
#define AFIO_EXTICR1_EXTI0_PG_Msk (0x3U << AFIO_EXTICR1_EXTI0_PG_Pos) /*!< 0x00000006 */
#define AFIO_EXTICR1_EXTI0_PG AFIO_EXTICR1_EXTI0_PG_Msk /*!< PG[0] pin */

/*!< EXTI1 configuration */
#define AFIO_EXTICR1_EXTI1_PA 0x00000000U /*!< PA[1] pin */
#define AFIO_EXTICR1_EXTI1_PB_Pos (4U)
#define AFIO_EXTICR1_EXTI1_PB_Msk (0x1U << AFIO_EXTICR1_EXTI1_PB_Pos) /*!< 0x00000010 */
#define AFIO_EXTICR1_EXTI1_PB AFIO_EXTICR1_EXTI1_PB_Msk /*!< PB[1] pin */
#define AFIO_EXTICR1_EXTI1_PC_Pos (5U)
#define AFIO_EXTICR1_EXTI1_PC_Msk (0x1U << AFIO_EXTICR1_EXTI1_PC_Pos) /*!< 0x00000020 */
#define AFIO_EXTICR1_EXTI1_PC AFIO_EXTICR1_EXTI1_PC_Msk /*!< PC[1] pin */
#define AFIO_EXTICR1_EXTI1_PD_Pos (4U)
#define AFIO_EXTICR1_EXTI1_PD_Msk (0x3U << AFIO_EXTICR1_EXTI1_PD_Pos) /*!< 0x00000030 */
#define AFIO_EXTICR1_EXTI1_PD AFIO_EXTICR1_EXTI1_PD_Msk /*!< PD[1] pin */
#define AFIO_EXTICR1_EXTI1_PE_Pos (6U)
#define AFIO_EXTICR1_EXTI1_PE_Msk (0x1U << AFIO_EXTICR1_EXTI1_PE_Pos) /*!< 0x00000040 */
#define AFIO_EXTICR1_EXTI1_PE AFIO_EXTICR1_EXTI1_PE_Msk /*!< PE[1] pin */
#define AFIO_EXTICR1_EXTI1_PF_Pos (4U)
#define AFIO_EXTICR1_EXTI1_PF_Msk (0x5U << AFIO_EXTICR1_EXTI1_PF_Pos) /*!< 0x00000050 */
#define AFIO_EXTICR1_EXTI1_PF AFIO_EXTICR1_EXTI1_PF_Msk /*!< PF[1] pin */
#define AFIO_EXTICR1_EXTI1_PG_Pos (5U)
#define AFIO_EXTICR1_EXTI1_PG_Msk (0x3U << AFIO_EXTICR1_EXTI1_PG_Pos) /*!< 0x00000060 */
#define AFIO_EXTICR1_EXTI1_PG AFIO_EXTICR1_EXTI1_PG_Msk /*!< PG[1] pin */

/*!< EXTI2 configuration */
#define AFIO_EXTICR1_EXTI2_PA 0x00000000U /*!< PA[2] pin */
#define AFIO_EXTICR1_EXTI2_PB_Pos (8U)
#define AFIO_EXTICR1_EXTI2_PB_Msk (0x1U << AFIO_EXTICR1_EXTI2_PB_Pos) /*!< 0x00000100 */
#define AFIO_EXTICR1_EXTI2_PB AFIO_EXTICR1_EXTI2_PB_Msk /*!< PB[2] pin */
#define AFIO_EXTICR1_EXTI2_PC_Pos (9U)
#define AFIO_EXTICR1_EXTI2_PC_Msk (0x1U << AFIO_EXTICR1_EXTI2_PC_Pos) /*!< 0x00000200 */
#define AFIO_EXTICR1_EXTI2_PC AFIO_EXTICR1_EXTI2_PC_Msk /*!< PC[2] pin */
#define AFIO_EXTICR1_EXTI2_PD_Pos (8U)
#define AFIO_EXTICR1_EXTI2_PD_Msk (0x3U << AFIO_EXTICR1_EXTI2_PD_Pos) /*!< 0x00000300 */
#define AFIO_EXTICR1_EXTI2_PD AFIO_EXTICR1_EXTI2_PD_Msk /*!< PD[2] pin */
#define AFIO_EXTICR1_EXTI2_PE_Pos (10U)
#define AFIO_EXTICR1_EXTI2_PE_Msk (0x1U << AFIO_EXTICR1_EXTI2_PE_Pos) /*!< 0x00000400 */
#define AFIO_EXTICR1_EXTI2_PE AFIO_EXTICR1_EXTI2_PE_Msk /*!< PE[2] pin */
#define AFIO_EXTICR1_EXTI2_PF_Pos (8U)
#define AFIO_EXTICR1_EXTI2_PF_Msk (0x5U << AFIO_EXTICR1_EXTI2_PF_Pos) /*!< 0x00000500 */
#define AFIO_EXTICR1_EXTI2_PF AFIO_EXTICR1_EXTI2_PF_Msk /*!< PF[2] pin */
#define AFIO_EXTICR1_EXTI2_PG_Pos (9U)
#define AFIO_EXTICR1_EXTI2_PG_Msk (0x3U << AFIO_EXTICR1_EXTI2_PG_Pos) /*!< 0x00000600 */
#define AFIO_EXTICR1_EXTI2_PG AFIO_EXTICR1_EXTI2_PG_Msk /*!< PG[2] pin */

/*!< EXTI3 configuration */
#define AFIO_EXTICR1_EXTI3_PA 0x00000000U /*!< PA[3] pin */
#define AFIO_EXTICR1_EXTI3_PB_Pos (12U)
#define AFIO_EXTICR1_EXTI3_PB_Msk (0x1U << AFIO_EXTICR1_EXTI3_PB_Pos) /*!< 0x00001000 */
#define AFIO_EXTICR1_EXTI3_PB AFIO_EXTICR1_EXTI3_PB_Msk /*!< PB[3] pin */
#define AFIO_EXTICR1_EXTI3_PC_Pos (13U)
#define AFIO_EXTICR1_EXTI3_PC_Msk (0x1U << AFIO_EXTICR1_EXTI3_PC_Pos) /*!< 0x00002000 */
#define AFIO_EXTICR1_EXTI3_PC AFIO_EXTICR1_EXTI3_PC_Msk /*!< PC[3] pin */
#define AFIO_EXTICR1_EXTI3_PD_Pos (12U)
#define AFIO_EXTICR1_EXTI3_PD_Msk (0x3U << AFIO_EXTICR1_EXTI3_PD_Pos) /*!< 0x00003000 */
#define AFIO_EXTICR1_EXTI3_PD AFIO_EXTICR1_EXTI3_PD_Msk /*!< PD[3] pin */
#define AFIO_EXTICR1_EXTI3_PE_Pos (14U)
#define AFIO_EXTICR1_EXTI3_PE_Msk (0x1U << AFIO_EXTICR1_EXTI3_PE_Pos) /*!< 0x00004000 */
#define AFIO_EXTICR1_EXTI3_PE AFIO_EXTICR1_EXTI3_PE_Msk /*!< PE[3] pin */
#define AFIO_EXTICR1_EXTI3_PF_Pos (12U)
#define AFIO_EXTICR1_EXTI3_PF_Msk (0x5U << AFIO_EXTICR1_EXTI3_PF_Pos) /*!< 0x00005000 */
#define AFIO_EXTICR1_EXTI3_PF AFIO_EXTICR1_EXTI3_PF_Msk /*!< PF[3] pin */
#define AFIO_EXTICR1_EXTI3_PG_Pos (13U)
#define AFIO_EXTICR1_EXTI3_PG_Msk (0x3U << AFIO_EXTICR1_EXTI3_PG_Pos) /*!< 0x00006000 */
#define AFIO_EXTICR1_EXTI3_PG AFIO_EXTICR1_EXTI3_PG_Msk /*!< PG[3] pin */

/*****************  Bit definition for AFIO_EXTICR2 register  *****************/
#define AFIO_EXTICR2_EXTI4_Pos (0U)
#define AFIO_EXTICR2_EXTI4_Msk (0xFU << AFIO_EXTICR2_EXTI4_Pos) /*!< 0x0000000F */
#define AFIO_EXTICR2_EXTI4 AFIO_EXTICR2_EXTI4_Msk /*!< EXTI 4 configuration */
#define AFIO_EXTICR2_EXTI5_Pos (4U)
#define AFIO_EXTICR2_EXTI5_Msk (0xFU << AFIO_EXTICR2_EXTI5_Pos) /*!< 0x000000F0 */
#define AFIO_EXTICR2_EXTI5 AFIO_EXTICR2_EXTI5_Msk /*!< EXTI 5 configuration */
#define AFIO_EXTICR2_EXTI6_Pos (8U)
#define AFIO_EXTICR2_EXTI6_Msk (0xFU << AFIO_EXTICR2_EXTI6_Pos) /*!< 0x00000F00 */
#define AFIO_EXTICR2_EXTI6 AFIO_EXTICR2_EXTI6_Msk /*!< EXTI 6 configuration */
#define AFIO_EXTICR2_EXTI7_Pos (12U)
#define AFIO_EXTICR2_EXTI7_Msk (0xFU << AFIO_EXTICR2_EXTI7_Pos) /*!< 0x0000F000 */
#define AFIO_EXTICR2_EXTI7 AFIO_EXTICR2_EXTI7_Msk /*!< EXTI 7 configuration */

/*!< EXTI4 configuration */
#define AFIO_EXTICR2_EXTI4_PA 0x00000000U /*!< PA[4] pin */
#define AFIO_EXTICR2_EXTI4_PB_Pos (0U)
#define AFIO_EXTICR2_EXTI4_PB_Msk (0x1U << AFIO_EXTICR2_EXTI4_PB_Pos) /*!< 0x00000001 */
#define AFIO_EXTICR2_EXTI4_PB AFIO_EXTICR2_EXTI4_PB_Msk /*!< PB[4] pin */
#define AFIO_EXTICR2_EXTI4_PC_Pos (1U)
#define AFIO_EXTICR2_EXTI4_PC_Msk (0x1U << AFIO_EXTICR2_EXTI4_PC_Pos) /*!< 0x00000002 */
#define AFIO_EXTICR2_EXTI4_PC AFIO_EXTICR2_EXTI4_PC_Msk /*!< PC[4] pin */
#define AFIO_EXTICR2_EXTI4_PD_Pos (0U)
#define AFIO_EXTICR2_EXTI4_PD_Msk (0x3U << AFIO_EXTICR2_EXTI4_PD_Pos) /*!< 0x00000003 */
#define AFIO_EXTICR2_EXTI4_PD AFIO_EXTICR2_EXTI4_PD_Msk /*!< PD[4] pin */
#define AFIO_EXTICR2_EXTI4_PE_Pos (2U)
#define AFIO_EXTICR2_EXTI4_PE_Msk (0x1U << AFIO_EXTICR2_EXTI4_PE_Pos) /*!< 0x00000004 */
#define AFIO_EXTICR2_EXTI4_PE AFIO_EXTICR2_EXTI4_PE_Msk /*!< PE[4] pin */
#define AFIO_EXTICR2_EXTI4_PF_Pos (0U)
#define AFIO_EXTICR2_EXTI4_PF_Msk (0x5U << AFIO_EXTICR2_EXTI4_PF_Pos) /*!< 0x00000005 */
#define AFIO_EXTICR2_EXTI4_PF AFIO_EXTICR2_EXTI4_PF_Msk /*!< PF[4] pin */
#define AFIO_EXTICR2_EXTI4_PG_Pos (1U)
#define AFIO_EXTICR2_EXTI4_PG_Msk (0x3U << AFIO_EXTICR2_EXTI4_PG_Pos) /*!< 0x00000006 */
#define AFIO_EXTICR2_EXTI4_PG AFIO_EXTICR2_EXTI4_PG_Msk /*!< PG[4] pin */

/* EXTI5 configuration */
#define AFIO_EXTICR2_EXTI5_PA 0x00000000U /*!< PA[5] pin */
#define AFIO_EXTICR2_EXTI5_PB_Pos (4U)
#define AFIO_EXTICR2_EXTI5_PB_Msk (0x1U << AFIO_EXTICR2_EXTI5_PB_Pos) /*!< 0x00000010 */
#define AFIO_EXTICR2_EXTI5_PB AFIO_EXTICR2_EXTI5_PB_Msk /*!< PB[5] pin */
#define AFIO_EXTICR2_EXTI5_PC_Pos (5U)
#define AFIO_EXTICR2_EXTI5_PC_Msk (0x1U << AFIO_EXTICR2_EXTI5_PC_Pos) /*!< 0x00000020 */
#define AFIO_EXTICR2_EXTI5_PC AFIO_EXTICR2_EXTI5_PC_Msk /*!< PC[5] pin */
#define AFIO_EXTICR2_EXTI5_PD_Pos (4U)
#define AFIO_EXTICR2_EXTI5_PD_Msk (0x3U << AFIO_EXTICR2_EXTI5_PD_Pos) /*!< 0x00000030 */
#define AFIO_EXTICR2_EXTI5_PD AFIO_EXTICR2_EXTI5_PD_Msk /*!< PD[5] pin */
#define AFIO_EXTICR2_EXTI5_PE_Pos (6U)
#define AFIO_EXTICR2_EXTI5_PE_Msk (0x1U << AFIO_EXTICR2_EXTI5_PE_Pos) /*!< 0x00000040 */
#define AFIO_EXTICR2_EXTI5_PE AFIO_EXTICR2_EXTI5_PE_Msk /*!< PE[5] pin */
#define AFIO_EXTICR2_EXTI5_PF_Pos (4U)
#define AFIO_EXTICR2_EXTI5_PF_Msk (0x5U << AFIO_EXTICR2_EXTI5_PF_Pos) /*!< 0x00000050 */
#define AFIO_EXTICR2_EXTI5_PF AFIO_EXTICR2_EXTI5_PF_Msk /*!< PF[5] pin */
#define AFIO_EXTICR2_EXTI5_PG_Pos (5U)
#define AFIO_EXTICR2_EXTI5_PG_Msk (0x3U << AFIO_EXTICR2_EXTI5_PG_Pos) /*!< 0x00000060 */
#define AFIO_EXTICR2_EXTI5_PG AFIO_EXTICR2_EXTI5_PG_Msk /*!< PG[5] pin */

/*!< EXTI6 configuration */
#define AFIO_EXTICR2_EXTI6_PA 0x00000000U /*!< PA[6] pin */
#define AFIO_EXTICR2_EXTI6_PB_Pos (8U)
#define AFIO_EXTICR2_EXTI6_PB_Msk (0x1U << AFIO_EXTICR2_EXTI6_PB_Pos) /*!< 0x00000100 */
#define AFIO_EXTICR2_EXTI6_PB AFIO_EXTICR2_EXTI6_PB_Msk /*!< PB[6] pin */
#define AFIO_EXTICR2_EXTI6_PC_Pos (9U)
#define AFIO_EXTICR2_EXTI6_PC_Msk (0x1U << AFIO_EXTICR2_EXTI6_PC_Pos) /*!< 0x00000200 */
#define AFIO_EXTICR2_EXTI6_PC AFIO_EXTICR2_EXTI6_PC_Msk /*!< PC[6] pin */
#define AFIO_EXTICR2_EXTI6_PD_Pos (8U)
#define AFIO_EXTICR2_EXTI6_PD_Msk (0x3U << AFIO_EXTICR2_EXTI6_PD_Pos) /*!< 0x00000300 */
#define AFIO_EXTICR2_EXTI6_PD AFIO_EXTICR2_EXTI6_PD_Msk /*!< PD[6] pin */
#define AFIO_EXTICR2_EXTI6_PE_Pos (10U)
#define AFIO_EXTICR2_EXTI6_PE_Msk (0x1U << AFIO_EXTICR2_EXTI6_PE_Pos) /*!< 0x00000400 */
#define AFIO_EXTICR2_EXTI6_PE AFIO_EXTICR2_EXTI6_PE_Msk /*!< PE[6] pin */
#define AFIO_EXTICR2_EXTI6_PF_Pos (8U)
#define AFIO_EXTICR2_EXTI6_PF_Msk (0x5U << AFIO_EXTICR2_EXTI6_PF_Pos) /*!< 0x00000500 */
#define AFIO_EXTICR2_EXTI6_PF AFIO_EXTICR2_EXTI6_PF_Msk /*!< PF[6] pin */
#define AFIO_EXTICR2_EXTI6_PG_Pos (9U)
#define AFIO_EXTICR2_EXTI6_PG_Msk (0x3U << AFIO_EXTICR2_EXTI6_PG_Pos) /*!< 0x00000600 */
#define AFIO_EXTICR2_EXTI6_PG AFIO_EXTICR2_EXTI6_PG_Msk /*!< PG[6] pin */

/*!< EXTI7 configuration */
#define AFIO_EXTICR2_EXTI7_PA 0x00000000U /*!< PA[7] pin */
#define AFIO_EXTICR2_EXTI7_PB_Pos (12U)
#define AFIO_EXTICR2_EXTI7_PB_Msk (0x1U << AFIO_EXTICR2_EXTI7_PB_Pos) /*!< 0x00001000 */
#define AFIO_EXTICR2_EXTI7_PB AFIO_EXTICR2_EXTI7_PB_Msk /*!< PB[7] pin */
#define AFIO_EXTICR2_EXTI7_PC_Pos (13U)
#define AFIO_EXTICR2_EXTI7_PC_Msk (0x1U << AFIO_EXTICR2_EXTI7_PC_Pos) /*!< 0x00002000 */
#define AFIO_EXTICR2_EXTI7_PC AFIO_EXTICR2_EXTI7_PC_Msk /*!< PC[7] pin */
#define AFIO_EXTICR2_EXTI7_PD_Pos (12U)
#define AFIO_EXTICR2_EXTI7_PD_Msk (0x3U << AFIO_EXTICR2_EXTI7_PD_Pos) /*!< 0x00003000 */
#define AFIO_EXTICR2_EXTI7_PD AFIO_EXTICR2_EXTI7_PD_Msk /*!< PD[7] pin */
#define AFIO_EXTICR2_EXTI7_PE_Pos (14U)
#define AFIO_EXTICR2_EXTI7_PE_Msk (0x1U << AFIO_EXTICR2_EXTI7_PE_Pos) /*!< 0x00004000 */
#define AFIO_EXTICR2_EXTI7_PE AFIO_EXTICR2_EXTI7_PE_Msk /*!< PE[7] pin */
#define AFIO_EXTICR2_EXTI7_PF_Pos (12U)
#define AFIO_EXTICR2_EXTI7_PF_Msk (0x5U << AFIO_EXTICR2_EXTI7_PF_Pos) /*!< 0x00005000 */
#define AFIO_EXTICR2_EXTI7_PF AFIO_EXTICR2_EXTI7_PF_Msk /*!< PF[7] pin */
#define AFIO_EXTICR2_EXTI7_PG_Pos (13U)
#define AFIO_EXTICR2_EXTI7_PG_Msk (0x3U << AFIO_EXTICR2_EXTI7_PG_Pos) /*!< 0x00006000 */
#define AFIO_EXTICR2_EXTI7_PG AFIO_EXTICR2_EXTI7_PG_Msk /*!< PG[7] pin */

/*****************  Bit definition for AFIO_EXTICR3 register  *****************/
#define AFIO_EXTICR3_EXTI8_Pos (0U)
#define AFIO_EXTICR3_EXTI8_Msk (0xFU << AFIO_EXTICR3_EXTI8_Pos) /*!< 0x0000000F */
#define AFIO_EXTICR3_EXTI8 AFIO_EXTICR3_EXTI8_Msk /*!< EXTI 8 configuration */
#define AFIO_EXTICR3_EXTI9_Pos (4U)
#define AFIO_EXTICR3_EXTI9_Msk (0xFU << AFIO_EXTICR3_EXTI9_Pos) /*!< 0x000000F0 */
#define AFIO_EXTICR3_EXTI9 AFIO_EXTICR3_EXTI9_Msk /*!< EXTI 9 configuration */
#define AFIO_EXTICR3_EXTI10_Pos (8U)
#define AFIO_EXTICR3_EXTI10_Msk (0xFU << AFIO_EXTICR3_EXTI10_Pos) /*!< 0x00000F00 */
#define AFIO_EXTICR3_EXTI10 AFIO_EXTICR3_EXTI10_Msk /*!< EXTI 10 configuration */
#define AFIO_EXTICR3_EXTI11_Pos (12U)
#define AFIO_EXTICR3_EXTI11_Msk (0xFU << AFIO_EXTICR3_EXTI11_Pos) /*!< 0x0000F000 */
#define AFIO_EXTICR3_EXTI11 AFIO_EXTICR3_EXTI11_Msk /*!< EXTI 11 configuration */

/*!< EXTI8 configuration */
#define AFIO_EXTICR3_EXTI8_PA 0x00000000U /*!< PA[8] pin */
#define AFIO_EXTICR3_EXTI8_PB_Pos (0U)
#define AFIO_EXTICR3_EXTI8_PB_Msk (0x1U << AFIO_EXTICR3_EXTI8_PB_Pos) /*!< 0x00000001 */
#define AFIO_EXTICR3_EXTI8_PB AFIO_EXTICR3_EXTI8_PB_Msk /*!< PB[8] pin */
#define AFIO_EXTICR3_EXTI8_PC_Pos (1U)
#define AFIO_EXTICR3_EXTI8_PC_Msk (0x1U << AFIO_EXTICR3_EXTI8_PC_Pos) /*!< 0x00000002 */
#define AFIO_EXTICR3_EXTI8_PC AFIO_EXTICR3_EXTI8_PC_Msk /*!< PC[8] pin */
#define AFIO_EXTICR3_EXTI8_PD_Pos (0U)
#define AFIO_EXTICR3_EXTI8_PD_Msk (0x3U << AFIO_EXTICR3_EXTI8_PD_Pos) /*!< 0x00000003 */
#define AFIO_EXTICR3_EXTI8_PD AFIO_EXTICR3_EXTI8_PD_Msk /*!< PD[8] pin */
#define AFIO_EXTICR3_EXTI8_PE_Pos (2U)
#define AFIO_EXTICR3_EXTI8_PE_Msk (0x1U << AFIO_EXTICR3_EXTI8_PE_Pos) /*!< 0x00000004 */
#define AFIO_EXTICR3_EXTI8_PE AFIO_EXTICR3_EXTI8_PE_Msk /*!< PE[8] pin */
#define AFIO_EXTICR3_EXTI8_PF_Pos (0U)
#define AFIO_EXTICR3_EXTI8_PF_Msk (0x5U << AFIO_EXTICR3_EXTI8_PF_Pos) /*!< 0x00000005 */
#define AFIO_EXTICR3_EXTI8_PF AFIO_EXTICR3_EXTI8_PF_Msk /*!< PF[8] pin */
#define AFIO_EXTICR3_EXTI8_PG_Pos (1U)
#define AFIO_EXTICR3_EXTI8_PG_Msk (0x3U << AFIO_EXTICR3_EXTI8_PG_Pos) /*!< 0x00000006 */
#define AFIO_EXTICR3_EXTI8_PG AFIO_EXTICR3_EXTI8_PG_Msk /*!< PG[8] pin */

/*!< EXTI9 configuration */
#define AFIO_EXTICR3_EXTI9_PA 0x00000000U /*!< PA[9] pin */
#define AFIO_EXTICR3_EXTI9_PB_Pos (4U)
#define AFIO_EXTICR3_EXTI9_PB_Msk (0x1U << AFIO_EXTICR3_EXTI9_PB_Pos) /*!< 0x00000010 */
#define AFIO_EXTICR3_EXTI9_PB AFIO_EXTICR3_EXTI9_PB_Msk /*!< PB[9] pin */
#define AFIO_EXTICR3_EXTI9_PC_Pos (5U)
#define AFIO_EXTICR3_EXTI9_PC_Msk (0x1U << AFIO_EXTICR3_EXTI9_PC_Pos) /*!< 0x00000020 */
#define AFIO_EXTICR3_EXTI9_PC AFIO_EXTICR3_EXTI9_PC_Msk /*!< PC[9] pin */
#define AFIO_EXTICR3_EXTI9_PD_Pos (4U)
#define AFIO_EXTICR3_EXTI9_PD_Msk (0x3U << AFIO_EXTICR3_EXTI9_PD_Pos) /*!< 0x00000030 */
#define AFIO_EXTICR3_EXTI9_PD AFIO_EXTICR3_EXTI9_PD_Msk /*!< PD[9] pin */
#define AFIO_EXTICR3_EXTI9_PE_Pos (6U)
#define AFIO_EXTICR3_EXTI9_PE_Msk (0x1U << AFIO_EXTICR3_EXTI9_PE_Pos) /*!< 0x00000040 */
#define AFIO_EXTICR3_EXTI9_PE AFIO_EXTICR3_EXTI9_PE_Msk /*!< PE[9] pin */
#define AFIO_EXTICR3_EXTI9_PF_Pos (4U)
#define AFIO_EXTICR3_EXTI9_PF_Msk (0x5U << AFIO_EXTICR3_EXTI9_PF_Pos) /*!< 0x00000050 */
#define AFIO_EXTICR3_EXTI9_PF AFIO_EXTICR3_EXTI9_PF_Msk /*!< PF[9] pin */
#define AFIO_EXTICR3_EXTI9_PG_Pos (5U)
#define AFIO_EXTICR3_EXTI9_PG_Msk (0x3U << AFIO_EXTICR3_EXTI9_PG_Pos) /*!< 0x00000060 */
#define AFIO_EXTICR3_EXTI9_PG AFIO_EXTICR3_EXTI9_PG_Msk /*!< PG[9] pin */

/*!< EXTI10 configuration */
#define AFIO_EXTICR3_EXTI10_PA 0x00000000U /*!< PA[10] pin */
#define AFIO_EXTICR3_EXTI10_PB_Pos (8U)
#define AFIO_EXTICR3_EXTI10_PB_Msk (0x1U << AFIO_EXTICR3_EXTI10_PB_Pos) /*!< 0x00000100 */
#define AFIO_EXTICR3_EXTI10_PB AFIO_EXTICR3_EXTI10_PB_Msk /*!< PB[10] pin */
#define AFIO_EXTICR3_EXTI10_PC_Pos (9U)
#define AFIO_EXTICR3_EXTI10_PC_Msk (0x1U << AFIO_EXTICR3_EXTI10_PC_Pos) /*!< 0x00000200 */
#define AFIO_EXTICR3_EXTI10_PC AFIO_EXTICR3_EXTI10_PC_Msk /*!< PC[10] pin */
#define AFIO_EXTICR3_EXTI10_PD_Pos (8U)
#define AFIO_EXTICR3_EXTI10_PD_Msk (0x3U << AFIO_EXTICR3_EXTI10_PD_Pos) /*!< 0x00000300 */
#define AFIO_EXTICR3_EXTI10_PD AFIO_EXTICR3_EXTI10_PD_Msk /*!< PD[10] pin */
#define AFIO_EXTICR3_EXTI10_PE_Pos (10U)
#define AFIO_EXTICR3_EXTI10_PE_Msk (0x1U << AFIO_EXTICR3_EXTI10_PE_Pos) /*!< 0x00000400 */
#define AFIO_EXTICR3_EXTI10_PE AFIO_EXTICR3_EXTI10_PE_Msk /*!< PE[10] pin */
#define AFIO_EXTICR3_EXTI10_PF_Pos (8U)
#define AFIO_EXTICR3_EXTI10_PF_Msk (0x5U << AFIO_EXTICR3_EXTI10_PF_Pos) /*!< 0x00000500 */
#define AFIO_EXTICR3_EXTI10_PF AFIO_EXTICR3_EXTI10_PF_Msk /*!< PF[10] pin */
#define AFIO_EXTICR3_EXTI10_PG_Pos (9U)
#define AFIO_EXTICR3_EXTI10_PG_Msk (0x3U << AFIO_EXTICR3_EXTI10_PG_Pos) /*!< 0x00000600 */
#define AFIO_EXTICR3_EXTI10_PG AFIO_EXTICR3_EXTI10_PG_Msk /*!< PG[10] pin */

/*!< EXTI11 configuration */
#define AFIO_EXTICR3_EXTI11_PA 0x00000000U /*!< PA[11] pin */
#define AFIO_EXTICR3_EXTI11_PB_Pos (12U)
#define AFIO_EXTICR3_EXTI11_PB_Msk (0x1U << AFIO_EXTICR3_EXTI11_PB_Pos) /*!< 0x00001000 */
#define AFIO_EXTICR3_EXTI11_PB AFIO_EXTICR3_EXTI11_PB_Msk /*!< PB[11] pin */
#define AFIO_EXTICR3_EXTI11_PC_Pos (13U)
#define AFIO_EXTICR3_EXTI11_PC_Msk (0x1U << AFIO_EXTICR3_EXTI11_PC_Pos) /*!< 0x00002000 */
#define AFIO_EXTICR3_EXTI11_PC AFIO_EXTICR3_EXTI11_PC_Msk /*!< PC[11] pin */
#define AFIO_EXTICR3_EXTI11_PD_Pos (12U)
#define AFIO_EXTICR3_EXTI11_PD_Msk (0x3U << AFIO_EXTICR3_EXTI11_PD_Pos) /*!< 0x00003000 */
#define AFIO_EXTICR3_EXTI11_PD AFIO_EXTICR3_EXTI11_PD_Msk /*!< PD[11] pin */
#define AFIO_EXTICR3_EXTI11_PE_Pos (14U)
#define AFIO_EXTICR3_EXTI11_PE_Msk (0x1U << AFIO_EXTICR3_EXTI11_PE_Pos) /*!< 0x00004000 */
#define AFIO_EXTICR3_EXTI11_PE AFIO_EXTICR3_EXTI11_PE_Msk /*!< PE[11] pin */
#define AFIO_EXTICR3_EXTI11_PF_Pos (12U)
#define AFIO_EXTICR3_EXTI11_PF_Msk (0x5U << AFIO_EXTICR3_EXTI11_PF_Pos) /*!< 0x00005000 */
#define AFIO_EXTICR3_EXTI11_PF AFIO_EXTICR3_EXTI11_PF_Msk /*!< PF[11] pin */
#define AFIO_EXTICR3_EXTI11_PG_Pos (13U)
#define AFIO_EXTICR3_EXTI11_PG_Msk (0x3U << AFIO_EXTICR3_EXTI11_PG_Pos) /*!< 0x00006000 */
#define AFIO_EXTICR3_EXTI11_PG AFIO_EXTICR3_EXTI11_PG_Msk /*!< PG[11] pin */

/*****************  Bit definition for AFIO_EXTICR4 register  *****************/
#define AFIO_EXTICR4_EXTI12_Pos (0U)
#define AFIO_EXTICR4_EXTI12_Msk (0xFU << AFIO_EXTICR4_EXTI12_Pos) /*!< 0x0000000F */
#define AFIO_EXTICR4_EXTI12 AFIO_EXTICR4_EXTI12_Msk /*!< EXTI 12 configuration */
#define AFIO_EXTICR4_EXTI13_Pos (4U)
#define AFIO_EXTICR4_EXTI13_Msk (0xFU << AFIO_EXTICR4_EXTI13_Pos) /*!< 0x000000F0 */
#define AFIO_EXTICR4_EXTI13 AFIO_EXTICR4_EXTI13_Msk /*!< EXTI 13 configuration */
#define AFIO_EXTICR4_EXTI14_Pos (8U)
#define AFIO_EXTICR4_EXTI14_Msk (0xFU << AFIO_EXTICR4_EXTI14_Pos) /*!< 0x00000F00 */
#define AFIO_EXTICR4_EXTI14 AFIO_EXTICR4_EXTI14_Msk /*!< EXTI 14 configuration */
#define AFIO_EXTICR4_EXTI15_Pos (12U)
#define AFIO_EXTICR4_EXTI15_Msk (0xFU << AFIO_EXTICR4_EXTI15_Pos) /*!< 0x0000F000 */
#define AFIO_EXTICR4_EXTI15 AFIO_EXTICR4_EXTI15_Msk /*!< EXTI 15 configuration */

/* EXTI12 configuration */
#define AFIO_EXTICR4_EXTI12_PA 0x00000000U /*!< PA[12] pin */
#define AFIO_EXTICR4_EXTI12_PB_Pos (0U)
#define AFIO_EXTICR4_EXTI12_PB_Msk (0x1U << AFIO_EXTICR4_EXTI12_PB_Pos) /*!< 0x00000001 */
#define AFIO_EXTICR4_EXTI12_PB AFIO_EXTICR4_EXTI12_PB_Msk /*!< PB[12] pin */
#define AFIO_EXTICR4_EXTI12_PC_Pos (1U)
#define AFIO_EXTICR4_EXTI12_PC_Msk (0x1U << AFIO_EXTICR4_EXTI12_PC_Pos) /*!< 0x00000002 */
#define AFIO_EXTICR4_EXTI12_PC AFIO_EXTICR4_EXTI12_PC_Msk /*!< PC[12] pin */
#define AFIO_EXTICR4_EXTI12_PD_Pos (0U)
#define AFIO_EXTICR4_EXTI12_PD_Msk (0x3U << AFIO_EXTICR4_EXTI12_PD_Pos) /*!< 0x00000003 */
#define AFIO_EXTICR4_EXTI12_PD AFIO_EXTICR4_EXTI12_PD_Msk /*!< PD[12] pin */
#define AFIO_EXTICR4_EXTI12_PE_Pos (2U)
#define AFIO_EXTICR4_EXTI12_PE_Msk (0x1U << AFIO_EXTICR4_EXTI12_PE_Pos) /*!< 0x00000004 */
#define AFIO_EXTICR4_EXTI12_PE AFIO_EXTICR4_EXTI12_PE_Msk /*!< PE[12] pin */
#define AFIO_EXTICR4_EXTI12_PF_Pos (0U)
#define AFIO_EXTICR4_EXTI12_PF_Msk (0x5U << AFIO_EXTICR4_EXTI12_PF_Pos) /*!< 0x00000005 */
#define AFIO_EXTICR4_EXTI12_PF AFIO_EXTICR4_EXTI12_PF_Msk /*!< PF[12] pin */
#define AFIO_EXTICR4_EXTI12_PG_Pos (1U)
#define AFIO_EXTICR4_EXTI12_PG_Msk (0x3U << AFIO_EXTICR4_EXTI12_PG_Pos) /*!< 0x00000006 */
#define AFIO_EXTICR4_EXTI12_PG AFIO_EXTICR4_EXTI12_PG_Msk /*!< PG[12] pin */

/* EXTI13 configuration */
#define AFIO_EXTICR4_EXTI13_PA 0x00000000U /*!< PA[13] pin */
#define AFIO_EXTICR4_EXTI13_PB_Pos (4U)
#define AFIO_EXTICR4_EXTI13_PB_Msk (0x1U << AFIO_EXTICR4_EXTI13_PB_Pos) /*!< 0x00000010 */
#define AFIO_EXTICR4_EXTI13_PB AFIO_EXTICR4_EXTI13_PB_Msk /*!< PB[13] pin */
#define AFIO_EXTICR4_EXTI13_PC_Pos (5U)
#define AFIO_EXTICR4_EXTI13_PC_Msk (0x1U << AFIO_EXTICR4_EXTI13_PC_Pos) /*!< 0x00000020 */
#define AFIO_EXTICR4_EXTI13_PC AFIO_EXTICR4_EXTI13_PC_Msk /*!< PC[13] pin */
#define AFIO_EXTICR4_EXTI13_PD_Pos (4U)
#define AFIO_EXTICR4_EXTI13_PD_Msk (0x3U << AFIO_EXTICR4_EXTI13_PD_Pos) /*!< 0x00000030 */
#define AFIO_EXTICR4_EXTI13_PD AFIO_EXTICR4_EXTI13_PD_Msk /*!< PD[13] pin */
#define AFIO_EXTICR4_EXTI13_PE_Pos (6U)
#define AFIO_EXTICR4_EXTI13_PE_Msk (0x1U << AFIO_EXTICR4_EXTI13_PE_Pos) /*!< 0x00000040 */
#define AFIO_EXTICR4_EXTI13_PE AFIO_EXTICR4_EXTI13_PE_Msk /*!< PE[13] pin */
#define AFIO_EXTICR4_EXTI13_PF_Pos (4U)
#define AFIO_EXTICR4_EXTI13_PF_Msk (0x5U << AFIO_EXTICR4_EXTI13_PF_Pos) /*!< 0x00000050 */
#define AFIO_EXTICR4_EXTI13_PF AFIO_EXTICR4_EXTI13_PF_Msk /*!< PF[13] pin */
#define AFIO_EXTICR4_EXTI13_PG_Pos (5U)
#define AFIO_EXTICR4_EXTI13_PG_Msk (0x3U << AFIO_EXTICR4_EXTI13_PG_Pos) /*!< 0x00000060 */
#define AFIO_EXTICR4_EXTI13_PG AFIO_EXTICR4_EXTI13_PG_Msk /*!< PG[13] pin */

/*!< EXTI14 configuration */
#define AFIO_EXTICR4_EXTI14_PA 0x00000000U /*!< PA[14] pin */
#define AFIO_EXTICR4_EXTI14_PB_Pos (8U)
#define AFIO_EXTICR4_EXTI14_PB_Msk (0x1U << AFIO_EXTICR4_EXTI14_PB_Pos) /*!< 0x00000100 */
#define AFIO_EXTICR4_EXTI14_PB AFIO_EXTICR4_EXTI14_PB_Msk /*!< PB[14] pin */
#define AFIO_EXTICR4_EXTI14_PC_Pos (9U)
#define AFIO_EXTICR4_EXTI14_PC_Msk (0x1U << AFIO_EXTICR4_EXTI14_PC_Pos) /*!< 0x00000200 */
#define AFIO_EXTICR4_EXTI14_PC AFIO_EXTICR4_EXTI14_PC_Msk /*!< PC[14] pin */
#define AFIO_EXTICR4_EXTI14_PD_Pos (8U)
#define AFIO_EXTICR4_EXTI14_PD_Msk (0x3U << AFIO_EXTICR4_EXTI14_PD_Pos) /*!< 0x00000300 */
#define AFIO_EXTICR4_EXTI14_PD AFIO_EXTICR4_EXTI14_PD_Msk /*!< PD[14] pin */
#define AFIO_EXTICR4_EXTI14_PE_Pos (10U)
#define AFIO_EXTICR4_EXTI14_PE_Msk (0x1U << AFIO_EXTICR4_EXTI14_PE_Pos) /*!< 0x00000400 */
#define AFIO_EXTICR4_EXTI14_PE AFIO_EXTICR4_EXTI14_PE_Msk /*!< PE[14] pin */
#define AFIO_EXTICR4_EXTI14_PF_Pos (8U)
#define AFIO_EXTICR4_EXTI14_PF_Msk (0x5U << AFIO_EXTICR4_EXTI14_PF_Pos) /*!< 0x00000500 */
#define AFIO_EXTICR4_EXTI14_PF AFIO_EXTICR4_EXTI14_PF_Msk /*!< PF[14] pin */
#define AFIO_EXTICR4_EXTI14_PG_Pos (9U)
#define AFIO_EXTICR4_EXTI14_PG_Msk (0x3U << AFIO_EXTICR4_EXTI14_PG_Pos) /*!< 0x00000600 */
#define AFIO_EXTICR4_EXTI14_PG AFIO_EXTICR4_EXTI14_PG_Msk /*!< PG[14] pin */

/*!< EXTI15 configuration */
#define AFIO_EXTICR4_EXTI15_PA 0x00000000U /*!< PA[15] pin */
#define AFIO_EXTICR4_EXTI15_PB_Pos (12U)
#define AFIO_EXTICR4_EXTI15_PB_Msk (0x1U << AFIO_EXTICR4_EXTI15_PB_Pos) /*!< 0x00001000 */
#define AFIO_EXTICR4_EXTI15_PB AFIO_EXTICR4_EXTI15_PB_Msk /*!< PB[15] pin */
#define AFIO_EXTICR4_EXTI15_PC_Pos (13U)
#define AFIO_EXTICR4_EXTI15_PC_Msk (0x1U << AFIO_EXTICR4_EXTI15_PC_Pos) /*!< 0x00002000 */
#define AFIO_EXTICR4_EXTI15_PC AFIO_EXTICR4_EXTI15_PC_Msk /*!< PC[15] pin */
#define AFIO_EXTICR4_EXTI15_PD_Pos (12U)
#define AFIO_EXTICR4_EXTI15_PD_Msk (0x3U << AFIO_EXTICR4_EXTI15_PD_Pos) /*!< 0x00003000 */
#define AFIO_EXTICR4_EXTI15_PD AFIO_EXTICR4_EXTI15_PD_Msk /*!< PD[15] pin */
#define AFIO_EXTICR4_EXTI15_PE_Pos (14U)
#define AFIO_EXTICR4_EXTI15_PE_Msk (0x1U << AFIO_EXTICR4_EXTI15_PE_Pos) /*!< 0x00004000 */
#define AFIO_EXTICR4_EXTI15_PE AFIO_EXTICR4_EXTI15_PE_Msk /*!< PE[15] pin */
#define AFIO_EXTICR4_EXTI15_PF_Pos (12U)
#define AFIO_EXTICR4_EXTI15_PF_Msk (0x5U << AFIO_EXTICR4_EXTI15_PF_Pos) /*!< 0x00005000 */
#define AFIO_EXTICR4_EXTI15_PF AFIO_EXTICR4_EXTI15_PF_Msk /*!< PF[15] pin */
#define AFIO_EXTICR4_EXTI15_PG_Pos (13U)
#define AFIO_EXTICR4_EXTI15_PG_Msk (0x3U << AFIO_EXTICR4_EXTI15_PG_Pos) /*!< 0x00006000 */
#define AFIO_EXTICR4_EXTI15_PG AFIO_EXTICR4_EXTI15_PG_Msk /*!< PG[15] pin */

/******************  Bit definition for AFIO_MAPR2 register  ******************/



/******************************************************************************/
/*                                                                            */
/*                    External Interrupt/Event Controller                     */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for EXTI_IMR register  *******************/
#define EXTI_IMR_MR0_Pos (0U)
#define EXTI_IMR_MR0_Msk (0x1U << EXTI_IMR_MR0_Pos) /*!< 0x00000001 */
#define EXTI_IMR_MR0 EXTI_IMR_MR0_Msk /*!< Interrupt Mask on line 0 */
#define EXTI_IMR_MR1_Pos (1U)
#define EXTI_IMR_MR1_Msk (0x1U << EXTI_IMR_MR1_Pos) /*!< 0x00000002 */
#define EXTI_IMR_MR1 EXTI_IMR_MR1_Msk /*!< Interrupt Mask on line 1 */
#define EXTI_IMR_MR2_Pos (2U)
#define EXTI_IMR_MR2_Msk (0x1U << EXTI_IMR_MR2_Pos) /*!< 0x00000004 */
#define EXTI_IMR_MR2 EXTI_IMR_MR2_Msk /*!< Interrupt Mask on line 2 */
#define EXTI_IMR_MR3_Pos (3U)
#define EXTI_IMR_MR3_Msk (0x1U << EXTI_IMR_MR3_Pos) /*!< 0x00000008 */
#define EXTI_IMR_MR3 EXTI_IMR_MR3_Msk /*!< Interrupt Mask on line 3 */
#define EXTI_IMR_MR4_Pos (4U)
#define EXTI_IMR_MR4_Msk (0x1U << EXTI_IMR_MR4_Pos) /*!< 0x00000010 */
#define EXTI_IMR_MR4 EXTI_IMR_MR4_Msk /*!< Interrupt Mask on line 4 */
#define EXTI_IMR_MR5_Pos (5U)
#define EXTI_IMR_MR5_Msk (0x1U << EXTI_IMR_MR5_Pos) /*!< 0x00000020 */
#define EXTI_IMR_MR5 EXTI_IMR_MR5_Msk /*!< Interrupt Mask on line 5 */
#define EXTI_IMR_MR6_Pos (6U)
#define EXTI_IMR_MR6_Msk (0x1U << EXTI_IMR_MR6_Pos) /*!< 0x00000040 */
#define EXTI_IMR_MR6 EXTI_IMR_MR6_Msk /*!< Interrupt Mask on line 6 */
#define EXTI_IMR_MR7_Pos (7U)
#define EXTI_IMR_MR7_Msk (0x1U << EXTI_IMR_MR7_Pos) /*!< 0x00000080 */
#define EXTI_IMR_MR7 EXTI_IMR_MR7_Msk /*!< Interrupt Mask on line 7 */
#define EXTI_IMR_MR8_Pos (8U)
#define EXTI_IMR_MR8_Msk (0x1U << EXTI_IMR_MR8_Pos) /*!< 0x00000100 */
#define EXTI_IMR_MR8 EXTI_IMR_MR8_Msk /*!< Interrupt Mask on line 8 */
#define EXTI_IMR_MR9_Pos (9U)
#define EXTI_IMR_MR9_Msk (0x1U << EXTI_IMR_MR9_Pos) /*!< 0x00000200 */
#define EXTI_IMR_MR9 EXTI_IMR_MR9_Msk /*!< Interrupt Mask on line 9 */
#define EXTI_IMR_MR10_Pos (10U)
#define EXTI_IMR_MR10_Msk (0x1U << EXTI_IMR_MR10_Pos) /*!< 0x00000400 */
#define EXTI_IMR_MR10 EXTI_IMR_MR10_Msk /*!< Interrupt Mask on line 10 */
#define EXTI_IMR_MR11_Pos (11U)
#define EXTI_IMR_MR11_Msk (0x1U << EXTI_IMR_MR11_Pos) /*!< 0x00000800 */
#define EXTI_IMR_MR11 EXTI_IMR_MR11_Msk /*!< Interrupt Mask on line 11 */
#define EXTI_IMR_MR12_Pos (12U)
#define EXTI_IMR_MR12_Msk (0x1U << EXTI_IMR_MR12_Pos) /*!< 0x00001000 */
#define EXTI_IMR_MR12 EXTI_IMR_MR12_Msk /*!< Interrupt Mask on line 12 */
#define EXTI_IMR_MR13_Pos (13U)
#define EXTI_IMR_MR13_Msk (0x1U << EXTI_IMR_MR13_Pos) /*!< 0x00002000 */
#define EXTI_IMR_MR13 EXTI_IMR_MR13_Msk /*!< Interrupt Mask on line 13 */
#define EXTI_IMR_MR14_Pos (14U)
#define EXTI_IMR_MR14_Msk (0x1U << EXTI_IMR_MR14_Pos) /*!< 0x00004000 */
#define EXTI_IMR_MR14 EXTI_IMR_MR14_Msk /*!< Interrupt Mask on line 14 */
#define EXTI_IMR_MR15_Pos (15U)
#define EXTI_IMR_MR15_Msk (0x1U << EXTI_IMR_MR15_Pos) /*!< 0x00008000 */
#define EXTI_IMR_MR15 EXTI_IMR_MR15_Msk /*!< Interrupt Mask on line 15 */
#define EXTI_IMR_MR16_Pos (16U)
#define EXTI_IMR_MR16_Msk (0x1U << EXTI_IMR_MR16_Pos) /*!< 0x00010000 */
#define EXTI_IMR_MR16 EXTI_IMR_MR16_Msk /*!< Interrupt Mask on line 16 */
#define EXTI_IMR_MR17_Pos (17U)
#define EXTI_IMR_MR17_Msk (0x1U << EXTI_IMR_MR17_Pos) /*!< 0x00020000 */
#define EXTI_IMR_MR17 EXTI_IMR_MR17_Msk /*!< Interrupt Mask on line 17 */
#define EXTI_IMR_MR18_Pos (18U)
#define EXTI_IMR_MR18_Msk (0x1U << EXTI_IMR_MR18_Pos) /*!< 0x00040000 */
#define EXTI_IMR_MR18 EXTI_IMR_MR18_Msk /*!< Interrupt Mask on line 18 */

/* References Defines */
#define EXTI_IMR_IM0 EXTI_IMR_MR0
#define EXTI_IMR_IM1 EXTI_IMR_MR1
#define EXTI_IMR_IM2 EXTI_IMR_MR2
#define EXTI_IMR_IM3 EXTI_IMR_MR3
#define EXTI_IMR_IM4 EXTI_IMR_MR4
#define EXTI_IMR_IM5 EXTI_IMR_MR5
#define EXTI_IMR_IM6 EXTI_IMR_MR6
#define EXTI_IMR_IM7 EXTI_IMR_MR7
#define EXTI_IMR_IM8 EXTI_IMR_MR8
#define EXTI_IMR_IM9 EXTI_IMR_MR9
#define EXTI_IMR_IM10 EXTI_IMR_MR10
#define EXTI_IMR_IM11 EXTI_IMR_MR11
#define EXTI_IMR_IM12 EXTI_IMR_MR12
#define EXTI_IMR_IM13 EXTI_IMR_MR13
#define EXTI_IMR_IM14 EXTI_IMR_MR14
#define EXTI_IMR_IM15 EXTI_IMR_MR15
#define EXTI_IMR_IM16 EXTI_IMR_MR16
#define EXTI_IMR_IM17 EXTI_IMR_MR17
#define EXTI_IMR_IM18 EXTI_IMR_MR18
#define EXTI_IMR_IM 0x0007FFFFU /*!< Interrupt Mask All */

/*******************  Bit definition for EXTI_EMR register  *******************/
#define EXTI_EMR_MR0_Pos (0U)
#define EXTI_EMR_MR0_Msk (0x1U << EXTI_EMR_MR0_Pos) /*!< 0x00000001 */
#define EXTI_EMR_MR0 EXTI_EMR_MR0_Msk /*!< Event Mask on line 0 */
#define EXTI_EMR_MR1_Pos (1U)
#define EXTI_EMR_MR1_Msk (0x1U << EXTI_EMR_MR1_Pos) /*!< 0x00000002 */
#define EXTI_EMR_MR1 EXTI_EMR_MR1_Msk /*!< Event Mask on line 1 */
#define EXTI_EMR_MR2_Pos (2U)
#define EXTI_EMR_MR2_Msk (0x1U << EXTI_EMR_MR2_Pos) /*!< 0x00000004 */
#define EXTI_EMR_MR2 EXTI_EMR_MR2_Msk /*!< Event Mask on line 2 */
#define EXTI_EMR_MR3_Pos (3U)
#define EXTI_EMR_MR3_Msk (0x1U << EXTI_EMR_MR3_Pos) /*!< 0x00000008 */
#define EXTI_EMR_MR3 EXTI_EMR_MR3_Msk /*!< Event Mask on line 3 */
#define EXTI_EMR_MR4_Pos (4U)
#define EXTI_EMR_MR4_Msk (0x1U << EXTI_EMR_MR4_Pos) /*!< 0x00000010 */
#define EXTI_EMR_MR4 EXTI_EMR_MR4_Msk /*!< Event Mask on line 4 */
#define EXTI_EMR_MR5_Pos (5U)
#define EXTI_EMR_MR5_Msk (0x1U << EXTI_EMR_MR5_Pos) /*!< 0x00000020 */
#define EXTI_EMR_MR5 EXTI_EMR_MR5_Msk /*!< Event Mask on line 5 */
#define EXTI_EMR_MR6_Pos (6U)
#define EXTI_EMR_MR6_Msk (0x1U << EXTI_EMR_MR6_Pos) /*!< 0x00000040 */
#define EXTI_EMR_MR6 EXTI_EMR_MR6_Msk /*!< Event Mask on line 6 */
#define EXTI_EMR_MR7_Pos (7U)
#define EXTI_EMR_MR7_Msk (0x1U << EXTI_EMR_MR7_Pos) /*!< 0x00000080 */
#define EXTI_EMR_MR7 EXTI_EMR_MR7_Msk /*!< Event Mask on line 7 */
#define EXTI_EMR_MR8_Pos (8U)
#define EXTI_EMR_MR8_Msk (0x1U << EXTI_EMR_MR8_Pos) /*!< 0x00000100 */
#define EXTI_EMR_MR8 EXTI_EMR_MR8_Msk /*!< Event Mask on line 8 */
#define EXTI_EMR_MR9_Pos (9U)
#define EXTI_EMR_MR9_Msk (0x1U << EXTI_EMR_MR9_Pos) /*!< 0x00000200 */
#define EXTI_EMR_MR9 EXTI_EMR_MR9_Msk /*!< Event Mask on line 9 */
#define EXTI_EMR_MR10_Pos (10U)
#define EXTI_EMR_MR10_Msk (0x1U << EXTI_EMR_MR10_Pos) /*!< 0x00000400 */
#define EXTI_EMR_MR10 EXTI_EMR_MR10_Msk /*!< Event Mask on line 10 */
#define EXTI_EMR_MR11_Pos (11U)
#define EXTI_EMR_MR11_Msk (0x1U << EXTI_EMR_MR11_Pos) /*!< 0x00000800 */
#define EXTI_EMR_MR11 EXTI_EMR_MR11_Msk /*!< Event Mask on line 11 */
#define EXTI_EMR_MR12_Pos (12U)
#define EXTI_EMR_MR12_Msk (0x1U << EXTI_EMR_MR12_Pos) /*!< 0x00001000 */
#define EXTI_EMR_MR12 EXTI_EMR_MR12_Msk /*!< Event Mask on line 12 */
#define EXTI_EMR_MR13_Pos (13U)
#define EXTI_EMR_MR13_Msk (0x1U << EXTI_EMR_MR13_Pos) /*!< 0x00002000 */
#define EXTI_EMR_MR13 EXTI_EMR_MR13_Msk /*!< Event Mask on line 13 */
#define EXTI_EMR_MR14_Pos (14U)
#define EXTI_EMR_MR14_Msk (0x1U << EXTI_EMR_MR14_Pos) /*!< 0x00004000 */
#define EXTI_EMR_MR14 EXTI_EMR_MR14_Msk /*!< Event Mask on line 14 */
#define EXTI_EMR_MR15_Pos (15U)
#define EXTI_EMR_MR15_Msk (0x1U << EXTI_EMR_MR15_Pos) /*!< 0x00008000 */
#define EXTI_EMR_MR15 EXTI_EMR_MR15_Msk /*!< Event Mask on line 15 */
#define EXTI_EMR_MR16_Pos (16U)
#define EXTI_EMR_MR16_Msk (0x1U << EXTI_EMR_MR16_Pos) /*!< 0x00010000 */
#define EXTI_EMR_MR16 EXTI_EMR_MR16_Msk /*!< Event Mask on line 16 */
#define EXTI_EMR_MR17_Pos (17U)
#define EXTI_EMR_MR17_Msk (0x1U << EXTI_EMR_MR17_Pos) /*!< 0x00020000 */
#define EXTI_EMR_MR17 EXTI_EMR_MR17_Msk /*!< Event Mask on line 17 */
#define EXTI_EMR_MR18_Pos (18U)
#define EXTI_EMR_MR18_Msk (0x1U << EXTI_EMR_MR18_Pos) /*!< 0x00040000 */
#define EXTI_EMR_MR18 EXTI_EMR_MR18_Msk /*!< Event Mask on line 18 */

/* References Defines */
#define EXTI_EMR_EM0 EXTI_EMR_MR0
#define EXTI_EMR_EM1 EXTI_EMR_MR1
#define EXTI_EMR_EM2 EXTI_EMR_MR2
#define EXTI_EMR_EM3 EXTI_EMR_MR3
#define EXTI_EMR_EM4 EXTI_EMR_MR4
#define EXTI_EMR_EM5 EXTI_EMR_MR5
#define EXTI_EMR_EM6 EXTI_EMR_MR6
#define EXTI_EMR_EM7 EXTI_EMR_MR7
#define EXTI_EMR_EM8 EXTI_EMR_MR8
#define EXTI_EMR_EM9 EXTI_EMR_MR9
#define EXTI_EMR_EM10 EXTI_EMR_MR10
#define EXTI_EMR_EM11 EXTI_EMR_MR11
#define EXTI_EMR_EM12 EXTI_EMR_MR12
#define EXTI_EMR_EM13 EXTI_EMR_MR13
#define EXTI_EMR_EM14 EXTI_EMR_MR14
#define EXTI_EMR_EM15 EXTI_EMR_MR15
#define EXTI_EMR_EM16 EXTI_EMR_MR16
#define EXTI_EMR_EM17 EXTI_EMR_MR17
#define EXTI_EMR_EM18 EXTI_EMR_MR18

/******************  Bit definition for EXTI_RTSR register  *******************/
#define EXTI_RTSR_TR0_Pos (0U)
#define EXTI_RTSR_TR0_Msk (0x1U << EXTI_RTSR_TR0_Pos) /*!< 0x00000001 */
#define EXTI_RTSR_TR0 EXTI_RTSR_TR0_Msk /*!< Rising trigger event configuration bit of line 0 */
#define EXTI_RTSR_TR1_Pos (1U)
#define EXTI_RTSR_TR1_Msk (0x1U << EXTI_RTSR_TR1_Pos) /*!< 0x00000002 */
#define EXTI_RTSR_TR1 EXTI_RTSR_TR1_Msk /*!< Rising trigger event configuration bit of line 1 */
#define EXTI_RTSR_TR2_Pos (2U)
#define EXTI_RTSR_TR2_Msk (0x1U << EXTI_RTSR_TR2_Pos) /*!< 0x00000004 */
#define EXTI_RTSR_TR2 EXTI_RTSR_TR2_Msk /*!< Rising trigger event configuration bit of line 2 */
#define EXTI_RTSR_TR3_Pos (3U)
#define EXTI_RTSR_TR3_Msk (0x1U << EXTI_RTSR_TR3_Pos) /*!< 0x00000008 */
#define EXTI_RTSR_TR3 EXTI_RTSR_TR3_Msk /*!< Rising trigger event configuration bit of line 3 */
#define EXTI_RTSR_TR4_Pos (4U)
#define EXTI_RTSR_TR4_Msk (0x1U << EXTI_RTSR_TR4_Pos) /*!< 0x00000010 */
#define EXTI_RTSR_TR4 EXTI_RTSR_TR4_Msk /*!< Rising trigger event configuration bit of line 4 */
#define EXTI_RTSR_TR5_Pos (5U)
#define EXTI_RTSR_TR5_Msk (0x1U << EXTI_RTSR_TR5_Pos) /*!< 0x00000020 */
#define EXTI_RTSR_TR5 EXTI_RTSR_TR5_Msk /*!< Rising trigger event configuration bit of line 5 */
#define EXTI_RTSR_TR6_Pos (6U)
#define EXTI_RTSR_TR6_Msk (0x1U << EXTI_RTSR_TR6_Pos) /*!< 0x00000040 */
#define EXTI_RTSR_TR6 EXTI_RTSR_TR6_Msk /*!< Rising trigger event configuration bit of line 6 */
#define EXTI_RTSR_TR7_Pos (7U)
#define EXTI_RTSR_TR7_Msk (0x1U << EXTI_RTSR_TR7_Pos) /*!< 0x00000080 */
#define EXTI_RTSR_TR7 EXTI_RTSR_TR7_Msk /*!< Rising trigger event configuration bit of line 7 */
#define EXTI_RTSR_TR8_Pos (8U)
#define EXTI_RTSR_TR8_Msk (0x1U << EXTI_RTSR_TR8_Pos) /*!< 0x00000100 */
#define EXTI_RTSR_TR8 EXTI_RTSR_TR8_Msk /*!< Rising trigger event configuration bit of line 8 */
#define EXTI_RTSR_TR9_Pos (9U)
#define EXTI_RTSR_TR9_Msk (0x1U << EXTI_RTSR_TR9_Pos) /*!< 0x00000200 */
#define EXTI_RTSR_TR9 EXTI_RTSR_TR9_Msk /*!< Rising trigger event configuration bit of line 9 */
#define EXTI_RTSR_TR10_Pos (10U)
#define EXTI_RTSR_TR10_Msk (0x1U << EXTI_RTSR_TR10_Pos) /*!< 0x00000400 */
#define EXTI_RTSR_TR10 EXTI_RTSR_TR10_Msk /*!< Rising trigger event configuration bit of line 10 */
#define EXTI_RTSR_TR11_Pos (11U)
#define EXTI_RTSR_TR11_Msk (0x1U << EXTI_RTSR_TR11_Pos) /*!< 0x00000800 */
#define EXTI_RTSR_TR11 EXTI_RTSR_TR11_Msk /*!< Rising trigger event configuration bit of line 11 */
#define EXTI_RTSR_TR12_Pos (12U)
#define EXTI_RTSR_TR12_Msk (0x1U << EXTI_RTSR_TR12_Pos) /*!< 0x00001000 */
#define EXTI_RTSR_TR12 EXTI_RTSR_TR12_Msk /*!< Rising trigger event configuration bit of line 12 */
#define EXTI_RTSR_TR13_Pos (13U)
#define EXTI_RTSR_TR13_Msk (0x1U << EXTI_RTSR_TR13_Pos) /*!< 0x00002000 */
#define EXTI_RTSR_TR13 EXTI_RTSR_TR13_Msk /*!< Rising trigger event configuration bit of line 13 */
#define EXTI_RTSR_TR14_Pos (14U)
#define EXTI_RTSR_TR14_Msk (0x1U << EXTI_RTSR_TR14_Pos) /*!< 0x00004000 */
#define EXTI_RTSR_TR14 EXTI_RTSR_TR14_Msk /*!< Rising trigger event configuration bit of line 14 */
#define EXTI_RTSR_TR15_Pos (15U)
#define EXTI_RTSR_TR15_Msk (0x1U << EXTI_RTSR_TR15_Pos) /*!< 0x00008000 */
#define EXTI_RTSR_TR15 EXTI_RTSR_TR15_Msk /*!< Rising trigger event configuration bit of line 15 */
#define EXTI_RTSR_TR16_Pos (16U)
#define EXTI_RTSR_TR16_Msk (0x1U << EXTI_RTSR_TR16_Pos) /*!< 0x00010000 */
#define EXTI_RTSR_TR16 EXTI_RTSR_TR16_Msk /*!< Rising trigger event configuration bit of line 16 */
#define EXTI_RTSR_TR17_Pos (17U)
#define EXTI_RTSR_TR17_Msk (0x1U << EXTI_RTSR_TR17_Pos) /*!< 0x00020000 */
#define EXTI_RTSR_TR17 EXTI_RTSR_TR17_Msk /*!< Rising trigger event configuration bit of line 17 */
#define EXTI_RTSR_TR18_Pos (18U)
#define EXTI_RTSR_TR18_Msk (0x1U << EXTI_RTSR_TR18_Pos) /*!< 0x00040000 */
#define EXTI_RTSR_TR18 EXTI_RTSR_TR18_Msk /*!< Rising trigger event configuration bit of line 18 */

/* References Defines */
#define EXTI_RTSR_RT0 EXTI_RTSR_TR0
#define EXTI_RTSR_RT1 EXTI_RTSR_TR1
#define EXTI_RTSR_RT2 EXTI_RTSR_TR2
#define EXTI_RTSR_RT3 EXTI_RTSR_TR3
#define EXTI_RTSR_RT4 EXTI_RTSR_TR4
#define EXTI_RTSR_RT5 EXTI_RTSR_TR5
#define EXTI_RTSR_RT6 EXTI_RTSR_TR6
#define EXTI_RTSR_RT7 EXTI_RTSR_TR7
#define EXTI_RTSR_RT8 EXTI_RTSR_TR8
#define EXTI_RTSR_RT9 EXTI_RTSR_TR9
#define EXTI_RTSR_RT10 EXTI_RTSR_TR10
#define EXTI_RTSR_RT11 EXTI_RTSR_TR11
#define EXTI_RTSR_RT12 EXTI_RTSR_TR12
#define EXTI_RTSR_RT13 EXTI_RTSR_TR13
#define EXTI_RTSR_RT14 EXTI_RTSR_TR14
#define EXTI_RTSR_RT15 EXTI_RTSR_TR15
#define EXTI_RTSR_RT16 EXTI_RTSR_TR16
#define EXTI_RTSR_RT17 EXTI_RTSR_TR17
#define EXTI_RTSR_RT18 EXTI_RTSR_TR18

/******************  Bit definition for EXTI_FTSR register  *******************/
#define EXTI_FTSR_TR0_Pos (0U)
#define EXTI_FTSR_TR0_Msk (0x1U << EXTI_FTSR_TR0_Pos) /*!< 0x00000001 */
#define EXTI_FTSR_TR0 EXTI_FTSR_TR0_Msk /*!< Falling trigger event configuration bit of line 0 */
#define EXTI_FTSR_TR1_Pos (1U)
#define EXTI_FTSR_TR1_Msk (0x1U << EXTI_FTSR_TR1_Pos) /*!< 0x00000002 */
#define EXTI_FTSR_TR1 EXTI_FTSR_TR1_Msk /*!< Falling trigger event configuration bit of line 1 */
#define EXTI_FTSR_TR2_Pos (2U)
#define EXTI_FTSR_TR2_Msk (0x1U << EXTI_FTSR_TR2_Pos) /*!< 0x00000004 */
#define EXTI_FTSR_TR2 EXTI_FTSR_TR2_Msk /*!< Falling trigger event configuration bit of line 2 */
#define EXTI_FTSR_TR3_Pos (3U)
#define EXTI_FTSR_TR3_Msk (0x1U << EXTI_FTSR_TR3_Pos) /*!< 0x00000008 */
#define EXTI_FTSR_TR3 EXTI_FTSR_TR3_Msk /*!< Falling trigger event configuration bit of line 3 */
#define EXTI_FTSR_TR4_Pos (4U)
#define EXTI_FTSR_TR4_Msk (0x1U << EXTI_FTSR_TR4_Pos) /*!< 0x00000010 */
#define EXTI_FTSR_TR4 EXTI_FTSR_TR4_Msk /*!< Falling trigger event configuration bit of line 4 */
#define EXTI_FTSR_TR5_Pos (5U)
#define EXTI_FTSR_TR5_Msk (0x1U << EXTI_FTSR_TR5_Pos) /*!< 0x00000020 */
#define EXTI_FTSR_TR5 EXTI_FTSR_TR5_Msk /*!< Falling trigger event configuration bit of line 5 */
#define EXTI_FTSR_TR6_Pos (6U)
#define EXTI_FTSR_TR6_Msk (0x1U << EXTI_FTSR_TR6_Pos) /*!< 0x00000040 */
#define EXTI_FTSR_TR6 EXTI_FTSR_TR6_Msk /*!< Falling trigger event configuration bit of line 6 */
#define EXTI_FTSR_TR7_Pos (7U)
#define EXTI_FTSR_TR7_Msk (0x1U << EXTI_FTSR_TR7_Pos) /*!< 0x00000080 */
#define EXTI_FTSR_TR7 EXTI_FTSR_TR7_Msk /*!< Falling trigger event configuration bit of line 7 */
#define EXTI_FTSR_TR8_Pos (8U)
#define EXTI_FTSR_TR8_Msk (0x1U << EXTI_FTSR_TR8_Pos) /*!< 0x00000100 */
#define EXTI_FTSR_TR8 EXTI_FTSR_TR8_Msk /*!< Falling trigger event configuration bit of line 8 */
#define EXTI_FTSR_TR9_Pos (9U)
#define EXTI_FTSR_TR9_Msk (0x1U << EXTI_FTSR_TR9_Pos) /*!< 0x00000200 */
#define EXTI_FTSR_TR9 EXTI_FTSR_TR9_Msk /*!< Falling trigger event configuration bit of line 9 */
#define EXTI_FTSR_TR10_Pos (10U)
#define EXTI_FTSR_TR10_Msk (0x1U << EXTI_FTSR_TR10_Pos) /*!< 0x00000400 */
#define EXTI_FTSR_TR10 EXTI_FTSR_TR10_Msk /*!< Falling trigger event configuration bit of line 10 */
#define EXTI_FTSR_TR11_Pos (11U)
#define EXTI_FTSR_TR11_Msk (0x1U << EXTI_FTSR_TR11_Pos) /*!< 0x00000800 */
#define EXTI_FTSR_TR11 EXTI_FTSR_TR11_Msk /*!< Falling trigger event configuration bit of line 11 */
#define EXTI_FTSR_TR12_Pos (12U)
#define EXTI_FTSR_TR12_Msk (0x1U << EXTI_FTSR_TR12_Pos) /*!< 0x00001000 */
#define EXTI_FTSR_TR12 EXTI_FTSR_TR12_Msk /*!< Falling trigger event configuration bit of line 12 */
#define EXTI_FTSR_TR13_Pos (13U)
#define EXTI_FTSR_TR13_Msk (0x1U << EXTI_FTSR_TR13_Pos) /*!< 0x00002000 */
#define EXTI_FTSR_TR13 EXTI_FTSR_TR13_Msk /*!< Falling trigger event configuration bit of line 13 */
#define EXTI_FTSR_TR14_Pos (14U)
#define EXTI_FTSR_TR14_Msk (0x1U << EXTI_FTSR_TR14_Pos) /*!< 0x00004000 */
#define EXTI_FTSR_TR14 EXTI_FTSR_TR14_Msk /*!< Falling trigger event configuration bit of line 14 */
#define EXTI_FTSR_TR15_Pos (15U)
#define EXTI_FTSR_TR15_Msk (0x1U << EXTI_FTSR_TR15_Pos) /*!< 0x00008000 */
#define EXTI_FTSR_TR15 EXTI_FTSR_TR15_Msk /*!< Falling trigger event configuration bit of line 15 */
#define EXTI_FTSR_TR16_Pos (16U)
#define EXTI_FTSR_TR16_Msk (0x1U << EXTI_FTSR_TR16_Pos) /*!< 0x00010000 */
#define EXTI_FTSR_TR16 EXTI_FTSR_TR16_Msk /*!< Falling trigger event configuration bit of line 16 */
#define EXTI_FTSR_TR17_Pos (17U)
#define EXTI_FTSR_TR17_Msk (0x1U << EXTI_FTSR_TR17_Pos) /*!< 0x00020000 */
#define EXTI_FTSR_TR17 EXTI_FTSR_TR17_Msk /*!< Falling trigger event configuration bit of line 17 */
#define EXTI_FTSR_TR18_Pos (18U)
#define EXTI_FTSR_TR18_Msk (0x1U << EXTI_FTSR_TR18_Pos) /*!< 0x00040000 */
#define EXTI_FTSR_TR18 EXTI_FTSR_TR18_Msk /*!< Falling trigger event configuration bit of line 18 */

/* References Defines */
#define EXTI_FTSR_FT0 EXTI_FTSR_TR0
#define EXTI_FTSR_FT1 EXTI_FTSR_TR1
#define EXTI_FTSR_FT2 EXTI_FTSR_TR2
#define EXTI_FTSR_FT3 EXTI_FTSR_TR3
#define EXTI_FTSR_FT4 EXTI_FTSR_TR4
#define EXTI_FTSR_FT5 EXTI_FTSR_TR5
#define EXTI_FTSR_FT6 EXTI_FTSR_TR6
#define EXTI_FTSR_FT7 EXTI_FTSR_TR7
#define EXTI_FTSR_FT8 EXTI_FTSR_TR8
#define EXTI_FTSR_FT9 EXTI_FTSR_TR9
#define EXTI_FTSR_FT10 EXTI_FTSR_TR10
#define EXTI_FTSR_FT11 EXTI_FTSR_TR11
#define EXTI_FTSR_FT12 EXTI_FTSR_TR12
#define EXTI_FTSR_FT13 EXTI_FTSR_TR13
#define EXTI_FTSR_FT14 EXTI_FTSR_TR14
#define EXTI_FTSR_FT15 EXTI_FTSR_TR15
#define EXTI_FTSR_FT16 EXTI_FTSR_TR16
#define EXTI_FTSR_FT17 EXTI_FTSR_TR17
#define EXTI_FTSR_FT18 EXTI_FTSR_TR18

/******************  Bit definition for EXTI_SWIER register  ******************/
#define EXTI_SWIER_SWIER0_Pos (0U)
#define EXTI_SWIER_SWIER0_Msk (0x1U << EXTI_SWIER_SWIER0_Pos) /*!< 0x00000001 */
#define EXTI_SWIER_SWIER0 EXTI_SWIER_SWIER0_Msk /*!< Software Interrupt on line 0 */
#define EXTI_SWIER_SWIER1_Pos (1U)
#define EXTI_SWIER_SWIER1_Msk (0x1U << EXTI_SWIER_SWIER1_Pos) /*!< 0x00000002 */
#define EXTI_SWIER_SWIER1 EXTI_SWIER_SWIER1_Msk /*!< Software Interrupt on line 1 */
#define EXTI_SWIER_SWIER2_Pos (2U)
#define EXTI_SWIER_SWIER2_Msk (0x1U << EXTI_SWIER_SWIER2_Pos) /*!< 0x00000004 */
#define EXTI_SWIER_SWIER2 EXTI_SWIER_SWIER2_Msk /*!< Software Interrupt on line 2 */
#define EXTI_SWIER_SWIER3_Pos (3U)
#define EXTI_SWIER_SWIER3_Msk (0x1U << EXTI_SWIER_SWIER3_Pos) /*!< 0x00000008 */
#define EXTI_SWIER_SWIER3 EXTI_SWIER_SWIER3_Msk /*!< Software Interrupt on line 3 */
#define EXTI_SWIER_SWIER4_Pos (4U)
#define EXTI_SWIER_SWIER4_Msk (0x1U << EXTI_SWIER_SWIER4_Pos) /*!< 0x00000010 */
#define EXTI_SWIER_SWIER4 EXTI_SWIER_SWIER4_Msk /*!< Software Interrupt on line 4 */
#define EXTI_SWIER_SWIER5_Pos (5U)
#define EXTI_SWIER_SWIER5_Msk (0x1U << EXTI_SWIER_SWIER5_Pos) /*!< 0x00000020 */
#define EXTI_SWIER_SWIER5 EXTI_SWIER_SWIER5_Msk /*!< Software Interrupt on line 5 */
#define EXTI_SWIER_SWIER6_Pos (6U)
#define EXTI_SWIER_SWIER6_Msk (0x1U << EXTI_SWIER_SWIER6_Pos) /*!< 0x00000040 */
#define EXTI_SWIER_SWIER6 EXTI_SWIER_SWIER6_Msk /*!< Software Interrupt on line 6 */
#define EXTI_SWIER_SWIER7_Pos (7U)
#define EXTI_SWIER_SWIER7_Msk (0x1U << EXTI_SWIER_SWIER7_Pos) /*!< 0x00000080 */
#define EXTI_SWIER_SWIER7 EXTI_SWIER_SWIER7_Msk /*!< Software Interrupt on line 7 */
#define EXTI_SWIER_SWIER8_Pos (8U)
#define EXTI_SWIER_SWIER8_Msk (0x1U << EXTI_SWIER_SWIER8_Pos) /*!< 0x00000100 */
#define EXTI_SWIER_SWIER8 EXTI_SWIER_SWIER8_Msk /*!< Software Interrupt on line 8 */
#define EXTI_SWIER_SWIER9_Pos (9U)
#define EXTI_SWIER_SWIER9_Msk (0x1U << EXTI_SWIER_SWIER9_Pos) /*!< 0x00000200 */
#define EXTI_SWIER_SWIER9 EXTI_SWIER_SWIER9_Msk /*!< Software Interrupt on line 9 */
#define EXTI_SWIER_SWIER10_Pos (10U)
#define EXTI_SWIER_SWIER10_Msk (0x1U << EXTI_SWIER_SWIER10_Pos) /*!< 0x00000400 */
#define EXTI_SWIER_SWIER10 EXTI_SWIER_SWIER10_Msk /*!< Software Interrupt on line 10 */
#define EXTI_SWIER_SWIER11_Pos (11U)
#define EXTI_SWIER_SWIER11_Msk (0x1U << EXTI_SWIER_SWIER11_Pos) /*!< 0x00000800 */
#define EXTI_SWIER_SWIER11 EXTI_SWIER_SWIER11_Msk /*!< Software Interrupt on line 11 */
#define EXTI_SWIER_SWIER12_Pos (12U)
#define EXTI_SWIER_SWIER12_Msk (0x1U << EXTI_SWIER_SWIER12_Pos) /*!< 0x00001000 */
#define EXTI_SWIER_SWIER12 EXTI_SWIER_SWIER12_Msk /*!< Software Interrupt on line 12 */
#define EXTI_SWIER_SWIER13_Pos (13U)
#define EXTI_SWIER_SWIER13_Msk (0x1U << EXTI_SWIER_SWIER13_Pos) /*!< 0x00002000 */
#define EXTI_SWIER_SWIER13 EXTI_SWIER_SWIER13_Msk /*!< Software Interrupt on line 13 */
#define EXTI_SWIER_SWIER14_Pos (14U)
#define EXTI_SWIER_SWIER14_Msk (0x1U << EXTI_SWIER_SWIER14_Pos) /*!< 0x00004000 */
#define EXTI_SWIER_SWIER14 EXTI_SWIER_SWIER14_Msk /*!< Software Interrupt on line 14 */
#define EXTI_SWIER_SWIER15_Pos (15U)
#define EXTI_SWIER_SWIER15_Msk (0x1U << EXTI_SWIER_SWIER15_Pos) /*!< 0x00008000 */
#define EXTI_SWIER_SWIER15 EXTI_SWIER_SWIER15_Msk /*!< Software Interrupt on line 15 */
#define EXTI_SWIER_SWIER16_Pos (16U)
#define EXTI_SWIER_SWIER16_Msk (0x1U << EXTI_SWIER_SWIER16_Pos) /*!< 0x00010000 */
#define EXTI_SWIER_SWIER16 EXTI_SWIER_SWIER16_Msk /*!< Software Interrupt on line 16 */
#define EXTI_SWIER_SWIER17_Pos (17U)
#define EXTI_SWIER_SWIER17_Msk (0x1U << EXTI_SWIER_SWIER17_Pos) /*!< 0x00020000 */
#define EXTI_SWIER_SWIER17 EXTI_SWIER_SWIER17_Msk /*!< Software Interrupt on line 17 */
#define EXTI_SWIER_SWIER18_Pos (18U)
#define EXTI_SWIER_SWIER18_Msk (0x1U << EXTI_SWIER_SWIER18_Pos) /*!< 0x00040000 */
#define EXTI_SWIER_SWIER18 EXTI_SWIER_SWIER18_Msk /*!< Software Interrupt on line 18 */

/* References Defines */
#define EXTI_SWIER_SWI0 EXTI_SWIER_SWIER0
#define EXTI_SWIER_SWI1 EXTI_SWIER_SWIER1
#define EXTI_SWIER_SWI2 EXTI_SWIER_SWIER2
#define EXTI_SWIER_SWI3 EXTI_SWIER_SWIER3
#define EXTI_SWIER_SWI4 EXTI_SWIER_SWIER4
#define EXTI_SWIER_SWI5 EXTI_SWIER_SWIER5
#define EXTI_SWIER_SWI6 EXTI_SWIER_SWIER6
#define EXTI_SWIER_SWI7 EXTI_SWIER_SWIER7
#define EXTI_SWIER_SWI8 EXTI_SWIER_SWIER8
#define EXTI_SWIER_SWI9 EXTI_SWIER_SWIER9
#define EXTI_SWIER_SWI10 EXTI_SWIER_SWIER10
#define EXTI_SWIER_SWI11 EXTI_SWIER_SWIER11
#define EXTI_SWIER_SWI12 EXTI_SWIER_SWIER12
#define EXTI_SWIER_SWI13 EXTI_SWIER_SWIER13
#define EXTI_SWIER_SWI14 EXTI_SWIER_SWIER14
#define EXTI_SWIER_SWI15 EXTI_SWIER_SWIER15
#define EXTI_SWIER_SWI16 EXTI_SWIER_SWIER16
#define EXTI_SWIER_SWI17 EXTI_SWIER_SWIER17
#define EXTI_SWIER_SWI18 EXTI_SWIER_SWIER18

/*******************  Bit definition for EXTI_PR register  ********************/
#define EXTI_PR_PR0_Pos (0U)
#define EXTI_PR_PR0_Msk (0x1U << EXTI_PR_PR0_Pos) /*!< 0x00000001 */
#define EXTI_PR_PR0 EXTI_PR_PR0_Msk /*!< Pending bit for line 0 */
#define EXTI_PR_PR1_Pos (1U)
#define EXTI_PR_PR1_Msk (0x1U << EXTI_PR_PR1_Pos) /*!< 0x00000002 */
#define EXTI_PR_PR1 EXTI_PR_PR1_Msk /*!< Pending bit for line 1 */
#define EXTI_PR_PR2_Pos (2U)
#define EXTI_PR_PR2_Msk (0x1U << EXTI_PR_PR2_Pos) /*!< 0x00000004 */
#define EXTI_PR_PR2 EXTI_PR_PR2_Msk /*!< Pending bit for line 2 */
#define EXTI_PR_PR3_Pos (3U)
#define EXTI_PR_PR3_Msk (0x1U << EXTI_PR_PR3_Pos) /*!< 0x00000008 */
#define EXTI_PR_PR3 EXTI_PR_PR3_Msk /*!< Pending bit for line 3 */
#define EXTI_PR_PR4_Pos (4U)
#define EXTI_PR_PR4_Msk (0x1U << EXTI_PR_PR4_Pos) /*!< 0x00000010 */
#define EXTI_PR_PR4 EXTI_PR_PR4_Msk /*!< Pending bit for line 4 */
#define EXTI_PR_PR5_Pos (5U)
#define EXTI_PR_PR5_Msk (0x1U << EXTI_PR_PR5_Pos) /*!< 0x00000020 */
#define EXTI_PR_PR5 EXTI_PR_PR5_Msk /*!< Pending bit for line 5 */
#define EXTI_PR_PR6_Pos (6U)
#define EXTI_PR_PR6_Msk (0x1U << EXTI_PR_PR6_Pos) /*!< 0x00000040 */
#define EXTI_PR_PR6 EXTI_PR_PR6_Msk /*!< Pending bit for line 6 */
#define EXTI_PR_PR7_Pos (7U)
#define EXTI_PR_PR7_Msk (0x1U << EXTI_PR_PR7_Pos) /*!< 0x00000080 */
#define EXTI_PR_PR7 EXTI_PR_PR7_Msk /*!< Pending bit for line 7 */
#define EXTI_PR_PR8_Pos (8U)
#define EXTI_PR_PR8_Msk (0x1U << EXTI_PR_PR8_Pos) /*!< 0x00000100 */
#define EXTI_PR_PR8 EXTI_PR_PR8_Msk /*!< Pending bit for line 8 */
#define EXTI_PR_PR9_Pos (9U)
#define EXTI_PR_PR9_Msk (0x1U << EXTI_PR_PR9_Pos) /*!< 0x00000200 */
#define EXTI_PR_PR9 EXTI_PR_PR9_Msk /*!< Pending bit for line 9 */
#define EXTI_PR_PR10_Pos (10U)
#define EXTI_PR_PR10_Msk (0x1U << EXTI_PR_PR10_Pos) /*!< 0x00000400 */
#define EXTI_PR_PR10 EXTI_PR_PR10_Msk /*!< Pending bit for line 10 */
#define EXTI_PR_PR11_Pos (11U)
#define EXTI_PR_PR11_Msk (0x1U << EXTI_PR_PR11_Pos) /*!< 0x00000800 */
#define EXTI_PR_PR11 EXTI_PR_PR11_Msk /*!< Pending bit for line 11 */
#define EXTI_PR_PR12_Pos (12U)
#define EXTI_PR_PR12_Msk (0x1U << EXTI_PR_PR12_Pos) /*!< 0x00001000 */
#define EXTI_PR_PR12 EXTI_PR_PR12_Msk /*!< Pending bit for line 12 */
#define EXTI_PR_PR13_Pos (13U)
#define EXTI_PR_PR13_Msk (0x1U << EXTI_PR_PR13_Pos) /*!< 0x00002000 */
#define EXTI_PR_PR13 EXTI_PR_PR13_Msk /*!< Pending bit for line 13 */
#define EXTI_PR_PR14_Pos (14U)
#define EXTI_PR_PR14_Msk (0x1U << EXTI_PR_PR14_Pos) /*!< 0x00004000 */
#define EXTI_PR_PR14 EXTI_PR_PR14_Msk /*!< Pending bit for line 14 */
#define EXTI_PR_PR15_Pos (15U)
#define EXTI_PR_PR15_Msk (0x1U << EXTI_PR_PR15_Pos) /*!< 0x00008000 */
#define EXTI_PR_PR15 EXTI_PR_PR15_Msk /*!< Pending bit for line 15 */
#define EXTI_PR_PR16_Pos (16U)
#define EXTI_PR_PR16_Msk (0x1U << EXTI_PR_PR16_Pos) /*!< 0x00010000 */
#define EXTI_PR_PR16 EXTI_PR_PR16_Msk /*!< Pending bit for line 16 */
#define EXTI_PR_PR17_Pos (17U)
#define EXTI_PR_PR17_Msk (0x1U << EXTI_PR_PR17_Pos) /*!< 0x00020000 */
#define EXTI_PR_PR17 EXTI_PR_PR17_Msk /*!< Pending bit for line 17 */
#define EXTI_PR_PR18_Pos (18U)
#define EXTI_PR_PR18_Msk (0x1U << EXTI_PR_PR18_Pos) /*!< 0x00040000 */
#define EXTI_PR_PR18 EXTI_PR_PR18_Msk /*!< Pending bit for line 18 */

/* References Defines */
#define EXTI_PR_PIF0 EXTI_PR_PR0
#define EXTI_PR_PIF1 EXTI_PR_PR1
#define EXTI_PR_PIF2 EXTI_PR_PR2
#define EXTI_PR_PIF3 EXTI_PR_PR3
#define EXTI_PR_PIF4 EXTI_PR_PR4
#define EXTI_PR_PIF5 EXTI_PR_PR5
#define EXTI_PR_PIF6 EXTI_PR_PR6
#define EXTI_PR_PIF7 EXTI_PR_PR7
#define EXTI_PR_PIF8 EXTI_PR_PR8
#define EXTI_PR_PIF9 EXTI_PR_PR9
#define EXTI_PR_PIF10 EXTI_PR_PR10
#define EXTI_PR_PIF11 EXTI_PR_PR11
#define EXTI_PR_PIF12 EXTI_PR_PR12
#define EXTI_PR_PIF13 EXTI_PR_PR13
#define EXTI_PR_PIF14 EXTI_PR_PR14
#define EXTI_PR_PIF15 EXTI_PR_PR15
#define EXTI_PR_PIF16 EXTI_PR_PR16
#define EXTI_PR_PIF17 EXTI_PR_PR17
#define EXTI_PR_PIF18 EXTI_PR_PR18

/******************************************************************************/
/*                                                                            */
/*                             DMA Controller                                 */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for DMA_ISR register  ********************/
#define DMA_ISR_GIF1_Pos (0U)
#define DMA_ISR_GIF1_Msk (0x1U << DMA_ISR_GIF1_Pos) /*!< 0x00000001 */
#define DMA_ISR_GIF1 DMA_ISR_GIF1_Msk /*!< Channel 1 Global interrupt flag */
#define DMA_ISR_TCIF1_Pos (1U)
#define DMA_ISR_TCIF1_Msk (0x1U << DMA_ISR_TCIF1_Pos) /*!< 0x00000002 */
#define DMA_ISR_TCIF1 DMA_ISR_TCIF1_Msk /*!< Channel 1 Transfer Complete flag */
#define DMA_ISR_HTIF1_Pos (2U)
#define DMA_ISR_HTIF1_Msk (0x1U << DMA_ISR_HTIF1_Pos) /*!< 0x00000004 */
#define DMA_ISR_HTIF1 DMA_ISR_HTIF1_Msk /*!< Channel 1 Half Transfer flag */
#define DMA_ISR_TEIF1_Pos (3U)
#define DMA_ISR_TEIF1_Msk (0x1U << DMA_ISR_TEIF1_Pos) /*!< 0x00000008 */
#define DMA_ISR_TEIF1 DMA_ISR_TEIF1_Msk /*!< Channel 1 Transfer Error flag */
#define DMA_ISR_GIF2_Pos (4U)
#define DMA_ISR_GIF2_Msk (0x1U << DMA_ISR_GIF2_Pos) /*!< 0x00000010 */
#define DMA_ISR_GIF2 DMA_ISR_GIF2_Msk /*!< Channel 2 Global interrupt flag */
#define DMA_ISR_TCIF2_Pos (5U)
#define DMA_ISR_TCIF2_Msk (0x1U << DMA_ISR_TCIF2_Pos) /*!< 0x00000020 */
#define DMA_ISR_TCIF2 DMA_ISR_TCIF2_Msk /*!< Channel 2 Transfer Complete flag */
#define DMA_ISR_HTIF2_Pos (6U)
#define DMA_ISR_HTIF2_Msk (0x1U << DMA_ISR_HTIF2_Pos) /*!< 0x00000040 */
#define DMA_ISR_HTIF2 DMA_ISR_HTIF2_Msk /*!< Channel 2 Half Transfer flag */
#define DMA_ISR_TEIF2_Pos (7U)
#define DMA_ISR_TEIF2_Msk (0x1U << DMA_ISR_TEIF2_Pos) /*!< 0x00000080 */
#define DMA_ISR_TEIF2 DMA_ISR_TEIF2_Msk /*!< Channel 2 Transfer Error flag */
#define DMA_ISR_GIF3_Pos (8U)
#define DMA_ISR_GIF3_Msk (0x1U << DMA_ISR_GIF3_Pos) /*!< 0x00000100 */
#define DMA_ISR_GIF3 DMA_ISR_GIF3_Msk /*!< Channel 3 Global interrupt flag */
#define DMA_ISR_TCIF3_Pos (9U)
#define DMA_ISR_TCIF3_Msk (0x1U << DMA_ISR_TCIF3_Pos) /*!< 0x00000200 */
#define DMA_ISR_TCIF3 DMA_ISR_TCIF3_Msk /*!< Channel 3 Transfer Complete flag */
#define DMA_ISR_HTIF3_Pos (10U)
#define DMA_ISR_HTIF3_Msk (0x1U << DMA_ISR_HTIF3_Pos) /*!< 0x00000400 */
#define DMA_ISR_HTIF3 DMA_ISR_HTIF3_Msk /*!< Channel 3 Half Transfer flag */
#define DMA_ISR_TEIF3_Pos (11U)
#define DMA_ISR_TEIF3_Msk (0x1U << DMA_ISR_TEIF3_Pos) /*!< 0x00000800 */
#define DMA_ISR_TEIF3 DMA_ISR_TEIF3_Msk /*!< Channel 3 Transfer Error flag */
#define DMA_ISR_GIF4_Pos (12U)
#define DMA_ISR_GIF4_Msk (0x1U << DMA_ISR_GIF4_Pos) /*!< 0x00001000 */
#define DMA_ISR_GIF4 DMA_ISR_GIF4_Msk /*!< Channel 4 Global interrupt flag */
#define DMA_ISR_TCIF4_Pos (13U)
#define DMA_ISR_TCIF4_Msk (0x1U << DMA_ISR_TCIF4_Pos) /*!< 0x00002000 */
#define DMA_ISR_TCIF4 DMA_ISR_TCIF4_Msk /*!< Channel 4 Transfer Complete flag */
#define DMA_ISR_HTIF4_Pos (14U)
#define DMA_ISR_HTIF4_Msk (0x1U << DMA_ISR_HTIF4_Pos) /*!< 0x00004000 */
#define DMA_ISR_HTIF4 DMA_ISR_HTIF4_Msk /*!< Channel 4 Half Transfer flag */
#define DMA_ISR_TEIF4_Pos (15U)
#define DMA_ISR_TEIF4_Msk (0x1U << DMA_ISR_TEIF4_Pos) /*!< 0x00008000 */
#define DMA_ISR_TEIF4 DMA_ISR_TEIF4_Msk /*!< Channel 4 Transfer Error flag */
#define DMA_ISR_GIF5_Pos (16U)
#define DMA_ISR_GIF5_Msk (0x1U << DMA_ISR_GIF5_Pos) /*!< 0x00010000 */
#define DMA_ISR_GIF5 DMA_ISR_GIF5_Msk /*!< Channel 5 Global interrupt flag */
#define DMA_ISR_TCIF5_Pos (17U)
#define DMA_ISR_TCIF5_Msk (0x1U << DMA_ISR_TCIF5_Pos) /*!< 0x00020000 */
#define DMA_ISR_TCIF5 DMA_ISR_TCIF5_Msk /*!< Channel 5 Transfer Complete flag */
#define DMA_ISR_HTIF5_Pos (18U)
#define DMA_ISR_HTIF5_Msk (0x1U << DMA_ISR_HTIF5_Pos) /*!< 0x00040000 */
#define DMA_ISR_HTIF5 DMA_ISR_HTIF5_Msk /*!< Channel 5 Half Transfer flag */
#define DMA_ISR_TEIF5_Pos (19U)
#define DMA_ISR_TEIF5_Msk (0x1U << DMA_ISR_TEIF5_Pos) /*!< 0x00080000 */
#define DMA_ISR_TEIF5 DMA_ISR_TEIF5_Msk /*!< Channel 5 Transfer Error flag */
#define DMA_ISR_GIF6_Pos (20U)
#define DMA_ISR_GIF6_Msk (0x1U << DMA_ISR_GIF6_Pos) /*!< 0x00100000 */
#define DMA_ISR_GIF6 DMA_ISR_GIF6_Msk /*!< Channel 6 Global interrupt flag */
#define DMA_ISR_TCIF6_Pos (21U)
#define DMA_ISR_TCIF6_Msk (0x1U << DMA_ISR_TCIF6_Pos) /*!< 0x00200000 */
#define DMA_ISR_TCIF6 DMA_ISR_TCIF6_Msk /*!< Channel 6 Transfer Complete flag */
#define DMA_ISR_HTIF6_Pos (22U)
#define DMA_ISR_HTIF6_Msk (0x1U << DMA_ISR_HTIF6_Pos) /*!< 0x00400000 */
#define DMA_ISR_HTIF6 DMA_ISR_HTIF6_Msk /*!< Channel 6 Half Transfer flag */
#define DMA_ISR_TEIF6_Pos (23U)
#define DMA_ISR_TEIF6_Msk (0x1U << DMA_ISR_TEIF6_Pos) /*!< 0x00800000 */
#define DMA_ISR_TEIF6 DMA_ISR_TEIF6_Msk /*!< Channel 6 Transfer Error flag */
#define DMA_ISR_GIF7_Pos (24U)
#define DMA_ISR_GIF7_Msk (0x1U << DMA_ISR_GIF7_Pos) /*!< 0x01000000 */
#define DMA_ISR_GIF7 DMA_ISR_GIF7_Msk /*!< Channel 7 Global interrupt flag */
#define DMA_ISR_TCIF7_Pos (25U)
#define DMA_ISR_TCIF7_Msk (0x1U << DMA_ISR_TCIF7_Pos) /*!< 0x02000000 */
#define DMA_ISR_TCIF7 DMA_ISR_TCIF7_Msk /*!< Channel 7 Transfer Complete flag */
#define DMA_ISR_HTIF7_Pos (26U)
#define DMA_ISR_HTIF7_Msk (0x1U << DMA_ISR_HTIF7_Pos) /*!< 0x04000000 */
#define DMA_ISR_HTIF7 DMA_ISR_HTIF7_Msk /*!< Channel 7 Half Transfer flag */
#define DMA_ISR_TEIF7_Pos (27U)
#define DMA_ISR_TEIF7_Msk (0x1U << DMA_ISR_TEIF7_Pos) /*!< 0x08000000 */
#define DMA_ISR_TEIF7 DMA_ISR_TEIF7_Msk /*!< Channel 7 Transfer Error flag */

/*******************  Bit definition for DMA_IFCR register  *******************/
#define DMA_IFCR_CGIF1_Pos (0U)
#define DMA_IFCR_CGIF1_Msk (0x1U << DMA_IFCR_CGIF1_Pos) /*!< 0x00000001 */
#define DMA_IFCR_CGIF1 DMA_IFCR_CGIF1_Msk /*!< Channel 1 Global interrupt clear */
#define DMA_IFCR_CTCIF1_Pos (1U)
#define DMA_IFCR_CTCIF1_Msk (0x1U << DMA_IFCR_CTCIF1_Pos) /*!< 0x00000002 */
#define DMA_IFCR_CTCIF1 DMA_IFCR_CTCIF1_Msk /*!< Channel 1 Transfer Complete clear */
#define DMA_IFCR_CHTIF1_Pos (2U)
#define DMA_IFCR_CHTIF1_Msk (0x1U << DMA_IFCR_CHTIF1_Pos) /*!< 0x00000004 */
#define DMA_IFCR_CHTIF1 DMA_IFCR_CHTIF1_Msk /*!< Channel 1 Half Transfer clear */
#define DMA_IFCR_CTEIF1_Pos (3U)
#define DMA_IFCR_CTEIF1_Msk (0x1U << DMA_IFCR_CTEIF1_Pos) /*!< 0x00000008 */
#define DMA_IFCR_CTEIF1 DMA_IFCR_CTEIF1_Msk /*!< Channel 1 Transfer Error clear */
#define DMA_IFCR_CGIF2_Pos (4U)
#define DMA_IFCR_CGIF2_Msk (0x1U << DMA_IFCR_CGIF2_Pos) /*!< 0x00000010 */
#define DMA_IFCR_CGIF2 DMA_IFCR_CGIF2_Msk /*!< Channel 2 Global interrupt clear */
#define DMA_IFCR_CTCIF2_Pos (5U)
#define DMA_IFCR_CTCIF2_Msk (0x1U << DMA_IFCR_CTCIF2_Pos) /*!< 0x00000020 */
#define DMA_IFCR_CTCIF2 DMA_IFCR_CTCIF2_Msk /*!< Channel 2 Transfer Complete clear */
#define DMA_IFCR_CHTIF2_Pos (6U)
#define DMA_IFCR_CHTIF2_Msk (0x1U << DMA_IFCR_CHTIF2_Pos) /*!< 0x00000040 */
#define DMA_IFCR_CHTIF2 DMA_IFCR_CHTIF2_Msk /*!< Channel 2 Half Transfer clear */
#define DMA_IFCR_CTEIF2_Pos (7U)
#define DMA_IFCR_CTEIF2_Msk (0x1U << DMA_IFCR_CTEIF2_Pos) /*!< 0x00000080 */
#define DMA_IFCR_CTEIF2 DMA_IFCR_CTEIF2_Msk /*!< Channel 2 Transfer Error clear */
#define DMA_IFCR_CGIF3_Pos (8U)
#define DMA_IFCR_CGIF3_Msk (0x1U << DMA_IFCR_CGIF3_Pos) /*!< 0x00000100 */
#define DMA_IFCR_CGIF3 DMA_IFCR_CGIF3_Msk /*!< Channel 3 Global interrupt clear */
#define DMA_IFCR_CTCIF3_Pos (9U)
#define DMA_IFCR_CTCIF3_Msk (0x1U << DMA_IFCR_CTCIF3_Pos) /*!< 0x00000200 */
#define DMA_IFCR_CTCIF3 DMA_IFCR_CTCIF3_Msk /*!< Channel 3 Transfer Complete clear */
#define DMA_IFCR_CHTIF3_Pos (10U)
#define DMA_IFCR_CHTIF3_Msk (0x1U << DMA_IFCR_CHTIF3_Pos) /*!< 0x00000400 */
#define DMA_IFCR_CHTIF3 DMA_IFCR_CHTIF3_Msk /*!< Channel 3 Half Transfer clear */
#define DMA_IFCR_CTEIF3_Pos (11U)
#define DMA_IFCR_CTEIF3_Msk (0x1U << DMA_IFCR_CTEIF3_Pos) /*!< 0x00000800 */
#define DMA_IFCR_CTEIF3 DMA_IFCR_CTEIF3_Msk /*!< Channel 3 Transfer Error clear */
#define DMA_IFCR_CGIF4_Pos (12U)
#define DMA_IFCR_CGIF4_Msk (0x1U << DMA_IFCR_CGIF4_Pos) /*!< 0x00001000 */
#define DMA_IFCR_CGIF4 DMA_IFCR_CGIF4_Msk /*!< Channel 4 Global interrupt clear */
#define DMA_IFCR_CTCIF4_Pos (13U)
#define DMA_IFCR_CTCIF4_Msk (0x1U << DMA_IFCR_CTCIF4_Pos) /*!< 0x00002000 */
#define DMA_IFCR_CTCIF4 DMA_IFCR_CTCIF4_Msk /*!< Channel 4 Transfer Complete clear */
#define DMA_IFCR_CHTIF4_Pos (14U)
#define DMA_IFCR_CHTIF4_Msk (0x1U << DMA_IFCR_CHTIF4_Pos) /*!< 0x00004000 */
#define DMA_IFCR_CHTIF4 DMA_IFCR_CHTIF4_Msk /*!< Channel 4 Half Transfer clear */
#define DMA_IFCR_CTEIF4_Pos (15U)
#define DMA_IFCR_CTEIF4_Msk (0x1U << DMA_IFCR_CTEIF4_Pos) /*!< 0x00008000 */
#define DMA_IFCR_CTEIF4 DMA_IFCR_CTEIF4_Msk /*!< Channel 4 Transfer Error clear */
#define DMA_IFCR_CGIF5_Pos (16U)
#define DMA_IFCR_CGIF5_Msk (0x1U << DMA_IFCR_CGIF5_Pos) /*!< 0x00010000 */
#define DMA_IFCR_CGIF5 DMA_IFCR_CGIF5_Msk /*!< Channel 5 Global interrupt clear */
#define DMA_IFCR_CTCIF5_Pos (17U)
#define DMA_IFCR_CTCIF5_Msk (0x1U << DMA_IFCR_CTCIF5_Pos) /*!< 0x00020000 */
#define DMA_IFCR_CTCIF5 DMA_IFCR_CTCIF5_Msk /*!< Channel 5 Transfer Complete clear */
#define DMA_IFCR_CHTIF5_Pos (18U)
#define DMA_IFCR_CHTIF5_Msk (0x1U << DMA_IFCR_CHTIF5_Pos) /*!< 0x00040000 */
#define DMA_IFCR_CHTIF5 DMA_IFCR_CHTIF5_Msk /*!< Channel 5 Half Transfer clear */
#define DMA_IFCR_CTEIF5_Pos (19U)
#define DMA_IFCR_CTEIF5_Msk (0x1U << DMA_IFCR_CTEIF5_Pos) /*!< 0x00080000 */
#define DMA_IFCR_CTEIF5 DMA_IFCR_CTEIF5_Msk /*!< Channel 5 Transfer Error clear */
#define DMA_IFCR_CGIF6_Pos (20U)
#define DMA_IFCR_CGIF6_Msk (0x1U << DMA_IFCR_CGIF6_Pos) /*!< 0x00100000 */
#define DMA_IFCR_CGIF6 DMA_IFCR_CGIF6_Msk /*!< Channel 6 Global interrupt clear */
#define DMA_IFCR_CTCIF6_Pos (21U)
#define DMA_IFCR_CTCIF6_Msk (0x1U << DMA_IFCR_CTCIF6_Pos) /*!< 0x00200000 */
#define DMA_IFCR_CTCIF6 DMA_IFCR_CTCIF6_Msk /*!< Channel 6 Transfer Complete clear */
#define DMA_IFCR_CHTIF6_Pos (22U)
#define DMA_IFCR_CHTIF6_Msk (0x1U << DMA_IFCR_CHTIF6_Pos) /*!< 0x00400000 */
#define DMA_IFCR_CHTIF6 DMA_IFCR_CHTIF6_Msk /*!< Channel 6 Half Transfer clear */
#define DMA_IFCR_CTEIF6_Pos (23U)
#define DMA_IFCR_CTEIF6_Msk (0x1U << DMA_IFCR_CTEIF6_Pos) /*!< 0x00800000 */
#define DMA_IFCR_CTEIF6 DMA_IFCR_CTEIF6_Msk /*!< Channel 6 Transfer Error clear */
#define DMA_IFCR_CGIF7_Pos (24U)
#define DMA_IFCR_CGIF7_Msk (0x1U << DMA_IFCR_CGIF7_Pos) /*!< 0x01000000 */
#define DMA_IFCR_CGIF7 DMA_IFCR_CGIF7_Msk /*!< Channel 7 Global interrupt clear */
#define DMA_IFCR_CTCIF7_Pos (25U)
#define DMA_IFCR_CTCIF7_Msk (0x1U << DMA_IFCR_CTCIF7_Pos) /*!< 0x02000000 */
#define DMA_IFCR_CTCIF7 DMA_IFCR_CTCIF7_Msk /*!< Channel 7 Transfer Complete clear */
#define DMA_IFCR_CHTIF7_Pos (26U)
#define DMA_IFCR_CHTIF7_Msk (0x1U << DMA_IFCR_CHTIF7_Pos) /*!< 0x04000000 */
#define DMA_IFCR_CHTIF7 DMA_IFCR_CHTIF7_Msk /*!< Channel 7 Half Transfer clear */
#define DMA_IFCR_CTEIF7_Pos (27U)
#define DMA_IFCR_CTEIF7_Msk (0x1U << DMA_IFCR_CTEIF7_Pos) /*!< 0x08000000 */
#define DMA_IFCR_CTEIF7 DMA_IFCR_CTEIF7_Msk /*!< Channel 7 Transfer Error clear */

/*******************  Bit definition for DMA_CCR register   *******************/
#define DMA_CCR_EN_Pos (0U)
#define DMA_CCR_EN_Msk (0x1U << DMA_CCR_EN_Pos) /*!< 0x00000001 */
#define DMA_CCR_EN DMA_CCR_EN_Msk /*!< Channel enable */
#define DMA_CCR_TCIE_Pos (1U)
#define DMA_CCR_TCIE_Msk (0x1U << DMA_CCR_TCIE_Pos) /*!< 0x00000002 */
#define DMA_CCR_TCIE DMA_CCR_TCIE_Msk /*!< Transfer complete interrupt enable */
#define DMA_CCR_HTIE_Pos (2U)
#define DMA_CCR_HTIE_Msk (0x1U << DMA_CCR_HTIE_Pos) /*!< 0x00000004 */
#define DMA_CCR_HTIE DMA_CCR_HTIE_Msk /*!< Half Transfer interrupt enable */
#define DMA_CCR_TEIE_Pos (3U)
#define DMA_CCR_TEIE_Msk (0x1U << DMA_CCR_TEIE_Pos) /*!< 0x00000008 */
#define DMA_CCR_TEIE DMA_CCR_TEIE_Msk /*!< Transfer error interrupt enable */
#define DMA_CCR_DIR_Pos (4U)
#define DMA_CCR_DIR_Msk (0x1U << DMA_CCR_DIR_Pos) /*!< 0x00000010 */
#define DMA_CCR_DIR DMA_CCR_DIR_Msk /*!< Data transfer direction */
#define DMA_CCR_CIRC_Pos (5U)
#define DMA_CCR_CIRC_Msk (0x1U << DMA_CCR_CIRC_Pos) /*!< 0x00000020 */
#define DMA_CCR_CIRC DMA_CCR_CIRC_Msk /*!< Circular mode */
#define DMA_CCR_PINC_Pos (6U)
#define DMA_CCR_PINC_Msk (0x1U << DMA_CCR_PINC_Pos) /*!< 0x00000040 */
#define DMA_CCR_PINC DMA_CCR_PINC_Msk /*!< Peripheral increment mode */
#define DMA_CCR_MINC_Pos (7U)
#define DMA_CCR_MINC_Msk (0x1U << DMA_CCR_MINC_Pos) /*!< 0x00000080 */
#define DMA_CCR_MINC DMA_CCR_MINC_Msk /*!< Memory increment mode */

#define DMA_CCR_PSIZE_Pos (8U)
#define DMA_CCR_PSIZE_Msk (0x3U << DMA_CCR_PSIZE_Pos) /*!< 0x00000300 */
#define DMA_CCR_PSIZE DMA_CCR_PSIZE_Msk /*!< PSIZE[1:0] bits (Peripheral size) */
#define DMA_CCR_PSIZE_0 (0x1U << DMA_CCR_PSIZE_Pos) /*!< 0x00000100 */
#define DMA_CCR_PSIZE_1 (0x2U << DMA_CCR_PSIZE_Pos) /*!< 0x00000200 */

#define DMA_CCR_MSIZE_Pos (10U)
#define DMA_CCR_MSIZE_Msk (0x3U << DMA_CCR_MSIZE_Pos) /*!< 0x00000C00 */
#define DMA_CCR_MSIZE DMA_CCR_MSIZE_Msk /*!< MSIZE[1:0] bits (Memory size) */
#define DMA_CCR_MSIZE_0 (0x1U << DMA_CCR_MSIZE_Pos) /*!< 0x00000400 */
#define DMA_CCR_MSIZE_1 (0x2U << DMA_CCR_MSIZE_Pos) /*!< 0x00000800 */

#define DMA_CCR_PL_Pos (12U)
#define DMA_CCR_PL_Msk (0x3U << DMA_CCR_PL_Pos) /*!< 0x00003000 */
#define DMA_CCR_PL DMA_CCR_PL_Msk /*!< PL[1:0] bits(Channel Priority level) */
#define DMA_CCR_PL_0 (0x1U << DMA_CCR_PL_Pos) /*!< 0x00001000 */
#define DMA_CCR_PL_1 (0x2U << DMA_CCR_PL_Pos) /*!< 0x00002000 */

#define DMA_CCR_MEM2MEM_Pos (14U)
#define DMA_CCR_MEM2MEM_Msk (0x1U << DMA_CCR_MEM2MEM_Pos) /*!< 0x00004000 */
#define DMA_CCR_MEM2MEM DMA_CCR_MEM2MEM_Msk /*!< Memory to memory mode */

/******************  Bit definition for DMA_CNDTR  register  ******************/
#define DMA_CNDTR_NDT_Pos (0U)
#define DMA_CNDTR_NDT_Msk (0xFFFFU << DMA_CNDTR_NDT_Pos) /*!< 0x0000FFFF */
#define DMA_CNDTR_NDT DMA_CNDTR_NDT_Msk /*!< Number of data to Transfer */

/******************  Bit definition for DMA_CPAR  register  *******************/
#define DMA_CPAR_PA_Pos (0U)
#define DMA_CPAR_PA_Msk (0xFFFFFFFFU << DMA_CPAR_PA_Pos) /*!< 0xFFFFFFFF */
#define DMA_CPAR_PA DMA_CPAR_PA_Msk /*!< Peripheral Address */

/******************  Bit definition for DMA_CMAR  register  *******************/
#define DMA_CMAR_MA_Pos (0U)
#define DMA_CMAR_MA_Msk (0xFFFFFFFFU << DMA_CMAR_MA_Pos) /*!< 0xFFFFFFFF */
#define DMA_CMAR_MA DMA_CMAR_MA_Msk /*!< Memory Address */

/******************************************************************************/
/*                                                                            */
/*                      Analog to Digital Converter (ADC)                     */
/*                                                                            */
/******************************************************************************/

/*

 * @brief Specific device feature definitions (not present on all devices in the STM32F1 family)

 */
# 3327 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
#define ADC_MULTIMODE_SUPPORT /*!< ADC feature available only on specific devices: multimode available on devices with several ADC instances */

/********************  Bit definition for ADC_SR register  ********************/
#define ADC_SR_AWD_Pos (0U)
#define ADC_SR_AWD_Msk (0x1U << ADC_SR_AWD_Pos) /*!< 0x00000001 */
#define ADC_SR_AWD ADC_SR_AWD_Msk /*!< ADC analog watchdog 1 flag */
#define ADC_SR_EOS_Pos (1U)
#define ADC_SR_EOS_Msk (0x1U << ADC_SR_EOS_Pos) /*!< 0x00000002 */
#define ADC_SR_EOS ADC_SR_EOS_Msk /*!< ADC group regular end of sequence conversions flag */
#define ADC_SR_JEOS_Pos (2U)
#define ADC_SR_JEOS_Msk (0x1U << ADC_SR_JEOS_Pos) /*!< 0x00000004 */
#define ADC_SR_JEOS ADC_SR_JEOS_Msk /*!< ADC group injected end of sequence conversions flag */
#define ADC_SR_JSTRT_Pos (3U)
#define ADC_SR_JSTRT_Msk (0x1U << ADC_SR_JSTRT_Pos) /*!< 0x00000008 */
#define ADC_SR_JSTRT ADC_SR_JSTRT_Msk /*!< ADC group injected conversion start flag */
#define ADC_SR_STRT_Pos (4U)
#define ADC_SR_STRT_Msk (0x1U << ADC_SR_STRT_Pos) /*!< 0x00000010 */
#define ADC_SR_STRT ADC_SR_STRT_Msk /*!< ADC group regular conversion start flag */

/* Legacy defines */
#define ADC_SR_EOC (ADC_SR_EOS)
#define ADC_SR_JEOC (ADC_SR_JEOS)

/*******************  Bit definition for ADC_CR1 register  ********************/
#define ADC_CR1_AWDCH_Pos (0U)
#define ADC_CR1_AWDCH_Msk (0x1FU << ADC_CR1_AWDCH_Pos) /*!< 0x0000001F */
#define ADC_CR1_AWDCH ADC_CR1_AWDCH_Msk /*!< ADC analog watchdog 1 monitored channel selection */
#define ADC_CR1_AWDCH_0 (0x01U << ADC_CR1_AWDCH_Pos) /*!< 0x00000001 */
#define ADC_CR1_AWDCH_1 (0x02U << ADC_CR1_AWDCH_Pos) /*!< 0x00000002 */
#define ADC_CR1_AWDCH_2 (0x04U << ADC_CR1_AWDCH_Pos) /*!< 0x00000004 */
#define ADC_CR1_AWDCH_3 (0x08U << ADC_CR1_AWDCH_Pos) /*!< 0x00000008 */
#define ADC_CR1_AWDCH_4 (0x10U << ADC_CR1_AWDCH_Pos) /*!< 0x00000010 */

#define ADC_CR1_EOSIE_Pos (5U)
#define ADC_CR1_EOSIE_Msk (0x1U << ADC_CR1_EOSIE_Pos) /*!< 0x00000020 */
#define ADC_CR1_EOSIE ADC_CR1_EOSIE_Msk /*!< ADC group regular end of sequence conversions interrupt */
#define ADC_CR1_AWDIE_Pos (6U)
#define ADC_CR1_AWDIE_Msk (0x1U << ADC_CR1_AWDIE_Pos) /*!< 0x00000040 */
#define ADC_CR1_AWDIE ADC_CR1_AWDIE_Msk /*!< ADC analog watchdog 1 interrupt */
#define ADC_CR1_JEOSIE_Pos (7U)
#define ADC_CR1_JEOSIE_Msk (0x1U << ADC_CR1_JEOSIE_Pos) /*!< 0x00000080 */
#define ADC_CR1_JEOSIE ADC_CR1_JEOSIE_Msk /*!< ADC group injected end of sequence conversions interrupt */
#define ADC_CR1_SCAN_Pos (8U)
#define ADC_CR1_SCAN_Msk (0x1U << ADC_CR1_SCAN_Pos) /*!< 0x00000100 */
#define ADC_CR1_SCAN ADC_CR1_SCAN_Msk /*!< ADC scan mode */
#define ADC_CR1_AWDSGL_Pos (9U)
#define ADC_CR1_AWDSGL_Msk (0x1U << ADC_CR1_AWDSGL_Pos) /*!< 0x00000200 */
#define ADC_CR1_AWDSGL ADC_CR1_AWDSGL_Msk /*!< ADC analog watchdog 1 monitoring a single channel or all channels */
#define ADC_CR1_JAUTO_Pos (10U)
#define ADC_CR1_JAUTO_Msk (0x1U << ADC_CR1_JAUTO_Pos) /*!< 0x00000400 */
#define ADC_CR1_JAUTO ADC_CR1_JAUTO_Msk /*!< ADC group injected automatic trigger mode */
#define ADC_CR1_DISCEN_Pos (11U)
#define ADC_CR1_DISCEN_Msk (0x1U << ADC_CR1_DISCEN_Pos) /*!< 0x00000800 */
#define ADC_CR1_DISCEN ADC_CR1_DISCEN_Msk /*!< ADC group regular sequencer discontinuous mode */
#define ADC_CR1_JDISCEN_Pos (12U)
#define ADC_CR1_JDISCEN_Msk (0x1U << ADC_CR1_JDISCEN_Pos) /*!< 0x00001000 */
#define ADC_CR1_JDISCEN ADC_CR1_JDISCEN_Msk /*!< ADC group injected sequencer discontinuous mode */

#define ADC_CR1_DISCNUM_Pos (13U)
#define ADC_CR1_DISCNUM_Msk (0x7U << ADC_CR1_DISCNUM_Pos) /*!< 0x0000E000 */
#define ADC_CR1_DISCNUM ADC_CR1_DISCNUM_Msk /*!< ADC group regular sequencer discontinuous number of ranks */
#define ADC_CR1_DISCNUM_0 (0x1U << ADC_CR1_DISCNUM_Pos) /*!< 0x00002000 */
#define ADC_CR1_DISCNUM_1 (0x2U << ADC_CR1_DISCNUM_Pos) /*!< 0x00004000 */
#define ADC_CR1_DISCNUM_2 (0x4U << ADC_CR1_DISCNUM_Pos) /*!< 0x00008000 */

#define ADC_CR1_DUALMOD_Pos (16U)
#define ADC_CR1_DUALMOD_Msk (0xFU << ADC_CR1_DUALMOD_Pos) /*!< 0x000F0000 */
#define ADC_CR1_DUALMOD ADC_CR1_DUALMOD_Msk /*!< ADC multimode mode selection */
#define ADC_CR1_DUALMOD_0 (0x1U << ADC_CR1_DUALMOD_Pos) /*!< 0x00010000 */
#define ADC_CR1_DUALMOD_1 (0x2U << ADC_CR1_DUALMOD_Pos) /*!< 0x00020000 */
#define ADC_CR1_DUALMOD_2 (0x4U << ADC_CR1_DUALMOD_Pos) /*!< 0x00040000 */
#define ADC_CR1_DUALMOD_3 (0x8U << ADC_CR1_DUALMOD_Pos) /*!< 0x00080000 */

#define ADC_CR1_JAWDEN_Pos (22U)
#define ADC_CR1_JAWDEN_Msk (0x1U << ADC_CR1_JAWDEN_Pos) /*!< 0x00400000 */
#define ADC_CR1_JAWDEN ADC_CR1_JAWDEN_Msk /*!< ADC analog watchdog 1 enable on scope ADC group injected */
#define ADC_CR1_AWDEN_Pos (23U)
#define ADC_CR1_AWDEN_Msk (0x1U << ADC_CR1_AWDEN_Pos) /*!< 0x00800000 */
#define ADC_CR1_AWDEN ADC_CR1_AWDEN_Msk /*!< ADC analog watchdog 1 enable on scope ADC group regular */

/* Legacy defines */
#define ADC_CR1_EOCIE (ADC_CR1_EOSIE)
#define ADC_CR1_JEOCIE (ADC_CR1_JEOSIE)

/*******************  Bit definition for ADC_CR2 register  ********************/
#define ADC_CR2_ADON_Pos (0U)
#define ADC_CR2_ADON_Msk (0x1U << ADC_CR2_ADON_Pos) /*!< 0x00000001 */
#define ADC_CR2_ADON ADC_CR2_ADON_Msk /*!< ADC enable */
#define ADC_CR2_CONT_Pos (1U)
#define ADC_CR2_CONT_Msk (0x1U << ADC_CR2_CONT_Pos) /*!< 0x00000002 */
#define ADC_CR2_CONT ADC_CR2_CONT_Msk /*!< ADC group regular continuous conversion mode */
#define ADC_CR2_CAL_Pos (2U)
#define ADC_CR2_CAL_Msk (0x1U << ADC_CR2_CAL_Pos) /*!< 0x00000004 */
#define ADC_CR2_CAL ADC_CR2_CAL_Msk /*!< ADC calibration start */
#define ADC_CR2_RSTCAL_Pos (3U)
#define ADC_CR2_RSTCAL_Msk (0x1U << ADC_CR2_RSTCAL_Pos) /*!< 0x00000008 */
#define ADC_CR2_RSTCAL ADC_CR2_RSTCAL_Msk /*!< ADC calibration reset */
#define ADC_CR2_DMA_Pos (8U)
#define ADC_CR2_DMA_Msk (0x1U << ADC_CR2_DMA_Pos) /*!< 0x00000100 */
#define ADC_CR2_DMA ADC_CR2_DMA_Msk /*!< ADC DMA transfer enable */
#define ADC_CR2_ALIGN_Pos (11U)
#define ADC_CR2_ALIGN_Msk (0x1U << ADC_CR2_ALIGN_Pos) /*!< 0x00000800 */
#define ADC_CR2_ALIGN ADC_CR2_ALIGN_Msk /*!< ADC data alignement */

#define ADC_CR2_JEXTSEL_Pos (12U)
#define ADC_CR2_JEXTSEL_Msk (0x7U << ADC_CR2_JEXTSEL_Pos) /*!< 0x00007000 */
#define ADC_CR2_JEXTSEL ADC_CR2_JEXTSEL_Msk /*!< ADC group injected external trigger source */
#define ADC_CR2_JEXTSEL_0 (0x1U << ADC_CR2_JEXTSEL_Pos) /*!< 0x00001000 */
#define ADC_CR2_JEXTSEL_1 (0x2U << ADC_CR2_JEXTSEL_Pos) /*!< 0x00002000 */
#define ADC_CR2_JEXTSEL_2 (0x4U << ADC_CR2_JEXTSEL_Pos) /*!< 0x00004000 */

#define ADC_CR2_JEXTTRIG_Pos (15U)
#define ADC_CR2_JEXTTRIG_Msk (0x1U << ADC_CR2_JEXTTRIG_Pos) /*!< 0x00008000 */
#define ADC_CR2_JEXTTRIG ADC_CR2_JEXTTRIG_Msk /*!< ADC group injected external trigger enable */

#define ADC_CR2_EXTSEL_Pos (17U)
#define ADC_CR2_EXTSEL_Msk (0x7U << ADC_CR2_EXTSEL_Pos) /*!< 0x000E0000 */
#define ADC_CR2_EXTSEL ADC_CR2_EXTSEL_Msk /*!< ADC group regular external trigger source */
#define ADC_CR2_EXTSEL_0 (0x1U << ADC_CR2_EXTSEL_Pos) /*!< 0x00020000 */
#define ADC_CR2_EXTSEL_1 (0x2U << ADC_CR2_EXTSEL_Pos) /*!< 0x00040000 */
#define ADC_CR2_EXTSEL_2 (0x4U << ADC_CR2_EXTSEL_Pos) /*!< 0x00080000 */

#define ADC_CR2_EXTTRIG_Pos (20U)
#define ADC_CR2_EXTTRIG_Msk (0x1U << ADC_CR2_EXTTRIG_Pos) /*!< 0x00100000 */
#define ADC_CR2_EXTTRIG ADC_CR2_EXTTRIG_Msk /*!< ADC group regular external trigger enable */
#define ADC_CR2_JSWSTART_Pos (21U)
#define ADC_CR2_JSWSTART_Msk (0x1U << ADC_CR2_JSWSTART_Pos) /*!< 0x00200000 */
#define ADC_CR2_JSWSTART ADC_CR2_JSWSTART_Msk /*!< ADC group injected conversion start */
#define ADC_CR2_SWSTART_Pos (22U)
#define ADC_CR2_SWSTART_Msk (0x1U << ADC_CR2_SWSTART_Pos) /*!< 0x00400000 */
#define ADC_CR2_SWSTART ADC_CR2_SWSTART_Msk /*!< ADC group regular conversion start */
#define ADC_CR2_TSVREFE_Pos (23U)
#define ADC_CR2_TSVREFE_Msk (0x1U << ADC_CR2_TSVREFE_Pos) /*!< 0x00800000 */
#define ADC_CR2_TSVREFE ADC_CR2_TSVREFE_Msk /*!< ADC internal path to VrefInt and temperature sensor enable */

/******************  Bit definition for ADC_SMPR1 register  *******************/
#define ADC_SMPR1_SMP10_Pos (0U)
#define ADC_SMPR1_SMP10_Msk (0x7U << ADC_SMPR1_SMP10_Pos) /*!< 0x00000007 */
#define ADC_SMPR1_SMP10 ADC_SMPR1_SMP10_Msk /*!< ADC channel 10 sampling time selection  */
#define ADC_SMPR1_SMP10_0 (0x1U << ADC_SMPR1_SMP10_Pos) /*!< 0x00000001 */
#define ADC_SMPR1_SMP10_1 (0x2U << ADC_SMPR1_SMP10_Pos) /*!< 0x00000002 */
#define ADC_SMPR1_SMP10_2 (0x4U << ADC_SMPR1_SMP10_Pos) /*!< 0x00000004 */

#define ADC_SMPR1_SMP11_Pos (3U)
#define ADC_SMPR1_SMP11_Msk (0x7U << ADC_SMPR1_SMP11_Pos) /*!< 0x00000038 */
#define ADC_SMPR1_SMP11 ADC_SMPR1_SMP11_Msk /*!< ADC channel 11 sampling time selection  */
#define ADC_SMPR1_SMP11_0 (0x1U << ADC_SMPR1_SMP11_Pos) /*!< 0x00000008 */
#define ADC_SMPR1_SMP11_1 (0x2U << ADC_SMPR1_SMP11_Pos) /*!< 0x00000010 */
#define ADC_SMPR1_SMP11_2 (0x4U << ADC_SMPR1_SMP11_Pos) /*!< 0x00000020 */

#define ADC_SMPR1_SMP12_Pos (6U)
#define ADC_SMPR1_SMP12_Msk (0x7U << ADC_SMPR1_SMP12_Pos) /*!< 0x000001C0 */
#define ADC_SMPR1_SMP12 ADC_SMPR1_SMP12_Msk /*!< ADC channel 12 sampling time selection  */
#define ADC_SMPR1_SMP12_0 (0x1U << ADC_SMPR1_SMP12_Pos) /*!< 0x00000040 */
#define ADC_SMPR1_SMP12_1 (0x2U << ADC_SMPR1_SMP12_Pos) /*!< 0x00000080 */
#define ADC_SMPR1_SMP12_2 (0x4U << ADC_SMPR1_SMP12_Pos) /*!< 0x00000100 */

#define ADC_SMPR1_SMP13_Pos (9U)
#define ADC_SMPR1_SMP13_Msk (0x7U << ADC_SMPR1_SMP13_Pos) /*!< 0x00000E00 */
#define ADC_SMPR1_SMP13 ADC_SMPR1_SMP13_Msk /*!< ADC channel 13 sampling time selection  */
#define ADC_SMPR1_SMP13_0 (0x1U << ADC_SMPR1_SMP13_Pos) /*!< 0x00000200 */
#define ADC_SMPR1_SMP13_1 (0x2U << ADC_SMPR1_SMP13_Pos) /*!< 0x00000400 */
#define ADC_SMPR1_SMP13_2 (0x4U << ADC_SMPR1_SMP13_Pos) /*!< 0x00000800 */

#define ADC_SMPR1_SMP14_Pos (12U)
#define ADC_SMPR1_SMP14_Msk (0x7U << ADC_SMPR1_SMP14_Pos) /*!< 0x00007000 */
#define ADC_SMPR1_SMP14 ADC_SMPR1_SMP14_Msk /*!< ADC channel 14 sampling time selection  */
#define ADC_SMPR1_SMP14_0 (0x1U << ADC_SMPR1_SMP14_Pos) /*!< 0x00001000 */
#define ADC_SMPR1_SMP14_1 (0x2U << ADC_SMPR1_SMP14_Pos) /*!< 0x00002000 */
#define ADC_SMPR1_SMP14_2 (0x4U << ADC_SMPR1_SMP14_Pos) /*!< 0x00004000 */

#define ADC_SMPR1_SMP15_Pos (15U)
#define ADC_SMPR1_SMP15_Msk (0x7U << ADC_SMPR1_SMP15_Pos) /*!< 0x00038000 */
#define ADC_SMPR1_SMP15 ADC_SMPR1_SMP15_Msk /*!< ADC channel 15 sampling time selection  */
#define ADC_SMPR1_SMP15_0 (0x1U << ADC_SMPR1_SMP15_Pos) /*!< 0x00008000 */
#define ADC_SMPR1_SMP15_1 (0x2U << ADC_SMPR1_SMP15_Pos) /*!< 0x00010000 */
#define ADC_SMPR1_SMP15_2 (0x4U << ADC_SMPR1_SMP15_Pos) /*!< 0x00020000 */

#define ADC_SMPR1_SMP16_Pos (18U)
#define ADC_SMPR1_SMP16_Msk (0x7U << ADC_SMPR1_SMP16_Pos) /*!< 0x001C0000 */
#define ADC_SMPR1_SMP16 ADC_SMPR1_SMP16_Msk /*!< ADC channel 16 sampling time selection  */
#define ADC_SMPR1_SMP16_0 (0x1U << ADC_SMPR1_SMP16_Pos) /*!< 0x00040000 */
#define ADC_SMPR1_SMP16_1 (0x2U << ADC_SMPR1_SMP16_Pos) /*!< 0x00080000 */
#define ADC_SMPR1_SMP16_2 (0x4U << ADC_SMPR1_SMP16_Pos) /*!< 0x00100000 */

#define ADC_SMPR1_SMP17_Pos (21U)
#define ADC_SMPR1_SMP17_Msk (0x7U << ADC_SMPR1_SMP17_Pos) /*!< 0x00E00000 */
#define ADC_SMPR1_SMP17 ADC_SMPR1_SMP17_Msk /*!< ADC channel 17 sampling time selection  */
#define ADC_SMPR1_SMP17_0 (0x1U << ADC_SMPR1_SMP17_Pos) /*!< 0x00200000 */
#define ADC_SMPR1_SMP17_1 (0x2U << ADC_SMPR1_SMP17_Pos) /*!< 0x00400000 */
#define ADC_SMPR1_SMP17_2 (0x4U << ADC_SMPR1_SMP17_Pos) /*!< 0x00800000 */

/******************  Bit definition for ADC_SMPR2 register  *******************/
#define ADC_SMPR2_SMP0_Pos (0U)
#define ADC_SMPR2_SMP0_Msk (0x7U << ADC_SMPR2_SMP0_Pos) /*!< 0x00000007 */
#define ADC_SMPR2_SMP0 ADC_SMPR2_SMP0_Msk /*!< ADC channel 0 sampling time selection  */
#define ADC_SMPR2_SMP0_0 (0x1U << ADC_SMPR2_SMP0_Pos) /*!< 0x00000001 */
#define ADC_SMPR2_SMP0_1 (0x2U << ADC_SMPR2_SMP0_Pos) /*!< 0x00000002 */
#define ADC_SMPR2_SMP0_2 (0x4U << ADC_SMPR2_SMP0_Pos) /*!< 0x00000004 */

#define ADC_SMPR2_SMP1_Pos (3U)
#define ADC_SMPR2_SMP1_Msk (0x7U << ADC_SMPR2_SMP1_Pos) /*!< 0x00000038 */
#define ADC_SMPR2_SMP1 ADC_SMPR2_SMP1_Msk /*!< ADC channel 1 sampling time selection  */
#define ADC_SMPR2_SMP1_0 (0x1U << ADC_SMPR2_SMP1_Pos) /*!< 0x00000008 */
#define ADC_SMPR2_SMP1_1 (0x2U << ADC_SMPR2_SMP1_Pos) /*!< 0x00000010 */
#define ADC_SMPR2_SMP1_2 (0x4U << ADC_SMPR2_SMP1_Pos) /*!< 0x00000020 */

#define ADC_SMPR2_SMP2_Pos (6U)
#define ADC_SMPR2_SMP2_Msk (0x7U << ADC_SMPR2_SMP2_Pos) /*!< 0x000001C0 */
#define ADC_SMPR2_SMP2 ADC_SMPR2_SMP2_Msk /*!< ADC channel 2 sampling time selection  */
#define ADC_SMPR2_SMP2_0 (0x1U << ADC_SMPR2_SMP2_Pos) /*!< 0x00000040 */
#define ADC_SMPR2_SMP2_1 (0x2U << ADC_SMPR2_SMP2_Pos) /*!< 0x00000080 */
#define ADC_SMPR2_SMP2_2 (0x4U << ADC_SMPR2_SMP2_Pos) /*!< 0x00000100 */

#define ADC_SMPR2_SMP3_Pos (9U)
#define ADC_SMPR2_SMP3_Msk (0x7U << ADC_SMPR2_SMP3_Pos) /*!< 0x00000E00 */
#define ADC_SMPR2_SMP3 ADC_SMPR2_SMP3_Msk /*!< ADC channel 3 sampling time selection  */
#define ADC_SMPR2_SMP3_0 (0x1U << ADC_SMPR2_SMP3_Pos) /*!< 0x00000200 */
#define ADC_SMPR2_SMP3_1 (0x2U << ADC_SMPR2_SMP3_Pos) /*!< 0x00000400 */
#define ADC_SMPR2_SMP3_2 (0x4U << ADC_SMPR2_SMP3_Pos) /*!< 0x00000800 */

#define ADC_SMPR2_SMP4_Pos (12U)
#define ADC_SMPR2_SMP4_Msk (0x7U << ADC_SMPR2_SMP4_Pos) /*!< 0x00007000 */
#define ADC_SMPR2_SMP4 ADC_SMPR2_SMP4_Msk /*!< ADC channel 4 sampling time selection  */
#define ADC_SMPR2_SMP4_0 (0x1U << ADC_SMPR2_SMP4_Pos) /*!< 0x00001000 */
#define ADC_SMPR2_SMP4_1 (0x2U << ADC_SMPR2_SMP4_Pos) /*!< 0x00002000 */
#define ADC_SMPR2_SMP4_2 (0x4U << ADC_SMPR2_SMP4_Pos) /*!< 0x00004000 */

#define ADC_SMPR2_SMP5_Pos (15U)
#define ADC_SMPR2_SMP5_Msk (0x7U << ADC_SMPR2_SMP5_Pos) /*!< 0x00038000 */
#define ADC_SMPR2_SMP5 ADC_SMPR2_SMP5_Msk /*!< ADC channel 5 sampling time selection  */
#define ADC_SMPR2_SMP5_0 (0x1U << ADC_SMPR2_SMP5_Pos) /*!< 0x00008000 */
#define ADC_SMPR2_SMP5_1 (0x2U << ADC_SMPR2_SMP5_Pos) /*!< 0x00010000 */
#define ADC_SMPR2_SMP5_2 (0x4U << ADC_SMPR2_SMP5_Pos) /*!< 0x00020000 */

#define ADC_SMPR2_SMP6_Pos (18U)
#define ADC_SMPR2_SMP6_Msk (0x7U << ADC_SMPR2_SMP6_Pos) /*!< 0x001C0000 */
#define ADC_SMPR2_SMP6 ADC_SMPR2_SMP6_Msk /*!< ADC channel 6 sampling time selection  */
#define ADC_SMPR2_SMP6_0 (0x1U << ADC_SMPR2_SMP6_Pos) /*!< 0x00040000 */
#define ADC_SMPR2_SMP6_1 (0x2U << ADC_SMPR2_SMP6_Pos) /*!< 0x00080000 */
#define ADC_SMPR2_SMP6_2 (0x4U << ADC_SMPR2_SMP6_Pos) /*!< 0x00100000 */

#define ADC_SMPR2_SMP7_Pos (21U)
#define ADC_SMPR2_SMP7_Msk (0x7U << ADC_SMPR2_SMP7_Pos) /*!< 0x00E00000 */
#define ADC_SMPR2_SMP7 ADC_SMPR2_SMP7_Msk /*!< ADC channel 7 sampling time selection  */
#define ADC_SMPR2_SMP7_0 (0x1U << ADC_SMPR2_SMP7_Pos) /*!< 0x00200000 */
#define ADC_SMPR2_SMP7_1 (0x2U << ADC_SMPR2_SMP7_Pos) /*!< 0x00400000 */
#define ADC_SMPR2_SMP7_2 (0x4U << ADC_SMPR2_SMP7_Pos) /*!< 0x00800000 */

#define ADC_SMPR2_SMP8_Pos (24U)
#define ADC_SMPR2_SMP8_Msk (0x7U << ADC_SMPR2_SMP8_Pos) /*!< 0x07000000 */
#define ADC_SMPR2_SMP8 ADC_SMPR2_SMP8_Msk /*!< ADC channel 8 sampling time selection  */
#define ADC_SMPR2_SMP8_0 (0x1U << ADC_SMPR2_SMP8_Pos) /*!< 0x01000000 */
#define ADC_SMPR2_SMP8_1 (0x2U << ADC_SMPR2_SMP8_Pos) /*!< 0x02000000 */
#define ADC_SMPR2_SMP8_2 (0x4U << ADC_SMPR2_SMP8_Pos) /*!< 0x04000000 */

#define ADC_SMPR2_SMP9_Pos (27U)
#define ADC_SMPR2_SMP9_Msk (0x7U << ADC_SMPR2_SMP9_Pos) /*!< 0x38000000 */
#define ADC_SMPR2_SMP9 ADC_SMPR2_SMP9_Msk /*!< ADC channel 9 sampling time selection  */
#define ADC_SMPR2_SMP9_0 (0x1U << ADC_SMPR2_SMP9_Pos) /*!< 0x08000000 */
#define ADC_SMPR2_SMP9_1 (0x2U << ADC_SMPR2_SMP9_Pos) /*!< 0x10000000 */
#define ADC_SMPR2_SMP9_2 (0x4U << ADC_SMPR2_SMP9_Pos) /*!< 0x20000000 */

/******************  Bit definition for ADC_JOFR1 register  *******************/
#define ADC_JOFR1_JOFFSET1_Pos (0U)
#define ADC_JOFR1_JOFFSET1_Msk (0xFFFU << ADC_JOFR1_JOFFSET1_Pos) /*!< 0x00000FFF */
#define ADC_JOFR1_JOFFSET1 ADC_JOFR1_JOFFSET1_Msk /*!< ADC group injected sequencer rank 1 offset value */

/******************  Bit definition for ADC_JOFR2 register  *******************/
#define ADC_JOFR2_JOFFSET2_Pos (0U)
#define ADC_JOFR2_JOFFSET2_Msk (0xFFFU << ADC_JOFR2_JOFFSET2_Pos) /*!< 0x00000FFF */
#define ADC_JOFR2_JOFFSET2 ADC_JOFR2_JOFFSET2_Msk /*!< ADC group injected sequencer rank 2 offset value */

/******************  Bit definition for ADC_JOFR3 register  *******************/
#define ADC_JOFR3_JOFFSET3_Pos (0U)
#define ADC_JOFR3_JOFFSET3_Msk (0xFFFU << ADC_JOFR3_JOFFSET3_Pos) /*!< 0x00000FFF */
#define ADC_JOFR3_JOFFSET3 ADC_JOFR3_JOFFSET3_Msk /*!< ADC group injected sequencer rank 3 offset value */

/******************  Bit definition for ADC_JOFR4 register  *******************/
#define ADC_JOFR4_JOFFSET4_Pos (0U)
#define ADC_JOFR4_JOFFSET4_Msk (0xFFFU << ADC_JOFR4_JOFFSET4_Pos) /*!< 0x00000FFF */
#define ADC_JOFR4_JOFFSET4 ADC_JOFR4_JOFFSET4_Msk /*!< ADC group injected sequencer rank 4 offset value */

/*******************  Bit definition for ADC_HTR register  ********************/
#define ADC_HTR_HT_Pos (0U)
#define ADC_HTR_HT_Msk (0xFFFU << ADC_HTR_HT_Pos) /*!< 0x00000FFF */
#define ADC_HTR_HT ADC_HTR_HT_Msk /*!< ADC analog watchdog 1 threshold high */

/*******************  Bit definition for ADC_LTR register  ********************/
#define ADC_LTR_LT_Pos (0U)
#define ADC_LTR_LT_Msk (0xFFFU << ADC_LTR_LT_Pos) /*!< 0x00000FFF */
#define ADC_LTR_LT ADC_LTR_LT_Msk /*!< ADC analog watchdog 1 threshold low */

/*******************  Bit definition for ADC_SQR1 register  *******************/
#define ADC_SQR1_SQ13_Pos (0U)
#define ADC_SQR1_SQ13_Msk (0x1FU << ADC_SQR1_SQ13_Pos) /*!< 0x0000001F */
#define ADC_SQR1_SQ13 ADC_SQR1_SQ13_Msk /*!< ADC group regular sequencer rank 13 */
#define ADC_SQR1_SQ13_0 (0x01U << ADC_SQR1_SQ13_Pos) /*!< 0x00000001 */
#define ADC_SQR1_SQ13_1 (0x02U << ADC_SQR1_SQ13_Pos) /*!< 0x00000002 */
#define ADC_SQR1_SQ13_2 (0x04U << ADC_SQR1_SQ13_Pos) /*!< 0x00000004 */
#define ADC_SQR1_SQ13_3 (0x08U << ADC_SQR1_SQ13_Pos) /*!< 0x00000008 */
#define ADC_SQR1_SQ13_4 (0x10U << ADC_SQR1_SQ13_Pos) /*!< 0x00000010 */

#define ADC_SQR1_SQ14_Pos (5U)
#define ADC_SQR1_SQ14_Msk (0x1FU << ADC_SQR1_SQ14_Pos) /*!< 0x000003E0 */
#define ADC_SQR1_SQ14 ADC_SQR1_SQ14_Msk /*!< ADC group regular sequencer rank 14 */
#define ADC_SQR1_SQ14_0 (0x01U << ADC_SQR1_SQ14_Pos) /*!< 0x00000020 */
#define ADC_SQR1_SQ14_1 (0x02U << ADC_SQR1_SQ14_Pos) /*!< 0x00000040 */
#define ADC_SQR1_SQ14_2 (0x04U << ADC_SQR1_SQ14_Pos) /*!< 0x00000080 */
#define ADC_SQR1_SQ14_3 (0x08U << ADC_SQR1_SQ14_Pos) /*!< 0x00000100 */
#define ADC_SQR1_SQ14_4 (0x10U << ADC_SQR1_SQ14_Pos) /*!< 0x00000200 */

#define ADC_SQR1_SQ15_Pos (10U)
#define ADC_SQR1_SQ15_Msk (0x1FU << ADC_SQR1_SQ15_Pos) /*!< 0x00007C00 */
#define ADC_SQR1_SQ15 ADC_SQR1_SQ15_Msk /*!< ADC group regular sequencer rank 15 */
#define ADC_SQR1_SQ15_0 (0x01U << ADC_SQR1_SQ15_Pos) /*!< 0x00000400 */
#define ADC_SQR1_SQ15_1 (0x02U << ADC_SQR1_SQ15_Pos) /*!< 0x00000800 */
#define ADC_SQR1_SQ15_2 (0x04U << ADC_SQR1_SQ15_Pos) /*!< 0x00001000 */
#define ADC_SQR1_SQ15_3 (0x08U << ADC_SQR1_SQ15_Pos) /*!< 0x00002000 */
#define ADC_SQR1_SQ15_4 (0x10U << ADC_SQR1_SQ15_Pos) /*!< 0x00004000 */

#define ADC_SQR1_SQ16_Pos (15U)
#define ADC_SQR1_SQ16_Msk (0x1FU << ADC_SQR1_SQ16_Pos) /*!< 0x000F8000 */
#define ADC_SQR1_SQ16 ADC_SQR1_SQ16_Msk /*!< ADC group regular sequencer rank 16 */
#define ADC_SQR1_SQ16_0 (0x01U << ADC_SQR1_SQ16_Pos) /*!< 0x00008000 */
#define ADC_SQR1_SQ16_1 (0x02U << ADC_SQR1_SQ16_Pos) /*!< 0x00010000 */
#define ADC_SQR1_SQ16_2 (0x04U << ADC_SQR1_SQ16_Pos) /*!< 0x00020000 */
#define ADC_SQR1_SQ16_3 (0x08U << ADC_SQR1_SQ16_Pos) /*!< 0x00040000 */
#define ADC_SQR1_SQ16_4 (0x10U << ADC_SQR1_SQ16_Pos) /*!< 0x00080000 */

#define ADC_SQR1_L_Pos (20U)
#define ADC_SQR1_L_Msk (0xFU << ADC_SQR1_L_Pos) /*!< 0x00F00000 */
#define ADC_SQR1_L ADC_SQR1_L_Msk /*!< ADC group regular sequencer scan length */
#define ADC_SQR1_L_0 (0x1U << ADC_SQR1_L_Pos) /*!< 0x00100000 */
#define ADC_SQR1_L_1 (0x2U << ADC_SQR1_L_Pos) /*!< 0x00200000 */
#define ADC_SQR1_L_2 (0x4U << ADC_SQR1_L_Pos) /*!< 0x00400000 */
#define ADC_SQR1_L_3 (0x8U << ADC_SQR1_L_Pos) /*!< 0x00800000 */

/*******************  Bit definition for ADC_SQR2 register  *******************/
#define ADC_SQR2_SQ7_Pos (0U)
#define ADC_SQR2_SQ7_Msk (0x1FU << ADC_SQR2_SQ7_Pos) /*!< 0x0000001F */
#define ADC_SQR2_SQ7 ADC_SQR2_SQ7_Msk /*!< ADC group regular sequencer rank 7 */
#define ADC_SQR2_SQ7_0 (0x01U << ADC_SQR2_SQ7_Pos) /*!< 0x00000001 */
#define ADC_SQR2_SQ7_1 (0x02U << ADC_SQR2_SQ7_Pos) /*!< 0x00000002 */
#define ADC_SQR2_SQ7_2 (0x04U << ADC_SQR2_SQ7_Pos) /*!< 0x00000004 */
#define ADC_SQR2_SQ7_3 (0x08U << ADC_SQR2_SQ7_Pos) /*!< 0x00000008 */
#define ADC_SQR2_SQ7_4 (0x10U << ADC_SQR2_SQ7_Pos) /*!< 0x00000010 */

#define ADC_SQR2_SQ8_Pos (5U)
#define ADC_SQR2_SQ8_Msk (0x1FU << ADC_SQR2_SQ8_Pos) /*!< 0x000003E0 */
#define ADC_SQR2_SQ8 ADC_SQR2_SQ8_Msk /*!< ADC group regular sequencer rank 8 */
#define ADC_SQR2_SQ8_0 (0x01U << ADC_SQR2_SQ8_Pos) /*!< 0x00000020 */
#define ADC_SQR2_SQ8_1 (0x02U << ADC_SQR2_SQ8_Pos) /*!< 0x00000040 */
#define ADC_SQR2_SQ8_2 (0x04U << ADC_SQR2_SQ8_Pos) /*!< 0x00000080 */
#define ADC_SQR2_SQ8_3 (0x08U << ADC_SQR2_SQ8_Pos) /*!< 0x00000100 */
#define ADC_SQR2_SQ8_4 (0x10U << ADC_SQR2_SQ8_Pos) /*!< 0x00000200 */

#define ADC_SQR2_SQ9_Pos (10U)
#define ADC_SQR2_SQ9_Msk (0x1FU << ADC_SQR2_SQ9_Pos) /*!< 0x00007C00 */
#define ADC_SQR2_SQ9 ADC_SQR2_SQ9_Msk /*!< ADC group regular sequencer rank 9 */
#define ADC_SQR2_SQ9_0 (0x01U << ADC_SQR2_SQ9_Pos) /*!< 0x00000400 */
#define ADC_SQR2_SQ9_1 (0x02U << ADC_SQR2_SQ9_Pos) /*!< 0x00000800 */
#define ADC_SQR2_SQ9_2 (0x04U << ADC_SQR2_SQ9_Pos) /*!< 0x00001000 */
#define ADC_SQR2_SQ9_3 (0x08U << ADC_SQR2_SQ9_Pos) /*!< 0x00002000 */
#define ADC_SQR2_SQ9_4 (0x10U << ADC_SQR2_SQ9_Pos) /*!< 0x00004000 */

#define ADC_SQR2_SQ10_Pos (15U)
#define ADC_SQR2_SQ10_Msk (0x1FU << ADC_SQR2_SQ10_Pos) /*!< 0x000F8000 */
#define ADC_SQR2_SQ10 ADC_SQR2_SQ10_Msk /*!< ADC group regular sequencer rank 10 */
#define ADC_SQR2_SQ10_0 (0x01U << ADC_SQR2_SQ10_Pos) /*!< 0x00008000 */
#define ADC_SQR2_SQ10_1 (0x02U << ADC_SQR2_SQ10_Pos) /*!< 0x00010000 */
#define ADC_SQR2_SQ10_2 (0x04U << ADC_SQR2_SQ10_Pos) /*!< 0x00020000 */
#define ADC_SQR2_SQ10_3 (0x08U << ADC_SQR2_SQ10_Pos) /*!< 0x00040000 */
#define ADC_SQR2_SQ10_4 (0x10U << ADC_SQR2_SQ10_Pos) /*!< 0x00080000 */

#define ADC_SQR2_SQ11_Pos (20U)
#define ADC_SQR2_SQ11_Msk (0x1FU << ADC_SQR2_SQ11_Pos) /*!< 0x01F00000 */
#define ADC_SQR2_SQ11 ADC_SQR2_SQ11_Msk /*!< ADC group regular sequencer rank 1 */
#define ADC_SQR2_SQ11_0 (0x01U << ADC_SQR2_SQ11_Pos) /*!< 0x00100000 */
#define ADC_SQR2_SQ11_1 (0x02U << ADC_SQR2_SQ11_Pos) /*!< 0x00200000 */
#define ADC_SQR2_SQ11_2 (0x04U << ADC_SQR2_SQ11_Pos) /*!< 0x00400000 */
#define ADC_SQR2_SQ11_3 (0x08U << ADC_SQR2_SQ11_Pos) /*!< 0x00800000 */
#define ADC_SQR2_SQ11_4 (0x10U << ADC_SQR2_SQ11_Pos) /*!< 0x01000000 */

#define ADC_SQR2_SQ12_Pos (25U)
#define ADC_SQR2_SQ12_Msk (0x1FU << ADC_SQR2_SQ12_Pos) /*!< 0x3E000000 */
#define ADC_SQR2_SQ12 ADC_SQR2_SQ12_Msk /*!< ADC group regular sequencer rank 12 */
#define ADC_SQR2_SQ12_0 (0x01U << ADC_SQR2_SQ12_Pos) /*!< 0x02000000 */
#define ADC_SQR2_SQ12_1 (0x02U << ADC_SQR2_SQ12_Pos) /*!< 0x04000000 */
#define ADC_SQR2_SQ12_2 (0x04U << ADC_SQR2_SQ12_Pos) /*!< 0x08000000 */
#define ADC_SQR2_SQ12_3 (0x08U << ADC_SQR2_SQ12_Pos) /*!< 0x10000000 */
#define ADC_SQR2_SQ12_4 (0x10U << ADC_SQR2_SQ12_Pos) /*!< 0x20000000 */

/*******************  Bit definition for ADC_SQR3 register  *******************/
#define ADC_SQR3_SQ1_Pos (0U)
#define ADC_SQR3_SQ1_Msk (0x1FU << ADC_SQR3_SQ1_Pos) /*!< 0x0000001F */
#define ADC_SQR3_SQ1 ADC_SQR3_SQ1_Msk /*!< ADC group regular sequencer rank 1 */
#define ADC_SQR3_SQ1_0 (0x01U << ADC_SQR3_SQ1_Pos) /*!< 0x00000001 */
#define ADC_SQR3_SQ1_1 (0x02U << ADC_SQR3_SQ1_Pos) /*!< 0x00000002 */
#define ADC_SQR3_SQ1_2 (0x04U << ADC_SQR3_SQ1_Pos) /*!< 0x00000004 */
#define ADC_SQR3_SQ1_3 (0x08U << ADC_SQR3_SQ1_Pos) /*!< 0x00000008 */
#define ADC_SQR3_SQ1_4 (0x10U << ADC_SQR3_SQ1_Pos) /*!< 0x00000010 */

#define ADC_SQR3_SQ2_Pos (5U)
#define ADC_SQR3_SQ2_Msk (0x1FU << ADC_SQR3_SQ2_Pos) /*!< 0x000003E0 */
#define ADC_SQR3_SQ2 ADC_SQR3_SQ2_Msk /*!< ADC group regular sequencer rank 2 */
#define ADC_SQR3_SQ2_0 (0x01U << ADC_SQR3_SQ2_Pos) /*!< 0x00000020 */
#define ADC_SQR3_SQ2_1 (0x02U << ADC_SQR3_SQ2_Pos) /*!< 0x00000040 */
#define ADC_SQR3_SQ2_2 (0x04U << ADC_SQR3_SQ2_Pos) /*!< 0x00000080 */
#define ADC_SQR3_SQ2_3 (0x08U << ADC_SQR3_SQ2_Pos) /*!< 0x00000100 */
#define ADC_SQR3_SQ2_4 (0x10U << ADC_SQR3_SQ2_Pos) /*!< 0x00000200 */

#define ADC_SQR3_SQ3_Pos (10U)
#define ADC_SQR3_SQ3_Msk (0x1FU << ADC_SQR3_SQ3_Pos) /*!< 0x00007C00 */
#define ADC_SQR3_SQ3 ADC_SQR3_SQ3_Msk /*!< ADC group regular sequencer rank 3 */
#define ADC_SQR3_SQ3_0 (0x01U << ADC_SQR3_SQ3_Pos) /*!< 0x00000400 */
#define ADC_SQR3_SQ3_1 (0x02U << ADC_SQR3_SQ3_Pos) /*!< 0x00000800 */
#define ADC_SQR3_SQ3_2 (0x04U << ADC_SQR3_SQ3_Pos) /*!< 0x00001000 */
#define ADC_SQR3_SQ3_3 (0x08U << ADC_SQR3_SQ3_Pos) /*!< 0x00002000 */
#define ADC_SQR3_SQ3_4 (0x10U << ADC_SQR3_SQ3_Pos) /*!< 0x00004000 */

#define ADC_SQR3_SQ4_Pos (15U)
#define ADC_SQR3_SQ4_Msk (0x1FU << ADC_SQR3_SQ4_Pos) /*!< 0x000F8000 */
#define ADC_SQR3_SQ4 ADC_SQR3_SQ4_Msk /*!< ADC group regular sequencer rank 4 */
#define ADC_SQR3_SQ4_0 (0x01U << ADC_SQR3_SQ4_Pos) /*!< 0x00008000 */
#define ADC_SQR3_SQ4_1 (0x02U << ADC_SQR3_SQ4_Pos) /*!< 0x00010000 */
#define ADC_SQR3_SQ4_2 (0x04U << ADC_SQR3_SQ4_Pos) /*!< 0x00020000 */
#define ADC_SQR3_SQ4_3 (0x08U << ADC_SQR3_SQ4_Pos) /*!< 0x00040000 */
#define ADC_SQR3_SQ4_4 (0x10U << ADC_SQR3_SQ4_Pos) /*!< 0x00080000 */

#define ADC_SQR3_SQ5_Pos (20U)
#define ADC_SQR3_SQ5_Msk (0x1FU << ADC_SQR3_SQ5_Pos) /*!< 0x01F00000 */
#define ADC_SQR3_SQ5 ADC_SQR3_SQ5_Msk /*!< ADC group regular sequencer rank 5 */
#define ADC_SQR3_SQ5_0 (0x01U << ADC_SQR3_SQ5_Pos) /*!< 0x00100000 */
#define ADC_SQR3_SQ5_1 (0x02U << ADC_SQR3_SQ5_Pos) /*!< 0x00200000 */
#define ADC_SQR3_SQ5_2 (0x04U << ADC_SQR3_SQ5_Pos) /*!< 0x00400000 */
#define ADC_SQR3_SQ5_3 (0x08U << ADC_SQR3_SQ5_Pos) /*!< 0x00800000 */
#define ADC_SQR3_SQ5_4 (0x10U << ADC_SQR3_SQ5_Pos) /*!< 0x01000000 */

#define ADC_SQR3_SQ6_Pos (25U)
#define ADC_SQR3_SQ6_Msk (0x1FU << ADC_SQR3_SQ6_Pos) /*!< 0x3E000000 */
#define ADC_SQR3_SQ6 ADC_SQR3_SQ6_Msk /*!< ADC group regular sequencer rank 6 */
#define ADC_SQR3_SQ6_0 (0x01U << ADC_SQR3_SQ6_Pos) /*!< 0x02000000 */
#define ADC_SQR3_SQ6_1 (0x02U << ADC_SQR3_SQ6_Pos) /*!< 0x04000000 */
#define ADC_SQR3_SQ6_2 (0x04U << ADC_SQR3_SQ6_Pos) /*!< 0x08000000 */
#define ADC_SQR3_SQ6_3 (0x08U << ADC_SQR3_SQ6_Pos) /*!< 0x10000000 */
#define ADC_SQR3_SQ6_4 (0x10U << ADC_SQR3_SQ6_Pos) /*!< 0x20000000 */

/*******************  Bit definition for ADC_JSQR register  *******************/
#define ADC_JSQR_JSQ1_Pos (0U)
#define ADC_JSQR_JSQ1_Msk (0x1FU << ADC_JSQR_JSQ1_Pos) /*!< 0x0000001F */
#define ADC_JSQR_JSQ1 ADC_JSQR_JSQ1_Msk /*!< ADC group injected sequencer rank 1 */
#define ADC_JSQR_JSQ1_0 (0x01U << ADC_JSQR_JSQ1_Pos) /*!< 0x00000001 */
#define ADC_JSQR_JSQ1_1 (0x02U << ADC_JSQR_JSQ1_Pos) /*!< 0x00000002 */
#define ADC_JSQR_JSQ1_2 (0x04U << ADC_JSQR_JSQ1_Pos) /*!< 0x00000004 */
#define ADC_JSQR_JSQ1_3 (0x08U << ADC_JSQR_JSQ1_Pos) /*!< 0x00000008 */
#define ADC_JSQR_JSQ1_4 (0x10U << ADC_JSQR_JSQ1_Pos) /*!< 0x00000010 */

#define ADC_JSQR_JSQ2_Pos (5U)
#define ADC_JSQR_JSQ2_Msk (0x1FU << ADC_JSQR_JSQ2_Pos) /*!< 0x000003E0 */
#define ADC_JSQR_JSQ2 ADC_JSQR_JSQ2_Msk /*!< ADC group injected sequencer rank 2 */
#define ADC_JSQR_JSQ2_0 (0x01U << ADC_JSQR_JSQ2_Pos) /*!< 0x00000020 */
#define ADC_JSQR_JSQ2_1 (0x02U << ADC_JSQR_JSQ2_Pos) /*!< 0x00000040 */
#define ADC_JSQR_JSQ2_2 (0x04U << ADC_JSQR_JSQ2_Pos) /*!< 0x00000080 */
#define ADC_JSQR_JSQ2_3 (0x08U << ADC_JSQR_JSQ2_Pos) /*!< 0x00000100 */
#define ADC_JSQR_JSQ2_4 (0x10U << ADC_JSQR_JSQ2_Pos) /*!< 0x00000200 */

#define ADC_JSQR_JSQ3_Pos (10U)
#define ADC_JSQR_JSQ3_Msk (0x1FU << ADC_JSQR_JSQ3_Pos) /*!< 0x00007C00 */
#define ADC_JSQR_JSQ3 ADC_JSQR_JSQ3_Msk /*!< ADC group injected sequencer rank 3 */
#define ADC_JSQR_JSQ3_0 (0x01U << ADC_JSQR_JSQ3_Pos) /*!< 0x00000400 */
#define ADC_JSQR_JSQ3_1 (0x02U << ADC_JSQR_JSQ3_Pos) /*!< 0x00000800 */
#define ADC_JSQR_JSQ3_2 (0x04U << ADC_JSQR_JSQ3_Pos) /*!< 0x00001000 */
#define ADC_JSQR_JSQ3_3 (0x08U << ADC_JSQR_JSQ3_Pos) /*!< 0x00002000 */
#define ADC_JSQR_JSQ3_4 (0x10U << ADC_JSQR_JSQ3_Pos) /*!< 0x00004000 */

#define ADC_JSQR_JSQ4_Pos (15U)
#define ADC_JSQR_JSQ4_Msk (0x1FU << ADC_JSQR_JSQ4_Pos) /*!< 0x000F8000 */
#define ADC_JSQR_JSQ4 ADC_JSQR_JSQ4_Msk /*!< ADC group injected sequencer rank 4 */
#define ADC_JSQR_JSQ4_0 (0x01U << ADC_JSQR_JSQ4_Pos) /*!< 0x00008000 */
#define ADC_JSQR_JSQ4_1 (0x02U << ADC_JSQR_JSQ4_Pos) /*!< 0x00010000 */
#define ADC_JSQR_JSQ4_2 (0x04U << ADC_JSQR_JSQ4_Pos) /*!< 0x00020000 */
#define ADC_JSQR_JSQ4_3 (0x08U << ADC_JSQR_JSQ4_Pos) /*!< 0x00040000 */
#define ADC_JSQR_JSQ4_4 (0x10U << ADC_JSQR_JSQ4_Pos) /*!< 0x00080000 */

#define ADC_JSQR_JL_Pos (20U)
#define ADC_JSQR_JL_Msk (0x3U << ADC_JSQR_JL_Pos) /*!< 0x00300000 */
#define ADC_JSQR_JL ADC_JSQR_JL_Msk /*!< ADC group injected sequencer scan length */
#define ADC_JSQR_JL_0 (0x1U << ADC_JSQR_JL_Pos) /*!< 0x00100000 */
#define ADC_JSQR_JL_1 (0x2U << ADC_JSQR_JL_Pos) /*!< 0x00200000 */

/*******************  Bit definition for ADC_JDR1 register  *******************/
#define ADC_JDR1_JDATA_Pos (0U)
#define ADC_JDR1_JDATA_Msk (0xFFFFU << ADC_JDR1_JDATA_Pos) /*!< 0x0000FFFF */
#define ADC_JDR1_JDATA ADC_JDR1_JDATA_Msk /*!< ADC group injected sequencer rank 1 conversion data */

/*******************  Bit definition for ADC_JDR2 register  *******************/
#define ADC_JDR2_JDATA_Pos (0U)
#define ADC_JDR2_JDATA_Msk (0xFFFFU << ADC_JDR2_JDATA_Pos) /*!< 0x0000FFFF */
#define ADC_JDR2_JDATA ADC_JDR2_JDATA_Msk /*!< ADC group injected sequencer rank 2 conversion data */

/*******************  Bit definition for ADC_JDR3 register  *******************/
#define ADC_JDR3_JDATA_Pos (0U)
#define ADC_JDR3_JDATA_Msk (0xFFFFU << ADC_JDR3_JDATA_Pos) /*!< 0x0000FFFF */
#define ADC_JDR3_JDATA ADC_JDR3_JDATA_Msk /*!< ADC group injected sequencer rank 3 conversion data */

/*******************  Bit definition for ADC_JDR4 register  *******************/
#define ADC_JDR4_JDATA_Pos (0U)
#define ADC_JDR4_JDATA_Msk (0xFFFFU << ADC_JDR4_JDATA_Pos) /*!< 0x0000FFFF */
#define ADC_JDR4_JDATA ADC_JDR4_JDATA_Msk /*!< ADC group injected sequencer rank 4 conversion data */

/********************  Bit definition for ADC_DR register  ********************/
#define ADC_DR_DATA_Pos (0U)
#define ADC_DR_DATA_Msk (0xFFFFU << ADC_DR_DATA_Pos) /*!< 0x0000FFFF */
#define ADC_DR_DATA ADC_DR_DATA_Msk /*!< ADC group regular conversion data */
#define ADC_DR_ADC2DATA_Pos (16U)
#define ADC_DR_ADC2DATA_Msk (0xFFFFU << ADC_DR_ADC2DATA_Pos) /*!< 0xFFFF0000 */
#define ADC_DR_ADC2DATA ADC_DR_ADC2DATA_Msk /*!< ADC group regular conversion data for ADC slave, in multimode */


/*****************************************************************************/
/*                                                                           */
/*                               Timers (TIM)                                */
/*                                                                           */
/*****************************************************************************/
/*******************  Bit definition for TIM_CR1 register  *******************/
#define TIM_CR1_CEN_Pos (0U)
#define TIM_CR1_CEN_Msk (0x1U << TIM_CR1_CEN_Pos) /*!< 0x00000001 */
#define TIM_CR1_CEN TIM_CR1_CEN_Msk /*!<Counter enable */
#define TIM_CR1_UDIS_Pos (1U)
#define TIM_CR1_UDIS_Msk (0x1U << TIM_CR1_UDIS_Pos) /*!< 0x00000002 */
#define TIM_CR1_UDIS TIM_CR1_UDIS_Msk /*!<Update disable */
#define TIM_CR1_URS_Pos (2U)
#define TIM_CR1_URS_Msk (0x1U << TIM_CR1_URS_Pos) /*!< 0x00000004 */
#define TIM_CR1_URS TIM_CR1_URS_Msk /*!<Update request source */
#define TIM_CR1_OPM_Pos (3U)
#define TIM_CR1_OPM_Msk (0x1U << TIM_CR1_OPM_Pos) /*!< 0x00000008 */
#define TIM_CR1_OPM TIM_CR1_OPM_Msk /*!<One pulse mode */
#define TIM_CR1_DIR_Pos (4U)
#define TIM_CR1_DIR_Msk (0x1U << TIM_CR1_DIR_Pos) /*!< 0x00000010 */
#define TIM_CR1_DIR TIM_CR1_DIR_Msk /*!<Direction */

#define TIM_CR1_CMS_Pos (5U)
#define TIM_CR1_CMS_Msk (0x3U << TIM_CR1_CMS_Pos) /*!< 0x00000060 */
#define TIM_CR1_CMS TIM_CR1_CMS_Msk /*!<CMS[1:0] bits (Center-aligned mode selection) */
#define TIM_CR1_CMS_0 (0x1U << TIM_CR1_CMS_Pos) /*!< 0x00000020 */
#define TIM_CR1_CMS_1 (0x2U << TIM_CR1_CMS_Pos) /*!< 0x00000040 */

#define TIM_CR1_ARPE_Pos (7U)
#define TIM_CR1_ARPE_Msk (0x1U << TIM_CR1_ARPE_Pos) /*!< 0x00000080 */
#define TIM_CR1_ARPE TIM_CR1_ARPE_Msk /*!<Auto-reload preload enable */

#define TIM_CR1_CKD_Pos (8U)
#define TIM_CR1_CKD_Msk (0x3U << TIM_CR1_CKD_Pos) /*!< 0x00000300 */
#define TIM_CR1_CKD TIM_CR1_CKD_Msk /*!<CKD[1:0] bits (clock division) */
#define TIM_CR1_CKD_0 (0x1U << TIM_CR1_CKD_Pos) /*!< 0x00000100 */
#define TIM_CR1_CKD_1 (0x2U << TIM_CR1_CKD_Pos) /*!< 0x00000200 */

/*******************  Bit definition for TIM_CR2 register  *******************/
#define TIM_CR2_CCPC_Pos (0U)
#define TIM_CR2_CCPC_Msk (0x1U << TIM_CR2_CCPC_Pos) /*!< 0x00000001 */
#define TIM_CR2_CCPC TIM_CR2_CCPC_Msk /*!<Capture/Compare Preloaded Control */
#define TIM_CR2_CCUS_Pos (2U)
#define TIM_CR2_CCUS_Msk (0x1U << TIM_CR2_CCUS_Pos) /*!< 0x00000004 */
#define TIM_CR2_CCUS TIM_CR2_CCUS_Msk /*!<Capture/Compare Control Update Selection */
#define TIM_CR2_CCDS_Pos (3U)
#define TIM_CR2_CCDS_Msk (0x1U << TIM_CR2_CCDS_Pos) /*!< 0x00000008 */
#define TIM_CR2_CCDS TIM_CR2_CCDS_Msk /*!<Capture/Compare DMA Selection */

#define TIM_CR2_MMS_Pos (4U)
#define TIM_CR2_MMS_Msk (0x7U << TIM_CR2_MMS_Pos) /*!< 0x00000070 */
#define TIM_CR2_MMS TIM_CR2_MMS_Msk /*!<MMS[2:0] bits (Master Mode Selection) */
#define TIM_CR2_MMS_0 (0x1U << TIM_CR2_MMS_Pos) /*!< 0x00000010 */
#define TIM_CR2_MMS_1 (0x2U << TIM_CR2_MMS_Pos) /*!< 0x00000020 */
#define TIM_CR2_MMS_2 (0x4U << TIM_CR2_MMS_Pos) /*!< 0x00000040 */

#define TIM_CR2_TI1S_Pos (7U)
#define TIM_CR2_TI1S_Msk (0x1U << TIM_CR2_TI1S_Pos) /*!< 0x00000080 */
#define TIM_CR2_TI1S TIM_CR2_TI1S_Msk /*!<TI1 Selection */
#define TIM_CR2_OIS1_Pos (8U)
#define TIM_CR2_OIS1_Msk (0x1U << TIM_CR2_OIS1_Pos) /*!< 0x00000100 */
#define TIM_CR2_OIS1 TIM_CR2_OIS1_Msk /*!<Output Idle state 1 (OC1 output) */
#define TIM_CR2_OIS1N_Pos (9U)
#define TIM_CR2_OIS1N_Msk (0x1U << TIM_CR2_OIS1N_Pos) /*!< 0x00000200 */
#define TIM_CR2_OIS1N TIM_CR2_OIS1N_Msk /*!<Output Idle state 1 (OC1N output) */
#define TIM_CR2_OIS2_Pos (10U)
#define TIM_CR2_OIS2_Msk (0x1U << TIM_CR2_OIS2_Pos) /*!< 0x00000400 */
#define TIM_CR2_OIS2 TIM_CR2_OIS2_Msk /*!<Output Idle state 2 (OC2 output) */
#define TIM_CR2_OIS2N_Pos (11U)
#define TIM_CR2_OIS2N_Msk (0x1U << TIM_CR2_OIS2N_Pos) /*!< 0x00000800 */
#define TIM_CR2_OIS2N TIM_CR2_OIS2N_Msk /*!<Output Idle state 2 (OC2N output) */
#define TIM_CR2_OIS3_Pos (12U)
#define TIM_CR2_OIS3_Msk (0x1U << TIM_CR2_OIS3_Pos) /*!< 0x00001000 */
#define TIM_CR2_OIS3 TIM_CR2_OIS3_Msk /*!<Output Idle state 3 (OC3 output) */
#define TIM_CR2_OIS3N_Pos (13U)
#define TIM_CR2_OIS3N_Msk (0x1U << TIM_CR2_OIS3N_Pos) /*!< 0x00002000 */
#define TIM_CR2_OIS3N TIM_CR2_OIS3N_Msk /*!<Output Idle state 3 (OC3N output) */
#define TIM_CR2_OIS4_Pos (14U)
#define TIM_CR2_OIS4_Msk (0x1U << TIM_CR2_OIS4_Pos) /*!< 0x00004000 */
#define TIM_CR2_OIS4 TIM_CR2_OIS4_Msk /*!<Output Idle state 4 (OC4 output) */

/*******************  Bit definition for TIM_SMCR register  ******************/
#define TIM_SMCR_SMS_Pos (0U)
#define TIM_SMCR_SMS_Msk (0x7U << TIM_SMCR_SMS_Pos) /*!< 0x00000007 */
#define TIM_SMCR_SMS TIM_SMCR_SMS_Msk /*!<SMS[2:0] bits (Slave mode selection) */
#define TIM_SMCR_SMS_0 (0x1U << TIM_SMCR_SMS_Pos) /*!< 0x00000001 */
#define TIM_SMCR_SMS_1 (0x2U << TIM_SMCR_SMS_Pos) /*!< 0x00000002 */
#define TIM_SMCR_SMS_2 (0x4U << TIM_SMCR_SMS_Pos) /*!< 0x00000004 */

#define TIM_SMCR_TS_Pos (4U)
#define TIM_SMCR_TS_Msk (0x7U << TIM_SMCR_TS_Pos) /*!< 0x00000070 */
#define TIM_SMCR_TS TIM_SMCR_TS_Msk /*!<TS[2:0] bits (Trigger selection) */
#define TIM_SMCR_TS_0 (0x1U << TIM_SMCR_TS_Pos) /*!< 0x00000010 */
#define TIM_SMCR_TS_1 (0x2U << TIM_SMCR_TS_Pos) /*!< 0x00000020 */
#define TIM_SMCR_TS_2 (0x4U << TIM_SMCR_TS_Pos) /*!< 0x00000040 */

#define TIM_SMCR_MSM_Pos (7U)
#define TIM_SMCR_MSM_Msk (0x1U << TIM_SMCR_MSM_Pos) /*!< 0x00000080 */
#define TIM_SMCR_MSM TIM_SMCR_MSM_Msk /*!<Master/slave mode */

#define TIM_SMCR_ETF_Pos (8U)
#define TIM_SMCR_ETF_Msk (0xFU << TIM_SMCR_ETF_Pos) /*!< 0x00000F00 */
#define TIM_SMCR_ETF TIM_SMCR_ETF_Msk /*!<ETF[3:0] bits (External trigger filter) */
#define TIM_SMCR_ETF_0 (0x1U << TIM_SMCR_ETF_Pos) /*!< 0x00000100 */
#define TIM_SMCR_ETF_1 (0x2U << TIM_SMCR_ETF_Pos) /*!< 0x00000200 */
#define TIM_SMCR_ETF_2 (0x4U << TIM_SMCR_ETF_Pos) /*!< 0x00000400 */
#define TIM_SMCR_ETF_3 (0x8U << TIM_SMCR_ETF_Pos) /*!< 0x00000800 */

#define TIM_SMCR_ETPS_Pos (12U)
#define TIM_SMCR_ETPS_Msk (0x3U << TIM_SMCR_ETPS_Pos) /*!< 0x00003000 */
#define TIM_SMCR_ETPS TIM_SMCR_ETPS_Msk /*!<ETPS[1:0] bits (External trigger prescaler) */
#define TIM_SMCR_ETPS_0 (0x1U << TIM_SMCR_ETPS_Pos) /*!< 0x00001000 */
#define TIM_SMCR_ETPS_1 (0x2U << TIM_SMCR_ETPS_Pos) /*!< 0x00002000 */

#define TIM_SMCR_ECE_Pos (14U)
#define TIM_SMCR_ECE_Msk (0x1U << TIM_SMCR_ECE_Pos) /*!< 0x00004000 */
#define TIM_SMCR_ECE TIM_SMCR_ECE_Msk /*!<External clock enable */
#define TIM_SMCR_ETP_Pos (15U)
#define TIM_SMCR_ETP_Msk (0x1U << TIM_SMCR_ETP_Pos) /*!< 0x00008000 */
#define TIM_SMCR_ETP TIM_SMCR_ETP_Msk /*!<External trigger polarity */

/*******************  Bit definition for TIM_DIER register  ******************/
#define TIM_DIER_UIE_Pos (0U)
#define TIM_DIER_UIE_Msk (0x1U << TIM_DIER_UIE_Pos) /*!< 0x00000001 */
#define TIM_DIER_UIE TIM_DIER_UIE_Msk /*!<Update interrupt enable */
#define TIM_DIER_CC1IE_Pos (1U)
#define TIM_DIER_CC1IE_Msk (0x1U << TIM_DIER_CC1IE_Pos) /*!< 0x00000002 */
#define TIM_DIER_CC1IE TIM_DIER_CC1IE_Msk /*!<Capture/Compare 1 interrupt enable */
#define TIM_DIER_CC2IE_Pos (2U)
#define TIM_DIER_CC2IE_Msk (0x1U << TIM_DIER_CC2IE_Pos) /*!< 0x00000004 */
#define TIM_DIER_CC2IE TIM_DIER_CC2IE_Msk /*!<Capture/Compare 2 interrupt enable */
#define TIM_DIER_CC3IE_Pos (3U)
#define TIM_DIER_CC3IE_Msk (0x1U << TIM_DIER_CC3IE_Pos) /*!< 0x00000008 */
#define TIM_DIER_CC3IE TIM_DIER_CC3IE_Msk /*!<Capture/Compare 3 interrupt enable */
#define TIM_DIER_CC4IE_Pos (4U)
#define TIM_DIER_CC4IE_Msk (0x1U << TIM_DIER_CC4IE_Pos) /*!< 0x00000010 */
#define TIM_DIER_CC4IE TIM_DIER_CC4IE_Msk /*!<Capture/Compare 4 interrupt enable */
#define TIM_DIER_COMIE_Pos (5U)
#define TIM_DIER_COMIE_Msk (0x1U << TIM_DIER_COMIE_Pos) /*!< 0x00000020 */
#define TIM_DIER_COMIE TIM_DIER_COMIE_Msk /*!<COM interrupt enable */
#define TIM_DIER_TIE_Pos (6U)
#define TIM_DIER_TIE_Msk (0x1U << TIM_DIER_TIE_Pos) /*!< 0x00000040 */
#define TIM_DIER_TIE TIM_DIER_TIE_Msk /*!<Trigger interrupt enable */
#define TIM_DIER_BIE_Pos (7U)
#define TIM_DIER_BIE_Msk (0x1U << TIM_DIER_BIE_Pos) /*!< 0x00000080 */
#define TIM_DIER_BIE TIM_DIER_BIE_Msk /*!<Break interrupt enable */
#define TIM_DIER_UDE_Pos (8U)
#define TIM_DIER_UDE_Msk (0x1U << TIM_DIER_UDE_Pos) /*!< 0x00000100 */
#define TIM_DIER_UDE TIM_DIER_UDE_Msk /*!<Update DMA request enable */
#define TIM_DIER_CC1DE_Pos (9U)
#define TIM_DIER_CC1DE_Msk (0x1U << TIM_DIER_CC1DE_Pos) /*!< 0x00000200 */
#define TIM_DIER_CC1DE TIM_DIER_CC1DE_Msk /*!<Capture/Compare 1 DMA request enable */
#define TIM_DIER_CC2DE_Pos (10U)
#define TIM_DIER_CC2DE_Msk (0x1U << TIM_DIER_CC2DE_Pos) /*!< 0x00000400 */
#define TIM_DIER_CC2DE TIM_DIER_CC2DE_Msk /*!<Capture/Compare 2 DMA request enable */
#define TIM_DIER_CC3DE_Pos (11U)
#define TIM_DIER_CC3DE_Msk (0x1U << TIM_DIER_CC3DE_Pos) /*!< 0x00000800 */
#define TIM_DIER_CC3DE TIM_DIER_CC3DE_Msk /*!<Capture/Compare 3 DMA request enable */
#define TIM_DIER_CC4DE_Pos (12U)
#define TIM_DIER_CC4DE_Msk (0x1U << TIM_DIER_CC4DE_Pos) /*!< 0x00001000 */
#define TIM_DIER_CC4DE TIM_DIER_CC4DE_Msk /*!<Capture/Compare 4 DMA request enable */
#define TIM_DIER_COMDE_Pos (13U)
#define TIM_DIER_COMDE_Msk (0x1U << TIM_DIER_COMDE_Pos) /*!< 0x00002000 */
#define TIM_DIER_COMDE TIM_DIER_COMDE_Msk /*!<COM DMA request enable */
#define TIM_DIER_TDE_Pos (14U)
#define TIM_DIER_TDE_Msk (0x1U << TIM_DIER_TDE_Pos) /*!< 0x00004000 */
#define TIM_DIER_TDE TIM_DIER_TDE_Msk /*!<Trigger DMA request enable */

/********************  Bit definition for TIM_SR register  *******************/
#define TIM_SR_UIF_Pos (0U)
#define TIM_SR_UIF_Msk (0x1U << TIM_SR_UIF_Pos) /*!< 0x00000001 */
#define TIM_SR_UIF TIM_SR_UIF_Msk /*!<Update interrupt Flag */
#define TIM_SR_CC1IF_Pos (1U)
#define TIM_SR_CC1IF_Msk (0x1U << TIM_SR_CC1IF_Pos) /*!< 0x00000002 */
#define TIM_SR_CC1IF TIM_SR_CC1IF_Msk /*!<Capture/Compare 1 interrupt Flag */
#define TIM_SR_CC2IF_Pos (2U)
#define TIM_SR_CC2IF_Msk (0x1U << TIM_SR_CC2IF_Pos) /*!< 0x00000004 */
#define TIM_SR_CC2IF TIM_SR_CC2IF_Msk /*!<Capture/Compare 2 interrupt Flag */
#define TIM_SR_CC3IF_Pos (3U)
#define TIM_SR_CC3IF_Msk (0x1U << TIM_SR_CC3IF_Pos) /*!< 0x00000008 */
#define TIM_SR_CC3IF TIM_SR_CC3IF_Msk /*!<Capture/Compare 3 interrupt Flag */
#define TIM_SR_CC4IF_Pos (4U)
#define TIM_SR_CC4IF_Msk (0x1U << TIM_SR_CC4IF_Pos) /*!< 0x00000010 */
#define TIM_SR_CC4IF TIM_SR_CC4IF_Msk /*!<Capture/Compare 4 interrupt Flag */
#define TIM_SR_COMIF_Pos (5U)
#define TIM_SR_COMIF_Msk (0x1U << TIM_SR_COMIF_Pos) /*!< 0x00000020 */
#define TIM_SR_COMIF TIM_SR_COMIF_Msk /*!<COM interrupt Flag */
#define TIM_SR_TIF_Pos (6U)
#define TIM_SR_TIF_Msk (0x1U << TIM_SR_TIF_Pos) /*!< 0x00000040 */
#define TIM_SR_TIF TIM_SR_TIF_Msk /*!<Trigger interrupt Flag */
#define TIM_SR_BIF_Pos (7U)
#define TIM_SR_BIF_Msk (0x1U << TIM_SR_BIF_Pos) /*!< 0x00000080 */
#define TIM_SR_BIF TIM_SR_BIF_Msk /*!<Break interrupt Flag */
#define TIM_SR_CC1OF_Pos (9U)
#define TIM_SR_CC1OF_Msk (0x1U << TIM_SR_CC1OF_Pos) /*!< 0x00000200 */
#define TIM_SR_CC1OF TIM_SR_CC1OF_Msk /*!<Capture/Compare 1 Overcapture Flag */
#define TIM_SR_CC2OF_Pos (10U)
#define TIM_SR_CC2OF_Msk (0x1U << TIM_SR_CC2OF_Pos) /*!< 0x00000400 */
#define TIM_SR_CC2OF TIM_SR_CC2OF_Msk /*!<Capture/Compare 2 Overcapture Flag */
#define TIM_SR_CC3OF_Pos (11U)
#define TIM_SR_CC3OF_Msk (0x1U << TIM_SR_CC3OF_Pos) /*!< 0x00000800 */
#define TIM_SR_CC3OF TIM_SR_CC3OF_Msk /*!<Capture/Compare 3 Overcapture Flag */
#define TIM_SR_CC4OF_Pos (12U)
#define TIM_SR_CC4OF_Msk (0x1U << TIM_SR_CC4OF_Pos) /*!< 0x00001000 */
#define TIM_SR_CC4OF TIM_SR_CC4OF_Msk /*!<Capture/Compare 4 Overcapture Flag */

/*******************  Bit definition for TIM_EGR register  *******************/
#define TIM_EGR_UG_Pos (0U)
#define TIM_EGR_UG_Msk (0x1U << TIM_EGR_UG_Pos) /*!< 0x00000001 */
#define TIM_EGR_UG TIM_EGR_UG_Msk /*!<Update Generation */
#define TIM_EGR_CC1G_Pos (1U)
#define TIM_EGR_CC1G_Msk (0x1U << TIM_EGR_CC1G_Pos) /*!< 0x00000002 */
#define TIM_EGR_CC1G TIM_EGR_CC1G_Msk /*!<Capture/Compare 1 Generation */
#define TIM_EGR_CC2G_Pos (2U)
#define TIM_EGR_CC2G_Msk (0x1U << TIM_EGR_CC2G_Pos) /*!< 0x00000004 */
#define TIM_EGR_CC2G TIM_EGR_CC2G_Msk /*!<Capture/Compare 2 Generation */
#define TIM_EGR_CC3G_Pos (3U)
#define TIM_EGR_CC3G_Msk (0x1U << TIM_EGR_CC3G_Pos) /*!< 0x00000008 */
#define TIM_EGR_CC3G TIM_EGR_CC3G_Msk /*!<Capture/Compare 3 Generation */
#define TIM_EGR_CC4G_Pos (4U)
#define TIM_EGR_CC4G_Msk (0x1U << TIM_EGR_CC4G_Pos) /*!< 0x00000010 */
#define TIM_EGR_CC4G TIM_EGR_CC4G_Msk /*!<Capture/Compare 4 Generation */
#define TIM_EGR_COMG_Pos (5U)
#define TIM_EGR_COMG_Msk (0x1U << TIM_EGR_COMG_Pos) /*!< 0x00000020 */
#define TIM_EGR_COMG TIM_EGR_COMG_Msk /*!<Capture/Compare Control Update Generation */
#define TIM_EGR_TG_Pos (6U)
#define TIM_EGR_TG_Msk (0x1U << TIM_EGR_TG_Pos) /*!< 0x00000040 */
#define TIM_EGR_TG TIM_EGR_TG_Msk /*!<Trigger Generation */
#define TIM_EGR_BG_Pos (7U)
#define TIM_EGR_BG_Msk (0x1U << TIM_EGR_BG_Pos) /*!< 0x00000080 */
#define TIM_EGR_BG TIM_EGR_BG_Msk /*!<Break Generation */

/******************  Bit definition for TIM_CCMR1 register  ******************/
#define TIM_CCMR1_CC1S_Pos (0U)
#define TIM_CCMR1_CC1S_Msk (0x3U << TIM_CCMR1_CC1S_Pos) /*!< 0x00000003 */
#define TIM_CCMR1_CC1S TIM_CCMR1_CC1S_Msk /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
#define TIM_CCMR1_CC1S_0 (0x1U << TIM_CCMR1_CC1S_Pos) /*!< 0x00000001 */
#define TIM_CCMR1_CC1S_1 (0x2U << TIM_CCMR1_CC1S_Pos) /*!< 0x00000002 */

#define TIM_CCMR1_OC1FE_Pos (2U)
#define TIM_CCMR1_OC1FE_Msk (0x1U << TIM_CCMR1_OC1FE_Pos) /*!< 0x00000004 */
#define TIM_CCMR1_OC1FE TIM_CCMR1_OC1FE_Msk /*!<Output Compare 1 Fast enable */
#define TIM_CCMR1_OC1PE_Pos (3U)
#define TIM_CCMR1_OC1PE_Msk (0x1U << TIM_CCMR1_OC1PE_Pos) /*!< 0x00000008 */
#define TIM_CCMR1_OC1PE TIM_CCMR1_OC1PE_Msk /*!<Output Compare 1 Preload enable */

#define TIM_CCMR1_OC1M_Pos (4U)
#define TIM_CCMR1_OC1M_Msk (0x7U << TIM_CCMR1_OC1M_Pos) /*!< 0x00000070 */
#define TIM_CCMR1_OC1M TIM_CCMR1_OC1M_Msk /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
#define TIM_CCMR1_OC1M_0 (0x1U << TIM_CCMR1_OC1M_Pos) /*!< 0x00000010 */
#define TIM_CCMR1_OC1M_1 (0x2U << TIM_CCMR1_OC1M_Pos) /*!< 0x00000020 */
#define TIM_CCMR1_OC1M_2 (0x4U << TIM_CCMR1_OC1M_Pos) /*!< 0x00000040 */

#define TIM_CCMR1_OC1CE_Pos (7U)
#define TIM_CCMR1_OC1CE_Msk (0x1U << TIM_CCMR1_OC1CE_Pos) /*!< 0x00000080 */
#define TIM_CCMR1_OC1CE TIM_CCMR1_OC1CE_Msk /*!<Output Compare 1Clear Enable */

#define TIM_CCMR1_CC2S_Pos (8U)
#define TIM_CCMR1_CC2S_Msk (0x3U << TIM_CCMR1_CC2S_Pos) /*!< 0x00000300 */
#define TIM_CCMR1_CC2S TIM_CCMR1_CC2S_Msk /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
#define TIM_CCMR1_CC2S_0 (0x1U << TIM_CCMR1_CC2S_Pos) /*!< 0x00000100 */
#define TIM_CCMR1_CC2S_1 (0x2U << TIM_CCMR1_CC2S_Pos) /*!< 0x00000200 */

#define TIM_CCMR1_OC2FE_Pos (10U)
#define TIM_CCMR1_OC2FE_Msk (0x1U << TIM_CCMR1_OC2FE_Pos) /*!< 0x00000400 */
#define TIM_CCMR1_OC2FE TIM_CCMR1_OC2FE_Msk /*!<Output Compare 2 Fast enable */
#define TIM_CCMR1_OC2PE_Pos (11U)
#define TIM_CCMR1_OC2PE_Msk (0x1U << TIM_CCMR1_OC2PE_Pos) /*!< 0x00000800 */
#define TIM_CCMR1_OC2PE TIM_CCMR1_OC2PE_Msk /*!<Output Compare 2 Preload enable */

#define TIM_CCMR1_OC2M_Pos (12U)
#define TIM_CCMR1_OC2M_Msk (0x7U << TIM_CCMR1_OC2M_Pos) /*!< 0x00007000 */
#define TIM_CCMR1_OC2M TIM_CCMR1_OC2M_Msk /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
#define TIM_CCMR1_OC2M_0 (0x1U << TIM_CCMR1_OC2M_Pos) /*!< 0x00001000 */
#define TIM_CCMR1_OC2M_1 (0x2U << TIM_CCMR1_OC2M_Pos) /*!< 0x00002000 */
#define TIM_CCMR1_OC2M_2 (0x4U << TIM_CCMR1_OC2M_Pos) /*!< 0x00004000 */

#define TIM_CCMR1_OC2CE_Pos (15U)
#define TIM_CCMR1_OC2CE_Msk (0x1U << TIM_CCMR1_OC2CE_Pos) /*!< 0x00008000 */
#define TIM_CCMR1_OC2CE TIM_CCMR1_OC2CE_Msk /*!<Output Compare 2 Clear Enable */

/*---------------------------------------------------------------------------*/

#define TIM_CCMR1_IC1PSC_Pos (2U)
#define TIM_CCMR1_IC1PSC_Msk (0x3U << TIM_CCMR1_IC1PSC_Pos) /*!< 0x0000000C */
#define TIM_CCMR1_IC1PSC TIM_CCMR1_IC1PSC_Msk /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
#define TIM_CCMR1_IC1PSC_0 (0x1U << TIM_CCMR1_IC1PSC_Pos) /*!< 0x00000004 */
#define TIM_CCMR1_IC1PSC_1 (0x2U << TIM_CCMR1_IC1PSC_Pos) /*!< 0x00000008 */

#define TIM_CCMR1_IC1F_Pos (4U)
#define TIM_CCMR1_IC1F_Msk (0xFU << TIM_CCMR1_IC1F_Pos) /*!< 0x000000F0 */
#define TIM_CCMR1_IC1F TIM_CCMR1_IC1F_Msk /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
#define TIM_CCMR1_IC1F_0 (0x1U << TIM_CCMR1_IC1F_Pos) /*!< 0x00000010 */
#define TIM_CCMR1_IC1F_1 (0x2U << TIM_CCMR1_IC1F_Pos) /*!< 0x00000020 */
#define TIM_CCMR1_IC1F_2 (0x4U << TIM_CCMR1_IC1F_Pos) /*!< 0x00000040 */
#define TIM_CCMR1_IC1F_3 (0x8U << TIM_CCMR1_IC1F_Pos) /*!< 0x00000080 */

#define TIM_CCMR1_IC2PSC_Pos (10U)
#define TIM_CCMR1_IC2PSC_Msk (0x3U << TIM_CCMR1_IC2PSC_Pos) /*!< 0x00000C00 */
#define TIM_CCMR1_IC2PSC TIM_CCMR1_IC2PSC_Msk /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
#define TIM_CCMR1_IC2PSC_0 (0x1U << TIM_CCMR1_IC2PSC_Pos) /*!< 0x00000400 */
#define TIM_CCMR1_IC2PSC_1 (0x2U << TIM_CCMR1_IC2PSC_Pos) /*!< 0x00000800 */

#define TIM_CCMR1_IC2F_Pos (12U)
#define TIM_CCMR1_IC2F_Msk (0xFU << TIM_CCMR1_IC2F_Pos) /*!< 0x0000F000 */
#define TIM_CCMR1_IC2F TIM_CCMR1_IC2F_Msk /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
#define TIM_CCMR1_IC2F_0 (0x1U << TIM_CCMR1_IC2F_Pos) /*!< 0x00001000 */
#define TIM_CCMR1_IC2F_1 (0x2U << TIM_CCMR1_IC2F_Pos) /*!< 0x00002000 */
#define TIM_CCMR1_IC2F_2 (0x4U << TIM_CCMR1_IC2F_Pos) /*!< 0x00004000 */
#define TIM_CCMR1_IC2F_3 (0x8U << TIM_CCMR1_IC2F_Pos) /*!< 0x00008000 */

/******************  Bit definition for TIM_CCMR2 register  ******************/
#define TIM_CCMR2_CC3S_Pos (0U)
#define TIM_CCMR2_CC3S_Msk (0x3U << TIM_CCMR2_CC3S_Pos) /*!< 0x00000003 */
#define TIM_CCMR2_CC3S TIM_CCMR2_CC3S_Msk /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
#define TIM_CCMR2_CC3S_0 (0x1U << TIM_CCMR2_CC3S_Pos) /*!< 0x00000001 */
#define TIM_CCMR2_CC3S_1 (0x2U << TIM_CCMR2_CC3S_Pos) /*!< 0x00000002 */

#define TIM_CCMR2_OC3FE_Pos (2U)
#define TIM_CCMR2_OC3FE_Msk (0x1U << TIM_CCMR2_OC3FE_Pos) /*!< 0x00000004 */
#define TIM_CCMR2_OC3FE TIM_CCMR2_OC3FE_Msk /*!<Output Compare 3 Fast enable */
#define TIM_CCMR2_OC3PE_Pos (3U)
#define TIM_CCMR2_OC3PE_Msk (0x1U << TIM_CCMR2_OC3PE_Pos) /*!< 0x00000008 */
#define TIM_CCMR2_OC3PE TIM_CCMR2_OC3PE_Msk /*!<Output Compare 3 Preload enable */

#define TIM_CCMR2_OC3M_Pos (4U)
#define TIM_CCMR2_OC3M_Msk (0x7U << TIM_CCMR2_OC3M_Pos) /*!< 0x00000070 */
#define TIM_CCMR2_OC3M TIM_CCMR2_OC3M_Msk /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
#define TIM_CCMR2_OC3M_0 (0x1U << TIM_CCMR2_OC3M_Pos) /*!< 0x00000010 */
#define TIM_CCMR2_OC3M_1 (0x2U << TIM_CCMR2_OC3M_Pos) /*!< 0x00000020 */
#define TIM_CCMR2_OC3M_2 (0x4U << TIM_CCMR2_OC3M_Pos) /*!< 0x00000040 */

#define TIM_CCMR2_OC3CE_Pos (7U)
#define TIM_CCMR2_OC3CE_Msk (0x1U << TIM_CCMR2_OC3CE_Pos) /*!< 0x00000080 */
#define TIM_CCMR2_OC3CE TIM_CCMR2_OC3CE_Msk /*!<Output Compare 3 Clear Enable */

#define TIM_CCMR2_CC4S_Pos (8U)
#define TIM_CCMR2_CC4S_Msk (0x3U << TIM_CCMR2_CC4S_Pos) /*!< 0x00000300 */
#define TIM_CCMR2_CC4S TIM_CCMR2_CC4S_Msk /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
#define TIM_CCMR2_CC4S_0 (0x1U << TIM_CCMR2_CC4S_Pos) /*!< 0x00000100 */
#define TIM_CCMR2_CC4S_1 (0x2U << TIM_CCMR2_CC4S_Pos) /*!< 0x00000200 */

#define TIM_CCMR2_OC4FE_Pos (10U)
#define TIM_CCMR2_OC4FE_Msk (0x1U << TIM_CCMR2_OC4FE_Pos) /*!< 0x00000400 */
#define TIM_CCMR2_OC4FE TIM_CCMR2_OC4FE_Msk /*!<Output Compare 4 Fast enable */
#define TIM_CCMR2_OC4PE_Pos (11U)
#define TIM_CCMR2_OC4PE_Msk (0x1U << TIM_CCMR2_OC4PE_Pos) /*!< 0x00000800 */
#define TIM_CCMR2_OC4PE TIM_CCMR2_OC4PE_Msk /*!<Output Compare 4 Preload enable */

#define TIM_CCMR2_OC4M_Pos (12U)
#define TIM_CCMR2_OC4M_Msk (0x7U << TIM_CCMR2_OC4M_Pos) /*!< 0x00007000 */
#define TIM_CCMR2_OC4M TIM_CCMR2_OC4M_Msk /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
#define TIM_CCMR2_OC4M_0 (0x1U << TIM_CCMR2_OC4M_Pos) /*!< 0x00001000 */
#define TIM_CCMR2_OC4M_1 (0x2U << TIM_CCMR2_OC4M_Pos) /*!< 0x00002000 */
#define TIM_CCMR2_OC4M_2 (0x4U << TIM_CCMR2_OC4M_Pos) /*!< 0x00004000 */

#define TIM_CCMR2_OC4CE_Pos (15U)
#define TIM_CCMR2_OC4CE_Msk (0x1U << TIM_CCMR2_OC4CE_Pos) /*!< 0x00008000 */
#define TIM_CCMR2_OC4CE TIM_CCMR2_OC4CE_Msk /*!<Output Compare 4 Clear Enable */

/*---------------------------------------------------------------------------*/

#define TIM_CCMR2_IC3PSC_Pos (2U)
#define TIM_CCMR2_IC3PSC_Msk (0x3U << TIM_CCMR2_IC3PSC_Pos) /*!< 0x0000000C */
#define TIM_CCMR2_IC3PSC TIM_CCMR2_IC3PSC_Msk /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
#define TIM_CCMR2_IC3PSC_0 (0x1U << TIM_CCMR2_IC3PSC_Pos) /*!< 0x00000004 */
#define TIM_CCMR2_IC3PSC_1 (0x2U << TIM_CCMR2_IC3PSC_Pos) /*!< 0x00000008 */

#define TIM_CCMR2_IC3F_Pos (4U)
#define TIM_CCMR2_IC3F_Msk (0xFU << TIM_CCMR2_IC3F_Pos) /*!< 0x000000F0 */
#define TIM_CCMR2_IC3F TIM_CCMR2_IC3F_Msk /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
#define TIM_CCMR2_IC3F_0 (0x1U << TIM_CCMR2_IC3F_Pos) /*!< 0x00000010 */
#define TIM_CCMR2_IC3F_1 (0x2U << TIM_CCMR2_IC3F_Pos) /*!< 0x00000020 */
#define TIM_CCMR2_IC3F_2 (0x4U << TIM_CCMR2_IC3F_Pos) /*!< 0x00000040 */
#define TIM_CCMR2_IC3F_3 (0x8U << TIM_CCMR2_IC3F_Pos) /*!< 0x00000080 */

#define TIM_CCMR2_IC4PSC_Pos (10U)
#define TIM_CCMR2_IC4PSC_Msk (0x3U << TIM_CCMR2_IC4PSC_Pos) /*!< 0x00000C00 */
#define TIM_CCMR2_IC4PSC TIM_CCMR2_IC4PSC_Msk /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
#define TIM_CCMR2_IC4PSC_0 (0x1U << TIM_CCMR2_IC4PSC_Pos) /*!< 0x00000400 */
#define TIM_CCMR2_IC4PSC_1 (0x2U << TIM_CCMR2_IC4PSC_Pos) /*!< 0x00000800 */

#define TIM_CCMR2_IC4F_Pos (12U)
#define TIM_CCMR2_IC4F_Msk (0xFU << TIM_CCMR2_IC4F_Pos) /*!< 0x0000F000 */
#define TIM_CCMR2_IC4F TIM_CCMR2_IC4F_Msk /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
#define TIM_CCMR2_IC4F_0 (0x1U << TIM_CCMR2_IC4F_Pos) /*!< 0x00001000 */
#define TIM_CCMR2_IC4F_1 (0x2U << TIM_CCMR2_IC4F_Pos) /*!< 0x00002000 */
#define TIM_CCMR2_IC4F_2 (0x4U << TIM_CCMR2_IC4F_Pos) /*!< 0x00004000 */
#define TIM_CCMR2_IC4F_3 (0x8U << TIM_CCMR2_IC4F_Pos) /*!< 0x00008000 */

/*******************  Bit definition for TIM_CCER register  ******************/
#define TIM_CCER_CC1E_Pos (0U)
#define TIM_CCER_CC1E_Msk (0x1U << TIM_CCER_CC1E_Pos) /*!< 0x00000001 */
#define TIM_CCER_CC1E TIM_CCER_CC1E_Msk /*!<Capture/Compare 1 output enable */
#define TIM_CCER_CC1P_Pos (1U)
#define TIM_CCER_CC1P_Msk (0x1U << TIM_CCER_CC1P_Pos) /*!< 0x00000002 */
#define TIM_CCER_CC1P TIM_CCER_CC1P_Msk /*!<Capture/Compare 1 output Polarity */
#define TIM_CCER_CC1NE_Pos (2U)
#define TIM_CCER_CC1NE_Msk (0x1U << TIM_CCER_CC1NE_Pos) /*!< 0x00000004 */
#define TIM_CCER_CC1NE TIM_CCER_CC1NE_Msk /*!<Capture/Compare 1 Complementary output enable */
#define TIM_CCER_CC1NP_Pos (3U)
#define TIM_CCER_CC1NP_Msk (0x1U << TIM_CCER_CC1NP_Pos) /*!< 0x00000008 */
#define TIM_CCER_CC1NP TIM_CCER_CC1NP_Msk /*!<Capture/Compare 1 Complementary output Polarity */
#define TIM_CCER_CC2E_Pos (4U)
#define TIM_CCER_CC2E_Msk (0x1U << TIM_CCER_CC2E_Pos) /*!< 0x00000010 */
#define TIM_CCER_CC2E TIM_CCER_CC2E_Msk /*!<Capture/Compare 2 output enable */
#define TIM_CCER_CC2P_Pos (5U)
#define TIM_CCER_CC2P_Msk (0x1U << TIM_CCER_CC2P_Pos) /*!< 0x00000020 */
#define TIM_CCER_CC2P TIM_CCER_CC2P_Msk /*!<Capture/Compare 2 output Polarity */
#define TIM_CCER_CC2NE_Pos (6U)
#define TIM_CCER_CC2NE_Msk (0x1U << TIM_CCER_CC2NE_Pos) /*!< 0x00000040 */
#define TIM_CCER_CC2NE TIM_CCER_CC2NE_Msk /*!<Capture/Compare 2 Complementary output enable */
#define TIM_CCER_CC2NP_Pos (7U)
#define TIM_CCER_CC2NP_Msk (0x1U << TIM_CCER_CC2NP_Pos) /*!< 0x00000080 */
#define TIM_CCER_CC2NP TIM_CCER_CC2NP_Msk /*!<Capture/Compare 2 Complementary output Polarity */
#define TIM_CCER_CC3E_Pos (8U)
#define TIM_CCER_CC3E_Msk (0x1U << TIM_CCER_CC3E_Pos) /*!< 0x00000100 */
#define TIM_CCER_CC3E TIM_CCER_CC3E_Msk /*!<Capture/Compare 3 output enable */
#define TIM_CCER_CC3P_Pos (9U)
#define TIM_CCER_CC3P_Msk (0x1U << TIM_CCER_CC3P_Pos) /*!< 0x00000200 */
#define TIM_CCER_CC3P TIM_CCER_CC3P_Msk /*!<Capture/Compare 3 output Polarity */
#define TIM_CCER_CC3NE_Pos (10U)
#define TIM_CCER_CC3NE_Msk (0x1U << TIM_CCER_CC3NE_Pos) /*!< 0x00000400 */
#define TIM_CCER_CC3NE TIM_CCER_CC3NE_Msk /*!<Capture/Compare 3 Complementary output enable */
#define TIM_CCER_CC3NP_Pos (11U)
#define TIM_CCER_CC3NP_Msk (0x1U << TIM_CCER_CC3NP_Pos) /*!< 0x00000800 */
#define TIM_CCER_CC3NP TIM_CCER_CC3NP_Msk /*!<Capture/Compare 3 Complementary output Polarity */
#define TIM_CCER_CC4E_Pos (12U)
#define TIM_CCER_CC4E_Msk (0x1U << TIM_CCER_CC4E_Pos) /*!< 0x00001000 */
#define TIM_CCER_CC4E TIM_CCER_CC4E_Msk /*!<Capture/Compare 4 output enable */
#define TIM_CCER_CC4P_Pos (13U)
#define TIM_CCER_CC4P_Msk (0x1U << TIM_CCER_CC4P_Pos) /*!< 0x00002000 */
#define TIM_CCER_CC4P TIM_CCER_CC4P_Msk /*!<Capture/Compare 4 output Polarity */

/*******************  Bit definition for TIM_CNT register  *******************/
#define TIM_CNT_CNT_Pos (0U)
#define TIM_CNT_CNT_Msk (0xFFFFFFFFU << TIM_CNT_CNT_Pos) /*!< 0xFFFFFFFF */
#define TIM_CNT_CNT TIM_CNT_CNT_Msk /*!<Counter Value */

/*******************  Bit definition for TIM_PSC register  *******************/
#define TIM_PSC_PSC_Pos (0U)
#define TIM_PSC_PSC_Msk (0xFFFFU << TIM_PSC_PSC_Pos) /*!< 0x0000FFFF */
#define TIM_PSC_PSC TIM_PSC_PSC_Msk /*!<Prescaler Value */

/*******************  Bit definition for TIM_ARR register  *******************/
#define TIM_ARR_ARR_Pos (0U)
#define TIM_ARR_ARR_Msk (0xFFFFFFFFU << TIM_ARR_ARR_Pos) /*!< 0xFFFFFFFF */
#define TIM_ARR_ARR TIM_ARR_ARR_Msk /*!<actual auto-reload Value */

/*******************  Bit definition for TIM_RCR register  *******************/
#define TIM_RCR_REP_Pos (0U)
#define TIM_RCR_REP_Msk (0xFFU << TIM_RCR_REP_Pos) /*!< 0x000000FF */
#define TIM_RCR_REP TIM_RCR_REP_Msk /*!<Repetition Counter Value */

/*******************  Bit definition for TIM_CCR1 register  ******************/
#define TIM_CCR1_CCR1_Pos (0U)
#define TIM_CCR1_CCR1_Msk (0xFFFFU << TIM_CCR1_CCR1_Pos) /*!< 0x0000FFFF */
#define TIM_CCR1_CCR1 TIM_CCR1_CCR1_Msk /*!<Capture/Compare 1 Value */

/*******************  Bit definition for TIM_CCR2 register  ******************/
#define TIM_CCR2_CCR2_Pos (0U)
#define TIM_CCR2_CCR2_Msk (0xFFFFU << TIM_CCR2_CCR2_Pos) /*!< 0x0000FFFF */
#define TIM_CCR2_CCR2 TIM_CCR2_CCR2_Msk /*!<Capture/Compare 2 Value */

/*******************  Bit definition for TIM_CCR3 register  ******************/
#define TIM_CCR3_CCR3_Pos (0U)
#define TIM_CCR3_CCR3_Msk (0xFFFFU << TIM_CCR3_CCR3_Pos) /*!< 0x0000FFFF */
#define TIM_CCR3_CCR3 TIM_CCR3_CCR3_Msk /*!<Capture/Compare 3 Value */

/*******************  Bit definition for TIM_CCR4 register  ******************/
#define TIM_CCR4_CCR4_Pos (0U)
#define TIM_CCR4_CCR4_Msk (0xFFFFU << TIM_CCR4_CCR4_Pos) /*!< 0x0000FFFF */
#define TIM_CCR4_CCR4 TIM_CCR4_CCR4_Msk /*!<Capture/Compare 4 Value */

/*******************  Bit definition for TIM_BDTR register  ******************/
#define TIM_BDTR_DTG_Pos (0U)
#define TIM_BDTR_DTG_Msk (0xFFU << TIM_BDTR_DTG_Pos) /*!< 0x000000FF */
#define TIM_BDTR_DTG TIM_BDTR_DTG_Msk /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
#define TIM_BDTR_DTG_0 (0x01U << TIM_BDTR_DTG_Pos) /*!< 0x00000001 */
#define TIM_BDTR_DTG_1 (0x02U << TIM_BDTR_DTG_Pos) /*!< 0x00000002 */
#define TIM_BDTR_DTG_2 (0x04U << TIM_BDTR_DTG_Pos) /*!< 0x00000004 */
#define TIM_BDTR_DTG_3 (0x08U << TIM_BDTR_DTG_Pos) /*!< 0x00000008 */
#define TIM_BDTR_DTG_4 (0x10U << TIM_BDTR_DTG_Pos) /*!< 0x00000010 */
#define TIM_BDTR_DTG_5 (0x20U << TIM_BDTR_DTG_Pos) /*!< 0x00000020 */
#define TIM_BDTR_DTG_6 (0x40U << TIM_BDTR_DTG_Pos) /*!< 0x00000040 */
#define TIM_BDTR_DTG_7 (0x80U << TIM_BDTR_DTG_Pos) /*!< 0x00000080 */

#define TIM_BDTR_LOCK_Pos (8U)
#define TIM_BDTR_LOCK_Msk (0x3U << TIM_BDTR_LOCK_Pos) /*!< 0x00000300 */
#define TIM_BDTR_LOCK TIM_BDTR_LOCK_Msk /*!<LOCK[1:0] bits (Lock Configuration) */
#define TIM_BDTR_LOCK_0 (0x1U << TIM_BDTR_LOCK_Pos) /*!< 0x00000100 */
#define TIM_BDTR_LOCK_1 (0x2U << TIM_BDTR_LOCK_Pos) /*!< 0x00000200 */

#define TIM_BDTR_OSSI_Pos (10U)
#define TIM_BDTR_OSSI_Msk (0x1U << TIM_BDTR_OSSI_Pos) /*!< 0x00000400 */
#define TIM_BDTR_OSSI TIM_BDTR_OSSI_Msk /*!<Off-State Selection for Idle mode */
#define TIM_BDTR_OSSR_Pos (11U)
#define TIM_BDTR_OSSR_Msk (0x1U << TIM_BDTR_OSSR_Pos) /*!< 0x00000800 */
#define TIM_BDTR_OSSR TIM_BDTR_OSSR_Msk /*!<Off-State Selection for Run mode */
#define TIM_BDTR_BKE_Pos (12U)
#define TIM_BDTR_BKE_Msk (0x1U << TIM_BDTR_BKE_Pos) /*!< 0x00001000 */
#define TIM_BDTR_BKE TIM_BDTR_BKE_Msk /*!<Break enable */
#define TIM_BDTR_BKP_Pos (13U)
#define TIM_BDTR_BKP_Msk (0x1U << TIM_BDTR_BKP_Pos) /*!< 0x00002000 */
#define TIM_BDTR_BKP TIM_BDTR_BKP_Msk /*!<Break Polarity */
#define TIM_BDTR_AOE_Pos (14U)
#define TIM_BDTR_AOE_Msk (0x1U << TIM_BDTR_AOE_Pos) /*!< 0x00004000 */
#define TIM_BDTR_AOE TIM_BDTR_AOE_Msk /*!<Automatic Output enable */
#define TIM_BDTR_MOE_Pos (15U)
#define TIM_BDTR_MOE_Msk (0x1U << TIM_BDTR_MOE_Pos) /*!< 0x00008000 */
#define TIM_BDTR_MOE TIM_BDTR_MOE_Msk /*!<Main Output enable */

/*******************  Bit definition for TIM_DCR register  *******************/
#define TIM_DCR_DBA_Pos (0U)
#define TIM_DCR_DBA_Msk (0x1FU << TIM_DCR_DBA_Pos) /*!< 0x0000001F */
#define TIM_DCR_DBA TIM_DCR_DBA_Msk /*!<DBA[4:0] bits (DMA Base Address) */
#define TIM_DCR_DBA_0 (0x01U << TIM_DCR_DBA_Pos) /*!< 0x00000001 */
#define TIM_DCR_DBA_1 (0x02U << TIM_DCR_DBA_Pos) /*!< 0x00000002 */
#define TIM_DCR_DBA_2 (0x04U << TIM_DCR_DBA_Pos) /*!< 0x00000004 */
#define TIM_DCR_DBA_3 (0x08U << TIM_DCR_DBA_Pos) /*!< 0x00000008 */
#define TIM_DCR_DBA_4 (0x10U << TIM_DCR_DBA_Pos) /*!< 0x00000010 */

#define TIM_DCR_DBL_Pos (8U)
#define TIM_DCR_DBL_Msk (0x1FU << TIM_DCR_DBL_Pos) /*!< 0x00001F00 */
#define TIM_DCR_DBL TIM_DCR_DBL_Msk /*!<DBL[4:0] bits (DMA Burst Length) */
#define TIM_DCR_DBL_0 (0x01U << TIM_DCR_DBL_Pos) /*!< 0x00000100 */
#define TIM_DCR_DBL_1 (0x02U << TIM_DCR_DBL_Pos) /*!< 0x00000200 */
#define TIM_DCR_DBL_2 (0x04U << TIM_DCR_DBL_Pos) /*!< 0x00000400 */
#define TIM_DCR_DBL_3 (0x08U << TIM_DCR_DBL_Pos) /*!< 0x00000800 */
#define TIM_DCR_DBL_4 (0x10U << TIM_DCR_DBL_Pos) /*!< 0x00001000 */

/*******************  Bit definition for TIM_DMAR register  ******************/
#define TIM_DMAR_DMAB_Pos (0U)
#define TIM_DMAR_DMAB_Msk (0xFFFFU << TIM_DMAR_DMAB_Pos) /*!< 0x0000FFFF */
#define TIM_DMAR_DMAB TIM_DMAR_DMAB_Msk /*!<DMA register for burst accesses */

/******************************************************************************/
/*                                                                            */
/*                             Real-Time Clock                                */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for RTC_CRH register  ********************/
#define RTC_CRH_SECIE_Pos (0U)
#define RTC_CRH_SECIE_Msk (0x1U << RTC_CRH_SECIE_Pos) /*!< 0x00000001 */
#define RTC_CRH_SECIE RTC_CRH_SECIE_Msk /*!< Second Interrupt Enable */
#define RTC_CRH_ALRIE_Pos (1U)
#define RTC_CRH_ALRIE_Msk (0x1U << RTC_CRH_ALRIE_Pos) /*!< 0x00000002 */
#define RTC_CRH_ALRIE RTC_CRH_ALRIE_Msk /*!< Alarm Interrupt Enable */
#define RTC_CRH_OWIE_Pos (2U)
#define RTC_CRH_OWIE_Msk (0x1U << RTC_CRH_OWIE_Pos) /*!< 0x00000004 */
#define RTC_CRH_OWIE RTC_CRH_OWIE_Msk /*!< OverfloW Interrupt Enable */

/*******************  Bit definition for RTC_CRL register  ********************/
#define RTC_CRL_SECF_Pos (0U)
#define RTC_CRL_SECF_Msk (0x1U << RTC_CRL_SECF_Pos) /*!< 0x00000001 */
#define RTC_CRL_SECF RTC_CRL_SECF_Msk /*!< Second Flag */
#define RTC_CRL_ALRF_Pos (1U)
#define RTC_CRL_ALRF_Msk (0x1U << RTC_CRL_ALRF_Pos) /*!< 0x00000002 */
#define RTC_CRL_ALRF RTC_CRL_ALRF_Msk /*!< Alarm Flag */
#define RTC_CRL_OWF_Pos (2U)
#define RTC_CRL_OWF_Msk (0x1U << RTC_CRL_OWF_Pos) /*!< 0x00000004 */
#define RTC_CRL_OWF RTC_CRL_OWF_Msk /*!< OverfloW Flag */
#define RTC_CRL_RSF_Pos (3U)
#define RTC_CRL_RSF_Msk (0x1U << RTC_CRL_RSF_Pos) /*!< 0x00000008 */
#define RTC_CRL_RSF RTC_CRL_RSF_Msk /*!< Registers Synchronized Flag */
#define RTC_CRL_CNF_Pos (4U)
#define RTC_CRL_CNF_Msk (0x1U << RTC_CRL_CNF_Pos) /*!< 0x00000010 */
#define RTC_CRL_CNF RTC_CRL_CNF_Msk /*!< Configuration Flag */
#define RTC_CRL_RTOFF_Pos (5U)
#define RTC_CRL_RTOFF_Msk (0x1U << RTC_CRL_RTOFF_Pos) /*!< 0x00000020 */
#define RTC_CRL_RTOFF RTC_CRL_RTOFF_Msk /*!< RTC operation OFF */

/*******************  Bit definition for RTC_PRLH register  *******************/
#define RTC_PRLH_PRL_Pos (0U)
#define RTC_PRLH_PRL_Msk (0xFU << RTC_PRLH_PRL_Pos) /*!< 0x0000000F */
#define RTC_PRLH_PRL RTC_PRLH_PRL_Msk /*!< RTC Prescaler Reload Value High */

/*******************  Bit definition for RTC_PRLL register  *******************/
#define RTC_PRLL_PRL_Pos (0U)
#define RTC_PRLL_PRL_Msk (0xFFFFU << RTC_PRLL_PRL_Pos) /*!< 0x0000FFFF */
#define RTC_PRLL_PRL RTC_PRLL_PRL_Msk /*!< RTC Prescaler Reload Value Low */

/*******************  Bit definition for RTC_DIVH register  *******************/
#define RTC_DIVH_RTC_DIV_Pos (0U)
#define RTC_DIVH_RTC_DIV_Msk (0xFU << RTC_DIVH_RTC_DIV_Pos) /*!< 0x0000000F */
#define RTC_DIVH_RTC_DIV RTC_DIVH_RTC_DIV_Msk /*!< RTC Clock Divider High */

/*******************  Bit definition for RTC_DIVL register  *******************/
#define RTC_DIVL_RTC_DIV_Pos (0U)
#define RTC_DIVL_RTC_DIV_Msk (0xFFFFU << RTC_DIVL_RTC_DIV_Pos) /*!< 0x0000FFFF */
#define RTC_DIVL_RTC_DIV RTC_DIVL_RTC_DIV_Msk /*!< RTC Clock Divider Low */

/*******************  Bit definition for RTC_CNTH register  *******************/
#define RTC_CNTH_RTC_CNT_Pos (0U)
#define RTC_CNTH_RTC_CNT_Msk (0xFFFFU << RTC_CNTH_RTC_CNT_Pos) /*!< 0x0000FFFF */
#define RTC_CNTH_RTC_CNT RTC_CNTH_RTC_CNT_Msk /*!< RTC Counter High */

/*******************  Bit definition for RTC_CNTL register  *******************/
#define RTC_CNTL_RTC_CNT_Pos (0U)
#define RTC_CNTL_RTC_CNT_Msk (0xFFFFU << RTC_CNTL_RTC_CNT_Pos) /*!< 0x0000FFFF */
#define RTC_CNTL_RTC_CNT RTC_CNTL_RTC_CNT_Msk /*!< RTC Counter Low */

/*******************  Bit definition for RTC_ALRH register  *******************/
#define RTC_ALRH_RTC_ALR_Pos (0U)
#define RTC_ALRH_RTC_ALR_Msk (0xFFFFU << RTC_ALRH_RTC_ALR_Pos) /*!< 0x0000FFFF */
#define RTC_ALRH_RTC_ALR RTC_ALRH_RTC_ALR_Msk /*!< RTC Alarm High */

/*******************  Bit definition for RTC_ALRL register  *******************/
#define RTC_ALRL_RTC_ALR_Pos (0U)
#define RTC_ALRL_RTC_ALR_Msk (0xFFFFU << RTC_ALRL_RTC_ALR_Pos) /*!< 0x0000FFFF */
#define RTC_ALRL_RTC_ALR RTC_ALRL_RTC_ALR_Msk /*!< RTC Alarm Low */

/******************************************************************************/
/*                                                                            */
/*                        Independent WATCHDOG (IWDG)                         */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for IWDG_KR register  ********************/
#define IWDG_KR_KEY_Pos (0U)
#define IWDG_KR_KEY_Msk (0xFFFFU << IWDG_KR_KEY_Pos) /*!< 0x0000FFFF */
#define IWDG_KR_KEY IWDG_KR_KEY_Msk /*!< Key value (write only, read 0000h) */

/*******************  Bit definition for IWDG_PR register  ********************/
#define IWDG_PR_PR_Pos (0U)
#define IWDG_PR_PR_Msk (0x7U << IWDG_PR_PR_Pos) /*!< 0x00000007 */
#define IWDG_PR_PR IWDG_PR_PR_Msk /*!< PR[2:0] (Prescaler divider) */
#define IWDG_PR_PR_0 (0x1U << IWDG_PR_PR_Pos) /*!< 0x00000001 */
#define IWDG_PR_PR_1 (0x2U << IWDG_PR_PR_Pos) /*!< 0x00000002 */
#define IWDG_PR_PR_2 (0x4U << IWDG_PR_PR_Pos) /*!< 0x00000004 */

/*******************  Bit definition for IWDG_RLR register  *******************/
#define IWDG_RLR_RL_Pos (0U)
#define IWDG_RLR_RL_Msk (0xFFFU << IWDG_RLR_RL_Pos) /*!< 0x00000FFF */
#define IWDG_RLR_RL IWDG_RLR_RL_Msk /*!< Watchdog counter reload value */

/*******************  Bit definition for IWDG_SR register  ********************/
#define IWDG_SR_PVU_Pos (0U)
#define IWDG_SR_PVU_Msk (0x1U << IWDG_SR_PVU_Pos) /*!< 0x00000001 */
#define IWDG_SR_PVU IWDG_SR_PVU_Msk /*!< Watchdog prescaler value update */
#define IWDG_SR_RVU_Pos (1U)
#define IWDG_SR_RVU_Msk (0x1U << IWDG_SR_RVU_Pos) /*!< 0x00000002 */
#define IWDG_SR_RVU IWDG_SR_RVU_Msk /*!< Watchdog counter reload value update */

/******************************************************************************/
/*                                                                            */
/*                         Window WATCHDOG (WWDG)                             */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for WWDG_CR register  ********************/
#define WWDG_CR_T_Pos (0U)
#define WWDG_CR_T_Msk (0x7FU << WWDG_CR_T_Pos) /*!< 0x0000007F */
#define WWDG_CR_T WWDG_CR_T_Msk /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
#define WWDG_CR_T_0 (0x01U << WWDG_CR_T_Pos) /*!< 0x00000001 */
#define WWDG_CR_T_1 (0x02U << WWDG_CR_T_Pos) /*!< 0x00000002 */
#define WWDG_CR_T_2 (0x04U << WWDG_CR_T_Pos) /*!< 0x00000004 */
#define WWDG_CR_T_3 (0x08U << WWDG_CR_T_Pos) /*!< 0x00000008 */
#define WWDG_CR_T_4 (0x10U << WWDG_CR_T_Pos) /*!< 0x00000010 */
#define WWDG_CR_T_5 (0x20U << WWDG_CR_T_Pos) /*!< 0x00000020 */
#define WWDG_CR_T_6 (0x40U << WWDG_CR_T_Pos) /*!< 0x00000040 */

/* Legacy defines */
#define WWDG_CR_T0 WWDG_CR_T_0
#define WWDG_CR_T1 WWDG_CR_T_1
#define WWDG_CR_T2 WWDG_CR_T_2
#define WWDG_CR_T3 WWDG_CR_T_3
#define WWDG_CR_T4 WWDG_CR_T_4
#define WWDG_CR_T5 WWDG_CR_T_5
#define WWDG_CR_T6 WWDG_CR_T_6

#define WWDG_CR_WDGA_Pos (7U)
#define WWDG_CR_WDGA_Msk (0x1U << WWDG_CR_WDGA_Pos) /*!< 0x00000080 */
#define WWDG_CR_WDGA WWDG_CR_WDGA_Msk /*!< Activation bit */

/*******************  Bit definition for WWDG_CFR register  *******************/
#define WWDG_CFR_W_Pos (0U)
#define WWDG_CFR_W_Msk (0x7FU << WWDG_CFR_W_Pos) /*!< 0x0000007F */
#define WWDG_CFR_W WWDG_CFR_W_Msk /*!< W[6:0] bits (7-bit window value) */
#define WWDG_CFR_W_0 (0x01U << WWDG_CFR_W_Pos) /*!< 0x00000001 */
#define WWDG_CFR_W_1 (0x02U << WWDG_CFR_W_Pos) /*!< 0x00000002 */
#define WWDG_CFR_W_2 (0x04U << WWDG_CFR_W_Pos) /*!< 0x00000004 */
#define WWDG_CFR_W_3 (0x08U << WWDG_CFR_W_Pos) /*!< 0x00000008 */
#define WWDG_CFR_W_4 (0x10U << WWDG_CFR_W_Pos) /*!< 0x00000010 */
#define WWDG_CFR_W_5 (0x20U << WWDG_CFR_W_Pos) /*!< 0x00000020 */
#define WWDG_CFR_W_6 (0x40U << WWDG_CFR_W_Pos) /*!< 0x00000040 */

/* Legacy defines */
#define WWDG_CFR_W0 WWDG_CFR_W_0
#define WWDG_CFR_W1 WWDG_CFR_W_1
#define WWDG_CFR_W2 WWDG_CFR_W_2
#define WWDG_CFR_W3 WWDG_CFR_W_3
#define WWDG_CFR_W4 WWDG_CFR_W_4
#define WWDG_CFR_W5 WWDG_CFR_W_5
#define WWDG_CFR_W6 WWDG_CFR_W_6

#define WWDG_CFR_WDGTB_Pos (7U)
#define WWDG_CFR_WDGTB_Msk (0x3U << WWDG_CFR_WDGTB_Pos) /*!< 0x00000180 */
#define WWDG_CFR_WDGTB WWDG_CFR_WDGTB_Msk /*!< WDGTB[1:0] bits (Timer Base) */
#define WWDG_CFR_WDGTB_0 (0x1U << WWDG_CFR_WDGTB_Pos) /*!< 0x00000080 */
#define WWDG_CFR_WDGTB_1 (0x2U << WWDG_CFR_WDGTB_Pos) /*!< 0x00000100 */

/* Legacy defines */
#define WWDG_CFR_WDGTB0 WWDG_CFR_WDGTB_0
#define WWDG_CFR_WDGTB1 WWDG_CFR_WDGTB_1

#define WWDG_CFR_EWI_Pos (9U)
#define WWDG_CFR_EWI_Msk (0x1U << WWDG_CFR_EWI_Pos) /*!< 0x00000200 */
#define WWDG_CFR_EWI WWDG_CFR_EWI_Msk /*!< Early Wakeup Interrupt */

/*******************  Bit definition for WWDG_SR register  ********************/
#define WWDG_SR_EWIF_Pos (0U)
#define WWDG_SR_EWIF_Msk (0x1U << WWDG_SR_EWIF_Pos) /*!< 0x00000001 */
#define WWDG_SR_EWIF WWDG_SR_EWIF_Msk /*!< Early Wakeup Interrupt Flag */


/******************************************************************************/
/*                                                                            */
/*                          SD host Interface                                 */
/*                                                                            */
/******************************************************************************/

/******************  Bit definition for SDIO_POWER register  ******************/
#define SDIO_POWER_PWRCTRL_Pos (0U)
#define SDIO_POWER_PWRCTRL_Msk (0x3U << SDIO_POWER_PWRCTRL_Pos) /*!< 0x00000003 */
#define SDIO_POWER_PWRCTRL SDIO_POWER_PWRCTRL_Msk /*!< PWRCTRL[1:0] bits (Power supply control bits) */
#define SDIO_POWER_PWRCTRL_0 (0x1U << SDIO_POWER_PWRCTRL_Pos) /*!< 0x01 */
#define SDIO_POWER_PWRCTRL_1 (0x2U << SDIO_POWER_PWRCTRL_Pos) /*!< 0x02 */

/******************  Bit definition for SDIO_CLKCR register  ******************/
#define SDIO_CLKCR_CLKDIV_Pos (0U)
#define SDIO_CLKCR_CLKDIV_Msk (0xFFU << SDIO_CLKCR_CLKDIV_Pos) /*!< 0x000000FF */
#define SDIO_CLKCR_CLKDIV SDIO_CLKCR_CLKDIV_Msk /*!< Clock divide factor */
#define SDIO_CLKCR_CLKEN_Pos (8U)
#define SDIO_CLKCR_CLKEN_Msk (0x1U << SDIO_CLKCR_CLKEN_Pos) /*!< 0x00000100 */
#define SDIO_CLKCR_CLKEN SDIO_CLKCR_CLKEN_Msk /*!< Clock enable bit */
#define SDIO_CLKCR_PWRSAV_Pos (9U)
#define SDIO_CLKCR_PWRSAV_Msk (0x1U << SDIO_CLKCR_PWRSAV_Pos) /*!< 0x00000200 */
#define SDIO_CLKCR_PWRSAV SDIO_CLKCR_PWRSAV_Msk /*!< Power saving configuration bit */
#define SDIO_CLKCR_BYPASS_Pos (10U)
#define SDIO_CLKCR_BYPASS_Msk (0x1U << SDIO_CLKCR_BYPASS_Pos) /*!< 0x00000400 */
#define SDIO_CLKCR_BYPASS SDIO_CLKCR_BYPASS_Msk /*!< Clock divider bypass enable bit */

#define SDIO_CLKCR_WIDBUS_Pos (11U)
#define SDIO_CLKCR_WIDBUS_Msk (0x3U << SDIO_CLKCR_WIDBUS_Pos) /*!< 0x00001800 */
#define SDIO_CLKCR_WIDBUS SDIO_CLKCR_WIDBUS_Msk /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */
#define SDIO_CLKCR_WIDBUS_0 (0x1U << SDIO_CLKCR_WIDBUS_Pos) /*!< 0x0800 */
#define SDIO_CLKCR_WIDBUS_1 (0x2U << SDIO_CLKCR_WIDBUS_Pos) /*!< 0x1000 */

#define SDIO_CLKCR_NEGEDGE_Pos (13U)
#define SDIO_CLKCR_NEGEDGE_Msk (0x1U << SDIO_CLKCR_NEGEDGE_Pos) /*!< 0x00002000 */
#define SDIO_CLKCR_NEGEDGE SDIO_CLKCR_NEGEDGE_Msk /*!< SDIO_CK dephasing selection bit */
#define SDIO_CLKCR_HWFC_EN_Pos (14U)
#define SDIO_CLKCR_HWFC_EN_Msk (0x1U << SDIO_CLKCR_HWFC_EN_Pos) /*!< 0x00004000 */
#define SDIO_CLKCR_HWFC_EN SDIO_CLKCR_HWFC_EN_Msk /*!< HW Flow Control enable */

/*******************  Bit definition for SDIO_ARG register  *******************/
#define SDIO_ARG_CMDARG_Pos (0U)
#define SDIO_ARG_CMDARG_Msk (0xFFFFFFFFU << SDIO_ARG_CMDARG_Pos) /*!< 0xFFFFFFFF */
#define SDIO_ARG_CMDARG SDIO_ARG_CMDARG_Msk /*!< Command argument */

/*******************  Bit definition for SDIO_CMD register  *******************/
#define SDIO_CMD_CMDINDEX_Pos (0U)
#define SDIO_CMD_CMDINDEX_Msk (0x3FU << SDIO_CMD_CMDINDEX_Pos) /*!< 0x0000003F */
#define SDIO_CMD_CMDINDEX SDIO_CMD_CMDINDEX_Msk /*!< Command Index */

#define SDIO_CMD_WAITRESP_Pos (6U)
#define SDIO_CMD_WAITRESP_Msk (0x3U << SDIO_CMD_WAITRESP_Pos) /*!< 0x000000C0 */
#define SDIO_CMD_WAITRESP SDIO_CMD_WAITRESP_Msk /*!< WAITRESP[1:0] bits (Wait for response bits) */
#define SDIO_CMD_WAITRESP_0 (0x1U << SDIO_CMD_WAITRESP_Pos) /*!< 0x0040 */
#define SDIO_CMD_WAITRESP_1 (0x2U << SDIO_CMD_WAITRESP_Pos) /*!< 0x0080 */

#define SDIO_CMD_WAITINT_Pos (8U)
#define SDIO_CMD_WAITINT_Msk (0x1U << SDIO_CMD_WAITINT_Pos) /*!< 0x00000100 */
#define SDIO_CMD_WAITINT SDIO_CMD_WAITINT_Msk /*!< CPSM Waits for Interrupt Request */
#define SDIO_CMD_WAITPEND_Pos (9U)
#define SDIO_CMD_WAITPEND_Msk (0x1U << SDIO_CMD_WAITPEND_Pos) /*!< 0x00000200 */
#define SDIO_CMD_WAITPEND SDIO_CMD_WAITPEND_Msk /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */
#define SDIO_CMD_CPSMEN_Pos (10U)
#define SDIO_CMD_CPSMEN_Msk (0x1U << SDIO_CMD_CPSMEN_Pos) /*!< 0x00000400 */
#define SDIO_CMD_CPSMEN SDIO_CMD_CPSMEN_Msk /*!< Command path state machine (CPSM) Enable bit */
#define SDIO_CMD_SDIOSUSPEND_Pos (11U)
#define SDIO_CMD_SDIOSUSPEND_Msk (0x1U << SDIO_CMD_SDIOSUSPEND_Pos) /*!< 0x00000800 */
#define SDIO_CMD_SDIOSUSPEND SDIO_CMD_SDIOSUSPEND_Msk /*!< SD I/O suspend command */
#define SDIO_CMD_ENCMDCOMPL_Pos (12U)
#define SDIO_CMD_ENCMDCOMPL_Msk (0x1U << SDIO_CMD_ENCMDCOMPL_Pos) /*!< 0x00001000 */
#define SDIO_CMD_ENCMDCOMPL SDIO_CMD_ENCMDCOMPL_Msk /*!< Enable CMD completion */
#define SDIO_CMD_NIEN_Pos (13U)
#define SDIO_CMD_NIEN_Msk (0x1U << SDIO_CMD_NIEN_Pos) /*!< 0x00002000 */
#define SDIO_CMD_NIEN SDIO_CMD_NIEN_Msk /*!< Not Interrupt Enable */
#define SDIO_CMD_CEATACMD_Pos (14U)
#define SDIO_CMD_CEATACMD_Msk (0x1U << SDIO_CMD_CEATACMD_Pos) /*!< 0x00004000 */
#define SDIO_CMD_CEATACMD SDIO_CMD_CEATACMD_Msk /*!< CE-ATA command */

/*****************  Bit definition for SDIO_RESPCMD register  *****************/
#define SDIO_RESPCMD_RESPCMD_Pos (0U)
#define SDIO_RESPCMD_RESPCMD_Msk (0x3FU << SDIO_RESPCMD_RESPCMD_Pos) /*!< 0x0000003F */
#define SDIO_RESPCMD_RESPCMD SDIO_RESPCMD_RESPCMD_Msk /*!< Response command index */

/******************  Bit definition for SDIO_RESP0 register  ******************/
#define SDIO_RESP0_CARDSTATUS0_Pos (0U)
#define SDIO_RESP0_CARDSTATUS0_Msk (0xFFFFFFFFU << SDIO_RESP0_CARDSTATUS0_Pos) /*!< 0xFFFFFFFF */
#define SDIO_RESP0_CARDSTATUS0 SDIO_RESP0_CARDSTATUS0_Msk /*!< Card Status */

/******************  Bit definition for SDIO_RESP1 register  ******************/
#define SDIO_RESP1_CARDSTATUS1_Pos (0U)
#define SDIO_RESP1_CARDSTATUS1_Msk (0xFFFFFFFFU << SDIO_RESP1_CARDSTATUS1_Pos) /*!< 0xFFFFFFFF */
#define SDIO_RESP1_CARDSTATUS1 SDIO_RESP1_CARDSTATUS1_Msk /*!< Card Status */

/******************  Bit definition for SDIO_RESP2 register  ******************/
#define SDIO_RESP2_CARDSTATUS2_Pos (0U)
#define SDIO_RESP2_CARDSTATUS2_Msk (0xFFFFFFFFU << SDIO_RESP2_CARDSTATUS2_Pos) /*!< 0xFFFFFFFF */
#define SDIO_RESP2_CARDSTATUS2 SDIO_RESP2_CARDSTATUS2_Msk /*!< Card Status */

/******************  Bit definition for SDIO_RESP3 register  ******************/
#define SDIO_RESP3_CARDSTATUS3_Pos (0U)
#define SDIO_RESP3_CARDSTATUS3_Msk (0xFFFFFFFFU << SDIO_RESP3_CARDSTATUS3_Pos) /*!< 0xFFFFFFFF */
#define SDIO_RESP3_CARDSTATUS3 SDIO_RESP3_CARDSTATUS3_Msk /*!< Card Status */

/******************  Bit definition for SDIO_RESP4 register  ******************/
#define SDIO_RESP4_CARDSTATUS4_Pos (0U)
#define SDIO_RESP4_CARDSTATUS4_Msk (0xFFFFFFFFU << SDIO_RESP4_CARDSTATUS4_Pos) /*!< 0xFFFFFFFF */
#define SDIO_RESP4_CARDSTATUS4 SDIO_RESP4_CARDSTATUS4_Msk /*!< Card Status */

/******************  Bit definition for SDIO_DTIMER register  *****************/
#define SDIO_DTIMER_DATATIME_Pos (0U)
#define SDIO_DTIMER_DATATIME_Msk (0xFFFFFFFFU << SDIO_DTIMER_DATATIME_Pos) /*!< 0xFFFFFFFF */
#define SDIO_DTIMER_DATATIME SDIO_DTIMER_DATATIME_Msk /*!< Data timeout period. */

/******************  Bit definition for SDIO_DLEN register  *******************/
#define SDIO_DLEN_DATALENGTH_Pos (0U)
#define SDIO_DLEN_DATALENGTH_Msk (0x1FFFFFFU << SDIO_DLEN_DATALENGTH_Pos) /*!< 0x01FFFFFF */
#define SDIO_DLEN_DATALENGTH SDIO_DLEN_DATALENGTH_Msk /*!< Data length value */

/******************  Bit definition for SDIO_DCTRL register  ******************/
#define SDIO_DCTRL_DTEN_Pos (0U)
#define SDIO_DCTRL_DTEN_Msk (0x1U << SDIO_DCTRL_DTEN_Pos) /*!< 0x00000001 */
#define SDIO_DCTRL_DTEN SDIO_DCTRL_DTEN_Msk /*!< Data transfer enabled bit */
#define SDIO_DCTRL_DTDIR_Pos (1U)
#define SDIO_DCTRL_DTDIR_Msk (0x1U << SDIO_DCTRL_DTDIR_Pos) /*!< 0x00000002 */
#define SDIO_DCTRL_DTDIR SDIO_DCTRL_DTDIR_Msk /*!< Data transfer direction selection */
#define SDIO_DCTRL_DTMODE_Pos (2U)
#define SDIO_DCTRL_DTMODE_Msk (0x1U << SDIO_DCTRL_DTMODE_Pos) /*!< 0x00000004 */
#define SDIO_DCTRL_DTMODE SDIO_DCTRL_DTMODE_Msk /*!< Data transfer mode selection */
#define SDIO_DCTRL_DMAEN_Pos (3U)
#define SDIO_DCTRL_DMAEN_Msk (0x1U << SDIO_DCTRL_DMAEN_Pos) /*!< 0x00000008 */
#define SDIO_DCTRL_DMAEN SDIO_DCTRL_DMAEN_Msk /*!< DMA enabled bit */

#define SDIO_DCTRL_DBLOCKSIZE_Pos (4U)
#define SDIO_DCTRL_DBLOCKSIZE_Msk (0xFU << SDIO_DCTRL_DBLOCKSIZE_Pos) /*!< 0x000000F0 */
#define SDIO_DCTRL_DBLOCKSIZE SDIO_DCTRL_DBLOCKSIZE_Msk /*!< DBLOCKSIZE[3:0] bits (Data block size) */
#define SDIO_DCTRL_DBLOCKSIZE_0 (0x1U << SDIO_DCTRL_DBLOCKSIZE_Pos) /*!< 0x0010 */
#define SDIO_DCTRL_DBLOCKSIZE_1 (0x2U << SDIO_DCTRL_DBLOCKSIZE_Pos) /*!< 0x0020 */
#define SDIO_DCTRL_DBLOCKSIZE_2 (0x4U << SDIO_DCTRL_DBLOCKSIZE_Pos) /*!< 0x0040 */
#define SDIO_DCTRL_DBLOCKSIZE_3 (0x8U << SDIO_DCTRL_DBLOCKSIZE_Pos) /*!< 0x0080 */

#define SDIO_DCTRL_RWSTART_Pos (8U)
#define SDIO_DCTRL_RWSTART_Msk (0x1U << SDIO_DCTRL_RWSTART_Pos) /*!< 0x00000100 */
#define SDIO_DCTRL_RWSTART SDIO_DCTRL_RWSTART_Msk /*!< Read wait start */
#define SDIO_DCTRL_RWSTOP_Pos (9U)
#define SDIO_DCTRL_RWSTOP_Msk (0x1U << SDIO_DCTRL_RWSTOP_Pos) /*!< 0x00000200 */
#define SDIO_DCTRL_RWSTOP SDIO_DCTRL_RWSTOP_Msk /*!< Read wait stop */
#define SDIO_DCTRL_RWMOD_Pos (10U)
#define SDIO_DCTRL_RWMOD_Msk (0x1U << SDIO_DCTRL_RWMOD_Pos) /*!< 0x00000400 */
#define SDIO_DCTRL_RWMOD SDIO_DCTRL_RWMOD_Msk /*!< Read wait mode */
#define SDIO_DCTRL_SDIOEN_Pos (11U)
#define SDIO_DCTRL_SDIOEN_Msk (0x1U << SDIO_DCTRL_SDIOEN_Pos) /*!< 0x00000800 */
#define SDIO_DCTRL_SDIOEN SDIO_DCTRL_SDIOEN_Msk /*!< SD I/O enable functions */

/******************  Bit definition for SDIO_DCOUNT register  *****************/
#define SDIO_DCOUNT_DATACOUNT_Pos (0U)
#define SDIO_DCOUNT_DATACOUNT_Msk (0x1FFFFFFU << SDIO_DCOUNT_DATACOUNT_Pos) /*!< 0x01FFFFFF */
#define SDIO_DCOUNT_DATACOUNT SDIO_DCOUNT_DATACOUNT_Msk /*!< Data count value */

/******************  Bit definition for SDIO_STA register  ********************/
#define SDIO_STA_CCRCFAIL_Pos (0U)
#define SDIO_STA_CCRCFAIL_Msk (0x1U << SDIO_STA_CCRCFAIL_Pos) /*!< 0x00000001 */
#define SDIO_STA_CCRCFAIL SDIO_STA_CCRCFAIL_Msk /*!< Command response received (CRC check failed) */
#define SDIO_STA_DCRCFAIL_Pos (1U)
#define SDIO_STA_DCRCFAIL_Msk (0x1U << SDIO_STA_DCRCFAIL_Pos) /*!< 0x00000002 */
#define SDIO_STA_DCRCFAIL SDIO_STA_DCRCFAIL_Msk /*!< Data block sent/received (CRC check failed) */
#define SDIO_STA_CTIMEOUT_Pos (2U)
#define SDIO_STA_CTIMEOUT_Msk (0x1U << SDIO_STA_CTIMEOUT_Pos) /*!< 0x00000004 */
#define SDIO_STA_CTIMEOUT SDIO_STA_CTIMEOUT_Msk /*!< Command response timeout */
#define SDIO_STA_DTIMEOUT_Pos (3U)
#define SDIO_STA_DTIMEOUT_Msk (0x1U << SDIO_STA_DTIMEOUT_Pos) /*!< 0x00000008 */
#define SDIO_STA_DTIMEOUT SDIO_STA_DTIMEOUT_Msk /*!< Data timeout */
#define SDIO_STA_TXUNDERR_Pos (4U)
#define SDIO_STA_TXUNDERR_Msk (0x1U << SDIO_STA_TXUNDERR_Pos) /*!< 0x00000010 */
#define SDIO_STA_TXUNDERR SDIO_STA_TXUNDERR_Msk /*!< Transmit FIFO underrun error */
#define SDIO_STA_RXOVERR_Pos (5U)
#define SDIO_STA_RXOVERR_Msk (0x1U << SDIO_STA_RXOVERR_Pos) /*!< 0x00000020 */
#define SDIO_STA_RXOVERR SDIO_STA_RXOVERR_Msk /*!< Received FIFO overrun error */
#define SDIO_STA_CMDREND_Pos (6U)
#define SDIO_STA_CMDREND_Msk (0x1U << SDIO_STA_CMDREND_Pos) /*!< 0x00000040 */
#define SDIO_STA_CMDREND SDIO_STA_CMDREND_Msk /*!< Command response received (CRC check passed) */
#define SDIO_STA_CMDSENT_Pos (7U)
#define SDIO_STA_CMDSENT_Msk (0x1U << SDIO_STA_CMDSENT_Pos) /*!< 0x00000080 */
#define SDIO_STA_CMDSENT SDIO_STA_CMDSENT_Msk /*!< Command sent (no response required) */
#define SDIO_STA_DATAEND_Pos (8U)
#define SDIO_STA_DATAEND_Msk (0x1U << SDIO_STA_DATAEND_Pos) /*!< 0x00000100 */
#define SDIO_STA_DATAEND SDIO_STA_DATAEND_Msk /*!< Data end (data counter, SDIDCOUNT, is zero) */
#define SDIO_STA_STBITERR_Pos (9U)
#define SDIO_STA_STBITERR_Msk (0x1U << SDIO_STA_STBITERR_Pos) /*!< 0x00000200 */
#define SDIO_STA_STBITERR SDIO_STA_STBITERR_Msk /*!< Start bit not detected on all data signals in wide bus mode */
#define SDIO_STA_DBCKEND_Pos (10U)
#define SDIO_STA_DBCKEND_Msk (0x1U << SDIO_STA_DBCKEND_Pos) /*!< 0x00000400 */
#define SDIO_STA_DBCKEND SDIO_STA_DBCKEND_Msk /*!< Data block sent/received (CRC check passed) */
#define SDIO_STA_CMDACT_Pos (11U)
#define SDIO_STA_CMDACT_Msk (0x1U << SDIO_STA_CMDACT_Pos) /*!< 0x00000800 */
#define SDIO_STA_CMDACT SDIO_STA_CMDACT_Msk /*!< Command transfer in progress */
#define SDIO_STA_TXACT_Pos (12U)
#define SDIO_STA_TXACT_Msk (0x1U << SDIO_STA_TXACT_Pos) /*!< 0x00001000 */
#define SDIO_STA_TXACT SDIO_STA_TXACT_Msk /*!< Data transmit in progress */
#define SDIO_STA_RXACT_Pos (13U)
#define SDIO_STA_RXACT_Msk (0x1U << SDIO_STA_RXACT_Pos) /*!< 0x00002000 */
#define SDIO_STA_RXACT SDIO_STA_RXACT_Msk /*!< Data receive in progress */
#define SDIO_STA_TXFIFOHE_Pos (14U)
#define SDIO_STA_TXFIFOHE_Msk (0x1U << SDIO_STA_TXFIFOHE_Pos) /*!< 0x00004000 */
#define SDIO_STA_TXFIFOHE SDIO_STA_TXFIFOHE_Msk /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */
#define SDIO_STA_RXFIFOHF_Pos (15U)
#define SDIO_STA_RXFIFOHF_Msk (0x1U << SDIO_STA_RXFIFOHF_Pos) /*!< 0x00008000 */
#define SDIO_STA_RXFIFOHF SDIO_STA_RXFIFOHF_Msk /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */
#define SDIO_STA_TXFIFOF_Pos (16U)
#define SDIO_STA_TXFIFOF_Msk (0x1U << SDIO_STA_TXFIFOF_Pos) /*!< 0x00010000 */
#define SDIO_STA_TXFIFOF SDIO_STA_TXFIFOF_Msk /*!< Transmit FIFO full */
#define SDIO_STA_RXFIFOF_Pos (17U)
#define SDIO_STA_RXFIFOF_Msk (0x1U << SDIO_STA_RXFIFOF_Pos) /*!< 0x00020000 */
#define SDIO_STA_RXFIFOF SDIO_STA_RXFIFOF_Msk /*!< Receive FIFO full */
#define SDIO_STA_TXFIFOE_Pos (18U)
#define SDIO_STA_TXFIFOE_Msk (0x1U << SDIO_STA_TXFIFOE_Pos) /*!< 0x00040000 */
#define SDIO_STA_TXFIFOE SDIO_STA_TXFIFOE_Msk /*!< Transmit FIFO empty */
#define SDIO_STA_RXFIFOE_Pos (19U)
#define SDIO_STA_RXFIFOE_Msk (0x1U << SDIO_STA_RXFIFOE_Pos) /*!< 0x00080000 */
#define SDIO_STA_RXFIFOE SDIO_STA_RXFIFOE_Msk /*!< Receive FIFO empty */
#define SDIO_STA_TXDAVL_Pos (20U)
#define SDIO_STA_TXDAVL_Msk (0x1U << SDIO_STA_TXDAVL_Pos) /*!< 0x00100000 */
#define SDIO_STA_TXDAVL SDIO_STA_TXDAVL_Msk /*!< Data available in transmit FIFO */
#define SDIO_STA_RXDAVL_Pos (21U)
#define SDIO_STA_RXDAVL_Msk (0x1U << SDIO_STA_RXDAVL_Pos) /*!< 0x00200000 */
#define SDIO_STA_RXDAVL SDIO_STA_RXDAVL_Msk /*!< Data available in receive FIFO */
#define SDIO_STA_SDIOIT_Pos (22U)
#define SDIO_STA_SDIOIT_Msk (0x1U << SDIO_STA_SDIOIT_Pos) /*!< 0x00400000 */
#define SDIO_STA_SDIOIT SDIO_STA_SDIOIT_Msk /*!< SDIO interrupt received */
#define SDIO_STA_CEATAEND_Pos (23U)
#define SDIO_STA_CEATAEND_Msk (0x1U << SDIO_STA_CEATAEND_Pos) /*!< 0x00800000 */
#define SDIO_STA_CEATAEND SDIO_STA_CEATAEND_Msk /*!< CE-ATA command completion signal received for CMD61 */

/*******************  Bit definition for SDIO_ICR register  *******************/
#define SDIO_ICR_CCRCFAILC_Pos (0U)
#define SDIO_ICR_CCRCFAILC_Msk (0x1U << SDIO_ICR_CCRCFAILC_Pos) /*!< 0x00000001 */
#define SDIO_ICR_CCRCFAILC SDIO_ICR_CCRCFAILC_Msk /*!< CCRCFAIL flag clear bit */
#define SDIO_ICR_DCRCFAILC_Pos (1U)
#define SDIO_ICR_DCRCFAILC_Msk (0x1U << SDIO_ICR_DCRCFAILC_Pos) /*!< 0x00000002 */
#define SDIO_ICR_DCRCFAILC SDIO_ICR_DCRCFAILC_Msk /*!< DCRCFAIL flag clear bit */
#define SDIO_ICR_CTIMEOUTC_Pos (2U)
#define SDIO_ICR_CTIMEOUTC_Msk (0x1U << SDIO_ICR_CTIMEOUTC_Pos) /*!< 0x00000004 */
#define SDIO_ICR_CTIMEOUTC SDIO_ICR_CTIMEOUTC_Msk /*!< CTIMEOUT flag clear bit */
#define SDIO_ICR_DTIMEOUTC_Pos (3U)
#define SDIO_ICR_DTIMEOUTC_Msk (0x1U << SDIO_ICR_DTIMEOUTC_Pos) /*!< 0x00000008 */
#define SDIO_ICR_DTIMEOUTC SDIO_ICR_DTIMEOUTC_Msk /*!< DTIMEOUT flag clear bit */
#define SDIO_ICR_TXUNDERRC_Pos (4U)
#define SDIO_ICR_TXUNDERRC_Msk (0x1U << SDIO_ICR_TXUNDERRC_Pos) /*!< 0x00000010 */
#define SDIO_ICR_TXUNDERRC SDIO_ICR_TXUNDERRC_Msk /*!< TXUNDERR flag clear bit */
#define SDIO_ICR_RXOVERRC_Pos (5U)
#define SDIO_ICR_RXOVERRC_Msk (0x1U << SDIO_ICR_RXOVERRC_Pos) /*!< 0x00000020 */
#define SDIO_ICR_RXOVERRC SDIO_ICR_RXOVERRC_Msk /*!< RXOVERR flag clear bit */
#define SDIO_ICR_CMDRENDC_Pos (6U)
#define SDIO_ICR_CMDRENDC_Msk (0x1U << SDIO_ICR_CMDRENDC_Pos) /*!< 0x00000040 */
#define SDIO_ICR_CMDRENDC SDIO_ICR_CMDRENDC_Msk /*!< CMDREND flag clear bit */
#define SDIO_ICR_CMDSENTC_Pos (7U)
#define SDIO_ICR_CMDSENTC_Msk (0x1U << SDIO_ICR_CMDSENTC_Pos) /*!< 0x00000080 */
#define SDIO_ICR_CMDSENTC SDIO_ICR_CMDSENTC_Msk /*!< CMDSENT flag clear bit */
#define SDIO_ICR_DATAENDC_Pos (8U)
#define SDIO_ICR_DATAENDC_Msk (0x1U << SDIO_ICR_DATAENDC_Pos) /*!< 0x00000100 */
#define SDIO_ICR_DATAENDC SDIO_ICR_DATAENDC_Msk /*!< DATAEND flag clear bit */
#define SDIO_ICR_STBITERRC_Pos (9U)
#define SDIO_ICR_STBITERRC_Msk (0x1U << SDIO_ICR_STBITERRC_Pos) /*!< 0x00000200 */
#define SDIO_ICR_STBITERRC SDIO_ICR_STBITERRC_Msk /*!< STBITERR flag clear bit */
#define SDIO_ICR_DBCKENDC_Pos (10U)
#define SDIO_ICR_DBCKENDC_Msk (0x1U << SDIO_ICR_DBCKENDC_Pos) /*!< 0x00000400 */
#define SDIO_ICR_DBCKENDC SDIO_ICR_DBCKENDC_Msk /*!< DBCKEND flag clear bit */
#define SDIO_ICR_SDIOITC_Pos (22U)
#define SDIO_ICR_SDIOITC_Msk (0x1U << SDIO_ICR_SDIOITC_Pos) /*!< 0x00400000 */
#define SDIO_ICR_SDIOITC SDIO_ICR_SDIOITC_Msk /*!< SDIOIT flag clear bit */
#define SDIO_ICR_CEATAENDC_Pos (23U)
#define SDIO_ICR_CEATAENDC_Msk (0x1U << SDIO_ICR_CEATAENDC_Pos) /*!< 0x00800000 */
#define SDIO_ICR_CEATAENDC SDIO_ICR_CEATAENDC_Msk /*!< CEATAEND flag clear bit */

/******************  Bit definition for SDIO_MASK register  *******************/
#define SDIO_MASK_CCRCFAILIE_Pos (0U)
#define SDIO_MASK_CCRCFAILIE_Msk (0x1U << SDIO_MASK_CCRCFAILIE_Pos) /*!< 0x00000001 */
#define SDIO_MASK_CCRCFAILIE SDIO_MASK_CCRCFAILIE_Msk /*!< Command CRC Fail Interrupt Enable */
#define SDIO_MASK_DCRCFAILIE_Pos (1U)
#define SDIO_MASK_DCRCFAILIE_Msk (0x1U << SDIO_MASK_DCRCFAILIE_Pos) /*!< 0x00000002 */
#define SDIO_MASK_DCRCFAILIE SDIO_MASK_DCRCFAILIE_Msk /*!< Data CRC Fail Interrupt Enable */
#define SDIO_MASK_CTIMEOUTIE_Pos (2U)
#define SDIO_MASK_CTIMEOUTIE_Msk (0x1U << SDIO_MASK_CTIMEOUTIE_Pos) /*!< 0x00000004 */
#define SDIO_MASK_CTIMEOUTIE SDIO_MASK_CTIMEOUTIE_Msk /*!< Command TimeOut Interrupt Enable */
#define SDIO_MASK_DTIMEOUTIE_Pos (3U)
#define SDIO_MASK_DTIMEOUTIE_Msk (0x1U << SDIO_MASK_DTIMEOUTIE_Pos) /*!< 0x00000008 */
#define SDIO_MASK_DTIMEOUTIE SDIO_MASK_DTIMEOUTIE_Msk /*!< Data TimeOut Interrupt Enable */
#define SDIO_MASK_TXUNDERRIE_Pos (4U)
#define SDIO_MASK_TXUNDERRIE_Msk (0x1U << SDIO_MASK_TXUNDERRIE_Pos) /*!< 0x00000010 */
#define SDIO_MASK_TXUNDERRIE SDIO_MASK_TXUNDERRIE_Msk /*!< Tx FIFO UnderRun Error Interrupt Enable */
#define SDIO_MASK_RXOVERRIE_Pos (5U)
#define SDIO_MASK_RXOVERRIE_Msk (0x1U << SDIO_MASK_RXOVERRIE_Pos) /*!< 0x00000020 */
#define SDIO_MASK_RXOVERRIE SDIO_MASK_RXOVERRIE_Msk /*!< Rx FIFO OverRun Error Interrupt Enable */
#define SDIO_MASK_CMDRENDIE_Pos (6U)
#define SDIO_MASK_CMDRENDIE_Msk (0x1U << SDIO_MASK_CMDRENDIE_Pos) /*!< 0x00000040 */
#define SDIO_MASK_CMDRENDIE SDIO_MASK_CMDRENDIE_Msk /*!< Command Response Received Interrupt Enable */
#define SDIO_MASK_CMDSENTIE_Pos (7U)
#define SDIO_MASK_CMDSENTIE_Msk (0x1U << SDIO_MASK_CMDSENTIE_Pos) /*!< 0x00000080 */
#define SDIO_MASK_CMDSENTIE SDIO_MASK_CMDSENTIE_Msk /*!< Command Sent Interrupt Enable */
#define SDIO_MASK_DATAENDIE_Pos (8U)
#define SDIO_MASK_DATAENDIE_Msk (0x1U << SDIO_MASK_DATAENDIE_Pos) /*!< 0x00000100 */
#define SDIO_MASK_DATAENDIE SDIO_MASK_DATAENDIE_Msk /*!< Data End Interrupt Enable */
#define SDIO_MASK_STBITERRIE_Pos (9U)
#define SDIO_MASK_STBITERRIE_Msk (0x1U << SDIO_MASK_STBITERRIE_Pos) /*!< 0x00000200 */
#define SDIO_MASK_STBITERRIE SDIO_MASK_STBITERRIE_Msk /*!< Start Bit Error Interrupt Enable */
#define SDIO_MASK_DBCKENDIE_Pos (10U)
#define SDIO_MASK_DBCKENDIE_Msk (0x1U << SDIO_MASK_DBCKENDIE_Pos) /*!< 0x00000400 */
#define SDIO_MASK_DBCKENDIE SDIO_MASK_DBCKENDIE_Msk /*!< Data Block End Interrupt Enable */
#define SDIO_MASK_CMDACTIE_Pos (11U)
#define SDIO_MASK_CMDACTIE_Msk (0x1U << SDIO_MASK_CMDACTIE_Pos) /*!< 0x00000800 */
#define SDIO_MASK_CMDACTIE SDIO_MASK_CMDACTIE_Msk /*!< Command Acting Interrupt Enable */
#define SDIO_MASK_TXACTIE_Pos (12U)
#define SDIO_MASK_TXACTIE_Msk (0x1U << SDIO_MASK_TXACTIE_Pos) /*!< 0x00001000 */
#define SDIO_MASK_TXACTIE SDIO_MASK_TXACTIE_Msk /*!< Data Transmit Acting Interrupt Enable */
#define SDIO_MASK_RXACTIE_Pos (13U)
#define SDIO_MASK_RXACTIE_Msk (0x1U << SDIO_MASK_RXACTIE_Pos) /*!< 0x00002000 */
#define SDIO_MASK_RXACTIE SDIO_MASK_RXACTIE_Msk /*!< Data receive acting interrupt enabled */
#define SDIO_MASK_TXFIFOHEIE_Pos (14U)
#define SDIO_MASK_TXFIFOHEIE_Msk (0x1U << SDIO_MASK_TXFIFOHEIE_Pos) /*!< 0x00004000 */
#define SDIO_MASK_TXFIFOHEIE SDIO_MASK_TXFIFOHEIE_Msk /*!< Tx FIFO Half Empty interrupt Enable */
#define SDIO_MASK_RXFIFOHFIE_Pos (15U)
#define SDIO_MASK_RXFIFOHFIE_Msk (0x1U << SDIO_MASK_RXFIFOHFIE_Pos) /*!< 0x00008000 */
#define SDIO_MASK_RXFIFOHFIE SDIO_MASK_RXFIFOHFIE_Msk /*!< Rx FIFO Half Full interrupt Enable */
#define SDIO_MASK_TXFIFOFIE_Pos (16U)
#define SDIO_MASK_TXFIFOFIE_Msk (0x1U << SDIO_MASK_TXFIFOFIE_Pos) /*!< 0x00010000 */
#define SDIO_MASK_TXFIFOFIE SDIO_MASK_TXFIFOFIE_Msk /*!< Tx FIFO Full interrupt Enable */
#define SDIO_MASK_RXFIFOFIE_Pos (17U)
#define SDIO_MASK_RXFIFOFIE_Msk (0x1U << SDIO_MASK_RXFIFOFIE_Pos) /*!< 0x00020000 */
#define SDIO_MASK_RXFIFOFIE SDIO_MASK_RXFIFOFIE_Msk /*!< Rx FIFO Full interrupt Enable */
#define SDIO_MASK_TXFIFOEIE_Pos (18U)
#define SDIO_MASK_TXFIFOEIE_Msk (0x1U << SDIO_MASK_TXFIFOEIE_Pos) /*!< 0x00040000 */
#define SDIO_MASK_TXFIFOEIE SDIO_MASK_TXFIFOEIE_Msk /*!< Tx FIFO Empty interrupt Enable */
#define SDIO_MASK_RXFIFOEIE_Pos (19U)
#define SDIO_MASK_RXFIFOEIE_Msk (0x1U << SDIO_MASK_RXFIFOEIE_Pos) /*!< 0x00080000 */
#define SDIO_MASK_RXFIFOEIE SDIO_MASK_RXFIFOEIE_Msk /*!< Rx FIFO Empty interrupt Enable */
#define SDIO_MASK_TXDAVLIE_Pos (20U)
#define SDIO_MASK_TXDAVLIE_Msk (0x1U << SDIO_MASK_TXDAVLIE_Pos) /*!< 0x00100000 */
#define SDIO_MASK_TXDAVLIE SDIO_MASK_TXDAVLIE_Msk /*!< Data available in Tx FIFO interrupt Enable */
#define SDIO_MASK_RXDAVLIE_Pos (21U)
#define SDIO_MASK_RXDAVLIE_Msk (0x1U << SDIO_MASK_RXDAVLIE_Pos) /*!< 0x00200000 */
#define SDIO_MASK_RXDAVLIE SDIO_MASK_RXDAVLIE_Msk /*!< Data available in Rx FIFO interrupt Enable */
#define SDIO_MASK_SDIOITIE_Pos (22U)
#define SDIO_MASK_SDIOITIE_Msk (0x1U << SDIO_MASK_SDIOITIE_Pos) /*!< 0x00400000 */
#define SDIO_MASK_SDIOITIE SDIO_MASK_SDIOITIE_Msk /*!< SDIO Mode Interrupt Received interrupt Enable */
#define SDIO_MASK_CEATAENDIE_Pos (23U)
#define SDIO_MASK_CEATAENDIE_Msk (0x1U << SDIO_MASK_CEATAENDIE_Pos) /*!< 0x00800000 */
#define SDIO_MASK_CEATAENDIE SDIO_MASK_CEATAENDIE_Msk /*!< CE-ATA command completion signal received Interrupt Enable */

/*****************  Bit definition for SDIO_FIFOCNT register  *****************/
#define SDIO_FIFOCNT_FIFOCOUNT_Pos (0U)
#define SDIO_FIFOCNT_FIFOCOUNT_Msk (0xFFFFFFU << SDIO_FIFOCNT_FIFOCOUNT_Pos) /*!< 0x00FFFFFF */
#define SDIO_FIFOCNT_FIFOCOUNT SDIO_FIFOCNT_FIFOCOUNT_Msk /*!< Remaining number of words to be written to or read from the FIFO */

/******************  Bit definition for SDIO_FIFO register  *******************/
#define SDIO_FIFO_FIFODATA_Pos (0U)
#define SDIO_FIFO_FIFODATA_Msk (0xFFFFFFFFU << SDIO_FIFO_FIFODATA_Pos) /*!< 0xFFFFFFFF */
#define SDIO_FIFO_FIFODATA SDIO_FIFO_FIFODATA_Msk /*!< Receive and transmit FIFO data */

/******************************************************************************/
/*                                                                            */
/*                                   USB Device FS                            */
/*                                                                            */
/******************************************************************************/

/*!< Endpoint-specific registers */
#define USB_EP0R USB_BASE /*!< Endpoint 0 register address */
#define USB_EP1R (USB_BASE + 0x00000004) /*!< Endpoint 1 register address */
#define USB_EP2R (USB_BASE + 0x00000008) /*!< Endpoint 2 register address */
#define USB_EP3R (USB_BASE + 0x0000000C) /*!< Endpoint 3 register address */
#define USB_EP4R (USB_BASE + 0x00000010) /*!< Endpoint 4 register address */
#define USB_EP5R (USB_BASE + 0x00000014) /*!< Endpoint 5 register address */
#define USB_EP6R (USB_BASE + 0x00000018) /*!< Endpoint 6 register address */
#define USB_EP7R (USB_BASE + 0x0000001C) /*!< Endpoint 7 register address */

/* bit positions */
#define USB_EP_CTR_RX_Pos (15U)
#define USB_EP_CTR_RX_Msk (0x1U << USB_EP_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP_CTR_RX USB_EP_CTR_RX_Msk /*!< EndPoint Correct TRansfer RX */
#define USB_EP_DTOG_RX_Pos (14U)
#define USB_EP_DTOG_RX_Msk (0x1U << USB_EP_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP_DTOG_RX USB_EP_DTOG_RX_Msk /*!< EndPoint Data TOGGLE RX */
#define USB_EPRX_STAT_Pos (12U)
#define USB_EPRX_STAT_Msk (0x3U << USB_EPRX_STAT_Pos) /*!< 0x00003000 */
#define USB_EPRX_STAT USB_EPRX_STAT_Msk /*!< EndPoint RX STATus bit field */
#define USB_EP_SETUP_Pos (11U)
#define USB_EP_SETUP_Msk (0x1U << USB_EP_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP_SETUP USB_EP_SETUP_Msk /*!< EndPoint SETUP */
#define USB_EP_T_FIELD_Pos (9U)
#define USB_EP_T_FIELD_Msk (0x3U << USB_EP_T_FIELD_Pos) /*!< 0x00000600 */
#define USB_EP_T_FIELD USB_EP_T_FIELD_Msk /*!< EndPoint TYPE */
#define USB_EP_KIND_Pos (8U)
#define USB_EP_KIND_Msk (0x1U << USB_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP_KIND USB_EP_KIND_Msk /*!< EndPoint KIND */
#define USB_EP_CTR_TX_Pos (7U)
#define USB_EP_CTR_TX_Msk (0x1U << USB_EP_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP_CTR_TX USB_EP_CTR_TX_Msk /*!< EndPoint Correct TRansfer TX */
#define USB_EP_DTOG_TX_Pos (6U)
#define USB_EP_DTOG_TX_Msk (0x1U << USB_EP_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP_DTOG_TX USB_EP_DTOG_TX_Msk /*!< EndPoint Data TOGGLE TX */
#define USB_EPTX_STAT_Pos (4U)
#define USB_EPTX_STAT_Msk (0x3U << USB_EPTX_STAT_Pos) /*!< 0x00000030 */
#define USB_EPTX_STAT USB_EPTX_STAT_Msk /*!< EndPoint TX STATus bit field */
#define USB_EPADDR_FIELD_Pos (0U)
#define USB_EPADDR_FIELD_Msk (0xFU << USB_EPADDR_FIELD_Pos) /*!< 0x0000000F */
#define USB_EPADDR_FIELD USB_EPADDR_FIELD_Msk /*!< EndPoint ADDRess FIELD */

/* EndPoint REGister MASK (no toggle fields) */
#define USB_EPREG_MASK (USB_EP_CTR_RX|USB_EP_SETUP|USB_EP_T_FIELD|USB_EP_KIND|USB_EP_CTR_TX|USB_EPADDR_FIELD)
                                                                           /*!< EP_TYPE[1:0] EndPoint TYPE */
#define USB_EP_TYPE_MASK_Pos (9U)
#define USB_EP_TYPE_MASK_Msk (0x3U << USB_EP_TYPE_MASK_Pos) /*!< 0x00000600 */
#define USB_EP_TYPE_MASK USB_EP_TYPE_MASK_Msk /*!< EndPoint TYPE Mask */
#define USB_EP_BULK 0x00000000U /*!< EndPoint BULK */
#define USB_EP_CONTROL 0x00000200U /*!< EndPoint CONTROL */
#define USB_EP_ISOCHRONOUS 0x00000400U /*!< EndPoint ISOCHRONOUS */
#define USB_EP_INTERRUPT 0x00000600U /*!< EndPoint INTERRUPT */
#define USB_EP_T_MASK (~USB_EP_T_FIELD & USB_EPREG_MASK)

#define USB_EPKIND_MASK (~USB_EP_KIND & USB_EPREG_MASK) /*!< EP_KIND EndPoint KIND */
                                                                               /*!< STAT_TX[1:0] STATus for TX transfer */
#define USB_EP_TX_DIS 0x00000000U /*!< EndPoint TX DISabled */
#define USB_EP_TX_STALL 0x00000010U /*!< EndPoint TX STALLed */
#define USB_EP_TX_NAK 0x00000020U /*!< EndPoint TX NAKed */
#define USB_EP_TX_VALID 0x00000030U /*!< EndPoint TX VALID */
#define USB_EPTX_DTOG1 0x00000010U /*!< EndPoint TX Data TOGgle bit1 */
#define USB_EPTX_DTOG2 0x00000020U /*!< EndPoint TX Data TOGgle bit2 */
#define USB_EPTX_DTOGMASK (USB_EPTX_STAT|USB_EPREG_MASK)
                                                                               /*!< STAT_RX[1:0] STATus for RX transfer */
#define USB_EP_RX_DIS 0x00000000U /*!< EndPoint RX DISabled */
#define USB_EP_RX_STALL 0x00001000U /*!< EndPoint RX STALLed */
#define USB_EP_RX_NAK 0x00002000U /*!< EndPoint RX NAKed */
#define USB_EP_RX_VALID 0x00003000U /*!< EndPoint RX VALID */
#define USB_EPRX_DTOG1 0x00001000U /*!< EndPoint RX Data TOGgle bit1 */
#define USB_EPRX_DTOG2 0x00002000U /*!< EndPoint RX Data TOGgle bit1 */
#define USB_EPRX_DTOGMASK (USB_EPRX_STAT|USB_EPREG_MASK)

/*******************  Bit definition for USB_EP0R register  *******************/
#define USB_EP0R_EA_Pos (0U)
#define USB_EP0R_EA_Msk (0xFU << USB_EP0R_EA_Pos) /*!< 0x0000000F */
#define USB_EP0R_EA USB_EP0R_EA_Msk /*!< Endpoint Address */

#define USB_EP0R_STAT_TX_Pos (4U)
#define USB_EP0R_STAT_TX_Msk (0x3U << USB_EP0R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP0R_STAT_TX USB_EP0R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP0R_STAT_TX_0 (0x1U << USB_EP0R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP0R_STAT_TX_1 (0x2U << USB_EP0R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP0R_DTOG_TX_Pos (6U)
#define USB_EP0R_DTOG_TX_Msk (0x1U << USB_EP0R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP0R_DTOG_TX USB_EP0R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP0R_CTR_TX_Pos (7U)
#define USB_EP0R_CTR_TX_Msk (0x1U << USB_EP0R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP0R_CTR_TX USB_EP0R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP0R_EP_KIND_Pos (8U)
#define USB_EP0R_EP_KIND_Msk (0x1U << USB_EP0R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP0R_EP_KIND USB_EP0R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP0R_EP_TYPE_Pos (9U)
#define USB_EP0R_EP_TYPE_Msk (0x3U << USB_EP0R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP0R_EP_TYPE USB_EP0R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP0R_EP_TYPE_0 (0x1U << USB_EP0R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP0R_EP_TYPE_1 (0x2U << USB_EP0R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP0R_SETUP_Pos (11U)
#define USB_EP0R_SETUP_Msk (0x1U << USB_EP0R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP0R_SETUP USB_EP0R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP0R_STAT_RX_Pos (12U)
#define USB_EP0R_STAT_RX_Msk (0x3U << USB_EP0R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP0R_STAT_RX USB_EP0R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP0R_STAT_RX_0 (0x1U << USB_EP0R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP0R_STAT_RX_1 (0x2U << USB_EP0R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP0R_DTOG_RX_Pos (14U)
#define USB_EP0R_DTOG_RX_Msk (0x1U << USB_EP0R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP0R_DTOG_RX USB_EP0R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP0R_CTR_RX_Pos (15U)
#define USB_EP0R_CTR_RX_Msk (0x1U << USB_EP0R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP0R_CTR_RX USB_EP0R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP1R register  *******************/
#define USB_EP1R_EA_Pos (0U)
#define USB_EP1R_EA_Msk (0xFU << USB_EP1R_EA_Pos) /*!< 0x0000000F */
#define USB_EP1R_EA USB_EP1R_EA_Msk /*!< Endpoint Address */

#define USB_EP1R_STAT_TX_Pos (4U)
#define USB_EP1R_STAT_TX_Msk (0x3U << USB_EP1R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP1R_STAT_TX USB_EP1R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP1R_STAT_TX_0 (0x1U << USB_EP1R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP1R_STAT_TX_1 (0x2U << USB_EP1R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP1R_DTOG_TX_Pos (6U)
#define USB_EP1R_DTOG_TX_Msk (0x1U << USB_EP1R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP1R_DTOG_TX USB_EP1R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP1R_CTR_TX_Pos (7U)
#define USB_EP1R_CTR_TX_Msk (0x1U << USB_EP1R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP1R_CTR_TX USB_EP1R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP1R_EP_KIND_Pos (8U)
#define USB_EP1R_EP_KIND_Msk (0x1U << USB_EP1R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP1R_EP_KIND USB_EP1R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP1R_EP_TYPE_Pos (9U)
#define USB_EP1R_EP_TYPE_Msk (0x3U << USB_EP1R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP1R_EP_TYPE USB_EP1R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP1R_EP_TYPE_0 (0x1U << USB_EP1R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP1R_EP_TYPE_1 (0x2U << USB_EP1R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP1R_SETUP_Pos (11U)
#define USB_EP1R_SETUP_Msk (0x1U << USB_EP1R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP1R_SETUP USB_EP1R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP1R_STAT_RX_Pos (12U)
#define USB_EP1R_STAT_RX_Msk (0x3U << USB_EP1R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP1R_STAT_RX USB_EP1R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP1R_STAT_RX_0 (0x1U << USB_EP1R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP1R_STAT_RX_1 (0x2U << USB_EP1R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP1R_DTOG_RX_Pos (14U)
#define USB_EP1R_DTOG_RX_Msk (0x1U << USB_EP1R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP1R_DTOG_RX USB_EP1R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP1R_CTR_RX_Pos (15U)
#define USB_EP1R_CTR_RX_Msk (0x1U << USB_EP1R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP1R_CTR_RX USB_EP1R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP2R register  *******************/
#define USB_EP2R_EA_Pos (0U)
#define USB_EP2R_EA_Msk (0xFU << USB_EP2R_EA_Pos) /*!< 0x0000000F */
#define USB_EP2R_EA USB_EP2R_EA_Msk /*!< Endpoint Address */

#define USB_EP2R_STAT_TX_Pos (4U)
#define USB_EP2R_STAT_TX_Msk (0x3U << USB_EP2R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP2R_STAT_TX USB_EP2R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP2R_STAT_TX_0 (0x1U << USB_EP2R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP2R_STAT_TX_1 (0x2U << USB_EP2R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP2R_DTOG_TX_Pos (6U)
#define USB_EP2R_DTOG_TX_Msk (0x1U << USB_EP2R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP2R_DTOG_TX USB_EP2R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP2R_CTR_TX_Pos (7U)
#define USB_EP2R_CTR_TX_Msk (0x1U << USB_EP2R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP2R_CTR_TX USB_EP2R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP2R_EP_KIND_Pos (8U)
#define USB_EP2R_EP_KIND_Msk (0x1U << USB_EP2R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP2R_EP_KIND USB_EP2R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP2R_EP_TYPE_Pos (9U)
#define USB_EP2R_EP_TYPE_Msk (0x3U << USB_EP2R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP2R_EP_TYPE USB_EP2R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP2R_EP_TYPE_0 (0x1U << USB_EP2R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP2R_EP_TYPE_1 (0x2U << USB_EP2R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP2R_SETUP_Pos (11U)
#define USB_EP2R_SETUP_Msk (0x1U << USB_EP2R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP2R_SETUP USB_EP2R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP2R_STAT_RX_Pos (12U)
#define USB_EP2R_STAT_RX_Msk (0x3U << USB_EP2R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP2R_STAT_RX USB_EP2R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP2R_STAT_RX_0 (0x1U << USB_EP2R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP2R_STAT_RX_1 (0x2U << USB_EP2R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP2R_DTOG_RX_Pos (14U)
#define USB_EP2R_DTOG_RX_Msk (0x1U << USB_EP2R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP2R_DTOG_RX USB_EP2R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP2R_CTR_RX_Pos (15U)
#define USB_EP2R_CTR_RX_Msk (0x1U << USB_EP2R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP2R_CTR_RX USB_EP2R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP3R register  *******************/
#define USB_EP3R_EA_Pos (0U)
#define USB_EP3R_EA_Msk (0xFU << USB_EP3R_EA_Pos) /*!< 0x0000000F */
#define USB_EP3R_EA USB_EP3R_EA_Msk /*!< Endpoint Address */

#define USB_EP3R_STAT_TX_Pos (4U)
#define USB_EP3R_STAT_TX_Msk (0x3U << USB_EP3R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP3R_STAT_TX USB_EP3R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP3R_STAT_TX_0 (0x1U << USB_EP3R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP3R_STAT_TX_1 (0x2U << USB_EP3R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP3R_DTOG_TX_Pos (6U)
#define USB_EP3R_DTOG_TX_Msk (0x1U << USB_EP3R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP3R_DTOG_TX USB_EP3R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP3R_CTR_TX_Pos (7U)
#define USB_EP3R_CTR_TX_Msk (0x1U << USB_EP3R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP3R_CTR_TX USB_EP3R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP3R_EP_KIND_Pos (8U)
#define USB_EP3R_EP_KIND_Msk (0x1U << USB_EP3R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP3R_EP_KIND USB_EP3R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP3R_EP_TYPE_Pos (9U)
#define USB_EP3R_EP_TYPE_Msk (0x3U << USB_EP3R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP3R_EP_TYPE USB_EP3R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP3R_EP_TYPE_0 (0x1U << USB_EP3R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP3R_EP_TYPE_1 (0x2U << USB_EP3R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP3R_SETUP_Pos (11U)
#define USB_EP3R_SETUP_Msk (0x1U << USB_EP3R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP3R_SETUP USB_EP3R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP3R_STAT_RX_Pos (12U)
#define USB_EP3R_STAT_RX_Msk (0x3U << USB_EP3R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP3R_STAT_RX USB_EP3R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP3R_STAT_RX_0 (0x1U << USB_EP3R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP3R_STAT_RX_1 (0x2U << USB_EP3R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP3R_DTOG_RX_Pos (14U)
#define USB_EP3R_DTOG_RX_Msk (0x1U << USB_EP3R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP3R_DTOG_RX USB_EP3R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP3R_CTR_RX_Pos (15U)
#define USB_EP3R_CTR_RX_Msk (0x1U << USB_EP3R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP3R_CTR_RX USB_EP3R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP4R register  *******************/
#define USB_EP4R_EA_Pos (0U)
#define USB_EP4R_EA_Msk (0xFU << USB_EP4R_EA_Pos) /*!< 0x0000000F */
#define USB_EP4R_EA USB_EP4R_EA_Msk /*!< Endpoint Address */

#define USB_EP4R_STAT_TX_Pos (4U)
#define USB_EP4R_STAT_TX_Msk (0x3U << USB_EP4R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP4R_STAT_TX USB_EP4R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP4R_STAT_TX_0 (0x1U << USB_EP4R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP4R_STAT_TX_1 (0x2U << USB_EP4R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP4R_DTOG_TX_Pos (6U)
#define USB_EP4R_DTOG_TX_Msk (0x1U << USB_EP4R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP4R_DTOG_TX USB_EP4R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP4R_CTR_TX_Pos (7U)
#define USB_EP4R_CTR_TX_Msk (0x1U << USB_EP4R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP4R_CTR_TX USB_EP4R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP4R_EP_KIND_Pos (8U)
#define USB_EP4R_EP_KIND_Msk (0x1U << USB_EP4R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP4R_EP_KIND USB_EP4R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP4R_EP_TYPE_Pos (9U)
#define USB_EP4R_EP_TYPE_Msk (0x3U << USB_EP4R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP4R_EP_TYPE USB_EP4R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP4R_EP_TYPE_0 (0x1U << USB_EP4R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP4R_EP_TYPE_1 (0x2U << USB_EP4R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP4R_SETUP_Pos (11U)
#define USB_EP4R_SETUP_Msk (0x1U << USB_EP4R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP4R_SETUP USB_EP4R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP4R_STAT_RX_Pos (12U)
#define USB_EP4R_STAT_RX_Msk (0x3U << USB_EP4R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP4R_STAT_RX USB_EP4R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP4R_STAT_RX_0 (0x1U << USB_EP4R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP4R_STAT_RX_1 (0x2U << USB_EP4R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP4R_DTOG_RX_Pos (14U)
#define USB_EP4R_DTOG_RX_Msk (0x1U << USB_EP4R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP4R_DTOG_RX USB_EP4R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP4R_CTR_RX_Pos (15U)
#define USB_EP4R_CTR_RX_Msk (0x1U << USB_EP4R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP4R_CTR_RX USB_EP4R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP5R register  *******************/
#define USB_EP5R_EA_Pos (0U)
#define USB_EP5R_EA_Msk (0xFU << USB_EP5R_EA_Pos) /*!< 0x0000000F */
#define USB_EP5R_EA USB_EP5R_EA_Msk /*!< Endpoint Address */

#define USB_EP5R_STAT_TX_Pos (4U)
#define USB_EP5R_STAT_TX_Msk (0x3U << USB_EP5R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP5R_STAT_TX USB_EP5R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP5R_STAT_TX_0 (0x1U << USB_EP5R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP5R_STAT_TX_1 (0x2U << USB_EP5R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP5R_DTOG_TX_Pos (6U)
#define USB_EP5R_DTOG_TX_Msk (0x1U << USB_EP5R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP5R_DTOG_TX USB_EP5R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP5R_CTR_TX_Pos (7U)
#define USB_EP5R_CTR_TX_Msk (0x1U << USB_EP5R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP5R_CTR_TX USB_EP5R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP5R_EP_KIND_Pos (8U)
#define USB_EP5R_EP_KIND_Msk (0x1U << USB_EP5R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP5R_EP_KIND USB_EP5R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP5R_EP_TYPE_Pos (9U)
#define USB_EP5R_EP_TYPE_Msk (0x3U << USB_EP5R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP5R_EP_TYPE USB_EP5R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP5R_EP_TYPE_0 (0x1U << USB_EP5R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP5R_EP_TYPE_1 (0x2U << USB_EP5R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP5R_SETUP_Pos (11U)
#define USB_EP5R_SETUP_Msk (0x1U << USB_EP5R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP5R_SETUP USB_EP5R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP5R_STAT_RX_Pos (12U)
#define USB_EP5R_STAT_RX_Msk (0x3U << USB_EP5R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP5R_STAT_RX USB_EP5R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP5R_STAT_RX_0 (0x1U << USB_EP5R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP5R_STAT_RX_1 (0x2U << USB_EP5R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP5R_DTOG_RX_Pos (14U)
#define USB_EP5R_DTOG_RX_Msk (0x1U << USB_EP5R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP5R_DTOG_RX USB_EP5R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP5R_CTR_RX_Pos (15U)
#define USB_EP5R_CTR_RX_Msk (0x1U << USB_EP5R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP5R_CTR_RX USB_EP5R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP6R register  *******************/
#define USB_EP6R_EA_Pos (0U)
#define USB_EP6R_EA_Msk (0xFU << USB_EP6R_EA_Pos) /*!< 0x0000000F */
#define USB_EP6R_EA USB_EP6R_EA_Msk /*!< Endpoint Address */

#define USB_EP6R_STAT_TX_Pos (4U)
#define USB_EP6R_STAT_TX_Msk (0x3U << USB_EP6R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP6R_STAT_TX USB_EP6R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP6R_STAT_TX_0 (0x1U << USB_EP6R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP6R_STAT_TX_1 (0x2U << USB_EP6R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP6R_DTOG_TX_Pos (6U)
#define USB_EP6R_DTOG_TX_Msk (0x1U << USB_EP6R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP6R_DTOG_TX USB_EP6R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP6R_CTR_TX_Pos (7U)
#define USB_EP6R_CTR_TX_Msk (0x1U << USB_EP6R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP6R_CTR_TX USB_EP6R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP6R_EP_KIND_Pos (8U)
#define USB_EP6R_EP_KIND_Msk (0x1U << USB_EP6R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP6R_EP_KIND USB_EP6R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP6R_EP_TYPE_Pos (9U)
#define USB_EP6R_EP_TYPE_Msk (0x3U << USB_EP6R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP6R_EP_TYPE USB_EP6R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP6R_EP_TYPE_0 (0x1U << USB_EP6R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP6R_EP_TYPE_1 (0x2U << USB_EP6R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP6R_SETUP_Pos (11U)
#define USB_EP6R_SETUP_Msk (0x1U << USB_EP6R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP6R_SETUP USB_EP6R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP6R_STAT_RX_Pos (12U)
#define USB_EP6R_STAT_RX_Msk (0x3U << USB_EP6R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP6R_STAT_RX USB_EP6R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP6R_STAT_RX_0 (0x1U << USB_EP6R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP6R_STAT_RX_1 (0x2U << USB_EP6R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP6R_DTOG_RX_Pos (14U)
#define USB_EP6R_DTOG_RX_Msk (0x1U << USB_EP6R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP6R_DTOG_RX USB_EP6R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP6R_CTR_RX_Pos (15U)
#define USB_EP6R_CTR_RX_Msk (0x1U << USB_EP6R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP6R_CTR_RX USB_EP6R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*******************  Bit definition for USB_EP7R register  *******************/
#define USB_EP7R_EA_Pos (0U)
#define USB_EP7R_EA_Msk (0xFU << USB_EP7R_EA_Pos) /*!< 0x0000000F */
#define USB_EP7R_EA USB_EP7R_EA_Msk /*!< Endpoint Address */

#define USB_EP7R_STAT_TX_Pos (4U)
#define USB_EP7R_STAT_TX_Msk (0x3U << USB_EP7R_STAT_TX_Pos) /*!< 0x00000030 */
#define USB_EP7R_STAT_TX USB_EP7R_STAT_TX_Msk /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */
#define USB_EP7R_STAT_TX_0 (0x1U << USB_EP7R_STAT_TX_Pos) /*!< 0x00000010 */
#define USB_EP7R_STAT_TX_1 (0x2U << USB_EP7R_STAT_TX_Pos) /*!< 0x00000020 */

#define USB_EP7R_DTOG_TX_Pos (6U)
#define USB_EP7R_DTOG_TX_Msk (0x1U << USB_EP7R_DTOG_TX_Pos) /*!< 0x00000040 */
#define USB_EP7R_DTOG_TX USB_EP7R_DTOG_TX_Msk /*!< Data Toggle, for transmission transfers */
#define USB_EP7R_CTR_TX_Pos (7U)
#define USB_EP7R_CTR_TX_Msk (0x1U << USB_EP7R_CTR_TX_Pos) /*!< 0x00000080 */
#define USB_EP7R_CTR_TX USB_EP7R_CTR_TX_Msk /*!< Correct Transfer for transmission */
#define USB_EP7R_EP_KIND_Pos (8U)
#define USB_EP7R_EP_KIND_Msk (0x1U << USB_EP7R_EP_KIND_Pos) /*!< 0x00000100 */
#define USB_EP7R_EP_KIND USB_EP7R_EP_KIND_Msk /*!< Endpoint Kind */

#define USB_EP7R_EP_TYPE_Pos (9U)
#define USB_EP7R_EP_TYPE_Msk (0x3U << USB_EP7R_EP_TYPE_Pos) /*!< 0x00000600 */
#define USB_EP7R_EP_TYPE USB_EP7R_EP_TYPE_Msk /*!< EP_TYPE[1:0] bits (Endpoint type) */
#define USB_EP7R_EP_TYPE_0 (0x1U << USB_EP7R_EP_TYPE_Pos) /*!< 0x00000200 */
#define USB_EP7R_EP_TYPE_1 (0x2U << USB_EP7R_EP_TYPE_Pos) /*!< 0x00000400 */

#define USB_EP7R_SETUP_Pos (11U)
#define USB_EP7R_SETUP_Msk (0x1U << USB_EP7R_SETUP_Pos) /*!< 0x00000800 */
#define USB_EP7R_SETUP USB_EP7R_SETUP_Msk /*!< Setup transaction completed */

#define USB_EP7R_STAT_RX_Pos (12U)
#define USB_EP7R_STAT_RX_Msk (0x3U << USB_EP7R_STAT_RX_Pos) /*!< 0x00003000 */
#define USB_EP7R_STAT_RX USB_EP7R_STAT_RX_Msk /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */
#define USB_EP7R_STAT_RX_0 (0x1U << USB_EP7R_STAT_RX_Pos) /*!< 0x00001000 */
#define USB_EP7R_STAT_RX_1 (0x2U << USB_EP7R_STAT_RX_Pos) /*!< 0x00002000 */

#define USB_EP7R_DTOG_RX_Pos (14U)
#define USB_EP7R_DTOG_RX_Msk (0x1U << USB_EP7R_DTOG_RX_Pos) /*!< 0x00004000 */
#define USB_EP7R_DTOG_RX USB_EP7R_DTOG_RX_Msk /*!< Data Toggle, for reception transfers */
#define USB_EP7R_CTR_RX_Pos (15U)
#define USB_EP7R_CTR_RX_Msk (0x1U << USB_EP7R_CTR_RX_Pos) /*!< 0x00008000 */
#define USB_EP7R_CTR_RX USB_EP7R_CTR_RX_Msk /*!< Correct Transfer for reception */

/*!< Common registers */
/*******************  Bit definition for USB_CNTR register  *******************/
#define USB_CNTR_FRES_Pos (0U)
#define USB_CNTR_FRES_Msk (0x1U << USB_CNTR_FRES_Pos) /*!< 0x00000001 */
#define USB_CNTR_FRES USB_CNTR_FRES_Msk /*!< Force USB Reset */
#define USB_CNTR_PDWN_Pos (1U)
#define USB_CNTR_PDWN_Msk (0x1U << USB_CNTR_PDWN_Pos) /*!< 0x00000002 */
#define USB_CNTR_PDWN USB_CNTR_PDWN_Msk /*!< Power down */
#define USB_CNTR_LP_MODE_Pos (2U)
#define USB_CNTR_LP_MODE_Msk (0x1U << USB_CNTR_LP_MODE_Pos) /*!< 0x00000004 */
#define USB_CNTR_LP_MODE USB_CNTR_LP_MODE_Msk /*!< Low-power mode */
#define USB_CNTR_FSUSP_Pos (3U)
#define USB_CNTR_FSUSP_Msk (0x1U << USB_CNTR_FSUSP_Pos) /*!< 0x00000008 */
#define USB_CNTR_FSUSP USB_CNTR_FSUSP_Msk /*!< Force suspend */
#define USB_CNTR_RESUME_Pos (4U)
#define USB_CNTR_RESUME_Msk (0x1U << USB_CNTR_RESUME_Pos) /*!< 0x00000010 */
#define USB_CNTR_RESUME USB_CNTR_RESUME_Msk /*!< Resume request */
#define USB_CNTR_ESOFM_Pos (8U)
#define USB_CNTR_ESOFM_Msk (0x1U << USB_CNTR_ESOFM_Pos) /*!< 0x00000100 */
#define USB_CNTR_ESOFM USB_CNTR_ESOFM_Msk /*!< Expected Start Of Frame Interrupt Mask */
#define USB_CNTR_SOFM_Pos (9U)
#define USB_CNTR_SOFM_Msk (0x1U << USB_CNTR_SOFM_Pos) /*!< 0x00000200 */
#define USB_CNTR_SOFM USB_CNTR_SOFM_Msk /*!< Start Of Frame Interrupt Mask */
#define USB_CNTR_RESETM_Pos (10U)
#define USB_CNTR_RESETM_Msk (0x1U << USB_CNTR_RESETM_Pos) /*!< 0x00000400 */
#define USB_CNTR_RESETM USB_CNTR_RESETM_Msk /*!< RESET Interrupt Mask */
#define USB_CNTR_SUSPM_Pos (11U)
#define USB_CNTR_SUSPM_Msk (0x1U << USB_CNTR_SUSPM_Pos) /*!< 0x00000800 */
#define USB_CNTR_SUSPM USB_CNTR_SUSPM_Msk /*!< Suspend mode Interrupt Mask */
#define USB_CNTR_WKUPM_Pos (12U)
#define USB_CNTR_WKUPM_Msk (0x1U << USB_CNTR_WKUPM_Pos) /*!< 0x00001000 */
#define USB_CNTR_WKUPM USB_CNTR_WKUPM_Msk /*!< Wakeup Interrupt Mask */
#define USB_CNTR_ERRM_Pos (13U)
#define USB_CNTR_ERRM_Msk (0x1U << USB_CNTR_ERRM_Pos) /*!< 0x00002000 */
#define USB_CNTR_ERRM USB_CNTR_ERRM_Msk /*!< Error Interrupt Mask */
#define USB_CNTR_PMAOVRM_Pos (14U)
#define USB_CNTR_PMAOVRM_Msk (0x1U << USB_CNTR_PMAOVRM_Pos) /*!< 0x00004000 */
#define USB_CNTR_PMAOVRM USB_CNTR_PMAOVRM_Msk /*!< Packet Memory Area Over / Underrun Interrupt Mask */
#define USB_CNTR_CTRM_Pos (15U)
#define USB_CNTR_CTRM_Msk (0x1U << USB_CNTR_CTRM_Pos) /*!< 0x00008000 */
#define USB_CNTR_CTRM USB_CNTR_CTRM_Msk /*!< Correct Transfer Interrupt Mask */

/*******************  Bit definition for USB_ISTR register  *******************/
#define USB_ISTR_EP_ID_Pos (0U)
#define USB_ISTR_EP_ID_Msk (0xFU << USB_ISTR_EP_ID_Pos) /*!< 0x0000000F */
#define USB_ISTR_EP_ID USB_ISTR_EP_ID_Msk /*!< Endpoint Identifier */
#define USB_ISTR_DIR_Pos (4U)
#define USB_ISTR_DIR_Msk (0x1U << USB_ISTR_DIR_Pos) /*!< 0x00000010 */
#define USB_ISTR_DIR USB_ISTR_DIR_Msk /*!< Direction of transaction */
#define USB_ISTR_ESOF_Pos (8U)
#define USB_ISTR_ESOF_Msk (0x1U << USB_ISTR_ESOF_Pos) /*!< 0x00000100 */
#define USB_ISTR_ESOF USB_ISTR_ESOF_Msk /*!< Expected Start Of Frame */
#define USB_ISTR_SOF_Pos (9U)
#define USB_ISTR_SOF_Msk (0x1U << USB_ISTR_SOF_Pos) /*!< 0x00000200 */
#define USB_ISTR_SOF USB_ISTR_SOF_Msk /*!< Start Of Frame */
#define USB_ISTR_RESET_Pos (10U)
#define USB_ISTR_RESET_Msk (0x1U << USB_ISTR_RESET_Pos) /*!< 0x00000400 */
#define USB_ISTR_RESET USB_ISTR_RESET_Msk /*!< USB RESET request */
#define USB_ISTR_SUSP_Pos (11U)
#define USB_ISTR_SUSP_Msk (0x1U << USB_ISTR_SUSP_Pos) /*!< 0x00000800 */
#define USB_ISTR_SUSP USB_ISTR_SUSP_Msk /*!< Suspend mode request */
#define USB_ISTR_WKUP_Pos (12U)
#define USB_ISTR_WKUP_Msk (0x1U << USB_ISTR_WKUP_Pos) /*!< 0x00001000 */
#define USB_ISTR_WKUP USB_ISTR_WKUP_Msk /*!< Wake up */
#define USB_ISTR_ERR_Pos (13U)
#define USB_ISTR_ERR_Msk (0x1U << USB_ISTR_ERR_Pos) /*!< 0x00002000 */
#define USB_ISTR_ERR USB_ISTR_ERR_Msk /*!< Error */
#define USB_ISTR_PMAOVR_Pos (14U)
#define USB_ISTR_PMAOVR_Msk (0x1U << USB_ISTR_PMAOVR_Pos) /*!< 0x00004000 */
#define USB_ISTR_PMAOVR USB_ISTR_PMAOVR_Msk /*!< Packet Memory Area Over / Underrun */
#define USB_ISTR_CTR_Pos (15U)
#define USB_ISTR_CTR_Msk (0x1U << USB_ISTR_CTR_Pos) /*!< 0x00008000 */
#define USB_ISTR_CTR USB_ISTR_CTR_Msk /*!< Correct Transfer */

/*******************  Bit definition for USB_FNR register  ********************/
#define USB_FNR_FN_Pos (0U)
#define USB_FNR_FN_Msk (0x7FFU << USB_FNR_FN_Pos) /*!< 0x000007FF */
#define USB_FNR_FN USB_FNR_FN_Msk /*!< Frame Number */
#define USB_FNR_LSOF_Pos (11U)
#define USB_FNR_LSOF_Msk (0x3U << USB_FNR_LSOF_Pos) /*!< 0x00001800 */
#define USB_FNR_LSOF USB_FNR_LSOF_Msk /*!< Lost SOF */
#define USB_FNR_LCK_Pos (13U)
#define USB_FNR_LCK_Msk (0x1U << USB_FNR_LCK_Pos) /*!< 0x00002000 */
#define USB_FNR_LCK USB_FNR_LCK_Msk /*!< Locked */
#define USB_FNR_RXDM_Pos (14U)
#define USB_FNR_RXDM_Msk (0x1U << USB_FNR_RXDM_Pos) /*!< 0x00004000 */
#define USB_FNR_RXDM USB_FNR_RXDM_Msk /*!< Receive Data - Line Status */
#define USB_FNR_RXDP_Pos (15U)
#define USB_FNR_RXDP_Msk (0x1U << USB_FNR_RXDP_Pos) /*!< 0x00008000 */
#define USB_FNR_RXDP USB_FNR_RXDP_Msk /*!< Receive Data + Line Status */

/******************  Bit definition for USB_DADDR register  *******************/
#define USB_DADDR_ADD_Pos (0U)
#define USB_DADDR_ADD_Msk (0x7FU << USB_DADDR_ADD_Pos) /*!< 0x0000007F */
#define USB_DADDR_ADD USB_DADDR_ADD_Msk /*!< ADD[6:0] bits (Device Address) */
#define USB_DADDR_ADD0_Pos (0U)
#define USB_DADDR_ADD0_Msk (0x1U << USB_DADDR_ADD0_Pos) /*!< 0x00000001 */
#define USB_DADDR_ADD0 USB_DADDR_ADD0_Msk /*!< Bit 0 */
#define USB_DADDR_ADD1_Pos (1U)
#define USB_DADDR_ADD1_Msk (0x1U << USB_DADDR_ADD1_Pos) /*!< 0x00000002 */
#define USB_DADDR_ADD1 USB_DADDR_ADD1_Msk /*!< Bit 1 */
#define USB_DADDR_ADD2_Pos (2U)
#define USB_DADDR_ADD2_Msk (0x1U << USB_DADDR_ADD2_Pos) /*!< 0x00000004 */
#define USB_DADDR_ADD2 USB_DADDR_ADD2_Msk /*!< Bit 2 */
#define USB_DADDR_ADD3_Pos (3U)
#define USB_DADDR_ADD3_Msk (0x1U << USB_DADDR_ADD3_Pos) /*!< 0x00000008 */
#define USB_DADDR_ADD3 USB_DADDR_ADD3_Msk /*!< Bit 3 */
#define USB_DADDR_ADD4_Pos (4U)
#define USB_DADDR_ADD4_Msk (0x1U << USB_DADDR_ADD4_Pos) /*!< 0x00000010 */
#define USB_DADDR_ADD4 USB_DADDR_ADD4_Msk /*!< Bit 4 */
#define USB_DADDR_ADD5_Pos (5U)
#define USB_DADDR_ADD5_Msk (0x1U << USB_DADDR_ADD5_Pos) /*!< 0x00000020 */
#define USB_DADDR_ADD5 USB_DADDR_ADD5_Msk /*!< Bit 5 */
#define USB_DADDR_ADD6_Pos (6U)
#define USB_DADDR_ADD6_Msk (0x1U << USB_DADDR_ADD6_Pos) /*!< 0x00000040 */
#define USB_DADDR_ADD6 USB_DADDR_ADD6_Msk /*!< Bit 6 */

#define USB_DADDR_EF_Pos (7U)
#define USB_DADDR_EF_Msk (0x1U << USB_DADDR_EF_Pos) /*!< 0x00000080 */
#define USB_DADDR_EF USB_DADDR_EF_Msk /*!< Enable Function */

/******************  Bit definition for USB_BTABLE register  ******************/
#define USB_BTABLE_BTABLE_Pos (3U)
#define USB_BTABLE_BTABLE_Msk (0x1FFFU << USB_BTABLE_BTABLE_Pos) /*!< 0x0000FFF8 */
#define USB_BTABLE_BTABLE USB_BTABLE_BTABLE_Msk /*!< Buffer Table */

/*!< Buffer descriptor table */
/*****************  Bit definition for USB_ADDR0_TX register  *****************/
#define USB_ADDR0_TX_ADDR0_TX_Pos (1U)
#define USB_ADDR0_TX_ADDR0_TX_Msk (0x7FFFU << USB_ADDR0_TX_ADDR0_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR0_TX_ADDR0_TX USB_ADDR0_TX_ADDR0_TX_Msk /*!< Transmission Buffer Address 0 */

/*****************  Bit definition for USB_ADDR1_TX register  *****************/
#define USB_ADDR1_TX_ADDR1_TX_Pos (1U)
#define USB_ADDR1_TX_ADDR1_TX_Msk (0x7FFFU << USB_ADDR1_TX_ADDR1_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR1_TX_ADDR1_TX USB_ADDR1_TX_ADDR1_TX_Msk /*!< Transmission Buffer Address 1 */

/*****************  Bit definition for USB_ADDR2_TX register  *****************/
#define USB_ADDR2_TX_ADDR2_TX_Pos (1U)
#define USB_ADDR2_TX_ADDR2_TX_Msk (0x7FFFU << USB_ADDR2_TX_ADDR2_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR2_TX_ADDR2_TX USB_ADDR2_TX_ADDR2_TX_Msk /*!< Transmission Buffer Address 2 */

/*****************  Bit definition for USB_ADDR3_TX register  *****************/
#define USB_ADDR3_TX_ADDR3_TX_Pos (1U)
#define USB_ADDR3_TX_ADDR3_TX_Msk (0x7FFFU << USB_ADDR3_TX_ADDR3_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR3_TX_ADDR3_TX USB_ADDR3_TX_ADDR3_TX_Msk /*!< Transmission Buffer Address 3 */

/*****************  Bit definition for USB_ADDR4_TX register  *****************/
#define USB_ADDR4_TX_ADDR4_TX_Pos (1U)
#define USB_ADDR4_TX_ADDR4_TX_Msk (0x7FFFU << USB_ADDR4_TX_ADDR4_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR4_TX_ADDR4_TX USB_ADDR4_TX_ADDR4_TX_Msk /*!< Transmission Buffer Address 4 */

/*****************  Bit definition for USB_ADDR5_TX register  *****************/
#define USB_ADDR5_TX_ADDR5_TX_Pos (1U)
#define USB_ADDR5_TX_ADDR5_TX_Msk (0x7FFFU << USB_ADDR5_TX_ADDR5_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR5_TX_ADDR5_TX USB_ADDR5_TX_ADDR5_TX_Msk /*!< Transmission Buffer Address 5 */

/*****************  Bit definition for USB_ADDR6_TX register  *****************/
#define USB_ADDR6_TX_ADDR6_TX_Pos (1U)
#define USB_ADDR6_TX_ADDR6_TX_Msk (0x7FFFU << USB_ADDR6_TX_ADDR6_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR6_TX_ADDR6_TX USB_ADDR6_TX_ADDR6_TX_Msk /*!< Transmission Buffer Address 6 */

/*****************  Bit definition for USB_ADDR7_TX register  *****************/
#define USB_ADDR7_TX_ADDR7_TX_Pos (1U)
#define USB_ADDR7_TX_ADDR7_TX_Msk (0x7FFFU << USB_ADDR7_TX_ADDR7_TX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR7_TX_ADDR7_TX USB_ADDR7_TX_ADDR7_TX_Msk /*!< Transmission Buffer Address 7 */

/*----------------------------------------------------------------------------*/

/*****************  Bit definition for USB_COUNT0_TX register  ****************/
#define USB_COUNT0_TX_COUNT0_TX_Pos (0U)
#define USB_COUNT0_TX_COUNT0_TX_Msk (0x3FFU << USB_COUNT0_TX_COUNT0_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT0_TX_COUNT0_TX USB_COUNT0_TX_COUNT0_TX_Msk /*!< Transmission Byte Count 0 */

/*****************  Bit definition for USB_COUNT1_TX register  ****************/
#define USB_COUNT1_TX_COUNT1_TX_Pos (0U)
#define USB_COUNT1_TX_COUNT1_TX_Msk (0x3FFU << USB_COUNT1_TX_COUNT1_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT1_TX_COUNT1_TX USB_COUNT1_TX_COUNT1_TX_Msk /*!< Transmission Byte Count 1 */

/*****************  Bit definition for USB_COUNT2_TX register  ****************/
#define USB_COUNT2_TX_COUNT2_TX_Pos (0U)
#define USB_COUNT2_TX_COUNT2_TX_Msk (0x3FFU << USB_COUNT2_TX_COUNT2_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT2_TX_COUNT2_TX USB_COUNT2_TX_COUNT2_TX_Msk /*!< Transmission Byte Count 2 */

/*****************  Bit definition for USB_COUNT3_TX register  ****************/
#define USB_COUNT3_TX_COUNT3_TX_Pos (0U)
#define USB_COUNT3_TX_COUNT3_TX_Msk (0x3FFU << USB_COUNT3_TX_COUNT3_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT3_TX_COUNT3_TX USB_COUNT3_TX_COUNT3_TX_Msk /*!< Transmission Byte Count 3 */

/*****************  Bit definition for USB_COUNT4_TX register  ****************/
#define USB_COUNT4_TX_COUNT4_TX_Pos (0U)
#define USB_COUNT4_TX_COUNT4_TX_Msk (0x3FFU << USB_COUNT4_TX_COUNT4_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT4_TX_COUNT4_TX USB_COUNT4_TX_COUNT4_TX_Msk /*!< Transmission Byte Count 4 */

/*****************  Bit definition for USB_COUNT5_TX register  ****************/
#define USB_COUNT5_TX_COUNT5_TX_Pos (0U)
#define USB_COUNT5_TX_COUNT5_TX_Msk (0x3FFU << USB_COUNT5_TX_COUNT5_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT5_TX_COUNT5_TX USB_COUNT5_TX_COUNT5_TX_Msk /*!< Transmission Byte Count 5 */

/*****************  Bit definition for USB_COUNT6_TX register  ****************/
#define USB_COUNT6_TX_COUNT6_TX_Pos (0U)
#define USB_COUNT6_TX_COUNT6_TX_Msk (0x3FFU << USB_COUNT6_TX_COUNT6_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT6_TX_COUNT6_TX USB_COUNT6_TX_COUNT6_TX_Msk /*!< Transmission Byte Count 6 */

/*****************  Bit definition for USB_COUNT7_TX register  ****************/
#define USB_COUNT7_TX_COUNT7_TX_Pos (0U)
#define USB_COUNT7_TX_COUNT7_TX_Msk (0x3FFU << USB_COUNT7_TX_COUNT7_TX_Pos) /*!< 0x000003FF */
#define USB_COUNT7_TX_COUNT7_TX USB_COUNT7_TX_COUNT7_TX_Msk /*!< Transmission Byte Count 7 */

/*----------------------------------------------------------------------------*/

/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/
#define USB_COUNT0_TX_0_COUNT0_TX_0 0x000003FFU /*!< Transmission Byte Count 0 (low) */

/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/
#define USB_COUNT0_TX_1_COUNT0_TX_1 0x03FF0000U /*!< Transmission Byte Count 0 (high) */

/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/
#define USB_COUNT1_TX_0_COUNT1_TX_0 0x000003FFU /*!< Transmission Byte Count 1 (low) */

/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/
#define USB_COUNT1_TX_1_COUNT1_TX_1 0x03FF0000U /*!< Transmission Byte Count 1 (high) */

/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/
#define USB_COUNT2_TX_0_COUNT2_TX_0 0x000003FFU /*!< Transmission Byte Count 2 (low) */

/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/
#define USB_COUNT2_TX_1_COUNT2_TX_1 0x03FF0000U /*!< Transmission Byte Count 2 (high) */

/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/
#define USB_COUNT3_TX_0_COUNT3_TX_0 0x000003FFU /*!< Transmission Byte Count 3 (low) */

/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/
#define USB_COUNT3_TX_1_COUNT3_TX_1 0x03FF0000U /*!< Transmission Byte Count 3 (high) */

/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/
#define USB_COUNT4_TX_0_COUNT4_TX_0 0x000003FFU /*!< Transmission Byte Count 4 (low) */

/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/
#define USB_COUNT4_TX_1_COUNT4_TX_1 0x03FF0000U /*!< Transmission Byte Count 4 (high) */

/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/
#define USB_COUNT5_TX_0_COUNT5_TX_0 0x000003FFU /*!< Transmission Byte Count 5 (low) */

/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/
#define USB_COUNT5_TX_1_COUNT5_TX_1 0x03FF0000U /*!< Transmission Byte Count 5 (high) */

/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/
#define USB_COUNT6_TX_0_COUNT6_TX_0 0x000003FFU /*!< Transmission Byte Count 6 (low) */

/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/
#define USB_COUNT6_TX_1_COUNT6_TX_1 0x03FF0000U /*!< Transmission Byte Count 6 (high) */

/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/
#define USB_COUNT7_TX_0_COUNT7_TX_0 0x000003FFU /*!< Transmission Byte Count 7 (low) */

/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/
#define USB_COUNT7_TX_1_COUNT7_TX_1 0x03FF0000U /*!< Transmission Byte Count 7 (high) */

/*----------------------------------------------------------------------------*/

/*****************  Bit definition for USB_ADDR0_RX register  *****************/
#define USB_ADDR0_RX_ADDR0_RX_Pos (1U)
#define USB_ADDR0_RX_ADDR0_RX_Msk (0x7FFFU << USB_ADDR0_RX_ADDR0_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR0_RX_ADDR0_RX USB_ADDR0_RX_ADDR0_RX_Msk /*!< Reception Buffer Address 0 */

/*****************  Bit definition for USB_ADDR1_RX register  *****************/
#define USB_ADDR1_RX_ADDR1_RX_Pos (1U)
#define USB_ADDR1_RX_ADDR1_RX_Msk (0x7FFFU << USB_ADDR1_RX_ADDR1_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR1_RX_ADDR1_RX USB_ADDR1_RX_ADDR1_RX_Msk /*!< Reception Buffer Address 1 */

/*****************  Bit definition for USB_ADDR2_RX register  *****************/
#define USB_ADDR2_RX_ADDR2_RX_Pos (1U)
#define USB_ADDR2_RX_ADDR2_RX_Msk (0x7FFFU << USB_ADDR2_RX_ADDR2_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR2_RX_ADDR2_RX USB_ADDR2_RX_ADDR2_RX_Msk /*!< Reception Buffer Address 2 */

/*****************  Bit definition for USB_ADDR3_RX register  *****************/
#define USB_ADDR3_RX_ADDR3_RX_Pos (1U)
#define USB_ADDR3_RX_ADDR3_RX_Msk (0x7FFFU << USB_ADDR3_RX_ADDR3_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR3_RX_ADDR3_RX USB_ADDR3_RX_ADDR3_RX_Msk /*!< Reception Buffer Address 3 */

/*****************  Bit definition for USB_ADDR4_RX register  *****************/
#define USB_ADDR4_RX_ADDR4_RX_Pos (1U)
#define USB_ADDR4_RX_ADDR4_RX_Msk (0x7FFFU << USB_ADDR4_RX_ADDR4_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR4_RX_ADDR4_RX USB_ADDR4_RX_ADDR4_RX_Msk /*!< Reception Buffer Address 4 */

/*****************  Bit definition for USB_ADDR5_RX register  *****************/
#define USB_ADDR5_RX_ADDR5_RX_Pos (1U)
#define USB_ADDR5_RX_ADDR5_RX_Msk (0x7FFFU << USB_ADDR5_RX_ADDR5_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR5_RX_ADDR5_RX USB_ADDR5_RX_ADDR5_RX_Msk /*!< Reception Buffer Address 5 */

/*****************  Bit definition for USB_ADDR6_RX register  *****************/
#define USB_ADDR6_RX_ADDR6_RX_Pos (1U)
#define USB_ADDR6_RX_ADDR6_RX_Msk (0x7FFFU << USB_ADDR6_RX_ADDR6_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR6_RX_ADDR6_RX USB_ADDR6_RX_ADDR6_RX_Msk /*!< Reception Buffer Address 6 */

/*****************  Bit definition for USB_ADDR7_RX register  *****************/
#define USB_ADDR7_RX_ADDR7_RX_Pos (1U)
#define USB_ADDR7_RX_ADDR7_RX_Msk (0x7FFFU << USB_ADDR7_RX_ADDR7_RX_Pos) /*!< 0x0000FFFE */
#define USB_ADDR7_RX_ADDR7_RX USB_ADDR7_RX_ADDR7_RX_Msk /*!< Reception Buffer Address 7 */

/*----------------------------------------------------------------------------*/

/*****************  Bit definition for USB_COUNT0_RX register  ****************/
#define USB_COUNT0_RX_COUNT0_RX_Pos (0U)
#define USB_COUNT0_RX_COUNT0_RX_Msk (0x3FFU << USB_COUNT0_RX_COUNT0_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT0_RX_COUNT0_RX USB_COUNT0_RX_COUNT0_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT0_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT0_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT0_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT0_RX_NUM_BLOCK USB_COUNT0_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT0_RX_NUM_BLOCK_0 (0x01U << USB_COUNT0_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT0_RX_NUM_BLOCK_1 (0x02U << USB_COUNT0_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT0_RX_NUM_BLOCK_2 (0x04U << USB_COUNT0_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT0_RX_NUM_BLOCK_3 (0x08U << USB_COUNT0_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT0_RX_NUM_BLOCK_4 (0x10U << USB_COUNT0_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT0_RX_BLSIZE_Pos (15U)
#define USB_COUNT0_RX_BLSIZE_Msk (0x1U << USB_COUNT0_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT0_RX_BLSIZE USB_COUNT0_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT1_RX register  ****************/
#define USB_COUNT1_RX_COUNT1_RX_Pos (0U)
#define USB_COUNT1_RX_COUNT1_RX_Msk (0x3FFU << USB_COUNT1_RX_COUNT1_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT1_RX_COUNT1_RX USB_COUNT1_RX_COUNT1_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT1_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT1_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT1_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT1_RX_NUM_BLOCK USB_COUNT1_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT1_RX_NUM_BLOCK_0 (0x01U << USB_COUNT1_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT1_RX_NUM_BLOCK_1 (0x02U << USB_COUNT1_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT1_RX_NUM_BLOCK_2 (0x04U << USB_COUNT1_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT1_RX_NUM_BLOCK_3 (0x08U << USB_COUNT1_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT1_RX_NUM_BLOCK_4 (0x10U << USB_COUNT1_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT1_RX_BLSIZE_Pos (15U)
#define USB_COUNT1_RX_BLSIZE_Msk (0x1U << USB_COUNT1_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT1_RX_BLSIZE USB_COUNT1_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT2_RX register  ****************/
#define USB_COUNT2_RX_COUNT2_RX_Pos (0U)
#define USB_COUNT2_RX_COUNT2_RX_Msk (0x3FFU << USB_COUNT2_RX_COUNT2_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT2_RX_COUNT2_RX USB_COUNT2_RX_COUNT2_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT2_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT2_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT2_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT2_RX_NUM_BLOCK USB_COUNT2_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT2_RX_NUM_BLOCK_0 (0x01U << USB_COUNT2_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT2_RX_NUM_BLOCK_1 (0x02U << USB_COUNT2_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT2_RX_NUM_BLOCK_2 (0x04U << USB_COUNT2_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT2_RX_NUM_BLOCK_3 (0x08U << USB_COUNT2_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT2_RX_NUM_BLOCK_4 (0x10U << USB_COUNT2_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT2_RX_BLSIZE_Pos (15U)
#define USB_COUNT2_RX_BLSIZE_Msk (0x1U << USB_COUNT2_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT2_RX_BLSIZE USB_COUNT2_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT3_RX register  ****************/
#define USB_COUNT3_RX_COUNT3_RX_Pos (0U)
#define USB_COUNT3_RX_COUNT3_RX_Msk (0x3FFU << USB_COUNT3_RX_COUNT3_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT3_RX_COUNT3_RX USB_COUNT3_RX_COUNT3_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT3_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT3_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT3_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT3_RX_NUM_BLOCK USB_COUNT3_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT3_RX_NUM_BLOCK_0 (0x01U << USB_COUNT3_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT3_RX_NUM_BLOCK_1 (0x02U << USB_COUNT3_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT3_RX_NUM_BLOCK_2 (0x04U << USB_COUNT3_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT3_RX_NUM_BLOCK_3 (0x08U << USB_COUNT3_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT3_RX_NUM_BLOCK_4 (0x10U << USB_COUNT3_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT3_RX_BLSIZE_Pos (15U)
#define USB_COUNT3_RX_BLSIZE_Msk (0x1U << USB_COUNT3_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT3_RX_BLSIZE USB_COUNT3_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT4_RX register  ****************/
#define USB_COUNT4_RX_COUNT4_RX_Pos (0U)
#define USB_COUNT4_RX_COUNT4_RX_Msk (0x3FFU << USB_COUNT4_RX_COUNT4_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT4_RX_COUNT4_RX USB_COUNT4_RX_COUNT4_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT4_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT4_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT4_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT4_RX_NUM_BLOCK USB_COUNT4_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT4_RX_NUM_BLOCK_0 (0x01U << USB_COUNT4_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT4_RX_NUM_BLOCK_1 (0x02U << USB_COUNT4_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT4_RX_NUM_BLOCK_2 (0x04U << USB_COUNT4_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT4_RX_NUM_BLOCK_3 (0x08U << USB_COUNT4_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT4_RX_NUM_BLOCK_4 (0x10U << USB_COUNT4_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT4_RX_BLSIZE_Pos (15U)
#define USB_COUNT4_RX_BLSIZE_Msk (0x1U << USB_COUNT4_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT4_RX_BLSIZE USB_COUNT4_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT5_RX register  ****************/
#define USB_COUNT5_RX_COUNT5_RX_Pos (0U)
#define USB_COUNT5_RX_COUNT5_RX_Msk (0x3FFU << USB_COUNT5_RX_COUNT5_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT5_RX_COUNT5_RX USB_COUNT5_RX_COUNT5_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT5_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT5_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT5_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT5_RX_NUM_BLOCK USB_COUNT5_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT5_RX_NUM_BLOCK_0 (0x01U << USB_COUNT5_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT5_RX_NUM_BLOCK_1 (0x02U << USB_COUNT5_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT5_RX_NUM_BLOCK_2 (0x04U << USB_COUNT5_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT5_RX_NUM_BLOCK_3 (0x08U << USB_COUNT5_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT5_RX_NUM_BLOCK_4 (0x10U << USB_COUNT5_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT5_RX_BLSIZE_Pos (15U)
#define USB_COUNT5_RX_BLSIZE_Msk (0x1U << USB_COUNT5_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT5_RX_BLSIZE USB_COUNT5_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT6_RX register  ****************/
#define USB_COUNT6_RX_COUNT6_RX_Pos (0U)
#define USB_COUNT6_RX_COUNT6_RX_Msk (0x3FFU << USB_COUNT6_RX_COUNT6_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT6_RX_COUNT6_RX USB_COUNT6_RX_COUNT6_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT6_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT6_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT6_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT6_RX_NUM_BLOCK USB_COUNT6_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT6_RX_NUM_BLOCK_0 (0x01U << USB_COUNT6_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT6_RX_NUM_BLOCK_1 (0x02U << USB_COUNT6_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT6_RX_NUM_BLOCK_2 (0x04U << USB_COUNT6_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT6_RX_NUM_BLOCK_3 (0x08U << USB_COUNT6_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT6_RX_NUM_BLOCK_4 (0x10U << USB_COUNT6_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT6_RX_BLSIZE_Pos (15U)
#define USB_COUNT6_RX_BLSIZE_Msk (0x1U << USB_COUNT6_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT6_RX_BLSIZE USB_COUNT6_RX_BLSIZE_Msk /*!< BLock SIZE */

/*****************  Bit definition for USB_COUNT7_RX register  ****************/
#define USB_COUNT7_RX_COUNT7_RX_Pos (0U)
#define USB_COUNT7_RX_COUNT7_RX_Msk (0x3FFU << USB_COUNT7_RX_COUNT7_RX_Pos) /*!< 0x000003FF */
#define USB_COUNT7_RX_COUNT7_RX USB_COUNT7_RX_COUNT7_RX_Msk /*!< Reception Byte Count */

#define USB_COUNT7_RX_NUM_BLOCK_Pos (10U)
#define USB_COUNT7_RX_NUM_BLOCK_Msk (0x1FU << USB_COUNT7_RX_NUM_BLOCK_Pos) /*!< 0x00007C00 */
#define USB_COUNT7_RX_NUM_BLOCK USB_COUNT7_RX_NUM_BLOCK_Msk /*!< NUM_BLOCK[4:0] bits (Number of blocks) */
#define USB_COUNT7_RX_NUM_BLOCK_0 (0x01U << USB_COUNT7_RX_NUM_BLOCK_Pos) /*!< 0x00000400 */
#define USB_COUNT7_RX_NUM_BLOCK_1 (0x02U << USB_COUNT7_RX_NUM_BLOCK_Pos) /*!< 0x00000800 */
#define USB_COUNT7_RX_NUM_BLOCK_2 (0x04U << USB_COUNT7_RX_NUM_BLOCK_Pos) /*!< 0x00001000 */
#define USB_COUNT7_RX_NUM_BLOCK_3 (0x08U << USB_COUNT7_RX_NUM_BLOCK_Pos) /*!< 0x00002000 */
#define USB_COUNT7_RX_NUM_BLOCK_4 (0x10U << USB_COUNT7_RX_NUM_BLOCK_Pos) /*!< 0x00004000 */

#define USB_COUNT7_RX_BLSIZE_Pos (15U)
#define USB_COUNT7_RX_BLSIZE_Msk (0x1U << USB_COUNT7_RX_BLSIZE_Pos) /*!< 0x00008000 */
#define USB_COUNT7_RX_BLSIZE USB_COUNT7_RX_BLSIZE_Msk /*!< BLock SIZE */

/*----------------------------------------------------------------------------*/

/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/
#define USB_COUNT0_RX_0_COUNT0_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT0_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT0_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT0_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT0_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT0_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT0_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT0_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/
#define USB_COUNT0_RX_1_COUNT0_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT0_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT0_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 1 */
#define USB_COUNT0_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT0_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT0_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT0_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT0_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/
#define USB_COUNT1_RX_0_COUNT1_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT1_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT1_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT1_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT1_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT1_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT1_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT1_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/
#define USB_COUNT1_RX_1_COUNT1_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT1_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT1_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT1_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT1_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT1_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT1_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT1_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/
#define USB_COUNT2_RX_0_COUNT2_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT2_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT2_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT2_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT2_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT2_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT2_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT2_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/
#define USB_COUNT2_RX_1_COUNT2_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT2_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT2_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT2_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT2_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT2_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT2_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT2_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/
#define USB_COUNT3_RX_0_COUNT3_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT3_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT3_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT3_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT3_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT3_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT3_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT3_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/
#define USB_COUNT3_RX_1_COUNT3_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT3_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT3_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT3_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT3_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT3_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT3_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT3_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/
#define USB_COUNT4_RX_0_COUNT4_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT4_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT4_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT4_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT4_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT4_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT4_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT4_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/
#define USB_COUNT4_RX_1_COUNT4_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT4_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT4_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT4_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT4_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT4_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT4_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT4_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/
#define USB_COUNT5_RX_0_COUNT5_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT5_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT5_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT5_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT5_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT5_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT5_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT5_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/
#define USB_COUNT5_RX_1_COUNT5_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT5_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT5_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT5_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT5_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT5_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT5_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT5_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/
#define USB_COUNT6_RX_0_COUNT6_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT6_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT6_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT6_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT6_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT6_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT6_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT6_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/
#define USB_COUNT6_RX_1_COUNT6_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT6_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT6_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT6_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT6_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT6_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT6_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT6_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/
#define USB_COUNT7_RX_0_COUNT7_RX_0 0x000003FFU /*!< Reception Byte Count (low) */

#define USB_COUNT7_RX_0_NUM_BLOCK_0 0x00007C00U /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */
#define USB_COUNT7_RX_0_NUM_BLOCK_0_0 0x00000400U /*!< Bit 0 */
#define USB_COUNT7_RX_0_NUM_BLOCK_0_1 0x00000800U /*!< Bit 1 */
#define USB_COUNT7_RX_0_NUM_BLOCK_0_2 0x00001000U /*!< Bit 2 */
#define USB_COUNT7_RX_0_NUM_BLOCK_0_3 0x00002000U /*!< Bit 3 */
#define USB_COUNT7_RX_0_NUM_BLOCK_0_4 0x00004000U /*!< Bit 4 */

#define USB_COUNT7_RX_0_BLSIZE_0 0x00008000U /*!< BLock SIZE (low) */

/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/
#define USB_COUNT7_RX_1_COUNT7_RX_1 0x03FF0000U /*!< Reception Byte Count (high) */

#define USB_COUNT7_RX_1_NUM_BLOCK_1 0x7C000000U /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */
#define USB_COUNT7_RX_1_NUM_BLOCK_1_0 0x04000000U /*!< Bit 0 */
#define USB_COUNT7_RX_1_NUM_BLOCK_1_1 0x08000000U /*!< Bit 1 */
#define USB_COUNT7_RX_1_NUM_BLOCK_1_2 0x10000000U /*!< Bit 2 */
#define USB_COUNT7_RX_1_NUM_BLOCK_1_3 0x20000000U /*!< Bit 3 */
#define USB_COUNT7_RX_1_NUM_BLOCK_1_4 0x40000000U /*!< Bit 4 */

#define USB_COUNT7_RX_1_BLSIZE_1 0x80000000U /*!< BLock SIZE (high) */

/******************************************************************************/
/*                                                                            */
/*                         Controller Area Network                            */
/*                                                                            */
/******************************************************************************/

/*!< CAN control and status registers */
/*******************  Bit definition for CAN_MCR register  ********************/
#define CAN_MCR_INRQ_Pos (0U)
#define CAN_MCR_INRQ_Msk (0x1U << CAN_MCR_INRQ_Pos) /*!< 0x00000001 */
#define CAN_MCR_INRQ CAN_MCR_INRQ_Msk /*!< Initialization Request */
#define CAN_MCR_SLEEP_Pos (1U)
#define CAN_MCR_SLEEP_Msk (0x1U << CAN_MCR_SLEEP_Pos) /*!< 0x00000002 */
#define CAN_MCR_SLEEP CAN_MCR_SLEEP_Msk /*!< Sleep Mode Request */
#define CAN_MCR_TXFP_Pos (2U)
#define CAN_MCR_TXFP_Msk (0x1U << CAN_MCR_TXFP_Pos) /*!< 0x00000004 */
#define CAN_MCR_TXFP CAN_MCR_TXFP_Msk /*!< Transmit FIFO Priority */
#define CAN_MCR_RFLM_Pos (3U)
#define CAN_MCR_RFLM_Msk (0x1U << CAN_MCR_RFLM_Pos) /*!< 0x00000008 */
#define CAN_MCR_RFLM CAN_MCR_RFLM_Msk /*!< Receive FIFO Locked Mode */
#define CAN_MCR_NART_Pos (4U)
#define CAN_MCR_NART_Msk (0x1U << CAN_MCR_NART_Pos) /*!< 0x00000010 */
#define CAN_MCR_NART CAN_MCR_NART_Msk /*!< No Automatic Retransmission */
#define CAN_MCR_AWUM_Pos (5U)
#define CAN_MCR_AWUM_Msk (0x1U << CAN_MCR_AWUM_Pos) /*!< 0x00000020 */
#define CAN_MCR_AWUM CAN_MCR_AWUM_Msk /*!< Automatic Wakeup Mode */
#define CAN_MCR_ABOM_Pos (6U)
#define CAN_MCR_ABOM_Msk (0x1U << CAN_MCR_ABOM_Pos) /*!< 0x00000040 */
#define CAN_MCR_ABOM CAN_MCR_ABOM_Msk /*!< Automatic Bus-Off Management */
#define CAN_MCR_TTCM_Pos (7U)
#define CAN_MCR_TTCM_Msk (0x1U << CAN_MCR_TTCM_Pos) /*!< 0x00000080 */
#define CAN_MCR_TTCM CAN_MCR_TTCM_Msk /*!< Time Triggered Communication Mode */
#define CAN_MCR_RESET_Pos (15U)
#define CAN_MCR_RESET_Msk (0x1U << CAN_MCR_RESET_Pos) /*!< 0x00008000 */
#define CAN_MCR_RESET CAN_MCR_RESET_Msk /*!< CAN software master reset */
#define CAN_MCR_DBF_Pos (16U)
#define CAN_MCR_DBF_Msk (0x1U << CAN_MCR_DBF_Pos) /*!< 0x00010000 */
#define CAN_MCR_DBF CAN_MCR_DBF_Msk /*!< CAN Debug freeze */

/*******************  Bit definition for CAN_MSR register  ********************/
#define CAN_MSR_INAK_Pos (0U)
#define CAN_MSR_INAK_Msk (0x1U << CAN_MSR_INAK_Pos) /*!< 0x00000001 */
#define CAN_MSR_INAK CAN_MSR_INAK_Msk /*!< Initialization Acknowledge */
#define CAN_MSR_SLAK_Pos (1U)
#define CAN_MSR_SLAK_Msk (0x1U << CAN_MSR_SLAK_Pos) /*!< 0x00000002 */
#define CAN_MSR_SLAK CAN_MSR_SLAK_Msk /*!< Sleep Acknowledge */
#define CAN_MSR_ERRI_Pos (2U)
#define CAN_MSR_ERRI_Msk (0x1U << CAN_MSR_ERRI_Pos) /*!< 0x00000004 */
#define CAN_MSR_ERRI CAN_MSR_ERRI_Msk /*!< Error Interrupt */
#define CAN_MSR_WKUI_Pos (3U)
#define CAN_MSR_WKUI_Msk (0x1U << CAN_MSR_WKUI_Pos) /*!< 0x00000008 */
#define CAN_MSR_WKUI CAN_MSR_WKUI_Msk /*!< Wakeup Interrupt */
#define CAN_MSR_SLAKI_Pos (4U)
#define CAN_MSR_SLAKI_Msk (0x1U << CAN_MSR_SLAKI_Pos) /*!< 0x00000010 */
#define CAN_MSR_SLAKI CAN_MSR_SLAKI_Msk /*!< Sleep Acknowledge Interrupt */
#define CAN_MSR_TXM_Pos (8U)
#define CAN_MSR_TXM_Msk (0x1U << CAN_MSR_TXM_Pos) /*!< 0x00000100 */
#define CAN_MSR_TXM CAN_MSR_TXM_Msk /*!< Transmit Mode */
#define CAN_MSR_RXM_Pos (9U)
#define CAN_MSR_RXM_Msk (0x1U << CAN_MSR_RXM_Pos) /*!< 0x00000200 */
#define CAN_MSR_RXM CAN_MSR_RXM_Msk /*!< Receive Mode */
#define CAN_MSR_SAMP_Pos (10U)
#define CAN_MSR_SAMP_Msk (0x1U << CAN_MSR_SAMP_Pos) /*!< 0x00000400 */
#define CAN_MSR_SAMP CAN_MSR_SAMP_Msk /*!< Last Sample Point */
#define CAN_MSR_RX_Pos (11U)
#define CAN_MSR_RX_Msk (0x1U << CAN_MSR_RX_Pos) /*!< 0x00000800 */
#define CAN_MSR_RX CAN_MSR_RX_Msk /*!< CAN Rx Signal */

/*******************  Bit definition for CAN_TSR register  ********************/
#define CAN_TSR_RQCP0_Pos (0U)
#define CAN_TSR_RQCP0_Msk (0x1U << CAN_TSR_RQCP0_Pos) /*!< 0x00000001 */
#define CAN_TSR_RQCP0 CAN_TSR_RQCP0_Msk /*!< Request Completed Mailbox0 */
#define CAN_TSR_TXOK0_Pos (1U)
#define CAN_TSR_TXOK0_Msk (0x1U << CAN_TSR_TXOK0_Pos) /*!< 0x00000002 */
#define CAN_TSR_TXOK0 CAN_TSR_TXOK0_Msk /*!< Transmission OK of Mailbox0 */
#define CAN_TSR_ALST0_Pos (2U)
#define CAN_TSR_ALST0_Msk (0x1U << CAN_TSR_ALST0_Pos) /*!< 0x00000004 */
#define CAN_TSR_ALST0 CAN_TSR_ALST0_Msk /*!< Arbitration Lost for Mailbox0 */
#define CAN_TSR_TERR0_Pos (3U)
#define CAN_TSR_TERR0_Msk (0x1U << CAN_TSR_TERR0_Pos) /*!< 0x00000008 */
#define CAN_TSR_TERR0 CAN_TSR_TERR0_Msk /*!< Transmission Error of Mailbox0 */
#define CAN_TSR_ABRQ0_Pos (7U)
#define CAN_TSR_ABRQ0_Msk (0x1U << CAN_TSR_ABRQ0_Pos) /*!< 0x00000080 */
#define CAN_TSR_ABRQ0 CAN_TSR_ABRQ0_Msk /*!< Abort Request for Mailbox0 */
#define CAN_TSR_RQCP1_Pos (8U)
#define CAN_TSR_RQCP1_Msk (0x1U << CAN_TSR_RQCP1_Pos) /*!< 0x00000100 */
#define CAN_TSR_RQCP1 CAN_TSR_RQCP1_Msk /*!< Request Completed Mailbox1 */
#define CAN_TSR_TXOK1_Pos (9U)
#define CAN_TSR_TXOK1_Msk (0x1U << CAN_TSR_TXOK1_Pos) /*!< 0x00000200 */
#define CAN_TSR_TXOK1 CAN_TSR_TXOK1_Msk /*!< Transmission OK of Mailbox1 */
#define CAN_TSR_ALST1_Pos (10U)
#define CAN_TSR_ALST1_Msk (0x1U << CAN_TSR_ALST1_Pos) /*!< 0x00000400 */
#define CAN_TSR_ALST1 CAN_TSR_ALST1_Msk /*!< Arbitration Lost for Mailbox1 */
#define CAN_TSR_TERR1_Pos (11U)
#define CAN_TSR_TERR1_Msk (0x1U << CAN_TSR_TERR1_Pos) /*!< 0x00000800 */
#define CAN_TSR_TERR1 CAN_TSR_TERR1_Msk /*!< Transmission Error of Mailbox1 */
#define CAN_TSR_ABRQ1_Pos (15U)
#define CAN_TSR_ABRQ1_Msk (0x1U << CAN_TSR_ABRQ1_Pos) /*!< 0x00008000 */
#define CAN_TSR_ABRQ1 CAN_TSR_ABRQ1_Msk /*!< Abort Request for Mailbox 1 */
#define CAN_TSR_RQCP2_Pos (16U)
#define CAN_TSR_RQCP2_Msk (0x1U << CAN_TSR_RQCP2_Pos) /*!< 0x00010000 */
#define CAN_TSR_RQCP2 CAN_TSR_RQCP2_Msk /*!< Request Completed Mailbox2 */
#define CAN_TSR_TXOK2_Pos (17U)
#define CAN_TSR_TXOK2_Msk (0x1U << CAN_TSR_TXOK2_Pos) /*!< 0x00020000 */
#define CAN_TSR_TXOK2 CAN_TSR_TXOK2_Msk /*!< Transmission OK of Mailbox 2 */
#define CAN_TSR_ALST2_Pos (18U)
#define CAN_TSR_ALST2_Msk (0x1U << CAN_TSR_ALST2_Pos) /*!< 0x00040000 */
#define CAN_TSR_ALST2 CAN_TSR_ALST2_Msk /*!< Arbitration Lost for mailbox 2 */
#define CAN_TSR_TERR2_Pos (19U)
#define CAN_TSR_TERR2_Msk (0x1U << CAN_TSR_TERR2_Pos) /*!< 0x00080000 */
#define CAN_TSR_TERR2 CAN_TSR_TERR2_Msk /*!< Transmission Error of Mailbox 2 */
#define CAN_TSR_ABRQ2_Pos (23U)
#define CAN_TSR_ABRQ2_Msk (0x1U << CAN_TSR_ABRQ2_Pos) /*!< 0x00800000 */
#define CAN_TSR_ABRQ2 CAN_TSR_ABRQ2_Msk /*!< Abort Request for Mailbox 2 */
#define CAN_TSR_CODE_Pos (24U)
#define CAN_TSR_CODE_Msk (0x3U << CAN_TSR_CODE_Pos) /*!< 0x03000000 */
#define CAN_TSR_CODE CAN_TSR_CODE_Msk /*!< Mailbox Code */

#define CAN_TSR_TME_Pos (26U)
#define CAN_TSR_TME_Msk (0x7U << CAN_TSR_TME_Pos) /*!< 0x1C000000 */
#define CAN_TSR_TME CAN_TSR_TME_Msk /*!< TME[2:0] bits */
#define CAN_TSR_TME0_Pos (26U)
#define CAN_TSR_TME0_Msk (0x1U << CAN_TSR_TME0_Pos) /*!< 0x04000000 */
#define CAN_TSR_TME0 CAN_TSR_TME0_Msk /*!< Transmit Mailbox 0 Empty */
#define CAN_TSR_TME1_Pos (27U)
#define CAN_TSR_TME1_Msk (0x1U << CAN_TSR_TME1_Pos) /*!< 0x08000000 */
#define CAN_TSR_TME1 CAN_TSR_TME1_Msk /*!< Transmit Mailbox 1 Empty */
#define CAN_TSR_TME2_Pos (28U)
#define CAN_TSR_TME2_Msk (0x1U << CAN_TSR_TME2_Pos) /*!< 0x10000000 */
#define CAN_TSR_TME2 CAN_TSR_TME2_Msk /*!< Transmit Mailbox 2 Empty */

#define CAN_TSR_LOW_Pos (29U)
#define CAN_TSR_LOW_Msk (0x7U << CAN_TSR_LOW_Pos) /*!< 0xE0000000 */
#define CAN_TSR_LOW CAN_TSR_LOW_Msk /*!< LOW[2:0] bits */
#define CAN_TSR_LOW0_Pos (29U)
#define CAN_TSR_LOW0_Msk (0x1U << CAN_TSR_LOW0_Pos) /*!< 0x20000000 */
#define CAN_TSR_LOW0 CAN_TSR_LOW0_Msk /*!< Lowest Priority Flag for Mailbox 0 */
#define CAN_TSR_LOW1_Pos (30U)
#define CAN_TSR_LOW1_Msk (0x1U << CAN_TSR_LOW1_Pos) /*!< 0x40000000 */
#define CAN_TSR_LOW1 CAN_TSR_LOW1_Msk /*!< Lowest Priority Flag for Mailbox 1 */
#define CAN_TSR_LOW2_Pos (31U)
#define CAN_TSR_LOW2_Msk (0x1U << CAN_TSR_LOW2_Pos) /*!< 0x80000000 */
#define CAN_TSR_LOW2 CAN_TSR_LOW2_Msk /*!< Lowest Priority Flag for Mailbox 2 */

/*******************  Bit definition for CAN_RF0R register  *******************/
#define CAN_RF0R_FMP0_Pos (0U)
#define CAN_RF0R_FMP0_Msk (0x3U << CAN_RF0R_FMP0_Pos) /*!< 0x00000003 */
#define CAN_RF0R_FMP0 CAN_RF0R_FMP0_Msk /*!< FIFO 0 Message Pending */
#define CAN_RF0R_FULL0_Pos (3U)
#define CAN_RF0R_FULL0_Msk (0x1U << CAN_RF0R_FULL0_Pos) /*!< 0x00000008 */
#define CAN_RF0R_FULL0 CAN_RF0R_FULL0_Msk /*!< FIFO 0 Full */
#define CAN_RF0R_FOVR0_Pos (4U)
#define CAN_RF0R_FOVR0_Msk (0x1U << CAN_RF0R_FOVR0_Pos) /*!< 0x00000010 */
#define CAN_RF0R_FOVR0 CAN_RF0R_FOVR0_Msk /*!< FIFO 0 Overrun */
#define CAN_RF0R_RFOM0_Pos (5U)
#define CAN_RF0R_RFOM0_Msk (0x1U << CAN_RF0R_RFOM0_Pos) /*!< 0x00000020 */
#define CAN_RF0R_RFOM0 CAN_RF0R_RFOM0_Msk /*!< Release FIFO 0 Output Mailbox */

/*******************  Bit definition for CAN_RF1R register  *******************/
#define CAN_RF1R_FMP1_Pos (0U)
#define CAN_RF1R_FMP1_Msk (0x3U << CAN_RF1R_FMP1_Pos) /*!< 0x00000003 */
#define CAN_RF1R_FMP1 CAN_RF1R_FMP1_Msk /*!< FIFO 1 Message Pending */
#define CAN_RF1R_FULL1_Pos (3U)
#define CAN_RF1R_FULL1_Msk (0x1U << CAN_RF1R_FULL1_Pos) /*!< 0x00000008 */
#define CAN_RF1R_FULL1 CAN_RF1R_FULL1_Msk /*!< FIFO 1 Full */
#define CAN_RF1R_FOVR1_Pos (4U)
#define CAN_RF1R_FOVR1_Msk (0x1U << CAN_RF1R_FOVR1_Pos) /*!< 0x00000010 */
#define CAN_RF1R_FOVR1 CAN_RF1R_FOVR1_Msk /*!< FIFO 1 Overrun */
#define CAN_RF1R_RFOM1_Pos (5U)
#define CAN_RF1R_RFOM1_Msk (0x1U << CAN_RF1R_RFOM1_Pos) /*!< 0x00000020 */
#define CAN_RF1R_RFOM1 CAN_RF1R_RFOM1_Msk /*!< Release FIFO 1 Output Mailbox */

/********************  Bit definition for CAN_IER register  *******************/
#define CAN_IER_TMEIE_Pos (0U)
#define CAN_IER_TMEIE_Msk (0x1U << CAN_IER_TMEIE_Pos) /*!< 0x00000001 */
#define CAN_IER_TMEIE CAN_IER_TMEIE_Msk /*!< Transmit Mailbox Empty Interrupt Enable */
#define CAN_IER_FMPIE0_Pos (1U)
#define CAN_IER_FMPIE0_Msk (0x1U << CAN_IER_FMPIE0_Pos) /*!< 0x00000002 */
#define CAN_IER_FMPIE0 CAN_IER_FMPIE0_Msk /*!< FIFO Message Pending Interrupt Enable */
#define CAN_IER_FFIE0_Pos (2U)
#define CAN_IER_FFIE0_Msk (0x1U << CAN_IER_FFIE0_Pos) /*!< 0x00000004 */
#define CAN_IER_FFIE0 CAN_IER_FFIE0_Msk /*!< FIFO Full Interrupt Enable */
#define CAN_IER_FOVIE0_Pos (3U)
#define CAN_IER_FOVIE0_Msk (0x1U << CAN_IER_FOVIE0_Pos) /*!< 0x00000008 */
#define CAN_IER_FOVIE0 CAN_IER_FOVIE0_Msk /*!< FIFO Overrun Interrupt Enable */
#define CAN_IER_FMPIE1_Pos (4U)
#define CAN_IER_FMPIE1_Msk (0x1U << CAN_IER_FMPIE1_Pos) /*!< 0x00000010 */
#define CAN_IER_FMPIE1 CAN_IER_FMPIE1_Msk /*!< FIFO Message Pending Interrupt Enable */
#define CAN_IER_FFIE1_Pos (5U)
#define CAN_IER_FFIE1_Msk (0x1U << CAN_IER_FFIE1_Pos) /*!< 0x00000020 */
#define CAN_IER_FFIE1 CAN_IER_FFIE1_Msk /*!< FIFO Full Interrupt Enable */
#define CAN_IER_FOVIE1_Pos (6U)
#define CAN_IER_FOVIE1_Msk (0x1U << CAN_IER_FOVIE1_Pos) /*!< 0x00000040 */
#define CAN_IER_FOVIE1 CAN_IER_FOVIE1_Msk /*!< FIFO Overrun Interrupt Enable */
#define CAN_IER_EWGIE_Pos (8U)
#define CAN_IER_EWGIE_Msk (0x1U << CAN_IER_EWGIE_Pos) /*!< 0x00000100 */
#define CAN_IER_EWGIE CAN_IER_EWGIE_Msk /*!< Error Warning Interrupt Enable */
#define CAN_IER_EPVIE_Pos (9U)
#define CAN_IER_EPVIE_Msk (0x1U << CAN_IER_EPVIE_Pos) /*!< 0x00000200 */
#define CAN_IER_EPVIE CAN_IER_EPVIE_Msk /*!< Error Passive Interrupt Enable */
#define CAN_IER_BOFIE_Pos (10U)
#define CAN_IER_BOFIE_Msk (0x1U << CAN_IER_BOFIE_Pos) /*!< 0x00000400 */
#define CAN_IER_BOFIE CAN_IER_BOFIE_Msk /*!< Bus-Off Interrupt Enable */
#define CAN_IER_LECIE_Pos (11U)
#define CAN_IER_LECIE_Msk (0x1U << CAN_IER_LECIE_Pos) /*!< 0x00000800 */
#define CAN_IER_LECIE CAN_IER_LECIE_Msk /*!< Last Error Code Interrupt Enable */
#define CAN_IER_ERRIE_Pos (15U)
#define CAN_IER_ERRIE_Msk (0x1U << CAN_IER_ERRIE_Pos) /*!< 0x00008000 */
#define CAN_IER_ERRIE CAN_IER_ERRIE_Msk /*!< Error Interrupt Enable */
#define CAN_IER_WKUIE_Pos (16U)
#define CAN_IER_WKUIE_Msk (0x1U << CAN_IER_WKUIE_Pos) /*!< 0x00010000 */
#define CAN_IER_WKUIE CAN_IER_WKUIE_Msk /*!< Wakeup Interrupt Enable */
#define CAN_IER_SLKIE_Pos (17U)
#define CAN_IER_SLKIE_Msk (0x1U << CAN_IER_SLKIE_Pos) /*!< 0x00020000 */
#define CAN_IER_SLKIE CAN_IER_SLKIE_Msk /*!< Sleep Interrupt Enable */

/********************  Bit definition for CAN_ESR register  *******************/
#define CAN_ESR_EWGF_Pos (0U)
#define CAN_ESR_EWGF_Msk (0x1U << CAN_ESR_EWGF_Pos) /*!< 0x00000001 */
#define CAN_ESR_EWGF CAN_ESR_EWGF_Msk /*!< Error Warning Flag */
#define CAN_ESR_EPVF_Pos (1U)
#define CAN_ESR_EPVF_Msk (0x1U << CAN_ESR_EPVF_Pos) /*!< 0x00000002 */
#define CAN_ESR_EPVF CAN_ESR_EPVF_Msk /*!< Error Passive Flag */
#define CAN_ESR_BOFF_Pos (2U)
#define CAN_ESR_BOFF_Msk (0x1U << CAN_ESR_BOFF_Pos) /*!< 0x00000004 */
#define CAN_ESR_BOFF CAN_ESR_BOFF_Msk /*!< Bus-Off Flag */

#define CAN_ESR_LEC_Pos (4U)
#define CAN_ESR_LEC_Msk (0x7U << CAN_ESR_LEC_Pos) /*!< 0x00000070 */
#define CAN_ESR_LEC CAN_ESR_LEC_Msk /*!< LEC[2:0] bits (Last Error Code) */
#define CAN_ESR_LEC_0 (0x1U << CAN_ESR_LEC_Pos) /*!< 0x00000010 */
#define CAN_ESR_LEC_1 (0x2U << CAN_ESR_LEC_Pos) /*!< 0x00000020 */
#define CAN_ESR_LEC_2 (0x4U << CAN_ESR_LEC_Pos) /*!< 0x00000040 */

#define CAN_ESR_TEC_Pos (16U)
#define CAN_ESR_TEC_Msk (0xFFU << CAN_ESR_TEC_Pos) /*!< 0x00FF0000 */
#define CAN_ESR_TEC CAN_ESR_TEC_Msk /*!< Least significant byte of the 9-bit Transmit Error Counter */
#define CAN_ESR_REC_Pos (24U)
#define CAN_ESR_REC_Msk (0xFFU << CAN_ESR_REC_Pos) /*!< 0xFF000000 */
#define CAN_ESR_REC CAN_ESR_REC_Msk /*!< Receive Error Counter */

/*******************  Bit definition for CAN_BTR register  ********************/
#define CAN_BTR_BRP_Pos (0U)
#define CAN_BTR_BRP_Msk (0x3FFU << CAN_BTR_BRP_Pos) /*!< 0x000003FF */
#define CAN_BTR_BRP CAN_BTR_BRP_Msk /*!<Baud Rate Prescaler */
#define CAN_BTR_TS1_Pos (16U)
#define CAN_BTR_TS1_Msk (0xFU << CAN_BTR_TS1_Pos) /*!< 0x000F0000 */
#define CAN_BTR_TS1 CAN_BTR_TS1_Msk /*!<Time Segment 1 */
#define CAN_BTR_TS1_0 (0x1U << CAN_BTR_TS1_Pos) /*!< 0x00010000 */
#define CAN_BTR_TS1_1 (0x2U << CAN_BTR_TS1_Pos) /*!< 0x00020000 */
#define CAN_BTR_TS1_2 (0x4U << CAN_BTR_TS1_Pos) /*!< 0x00040000 */
#define CAN_BTR_TS1_3 (0x8U << CAN_BTR_TS1_Pos) /*!< 0x00080000 */
#define CAN_BTR_TS2_Pos (20U)
#define CAN_BTR_TS2_Msk (0x7U << CAN_BTR_TS2_Pos) /*!< 0x00700000 */
#define CAN_BTR_TS2 CAN_BTR_TS2_Msk /*!<Time Segment 2 */
#define CAN_BTR_TS2_0 (0x1U << CAN_BTR_TS2_Pos) /*!< 0x00100000 */
#define CAN_BTR_TS2_1 (0x2U << CAN_BTR_TS2_Pos) /*!< 0x00200000 */
#define CAN_BTR_TS2_2 (0x4U << CAN_BTR_TS2_Pos) /*!< 0x00400000 */
#define CAN_BTR_SJW_Pos (24U)
#define CAN_BTR_SJW_Msk (0x3U << CAN_BTR_SJW_Pos) /*!< 0x03000000 */
#define CAN_BTR_SJW CAN_BTR_SJW_Msk /*!<Resynchronization Jump Width */
#define CAN_BTR_SJW_0 (0x1U << CAN_BTR_SJW_Pos) /*!< 0x01000000 */
#define CAN_BTR_SJW_1 (0x2U << CAN_BTR_SJW_Pos) /*!< 0x02000000 */
#define CAN_BTR_LBKM_Pos (30U)
#define CAN_BTR_LBKM_Msk (0x1U << CAN_BTR_LBKM_Pos) /*!< 0x40000000 */
#define CAN_BTR_LBKM CAN_BTR_LBKM_Msk /*!<Loop Back Mode (Debug) */
#define CAN_BTR_SILM_Pos (31U)
#define CAN_BTR_SILM_Msk (0x1U << CAN_BTR_SILM_Pos) /*!< 0x80000000 */
#define CAN_BTR_SILM CAN_BTR_SILM_Msk /*!<Silent Mode */

/*!< Mailbox registers */
/******************  Bit definition for CAN_TI0R register  ********************/
#define CAN_TI0R_TXRQ_Pos (0U)
#define CAN_TI0R_TXRQ_Msk (0x1U << CAN_TI0R_TXRQ_Pos) /*!< 0x00000001 */
#define CAN_TI0R_TXRQ CAN_TI0R_TXRQ_Msk /*!< Transmit Mailbox Request */
#define CAN_TI0R_RTR_Pos (1U)
#define CAN_TI0R_RTR_Msk (0x1U << CAN_TI0R_RTR_Pos) /*!< 0x00000002 */
#define CAN_TI0R_RTR CAN_TI0R_RTR_Msk /*!< Remote Transmission Request */
#define CAN_TI0R_IDE_Pos (2U)
#define CAN_TI0R_IDE_Msk (0x1U << CAN_TI0R_IDE_Pos) /*!< 0x00000004 */
#define CAN_TI0R_IDE CAN_TI0R_IDE_Msk /*!< Identifier Extension */
#define CAN_TI0R_EXID_Pos (3U)
#define CAN_TI0R_EXID_Msk (0x3FFFFU << CAN_TI0R_EXID_Pos) /*!< 0x001FFFF8 */
#define CAN_TI0R_EXID CAN_TI0R_EXID_Msk /*!< Extended Identifier */
#define CAN_TI0R_STID_Pos (21U)
#define CAN_TI0R_STID_Msk (0x7FFU << CAN_TI0R_STID_Pos) /*!< 0xFFE00000 */
#define CAN_TI0R_STID CAN_TI0R_STID_Msk /*!< Standard Identifier or Extended Identifier */

/******************  Bit definition for CAN_TDT0R register  *******************/
#define CAN_TDT0R_DLC_Pos (0U)
#define CAN_TDT0R_DLC_Msk (0xFU << CAN_TDT0R_DLC_Pos) /*!< 0x0000000F */
#define CAN_TDT0R_DLC CAN_TDT0R_DLC_Msk /*!< Data Length Code */
#define CAN_TDT0R_TGT_Pos (8U)
#define CAN_TDT0R_TGT_Msk (0x1U << CAN_TDT0R_TGT_Pos) /*!< 0x00000100 */
#define CAN_TDT0R_TGT CAN_TDT0R_TGT_Msk /*!< Transmit Global Time */
#define CAN_TDT0R_TIME_Pos (16U)
#define CAN_TDT0R_TIME_Msk (0xFFFFU << CAN_TDT0R_TIME_Pos) /*!< 0xFFFF0000 */
#define CAN_TDT0R_TIME CAN_TDT0R_TIME_Msk /*!< Message Time Stamp */

/******************  Bit definition for CAN_TDL0R register  *******************/
#define CAN_TDL0R_DATA0_Pos (0U)
#define CAN_TDL0R_DATA0_Msk (0xFFU << CAN_TDL0R_DATA0_Pos) /*!< 0x000000FF */
#define CAN_TDL0R_DATA0 CAN_TDL0R_DATA0_Msk /*!< Data byte 0 */
#define CAN_TDL0R_DATA1_Pos (8U)
#define CAN_TDL0R_DATA1_Msk (0xFFU << CAN_TDL0R_DATA1_Pos) /*!< 0x0000FF00 */
#define CAN_TDL0R_DATA1 CAN_TDL0R_DATA1_Msk /*!< Data byte 1 */
#define CAN_TDL0R_DATA2_Pos (16U)
#define CAN_TDL0R_DATA2_Msk (0xFFU << CAN_TDL0R_DATA2_Pos) /*!< 0x00FF0000 */
#define CAN_TDL0R_DATA2 CAN_TDL0R_DATA2_Msk /*!< Data byte 2 */
#define CAN_TDL0R_DATA3_Pos (24U)
#define CAN_TDL0R_DATA3_Msk (0xFFU << CAN_TDL0R_DATA3_Pos) /*!< 0xFF000000 */
#define CAN_TDL0R_DATA3 CAN_TDL0R_DATA3_Msk /*!< Data byte 3 */

/******************  Bit definition for CAN_TDH0R register  *******************/
#define CAN_TDH0R_DATA4_Pos (0U)
#define CAN_TDH0R_DATA4_Msk (0xFFU << CAN_TDH0R_DATA4_Pos) /*!< 0x000000FF */
#define CAN_TDH0R_DATA4 CAN_TDH0R_DATA4_Msk /*!< Data byte 4 */
#define CAN_TDH0R_DATA5_Pos (8U)
#define CAN_TDH0R_DATA5_Msk (0xFFU << CAN_TDH0R_DATA5_Pos) /*!< 0x0000FF00 */
#define CAN_TDH0R_DATA5 CAN_TDH0R_DATA5_Msk /*!< Data byte 5 */
#define CAN_TDH0R_DATA6_Pos (16U)
#define CAN_TDH0R_DATA6_Msk (0xFFU << CAN_TDH0R_DATA6_Pos) /*!< 0x00FF0000 */
#define CAN_TDH0R_DATA6 CAN_TDH0R_DATA6_Msk /*!< Data byte 6 */
#define CAN_TDH0R_DATA7_Pos (24U)
#define CAN_TDH0R_DATA7_Msk (0xFFU << CAN_TDH0R_DATA7_Pos) /*!< 0xFF000000 */
#define CAN_TDH0R_DATA7 CAN_TDH0R_DATA7_Msk /*!< Data byte 7 */

/*******************  Bit definition for CAN_TI1R register  *******************/
#define CAN_TI1R_TXRQ_Pos (0U)
#define CAN_TI1R_TXRQ_Msk (0x1U << CAN_TI1R_TXRQ_Pos) /*!< 0x00000001 */
#define CAN_TI1R_TXRQ CAN_TI1R_TXRQ_Msk /*!< Transmit Mailbox Request */
#define CAN_TI1R_RTR_Pos (1U)
#define CAN_TI1R_RTR_Msk (0x1U << CAN_TI1R_RTR_Pos) /*!< 0x00000002 */
#define CAN_TI1R_RTR CAN_TI1R_RTR_Msk /*!< Remote Transmission Request */
#define CAN_TI1R_IDE_Pos (2U)
#define CAN_TI1R_IDE_Msk (0x1U << CAN_TI1R_IDE_Pos) /*!< 0x00000004 */
#define CAN_TI1R_IDE CAN_TI1R_IDE_Msk /*!< Identifier Extension */
#define CAN_TI1R_EXID_Pos (3U)
#define CAN_TI1R_EXID_Msk (0x3FFFFU << CAN_TI1R_EXID_Pos) /*!< 0x001FFFF8 */
#define CAN_TI1R_EXID CAN_TI1R_EXID_Msk /*!< Extended Identifier */
#define CAN_TI1R_STID_Pos (21U)
#define CAN_TI1R_STID_Msk (0x7FFU << CAN_TI1R_STID_Pos) /*!< 0xFFE00000 */
#define CAN_TI1R_STID CAN_TI1R_STID_Msk /*!< Standard Identifier or Extended Identifier */

/*******************  Bit definition for CAN_TDT1R register  ******************/
#define CAN_TDT1R_DLC_Pos (0U)
#define CAN_TDT1R_DLC_Msk (0xFU << CAN_TDT1R_DLC_Pos) /*!< 0x0000000F */
#define CAN_TDT1R_DLC CAN_TDT1R_DLC_Msk /*!< Data Length Code */
#define CAN_TDT1R_TGT_Pos (8U)
#define CAN_TDT1R_TGT_Msk (0x1U << CAN_TDT1R_TGT_Pos) /*!< 0x00000100 */
#define CAN_TDT1R_TGT CAN_TDT1R_TGT_Msk /*!< Transmit Global Time */
#define CAN_TDT1R_TIME_Pos (16U)
#define CAN_TDT1R_TIME_Msk (0xFFFFU << CAN_TDT1R_TIME_Pos) /*!< 0xFFFF0000 */
#define CAN_TDT1R_TIME CAN_TDT1R_TIME_Msk /*!< Message Time Stamp */

/*******************  Bit definition for CAN_TDL1R register  ******************/
#define CAN_TDL1R_DATA0_Pos (0U)
#define CAN_TDL1R_DATA0_Msk (0xFFU << CAN_TDL1R_DATA0_Pos) /*!< 0x000000FF */
#define CAN_TDL1R_DATA0 CAN_TDL1R_DATA0_Msk /*!< Data byte 0 */
#define CAN_TDL1R_DATA1_Pos (8U)
#define CAN_TDL1R_DATA1_Msk (0xFFU << CAN_TDL1R_DATA1_Pos) /*!< 0x0000FF00 */
#define CAN_TDL1R_DATA1 CAN_TDL1R_DATA1_Msk /*!< Data byte 1 */
#define CAN_TDL1R_DATA2_Pos (16U)
#define CAN_TDL1R_DATA2_Msk (0xFFU << CAN_TDL1R_DATA2_Pos) /*!< 0x00FF0000 */
#define CAN_TDL1R_DATA2 CAN_TDL1R_DATA2_Msk /*!< Data byte 2 */
#define CAN_TDL1R_DATA3_Pos (24U)
#define CAN_TDL1R_DATA3_Msk (0xFFU << CAN_TDL1R_DATA3_Pos) /*!< 0xFF000000 */
#define CAN_TDL1R_DATA3 CAN_TDL1R_DATA3_Msk /*!< Data byte 3 */

/*******************  Bit definition for CAN_TDH1R register  ******************/
#define CAN_TDH1R_DATA4_Pos (0U)
#define CAN_TDH1R_DATA4_Msk (0xFFU << CAN_TDH1R_DATA4_Pos) /*!< 0x000000FF */
#define CAN_TDH1R_DATA4 CAN_TDH1R_DATA4_Msk /*!< Data byte 4 */
#define CAN_TDH1R_DATA5_Pos (8U)
#define CAN_TDH1R_DATA5_Msk (0xFFU << CAN_TDH1R_DATA5_Pos) /*!< 0x0000FF00 */
#define CAN_TDH1R_DATA5 CAN_TDH1R_DATA5_Msk /*!< Data byte 5 */
#define CAN_TDH1R_DATA6_Pos (16U)
#define CAN_TDH1R_DATA6_Msk (0xFFU << CAN_TDH1R_DATA6_Pos) /*!< 0x00FF0000 */
#define CAN_TDH1R_DATA6 CAN_TDH1R_DATA6_Msk /*!< Data byte 6 */
#define CAN_TDH1R_DATA7_Pos (24U)
#define CAN_TDH1R_DATA7_Msk (0xFFU << CAN_TDH1R_DATA7_Pos) /*!< 0xFF000000 */
#define CAN_TDH1R_DATA7 CAN_TDH1R_DATA7_Msk /*!< Data byte 7 */

/*******************  Bit definition for CAN_TI2R register  *******************/
#define CAN_TI2R_TXRQ_Pos (0U)
#define CAN_TI2R_TXRQ_Msk (0x1U << CAN_TI2R_TXRQ_Pos) /*!< 0x00000001 */
#define CAN_TI2R_TXRQ CAN_TI2R_TXRQ_Msk /*!< Transmit Mailbox Request */
#define CAN_TI2R_RTR_Pos (1U)
#define CAN_TI2R_RTR_Msk (0x1U << CAN_TI2R_RTR_Pos) /*!< 0x00000002 */
#define CAN_TI2R_RTR CAN_TI2R_RTR_Msk /*!< Remote Transmission Request */
#define CAN_TI2R_IDE_Pos (2U)
#define CAN_TI2R_IDE_Msk (0x1U << CAN_TI2R_IDE_Pos) /*!< 0x00000004 */
#define CAN_TI2R_IDE CAN_TI2R_IDE_Msk /*!< Identifier Extension */
#define CAN_TI2R_EXID_Pos (3U)
#define CAN_TI2R_EXID_Msk (0x3FFFFU << CAN_TI2R_EXID_Pos) /*!< 0x001FFFF8 */
#define CAN_TI2R_EXID CAN_TI2R_EXID_Msk /*!< Extended identifier */
#define CAN_TI2R_STID_Pos (21U)
#define CAN_TI2R_STID_Msk (0x7FFU << CAN_TI2R_STID_Pos) /*!< 0xFFE00000 */
#define CAN_TI2R_STID CAN_TI2R_STID_Msk /*!< Standard Identifier or Extended Identifier */

/*******************  Bit definition for CAN_TDT2R register  ******************/
#define CAN_TDT2R_DLC_Pos (0U)
#define CAN_TDT2R_DLC_Msk (0xFU << CAN_TDT2R_DLC_Pos) /*!< 0x0000000F */
#define CAN_TDT2R_DLC CAN_TDT2R_DLC_Msk /*!< Data Length Code */
#define CAN_TDT2R_TGT_Pos (8U)
#define CAN_TDT2R_TGT_Msk (0x1U << CAN_TDT2R_TGT_Pos) /*!< 0x00000100 */
#define CAN_TDT2R_TGT CAN_TDT2R_TGT_Msk /*!< Transmit Global Time */
#define CAN_TDT2R_TIME_Pos (16U)
#define CAN_TDT2R_TIME_Msk (0xFFFFU << CAN_TDT2R_TIME_Pos) /*!< 0xFFFF0000 */
#define CAN_TDT2R_TIME CAN_TDT2R_TIME_Msk /*!< Message Time Stamp */

/*******************  Bit definition for CAN_TDL2R register  ******************/
#define CAN_TDL2R_DATA0_Pos (0U)
#define CAN_TDL2R_DATA0_Msk (0xFFU << CAN_TDL2R_DATA0_Pos) /*!< 0x000000FF */
#define CAN_TDL2R_DATA0 CAN_TDL2R_DATA0_Msk /*!< Data byte 0 */
#define CAN_TDL2R_DATA1_Pos (8U)
#define CAN_TDL2R_DATA1_Msk (0xFFU << CAN_TDL2R_DATA1_Pos) /*!< 0x0000FF00 */
#define CAN_TDL2R_DATA1 CAN_TDL2R_DATA1_Msk /*!< Data byte 1 */
#define CAN_TDL2R_DATA2_Pos (16U)
#define CAN_TDL2R_DATA2_Msk (0xFFU << CAN_TDL2R_DATA2_Pos) /*!< 0x00FF0000 */
#define CAN_TDL2R_DATA2 CAN_TDL2R_DATA2_Msk /*!< Data byte 2 */
#define CAN_TDL2R_DATA3_Pos (24U)
#define CAN_TDL2R_DATA3_Msk (0xFFU << CAN_TDL2R_DATA3_Pos) /*!< 0xFF000000 */
#define CAN_TDL2R_DATA3 CAN_TDL2R_DATA3_Msk /*!< Data byte 3 */

/*******************  Bit definition for CAN_TDH2R register  ******************/
#define CAN_TDH2R_DATA4_Pos (0U)
#define CAN_TDH2R_DATA4_Msk (0xFFU << CAN_TDH2R_DATA4_Pos) /*!< 0x000000FF */
#define CAN_TDH2R_DATA4 CAN_TDH2R_DATA4_Msk /*!< Data byte 4 */
#define CAN_TDH2R_DATA5_Pos (8U)
#define CAN_TDH2R_DATA5_Msk (0xFFU << CAN_TDH2R_DATA5_Pos) /*!< 0x0000FF00 */
#define CAN_TDH2R_DATA5 CAN_TDH2R_DATA5_Msk /*!< Data byte 5 */
#define CAN_TDH2R_DATA6_Pos (16U)
#define CAN_TDH2R_DATA6_Msk (0xFFU << CAN_TDH2R_DATA6_Pos) /*!< 0x00FF0000 */
#define CAN_TDH2R_DATA6 CAN_TDH2R_DATA6_Msk /*!< Data byte 6 */
#define CAN_TDH2R_DATA7_Pos (24U)
#define CAN_TDH2R_DATA7_Msk (0xFFU << CAN_TDH2R_DATA7_Pos) /*!< 0xFF000000 */
#define CAN_TDH2R_DATA7 CAN_TDH2R_DATA7_Msk /*!< Data byte 7 */

/*******************  Bit definition for CAN_RI0R register  *******************/
#define CAN_RI0R_RTR_Pos (1U)
#define CAN_RI0R_RTR_Msk (0x1U << CAN_RI0R_RTR_Pos) /*!< 0x00000002 */
#define CAN_RI0R_RTR CAN_RI0R_RTR_Msk /*!< Remote Transmission Request */
#define CAN_RI0R_IDE_Pos (2U)
#define CAN_RI0R_IDE_Msk (0x1U << CAN_RI0R_IDE_Pos) /*!< 0x00000004 */
#define CAN_RI0R_IDE CAN_RI0R_IDE_Msk /*!< Identifier Extension */
#define CAN_RI0R_EXID_Pos (3U)
#define CAN_RI0R_EXID_Msk (0x3FFFFU << CAN_RI0R_EXID_Pos) /*!< 0x001FFFF8 */
#define CAN_RI0R_EXID CAN_RI0R_EXID_Msk /*!< Extended Identifier */
#define CAN_RI0R_STID_Pos (21U)
#define CAN_RI0R_STID_Msk (0x7FFU << CAN_RI0R_STID_Pos) /*!< 0xFFE00000 */
#define CAN_RI0R_STID CAN_RI0R_STID_Msk /*!< Standard Identifier or Extended Identifier */

/*******************  Bit definition for CAN_RDT0R register  ******************/
#define CAN_RDT0R_DLC_Pos (0U)
#define CAN_RDT0R_DLC_Msk (0xFU << CAN_RDT0R_DLC_Pos) /*!< 0x0000000F */
#define CAN_RDT0R_DLC CAN_RDT0R_DLC_Msk /*!< Data Length Code */
#define CAN_RDT0R_FMI_Pos (8U)
#define CAN_RDT0R_FMI_Msk (0xFFU << CAN_RDT0R_FMI_Pos) /*!< 0x0000FF00 */
#define CAN_RDT0R_FMI CAN_RDT0R_FMI_Msk /*!< Filter Match Index */
#define CAN_RDT0R_TIME_Pos (16U)
#define CAN_RDT0R_TIME_Msk (0xFFFFU << CAN_RDT0R_TIME_Pos) /*!< 0xFFFF0000 */
#define CAN_RDT0R_TIME CAN_RDT0R_TIME_Msk /*!< Message Time Stamp */

/*******************  Bit definition for CAN_RDL0R register  ******************/
#define CAN_RDL0R_DATA0_Pos (0U)
#define CAN_RDL0R_DATA0_Msk (0xFFU << CAN_RDL0R_DATA0_Pos) /*!< 0x000000FF */
#define CAN_RDL0R_DATA0 CAN_RDL0R_DATA0_Msk /*!< Data byte 0 */
#define CAN_RDL0R_DATA1_Pos (8U)
#define CAN_RDL0R_DATA1_Msk (0xFFU << CAN_RDL0R_DATA1_Pos) /*!< 0x0000FF00 */
#define CAN_RDL0R_DATA1 CAN_RDL0R_DATA1_Msk /*!< Data byte 1 */
#define CAN_RDL0R_DATA2_Pos (16U)
#define CAN_RDL0R_DATA2_Msk (0xFFU << CAN_RDL0R_DATA2_Pos) /*!< 0x00FF0000 */
#define CAN_RDL0R_DATA2 CAN_RDL0R_DATA2_Msk /*!< Data byte 2 */
#define CAN_RDL0R_DATA3_Pos (24U)
#define CAN_RDL0R_DATA3_Msk (0xFFU << CAN_RDL0R_DATA3_Pos) /*!< 0xFF000000 */
#define CAN_RDL0R_DATA3 CAN_RDL0R_DATA3_Msk /*!< Data byte 3 */

/*******************  Bit definition for CAN_RDH0R register  ******************/
#define CAN_RDH0R_DATA4_Pos (0U)
#define CAN_RDH0R_DATA4_Msk (0xFFU << CAN_RDH0R_DATA4_Pos) /*!< 0x000000FF */
#define CAN_RDH0R_DATA4 CAN_RDH0R_DATA4_Msk /*!< Data byte 4 */
#define CAN_RDH0R_DATA5_Pos (8U)
#define CAN_RDH0R_DATA5_Msk (0xFFU << CAN_RDH0R_DATA5_Pos) /*!< 0x0000FF00 */
#define CAN_RDH0R_DATA5 CAN_RDH0R_DATA5_Msk /*!< Data byte 5 */
#define CAN_RDH0R_DATA6_Pos (16U)
#define CAN_RDH0R_DATA6_Msk (0xFFU << CAN_RDH0R_DATA6_Pos) /*!< 0x00FF0000 */
#define CAN_RDH0R_DATA6 CAN_RDH0R_DATA6_Msk /*!< Data byte 6 */
#define CAN_RDH0R_DATA7_Pos (24U)
#define CAN_RDH0R_DATA7_Msk (0xFFU << CAN_RDH0R_DATA7_Pos) /*!< 0xFF000000 */
#define CAN_RDH0R_DATA7 CAN_RDH0R_DATA7_Msk /*!< Data byte 7 */

/*******************  Bit definition for CAN_RI1R register  *******************/
#define CAN_RI1R_RTR_Pos (1U)
#define CAN_RI1R_RTR_Msk (0x1U << CAN_RI1R_RTR_Pos) /*!< 0x00000002 */
#define CAN_RI1R_RTR CAN_RI1R_RTR_Msk /*!< Remote Transmission Request */
#define CAN_RI1R_IDE_Pos (2U)
#define CAN_RI1R_IDE_Msk (0x1U << CAN_RI1R_IDE_Pos) /*!< 0x00000004 */
#define CAN_RI1R_IDE CAN_RI1R_IDE_Msk /*!< Identifier Extension */
#define CAN_RI1R_EXID_Pos (3U)
#define CAN_RI1R_EXID_Msk (0x3FFFFU << CAN_RI1R_EXID_Pos) /*!< 0x001FFFF8 */
#define CAN_RI1R_EXID CAN_RI1R_EXID_Msk /*!< Extended identifier */
#define CAN_RI1R_STID_Pos (21U)
#define CAN_RI1R_STID_Msk (0x7FFU << CAN_RI1R_STID_Pos) /*!< 0xFFE00000 */
#define CAN_RI1R_STID CAN_RI1R_STID_Msk /*!< Standard Identifier or Extended Identifier */

/*******************  Bit definition for CAN_RDT1R register  ******************/
#define CAN_RDT1R_DLC_Pos (0U)
#define CAN_RDT1R_DLC_Msk (0xFU << CAN_RDT1R_DLC_Pos) /*!< 0x0000000F */
#define CAN_RDT1R_DLC CAN_RDT1R_DLC_Msk /*!< Data Length Code */
#define CAN_RDT1R_FMI_Pos (8U)
#define CAN_RDT1R_FMI_Msk (0xFFU << CAN_RDT1R_FMI_Pos) /*!< 0x0000FF00 */
#define CAN_RDT1R_FMI CAN_RDT1R_FMI_Msk /*!< Filter Match Index */
#define CAN_RDT1R_TIME_Pos (16U)
#define CAN_RDT1R_TIME_Msk (0xFFFFU << CAN_RDT1R_TIME_Pos) /*!< 0xFFFF0000 */
#define CAN_RDT1R_TIME CAN_RDT1R_TIME_Msk /*!< Message Time Stamp */

/*******************  Bit definition for CAN_RDL1R register  ******************/
#define CAN_RDL1R_DATA0_Pos (0U)
#define CAN_RDL1R_DATA0_Msk (0xFFU << CAN_RDL1R_DATA0_Pos) /*!< 0x000000FF */
#define CAN_RDL1R_DATA0 CAN_RDL1R_DATA0_Msk /*!< Data byte 0 */
#define CAN_RDL1R_DATA1_Pos (8U)
#define CAN_RDL1R_DATA1_Msk (0xFFU << CAN_RDL1R_DATA1_Pos) /*!< 0x0000FF00 */
#define CAN_RDL1R_DATA1 CAN_RDL1R_DATA1_Msk /*!< Data byte 1 */
#define CAN_RDL1R_DATA2_Pos (16U)
#define CAN_RDL1R_DATA2_Msk (0xFFU << CAN_RDL1R_DATA2_Pos) /*!< 0x00FF0000 */
#define CAN_RDL1R_DATA2 CAN_RDL1R_DATA2_Msk /*!< Data byte 2 */
#define CAN_RDL1R_DATA3_Pos (24U)
#define CAN_RDL1R_DATA3_Msk (0xFFU << CAN_RDL1R_DATA3_Pos) /*!< 0xFF000000 */
#define CAN_RDL1R_DATA3 CAN_RDL1R_DATA3_Msk /*!< Data byte 3 */

/*******************  Bit definition for CAN_RDH1R register  ******************/
#define CAN_RDH1R_DATA4_Pos (0U)
#define CAN_RDH1R_DATA4_Msk (0xFFU << CAN_RDH1R_DATA4_Pos) /*!< 0x000000FF */
#define CAN_RDH1R_DATA4 CAN_RDH1R_DATA4_Msk /*!< Data byte 4 */
#define CAN_RDH1R_DATA5_Pos (8U)
#define CAN_RDH1R_DATA5_Msk (0xFFU << CAN_RDH1R_DATA5_Pos) /*!< 0x0000FF00 */
#define CAN_RDH1R_DATA5 CAN_RDH1R_DATA5_Msk /*!< Data byte 5 */
#define CAN_RDH1R_DATA6_Pos (16U)
#define CAN_RDH1R_DATA6_Msk (0xFFU << CAN_RDH1R_DATA6_Pos) /*!< 0x00FF0000 */
#define CAN_RDH1R_DATA6 CAN_RDH1R_DATA6_Msk /*!< Data byte 6 */
#define CAN_RDH1R_DATA7_Pos (24U)
#define CAN_RDH1R_DATA7_Msk (0xFFU << CAN_RDH1R_DATA7_Pos) /*!< 0xFF000000 */
#define CAN_RDH1R_DATA7 CAN_RDH1R_DATA7_Msk /*!< Data byte 7 */

/*!< CAN filter registers */
/*******************  Bit definition for CAN_FMR register  ********************/
#define CAN_FMR_FINIT_Pos (0U)
#define CAN_FMR_FINIT_Msk (0x1U << CAN_FMR_FINIT_Pos) /*!< 0x00000001 */
#define CAN_FMR_FINIT CAN_FMR_FINIT_Msk /*!< Filter Init Mode */
#define CAN_FMR_CAN2SB_Pos (8U)
#define CAN_FMR_CAN2SB_Msk (0x3FU << CAN_FMR_CAN2SB_Pos) /*!< 0x00003F00 */
#define CAN_FMR_CAN2SB CAN_FMR_CAN2SB_Msk /*!< CAN2 start bank */

/*******************  Bit definition for CAN_FM1R register  *******************/
#define CAN_FM1R_FBM_Pos (0U)
#define CAN_FM1R_FBM_Msk (0x3FFFU << CAN_FM1R_FBM_Pos) /*!< 0x00003FFF */
#define CAN_FM1R_FBM CAN_FM1R_FBM_Msk /*!< Filter Mode */
#define CAN_FM1R_FBM0_Pos (0U)
#define CAN_FM1R_FBM0_Msk (0x1U << CAN_FM1R_FBM0_Pos) /*!< 0x00000001 */
#define CAN_FM1R_FBM0 CAN_FM1R_FBM0_Msk /*!< Filter Init Mode for filter 0 */
#define CAN_FM1R_FBM1_Pos (1U)
#define CAN_FM1R_FBM1_Msk (0x1U << CAN_FM1R_FBM1_Pos) /*!< 0x00000002 */
#define CAN_FM1R_FBM1 CAN_FM1R_FBM1_Msk /*!< Filter Init Mode for filter 1 */
#define CAN_FM1R_FBM2_Pos (2U)
#define CAN_FM1R_FBM2_Msk (0x1U << CAN_FM1R_FBM2_Pos) /*!< 0x00000004 */
#define CAN_FM1R_FBM2 CAN_FM1R_FBM2_Msk /*!< Filter Init Mode for filter 2 */
#define CAN_FM1R_FBM3_Pos (3U)
#define CAN_FM1R_FBM3_Msk (0x1U << CAN_FM1R_FBM3_Pos) /*!< 0x00000008 */
#define CAN_FM1R_FBM3 CAN_FM1R_FBM3_Msk /*!< Filter Init Mode for filter 3 */
#define CAN_FM1R_FBM4_Pos (4U)
#define CAN_FM1R_FBM4_Msk (0x1U << CAN_FM1R_FBM4_Pos) /*!< 0x00000010 */
#define CAN_FM1R_FBM4 CAN_FM1R_FBM4_Msk /*!< Filter Init Mode for filter 4 */
#define CAN_FM1R_FBM5_Pos (5U)
#define CAN_FM1R_FBM5_Msk (0x1U << CAN_FM1R_FBM5_Pos) /*!< 0x00000020 */
#define CAN_FM1R_FBM5 CAN_FM1R_FBM5_Msk /*!< Filter Init Mode for filter 5 */
#define CAN_FM1R_FBM6_Pos (6U)
#define CAN_FM1R_FBM6_Msk (0x1U << CAN_FM1R_FBM6_Pos) /*!< 0x00000040 */
#define CAN_FM1R_FBM6 CAN_FM1R_FBM6_Msk /*!< Filter Init Mode for filter 6 */
#define CAN_FM1R_FBM7_Pos (7U)
#define CAN_FM1R_FBM7_Msk (0x1U << CAN_FM1R_FBM7_Pos) /*!< 0x00000080 */
#define CAN_FM1R_FBM7 CAN_FM1R_FBM7_Msk /*!< Filter Init Mode for filter 7 */
#define CAN_FM1R_FBM8_Pos (8U)
#define CAN_FM1R_FBM8_Msk (0x1U << CAN_FM1R_FBM8_Pos) /*!< 0x00000100 */
#define CAN_FM1R_FBM8 CAN_FM1R_FBM8_Msk /*!< Filter Init Mode for filter 8 */
#define CAN_FM1R_FBM9_Pos (9U)
#define CAN_FM1R_FBM9_Msk (0x1U << CAN_FM1R_FBM9_Pos) /*!< 0x00000200 */
#define CAN_FM1R_FBM9 CAN_FM1R_FBM9_Msk /*!< Filter Init Mode for filter 9 */
#define CAN_FM1R_FBM10_Pos (10U)
#define CAN_FM1R_FBM10_Msk (0x1U << CAN_FM1R_FBM10_Pos) /*!< 0x00000400 */
#define CAN_FM1R_FBM10 CAN_FM1R_FBM10_Msk /*!< Filter Init Mode for filter 10 */
#define CAN_FM1R_FBM11_Pos (11U)
#define CAN_FM1R_FBM11_Msk (0x1U << CAN_FM1R_FBM11_Pos) /*!< 0x00000800 */
#define CAN_FM1R_FBM11 CAN_FM1R_FBM11_Msk /*!< Filter Init Mode for filter 11 */
#define CAN_FM1R_FBM12_Pos (12U)
#define CAN_FM1R_FBM12_Msk (0x1U << CAN_FM1R_FBM12_Pos) /*!< 0x00001000 */
#define CAN_FM1R_FBM12 CAN_FM1R_FBM12_Msk /*!< Filter Init Mode for filter 12 */
#define CAN_FM1R_FBM13_Pos (13U)
#define CAN_FM1R_FBM13_Msk (0x1U << CAN_FM1R_FBM13_Pos) /*!< 0x00002000 */
#define CAN_FM1R_FBM13 CAN_FM1R_FBM13_Msk /*!< Filter Init Mode for filter 13 */

/*******************  Bit definition for CAN_FS1R register  *******************/
#define CAN_FS1R_FSC_Pos (0U)
#define CAN_FS1R_FSC_Msk (0x3FFFU << CAN_FS1R_FSC_Pos) /*!< 0x00003FFF */
#define CAN_FS1R_FSC CAN_FS1R_FSC_Msk /*!< Filter Scale Configuration */
#define CAN_FS1R_FSC0_Pos (0U)
#define CAN_FS1R_FSC0_Msk (0x1U << CAN_FS1R_FSC0_Pos) /*!< 0x00000001 */
#define CAN_FS1R_FSC0 CAN_FS1R_FSC0_Msk /*!< Filter Scale Configuration for filter 0 */
#define CAN_FS1R_FSC1_Pos (1U)
#define CAN_FS1R_FSC1_Msk (0x1U << CAN_FS1R_FSC1_Pos) /*!< 0x00000002 */
#define CAN_FS1R_FSC1 CAN_FS1R_FSC1_Msk /*!< Filter Scale Configuration for filter 1 */
#define CAN_FS1R_FSC2_Pos (2U)
#define CAN_FS1R_FSC2_Msk (0x1U << CAN_FS1R_FSC2_Pos) /*!< 0x00000004 */
#define CAN_FS1R_FSC2 CAN_FS1R_FSC2_Msk /*!< Filter Scale Configuration for filter 2 */
#define CAN_FS1R_FSC3_Pos (3U)
#define CAN_FS1R_FSC3_Msk (0x1U << CAN_FS1R_FSC3_Pos) /*!< 0x00000008 */
#define CAN_FS1R_FSC3 CAN_FS1R_FSC3_Msk /*!< Filter Scale Configuration for filter 3 */
#define CAN_FS1R_FSC4_Pos (4U)
#define CAN_FS1R_FSC4_Msk (0x1U << CAN_FS1R_FSC4_Pos) /*!< 0x00000010 */
#define CAN_FS1R_FSC4 CAN_FS1R_FSC4_Msk /*!< Filter Scale Configuration for filter 4 */
#define CAN_FS1R_FSC5_Pos (5U)
#define CAN_FS1R_FSC5_Msk (0x1U << CAN_FS1R_FSC5_Pos) /*!< 0x00000020 */
#define CAN_FS1R_FSC5 CAN_FS1R_FSC5_Msk /*!< Filter Scale Configuration for filter 5 */
#define CAN_FS1R_FSC6_Pos (6U)
#define CAN_FS1R_FSC6_Msk (0x1U << CAN_FS1R_FSC6_Pos) /*!< 0x00000040 */
#define CAN_FS1R_FSC6 CAN_FS1R_FSC6_Msk /*!< Filter Scale Configuration for filter 6 */
#define CAN_FS1R_FSC7_Pos (7U)
#define CAN_FS1R_FSC7_Msk (0x1U << CAN_FS1R_FSC7_Pos) /*!< 0x00000080 */
#define CAN_FS1R_FSC7 CAN_FS1R_FSC7_Msk /*!< Filter Scale Configuration for filter 7 */
#define CAN_FS1R_FSC8_Pos (8U)
#define CAN_FS1R_FSC8_Msk (0x1U << CAN_FS1R_FSC8_Pos) /*!< 0x00000100 */
#define CAN_FS1R_FSC8 CAN_FS1R_FSC8_Msk /*!< Filter Scale Configuration for filter 8 */
#define CAN_FS1R_FSC9_Pos (9U)
#define CAN_FS1R_FSC9_Msk (0x1U << CAN_FS1R_FSC9_Pos) /*!< 0x00000200 */
#define CAN_FS1R_FSC9 CAN_FS1R_FSC9_Msk /*!< Filter Scale Configuration for filter 9 */
#define CAN_FS1R_FSC10_Pos (10U)
#define CAN_FS1R_FSC10_Msk (0x1U << CAN_FS1R_FSC10_Pos) /*!< 0x00000400 */
#define CAN_FS1R_FSC10 CAN_FS1R_FSC10_Msk /*!< Filter Scale Configuration for filter 10 */
#define CAN_FS1R_FSC11_Pos (11U)
#define CAN_FS1R_FSC11_Msk (0x1U << CAN_FS1R_FSC11_Pos) /*!< 0x00000800 */
#define CAN_FS1R_FSC11 CAN_FS1R_FSC11_Msk /*!< Filter Scale Configuration for filter 11 */
#define CAN_FS1R_FSC12_Pos (12U)
#define CAN_FS1R_FSC12_Msk (0x1U << CAN_FS1R_FSC12_Pos) /*!< 0x00001000 */
#define CAN_FS1R_FSC12 CAN_FS1R_FSC12_Msk /*!< Filter Scale Configuration for filter 12 */
#define CAN_FS1R_FSC13_Pos (13U)
#define CAN_FS1R_FSC13_Msk (0x1U << CAN_FS1R_FSC13_Pos) /*!< 0x00002000 */
#define CAN_FS1R_FSC13 CAN_FS1R_FSC13_Msk /*!< Filter Scale Configuration for filter 13 */

/******************  Bit definition for CAN_FFA1R register  *******************/
#define CAN_FFA1R_FFA_Pos (0U)
#define CAN_FFA1R_FFA_Msk (0x3FFFU << CAN_FFA1R_FFA_Pos) /*!< 0x00003FFF */
#define CAN_FFA1R_FFA CAN_FFA1R_FFA_Msk /*!< Filter FIFO Assignment */
#define CAN_FFA1R_FFA0_Pos (0U)
#define CAN_FFA1R_FFA0_Msk (0x1U << CAN_FFA1R_FFA0_Pos) /*!< 0x00000001 */
#define CAN_FFA1R_FFA0 CAN_FFA1R_FFA0_Msk /*!< Filter FIFO Assignment for filter 0 */
#define CAN_FFA1R_FFA1_Pos (1U)
#define CAN_FFA1R_FFA1_Msk (0x1U << CAN_FFA1R_FFA1_Pos) /*!< 0x00000002 */
#define CAN_FFA1R_FFA1 CAN_FFA1R_FFA1_Msk /*!< Filter FIFO Assignment for filter 1 */
#define CAN_FFA1R_FFA2_Pos (2U)
#define CAN_FFA1R_FFA2_Msk (0x1U << CAN_FFA1R_FFA2_Pos) /*!< 0x00000004 */
#define CAN_FFA1R_FFA2 CAN_FFA1R_FFA2_Msk /*!< Filter FIFO Assignment for filter 2 */
#define CAN_FFA1R_FFA3_Pos (3U)
#define CAN_FFA1R_FFA3_Msk (0x1U << CAN_FFA1R_FFA3_Pos) /*!< 0x00000008 */
#define CAN_FFA1R_FFA3 CAN_FFA1R_FFA3_Msk /*!< Filter FIFO Assignment for filter 3 */
#define CAN_FFA1R_FFA4_Pos (4U)
#define CAN_FFA1R_FFA4_Msk (0x1U << CAN_FFA1R_FFA4_Pos) /*!< 0x00000010 */
#define CAN_FFA1R_FFA4 CAN_FFA1R_FFA4_Msk /*!< Filter FIFO Assignment for filter 4 */
#define CAN_FFA1R_FFA5_Pos (5U)
#define CAN_FFA1R_FFA5_Msk (0x1U << CAN_FFA1R_FFA5_Pos) /*!< 0x00000020 */
#define CAN_FFA1R_FFA5 CAN_FFA1R_FFA5_Msk /*!< Filter FIFO Assignment for filter 5 */
#define CAN_FFA1R_FFA6_Pos (6U)
#define CAN_FFA1R_FFA6_Msk (0x1U << CAN_FFA1R_FFA6_Pos) /*!< 0x00000040 */
#define CAN_FFA1R_FFA6 CAN_FFA1R_FFA6_Msk /*!< Filter FIFO Assignment for filter 6 */
#define CAN_FFA1R_FFA7_Pos (7U)
#define CAN_FFA1R_FFA7_Msk (0x1U << CAN_FFA1R_FFA7_Pos) /*!< 0x00000080 */
#define CAN_FFA1R_FFA7 CAN_FFA1R_FFA7_Msk /*!< Filter FIFO Assignment for filter 7 */
#define CAN_FFA1R_FFA8_Pos (8U)
#define CAN_FFA1R_FFA8_Msk (0x1U << CAN_FFA1R_FFA8_Pos) /*!< 0x00000100 */
#define CAN_FFA1R_FFA8 CAN_FFA1R_FFA8_Msk /*!< Filter FIFO Assignment for filter 8 */
#define CAN_FFA1R_FFA9_Pos (9U)
#define CAN_FFA1R_FFA9_Msk (0x1U << CAN_FFA1R_FFA9_Pos) /*!< 0x00000200 */
#define CAN_FFA1R_FFA9 CAN_FFA1R_FFA9_Msk /*!< Filter FIFO Assignment for filter 9 */
#define CAN_FFA1R_FFA10_Pos (10U)
#define CAN_FFA1R_FFA10_Msk (0x1U << CAN_FFA1R_FFA10_Pos) /*!< 0x00000400 */
#define CAN_FFA1R_FFA10 CAN_FFA1R_FFA10_Msk /*!< Filter FIFO Assignment for filter 10 */
#define CAN_FFA1R_FFA11_Pos (11U)
#define CAN_FFA1R_FFA11_Msk (0x1U << CAN_FFA1R_FFA11_Pos) /*!< 0x00000800 */
#define CAN_FFA1R_FFA11 CAN_FFA1R_FFA11_Msk /*!< Filter FIFO Assignment for filter 11 */
#define CAN_FFA1R_FFA12_Pos (12U)
#define CAN_FFA1R_FFA12_Msk (0x1U << CAN_FFA1R_FFA12_Pos) /*!< 0x00001000 */
#define CAN_FFA1R_FFA12 CAN_FFA1R_FFA12_Msk /*!< Filter FIFO Assignment for filter 12 */
#define CAN_FFA1R_FFA13_Pos (13U)
#define CAN_FFA1R_FFA13_Msk (0x1U << CAN_FFA1R_FFA13_Pos) /*!< 0x00002000 */
#define CAN_FFA1R_FFA13 CAN_FFA1R_FFA13_Msk /*!< Filter FIFO Assignment for filter 13 */

/*******************  Bit definition for CAN_FA1R register  *******************/
#define CAN_FA1R_FACT_Pos (0U)
#define CAN_FA1R_FACT_Msk (0x3FFFU << CAN_FA1R_FACT_Pos) /*!< 0x00003FFF */
#define CAN_FA1R_FACT CAN_FA1R_FACT_Msk /*!< Filter Active */
#define CAN_FA1R_FACT0_Pos (0U)
#define CAN_FA1R_FACT0_Msk (0x1U << CAN_FA1R_FACT0_Pos) /*!< 0x00000001 */
#define CAN_FA1R_FACT0 CAN_FA1R_FACT0_Msk /*!< Filter 0 Active */
#define CAN_FA1R_FACT1_Pos (1U)
#define CAN_FA1R_FACT1_Msk (0x1U << CAN_FA1R_FACT1_Pos) /*!< 0x00000002 */
#define CAN_FA1R_FACT1 CAN_FA1R_FACT1_Msk /*!< Filter 1 Active */
#define CAN_FA1R_FACT2_Pos (2U)
#define CAN_FA1R_FACT2_Msk (0x1U << CAN_FA1R_FACT2_Pos) /*!< 0x00000004 */
#define CAN_FA1R_FACT2 CAN_FA1R_FACT2_Msk /*!< Filter 2 Active */
#define CAN_FA1R_FACT3_Pos (3U)
#define CAN_FA1R_FACT3_Msk (0x1U << CAN_FA1R_FACT3_Pos) /*!< 0x00000008 */
#define CAN_FA1R_FACT3 CAN_FA1R_FACT3_Msk /*!< Filter 3 Active */
#define CAN_FA1R_FACT4_Pos (4U)
#define CAN_FA1R_FACT4_Msk (0x1U << CAN_FA1R_FACT4_Pos) /*!< 0x00000010 */
#define CAN_FA1R_FACT4 CAN_FA1R_FACT4_Msk /*!< Filter 4 Active */
#define CAN_FA1R_FACT5_Pos (5U)
#define CAN_FA1R_FACT5_Msk (0x1U << CAN_FA1R_FACT5_Pos) /*!< 0x00000020 */
#define CAN_FA1R_FACT5 CAN_FA1R_FACT5_Msk /*!< Filter 5 Active */
#define CAN_FA1R_FACT6_Pos (6U)
#define CAN_FA1R_FACT6_Msk (0x1U << CAN_FA1R_FACT6_Pos) /*!< 0x00000040 */
#define CAN_FA1R_FACT6 CAN_FA1R_FACT6_Msk /*!< Filter 6 Active */
#define CAN_FA1R_FACT7_Pos (7U)
#define CAN_FA1R_FACT7_Msk (0x1U << CAN_FA1R_FACT7_Pos) /*!< 0x00000080 */
#define CAN_FA1R_FACT7 CAN_FA1R_FACT7_Msk /*!< Filter 7 Active */
#define CAN_FA1R_FACT8_Pos (8U)
#define CAN_FA1R_FACT8_Msk (0x1U << CAN_FA1R_FACT8_Pos) /*!< 0x00000100 */
#define CAN_FA1R_FACT8 CAN_FA1R_FACT8_Msk /*!< Filter 8 Active */
#define CAN_FA1R_FACT9_Pos (9U)
#define CAN_FA1R_FACT9_Msk (0x1U << CAN_FA1R_FACT9_Pos) /*!< 0x00000200 */
#define CAN_FA1R_FACT9 CAN_FA1R_FACT9_Msk /*!< Filter 9 Active */
#define CAN_FA1R_FACT10_Pos (10U)
#define CAN_FA1R_FACT10_Msk (0x1U << CAN_FA1R_FACT10_Pos) /*!< 0x00000400 */
#define CAN_FA1R_FACT10 CAN_FA1R_FACT10_Msk /*!< Filter 10 Active */
#define CAN_FA1R_FACT11_Pos (11U)
#define CAN_FA1R_FACT11_Msk (0x1U << CAN_FA1R_FACT11_Pos) /*!< 0x00000800 */
#define CAN_FA1R_FACT11 CAN_FA1R_FACT11_Msk /*!< Filter 11 Active */
#define CAN_FA1R_FACT12_Pos (12U)
#define CAN_FA1R_FACT12_Msk (0x1U << CAN_FA1R_FACT12_Pos) /*!< 0x00001000 */
#define CAN_FA1R_FACT12 CAN_FA1R_FACT12_Msk /*!< Filter 12 Active */
#define CAN_FA1R_FACT13_Pos (13U)
#define CAN_FA1R_FACT13_Msk (0x1U << CAN_FA1R_FACT13_Pos) /*!< 0x00002000 */
#define CAN_FA1R_FACT13 CAN_FA1R_FACT13_Msk /*!< Filter 13 Active */

/*******************  Bit definition for CAN_F0R1 register  *******************/
#define CAN_F0R1_FB0_Pos (0U)
#define CAN_F0R1_FB0_Msk (0x1U << CAN_F0R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F0R1_FB0 CAN_F0R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F0R1_FB1_Pos (1U)
#define CAN_F0R1_FB1_Msk (0x1U << CAN_F0R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F0R1_FB1 CAN_F0R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F0R1_FB2_Pos (2U)
#define CAN_F0R1_FB2_Msk (0x1U << CAN_F0R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F0R1_FB2 CAN_F0R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F0R1_FB3_Pos (3U)
#define CAN_F0R1_FB3_Msk (0x1U << CAN_F0R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F0R1_FB3 CAN_F0R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F0R1_FB4_Pos (4U)
#define CAN_F0R1_FB4_Msk (0x1U << CAN_F0R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F0R1_FB4 CAN_F0R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F0R1_FB5_Pos (5U)
#define CAN_F0R1_FB5_Msk (0x1U << CAN_F0R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F0R1_FB5 CAN_F0R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F0R1_FB6_Pos (6U)
#define CAN_F0R1_FB6_Msk (0x1U << CAN_F0R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F0R1_FB6 CAN_F0R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F0R1_FB7_Pos (7U)
#define CAN_F0R1_FB7_Msk (0x1U << CAN_F0R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F0R1_FB7 CAN_F0R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F0R1_FB8_Pos (8U)
#define CAN_F0R1_FB8_Msk (0x1U << CAN_F0R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F0R1_FB8 CAN_F0R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F0R1_FB9_Pos (9U)
#define CAN_F0R1_FB9_Msk (0x1U << CAN_F0R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F0R1_FB9 CAN_F0R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F0R1_FB10_Pos (10U)
#define CAN_F0R1_FB10_Msk (0x1U << CAN_F0R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F0R1_FB10 CAN_F0R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F0R1_FB11_Pos (11U)
#define CAN_F0R1_FB11_Msk (0x1U << CAN_F0R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F0R1_FB11 CAN_F0R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F0R1_FB12_Pos (12U)
#define CAN_F0R1_FB12_Msk (0x1U << CAN_F0R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F0R1_FB12 CAN_F0R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F0R1_FB13_Pos (13U)
#define CAN_F0R1_FB13_Msk (0x1U << CAN_F0R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F0R1_FB13 CAN_F0R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F0R1_FB14_Pos (14U)
#define CAN_F0R1_FB14_Msk (0x1U << CAN_F0R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F0R1_FB14 CAN_F0R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F0R1_FB15_Pos (15U)
#define CAN_F0R1_FB15_Msk (0x1U << CAN_F0R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F0R1_FB15 CAN_F0R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F0R1_FB16_Pos (16U)
#define CAN_F0R1_FB16_Msk (0x1U << CAN_F0R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F0R1_FB16 CAN_F0R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F0R1_FB17_Pos (17U)
#define CAN_F0R1_FB17_Msk (0x1U << CAN_F0R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F0R1_FB17 CAN_F0R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F0R1_FB18_Pos (18U)
#define CAN_F0R1_FB18_Msk (0x1U << CAN_F0R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F0R1_FB18 CAN_F0R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F0R1_FB19_Pos (19U)
#define CAN_F0R1_FB19_Msk (0x1U << CAN_F0R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F0R1_FB19 CAN_F0R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F0R1_FB20_Pos (20U)
#define CAN_F0R1_FB20_Msk (0x1U << CAN_F0R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F0R1_FB20 CAN_F0R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F0R1_FB21_Pos (21U)
#define CAN_F0R1_FB21_Msk (0x1U << CAN_F0R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F0R1_FB21 CAN_F0R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F0R1_FB22_Pos (22U)
#define CAN_F0R1_FB22_Msk (0x1U << CAN_F0R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F0R1_FB22 CAN_F0R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F0R1_FB23_Pos (23U)
#define CAN_F0R1_FB23_Msk (0x1U << CAN_F0R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F0R1_FB23 CAN_F0R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F0R1_FB24_Pos (24U)
#define CAN_F0R1_FB24_Msk (0x1U << CAN_F0R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F0R1_FB24 CAN_F0R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F0R1_FB25_Pos (25U)
#define CAN_F0R1_FB25_Msk (0x1U << CAN_F0R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F0R1_FB25 CAN_F0R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F0R1_FB26_Pos (26U)
#define CAN_F0R1_FB26_Msk (0x1U << CAN_F0R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F0R1_FB26 CAN_F0R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F0R1_FB27_Pos (27U)
#define CAN_F0R1_FB27_Msk (0x1U << CAN_F0R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F0R1_FB27 CAN_F0R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F0R1_FB28_Pos (28U)
#define CAN_F0R1_FB28_Msk (0x1U << CAN_F0R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F0R1_FB28 CAN_F0R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F0R1_FB29_Pos (29U)
#define CAN_F0R1_FB29_Msk (0x1U << CAN_F0R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F0R1_FB29 CAN_F0R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F0R1_FB30_Pos (30U)
#define CAN_F0R1_FB30_Msk (0x1U << CAN_F0R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F0R1_FB30 CAN_F0R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F0R1_FB31_Pos (31U)
#define CAN_F0R1_FB31_Msk (0x1U << CAN_F0R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F0R1_FB31 CAN_F0R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F1R1 register  *******************/
#define CAN_F1R1_FB0_Pos (0U)
#define CAN_F1R1_FB0_Msk (0x1U << CAN_F1R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F1R1_FB0 CAN_F1R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F1R1_FB1_Pos (1U)
#define CAN_F1R1_FB1_Msk (0x1U << CAN_F1R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F1R1_FB1 CAN_F1R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F1R1_FB2_Pos (2U)
#define CAN_F1R1_FB2_Msk (0x1U << CAN_F1R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F1R1_FB2 CAN_F1R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F1R1_FB3_Pos (3U)
#define CAN_F1R1_FB3_Msk (0x1U << CAN_F1R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F1R1_FB3 CAN_F1R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F1R1_FB4_Pos (4U)
#define CAN_F1R1_FB4_Msk (0x1U << CAN_F1R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F1R1_FB4 CAN_F1R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F1R1_FB5_Pos (5U)
#define CAN_F1R1_FB5_Msk (0x1U << CAN_F1R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F1R1_FB5 CAN_F1R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F1R1_FB6_Pos (6U)
#define CAN_F1R1_FB6_Msk (0x1U << CAN_F1R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F1R1_FB6 CAN_F1R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F1R1_FB7_Pos (7U)
#define CAN_F1R1_FB7_Msk (0x1U << CAN_F1R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F1R1_FB7 CAN_F1R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F1R1_FB8_Pos (8U)
#define CAN_F1R1_FB8_Msk (0x1U << CAN_F1R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F1R1_FB8 CAN_F1R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F1R1_FB9_Pos (9U)
#define CAN_F1R1_FB9_Msk (0x1U << CAN_F1R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F1R1_FB9 CAN_F1R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F1R1_FB10_Pos (10U)
#define CAN_F1R1_FB10_Msk (0x1U << CAN_F1R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F1R1_FB10 CAN_F1R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F1R1_FB11_Pos (11U)
#define CAN_F1R1_FB11_Msk (0x1U << CAN_F1R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F1R1_FB11 CAN_F1R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F1R1_FB12_Pos (12U)
#define CAN_F1R1_FB12_Msk (0x1U << CAN_F1R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F1R1_FB12 CAN_F1R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F1R1_FB13_Pos (13U)
#define CAN_F1R1_FB13_Msk (0x1U << CAN_F1R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F1R1_FB13 CAN_F1R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F1R1_FB14_Pos (14U)
#define CAN_F1R1_FB14_Msk (0x1U << CAN_F1R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F1R1_FB14 CAN_F1R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F1R1_FB15_Pos (15U)
#define CAN_F1R1_FB15_Msk (0x1U << CAN_F1R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F1R1_FB15 CAN_F1R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F1R1_FB16_Pos (16U)
#define CAN_F1R1_FB16_Msk (0x1U << CAN_F1R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F1R1_FB16 CAN_F1R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F1R1_FB17_Pos (17U)
#define CAN_F1R1_FB17_Msk (0x1U << CAN_F1R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F1R1_FB17 CAN_F1R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F1R1_FB18_Pos (18U)
#define CAN_F1R1_FB18_Msk (0x1U << CAN_F1R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F1R1_FB18 CAN_F1R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F1R1_FB19_Pos (19U)
#define CAN_F1R1_FB19_Msk (0x1U << CAN_F1R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F1R1_FB19 CAN_F1R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F1R1_FB20_Pos (20U)
#define CAN_F1R1_FB20_Msk (0x1U << CAN_F1R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F1R1_FB20 CAN_F1R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F1R1_FB21_Pos (21U)
#define CAN_F1R1_FB21_Msk (0x1U << CAN_F1R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F1R1_FB21 CAN_F1R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F1R1_FB22_Pos (22U)
#define CAN_F1R1_FB22_Msk (0x1U << CAN_F1R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F1R1_FB22 CAN_F1R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F1R1_FB23_Pos (23U)
#define CAN_F1R1_FB23_Msk (0x1U << CAN_F1R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F1R1_FB23 CAN_F1R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F1R1_FB24_Pos (24U)
#define CAN_F1R1_FB24_Msk (0x1U << CAN_F1R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F1R1_FB24 CAN_F1R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F1R1_FB25_Pos (25U)
#define CAN_F1R1_FB25_Msk (0x1U << CAN_F1R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F1R1_FB25 CAN_F1R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F1R1_FB26_Pos (26U)
#define CAN_F1R1_FB26_Msk (0x1U << CAN_F1R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F1R1_FB26 CAN_F1R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F1R1_FB27_Pos (27U)
#define CAN_F1R1_FB27_Msk (0x1U << CAN_F1R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F1R1_FB27 CAN_F1R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F1R1_FB28_Pos (28U)
#define CAN_F1R1_FB28_Msk (0x1U << CAN_F1R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F1R1_FB28 CAN_F1R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F1R1_FB29_Pos (29U)
#define CAN_F1R1_FB29_Msk (0x1U << CAN_F1R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F1R1_FB29 CAN_F1R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F1R1_FB30_Pos (30U)
#define CAN_F1R1_FB30_Msk (0x1U << CAN_F1R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F1R1_FB30 CAN_F1R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F1R1_FB31_Pos (31U)
#define CAN_F1R1_FB31_Msk (0x1U << CAN_F1R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F1R1_FB31 CAN_F1R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F2R1 register  *******************/
#define CAN_F2R1_FB0_Pos (0U)
#define CAN_F2R1_FB0_Msk (0x1U << CAN_F2R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F2R1_FB0 CAN_F2R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F2R1_FB1_Pos (1U)
#define CAN_F2R1_FB1_Msk (0x1U << CAN_F2R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F2R1_FB1 CAN_F2R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F2R1_FB2_Pos (2U)
#define CAN_F2R1_FB2_Msk (0x1U << CAN_F2R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F2R1_FB2 CAN_F2R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F2R1_FB3_Pos (3U)
#define CAN_F2R1_FB3_Msk (0x1U << CAN_F2R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F2R1_FB3 CAN_F2R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F2R1_FB4_Pos (4U)
#define CAN_F2R1_FB4_Msk (0x1U << CAN_F2R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F2R1_FB4 CAN_F2R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F2R1_FB5_Pos (5U)
#define CAN_F2R1_FB5_Msk (0x1U << CAN_F2R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F2R1_FB5 CAN_F2R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F2R1_FB6_Pos (6U)
#define CAN_F2R1_FB6_Msk (0x1U << CAN_F2R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F2R1_FB6 CAN_F2R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F2R1_FB7_Pos (7U)
#define CAN_F2R1_FB7_Msk (0x1U << CAN_F2R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F2R1_FB7 CAN_F2R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F2R1_FB8_Pos (8U)
#define CAN_F2R1_FB8_Msk (0x1U << CAN_F2R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F2R1_FB8 CAN_F2R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F2R1_FB9_Pos (9U)
#define CAN_F2R1_FB9_Msk (0x1U << CAN_F2R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F2R1_FB9 CAN_F2R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F2R1_FB10_Pos (10U)
#define CAN_F2R1_FB10_Msk (0x1U << CAN_F2R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F2R1_FB10 CAN_F2R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F2R1_FB11_Pos (11U)
#define CAN_F2R1_FB11_Msk (0x1U << CAN_F2R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F2R1_FB11 CAN_F2R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F2R1_FB12_Pos (12U)
#define CAN_F2R1_FB12_Msk (0x1U << CAN_F2R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F2R1_FB12 CAN_F2R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F2R1_FB13_Pos (13U)
#define CAN_F2R1_FB13_Msk (0x1U << CAN_F2R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F2R1_FB13 CAN_F2R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F2R1_FB14_Pos (14U)
#define CAN_F2R1_FB14_Msk (0x1U << CAN_F2R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F2R1_FB14 CAN_F2R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F2R1_FB15_Pos (15U)
#define CAN_F2R1_FB15_Msk (0x1U << CAN_F2R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F2R1_FB15 CAN_F2R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F2R1_FB16_Pos (16U)
#define CAN_F2R1_FB16_Msk (0x1U << CAN_F2R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F2R1_FB16 CAN_F2R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F2R1_FB17_Pos (17U)
#define CAN_F2R1_FB17_Msk (0x1U << CAN_F2R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F2R1_FB17 CAN_F2R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F2R1_FB18_Pos (18U)
#define CAN_F2R1_FB18_Msk (0x1U << CAN_F2R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F2R1_FB18 CAN_F2R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F2R1_FB19_Pos (19U)
#define CAN_F2R1_FB19_Msk (0x1U << CAN_F2R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F2R1_FB19 CAN_F2R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F2R1_FB20_Pos (20U)
#define CAN_F2R1_FB20_Msk (0x1U << CAN_F2R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F2R1_FB20 CAN_F2R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F2R1_FB21_Pos (21U)
#define CAN_F2R1_FB21_Msk (0x1U << CAN_F2R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F2R1_FB21 CAN_F2R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F2R1_FB22_Pos (22U)
#define CAN_F2R1_FB22_Msk (0x1U << CAN_F2R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F2R1_FB22 CAN_F2R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F2R1_FB23_Pos (23U)
#define CAN_F2R1_FB23_Msk (0x1U << CAN_F2R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F2R1_FB23 CAN_F2R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F2R1_FB24_Pos (24U)
#define CAN_F2R1_FB24_Msk (0x1U << CAN_F2R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F2R1_FB24 CAN_F2R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F2R1_FB25_Pos (25U)
#define CAN_F2R1_FB25_Msk (0x1U << CAN_F2R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F2R1_FB25 CAN_F2R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F2R1_FB26_Pos (26U)
#define CAN_F2R1_FB26_Msk (0x1U << CAN_F2R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F2R1_FB26 CAN_F2R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F2R1_FB27_Pos (27U)
#define CAN_F2R1_FB27_Msk (0x1U << CAN_F2R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F2R1_FB27 CAN_F2R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F2R1_FB28_Pos (28U)
#define CAN_F2R1_FB28_Msk (0x1U << CAN_F2R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F2R1_FB28 CAN_F2R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F2R1_FB29_Pos (29U)
#define CAN_F2R1_FB29_Msk (0x1U << CAN_F2R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F2R1_FB29 CAN_F2R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F2R1_FB30_Pos (30U)
#define CAN_F2R1_FB30_Msk (0x1U << CAN_F2R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F2R1_FB30 CAN_F2R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F2R1_FB31_Pos (31U)
#define CAN_F2R1_FB31_Msk (0x1U << CAN_F2R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F2R1_FB31 CAN_F2R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F3R1 register  *******************/
#define CAN_F3R1_FB0_Pos (0U)
#define CAN_F3R1_FB0_Msk (0x1U << CAN_F3R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F3R1_FB0 CAN_F3R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F3R1_FB1_Pos (1U)
#define CAN_F3R1_FB1_Msk (0x1U << CAN_F3R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F3R1_FB1 CAN_F3R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F3R1_FB2_Pos (2U)
#define CAN_F3R1_FB2_Msk (0x1U << CAN_F3R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F3R1_FB2 CAN_F3R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F3R1_FB3_Pos (3U)
#define CAN_F3R1_FB3_Msk (0x1U << CAN_F3R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F3R1_FB3 CAN_F3R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F3R1_FB4_Pos (4U)
#define CAN_F3R1_FB4_Msk (0x1U << CAN_F3R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F3R1_FB4 CAN_F3R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F3R1_FB5_Pos (5U)
#define CAN_F3R1_FB5_Msk (0x1U << CAN_F3R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F3R1_FB5 CAN_F3R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F3R1_FB6_Pos (6U)
#define CAN_F3R1_FB6_Msk (0x1U << CAN_F3R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F3R1_FB6 CAN_F3R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F3R1_FB7_Pos (7U)
#define CAN_F3R1_FB7_Msk (0x1U << CAN_F3R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F3R1_FB7 CAN_F3R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F3R1_FB8_Pos (8U)
#define CAN_F3R1_FB8_Msk (0x1U << CAN_F3R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F3R1_FB8 CAN_F3R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F3R1_FB9_Pos (9U)
#define CAN_F3R1_FB9_Msk (0x1U << CAN_F3R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F3R1_FB9 CAN_F3R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F3R1_FB10_Pos (10U)
#define CAN_F3R1_FB10_Msk (0x1U << CAN_F3R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F3R1_FB10 CAN_F3R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F3R1_FB11_Pos (11U)
#define CAN_F3R1_FB11_Msk (0x1U << CAN_F3R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F3R1_FB11 CAN_F3R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F3R1_FB12_Pos (12U)
#define CAN_F3R1_FB12_Msk (0x1U << CAN_F3R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F3R1_FB12 CAN_F3R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F3R1_FB13_Pos (13U)
#define CAN_F3R1_FB13_Msk (0x1U << CAN_F3R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F3R1_FB13 CAN_F3R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F3R1_FB14_Pos (14U)
#define CAN_F3R1_FB14_Msk (0x1U << CAN_F3R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F3R1_FB14 CAN_F3R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F3R1_FB15_Pos (15U)
#define CAN_F3R1_FB15_Msk (0x1U << CAN_F3R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F3R1_FB15 CAN_F3R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F3R1_FB16_Pos (16U)
#define CAN_F3R1_FB16_Msk (0x1U << CAN_F3R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F3R1_FB16 CAN_F3R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F3R1_FB17_Pos (17U)
#define CAN_F3R1_FB17_Msk (0x1U << CAN_F3R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F3R1_FB17 CAN_F3R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F3R1_FB18_Pos (18U)
#define CAN_F3R1_FB18_Msk (0x1U << CAN_F3R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F3R1_FB18 CAN_F3R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F3R1_FB19_Pos (19U)
#define CAN_F3R1_FB19_Msk (0x1U << CAN_F3R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F3R1_FB19 CAN_F3R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F3R1_FB20_Pos (20U)
#define CAN_F3R1_FB20_Msk (0x1U << CAN_F3R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F3R1_FB20 CAN_F3R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F3R1_FB21_Pos (21U)
#define CAN_F3R1_FB21_Msk (0x1U << CAN_F3R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F3R1_FB21 CAN_F3R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F3R1_FB22_Pos (22U)
#define CAN_F3R1_FB22_Msk (0x1U << CAN_F3R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F3R1_FB22 CAN_F3R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F3R1_FB23_Pos (23U)
#define CAN_F3R1_FB23_Msk (0x1U << CAN_F3R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F3R1_FB23 CAN_F3R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F3R1_FB24_Pos (24U)
#define CAN_F3R1_FB24_Msk (0x1U << CAN_F3R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F3R1_FB24 CAN_F3R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F3R1_FB25_Pos (25U)
#define CAN_F3R1_FB25_Msk (0x1U << CAN_F3R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F3R1_FB25 CAN_F3R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F3R1_FB26_Pos (26U)
#define CAN_F3R1_FB26_Msk (0x1U << CAN_F3R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F3R1_FB26 CAN_F3R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F3R1_FB27_Pos (27U)
#define CAN_F3R1_FB27_Msk (0x1U << CAN_F3R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F3R1_FB27 CAN_F3R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F3R1_FB28_Pos (28U)
#define CAN_F3R1_FB28_Msk (0x1U << CAN_F3R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F3R1_FB28 CAN_F3R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F3R1_FB29_Pos (29U)
#define CAN_F3R1_FB29_Msk (0x1U << CAN_F3R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F3R1_FB29 CAN_F3R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F3R1_FB30_Pos (30U)
#define CAN_F3R1_FB30_Msk (0x1U << CAN_F3R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F3R1_FB30 CAN_F3R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F3R1_FB31_Pos (31U)
#define CAN_F3R1_FB31_Msk (0x1U << CAN_F3R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F3R1_FB31 CAN_F3R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F4R1 register  *******************/
#define CAN_F4R1_FB0_Pos (0U)
#define CAN_F4R1_FB0_Msk (0x1U << CAN_F4R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F4R1_FB0 CAN_F4R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F4R1_FB1_Pos (1U)
#define CAN_F4R1_FB1_Msk (0x1U << CAN_F4R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F4R1_FB1 CAN_F4R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F4R1_FB2_Pos (2U)
#define CAN_F4R1_FB2_Msk (0x1U << CAN_F4R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F4R1_FB2 CAN_F4R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F4R1_FB3_Pos (3U)
#define CAN_F4R1_FB3_Msk (0x1U << CAN_F4R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F4R1_FB3 CAN_F4R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F4R1_FB4_Pos (4U)
#define CAN_F4R1_FB4_Msk (0x1U << CAN_F4R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F4R1_FB4 CAN_F4R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F4R1_FB5_Pos (5U)
#define CAN_F4R1_FB5_Msk (0x1U << CAN_F4R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F4R1_FB5 CAN_F4R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F4R1_FB6_Pos (6U)
#define CAN_F4R1_FB6_Msk (0x1U << CAN_F4R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F4R1_FB6 CAN_F4R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F4R1_FB7_Pos (7U)
#define CAN_F4R1_FB7_Msk (0x1U << CAN_F4R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F4R1_FB7 CAN_F4R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F4R1_FB8_Pos (8U)
#define CAN_F4R1_FB8_Msk (0x1U << CAN_F4R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F4R1_FB8 CAN_F4R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F4R1_FB9_Pos (9U)
#define CAN_F4R1_FB9_Msk (0x1U << CAN_F4R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F4R1_FB9 CAN_F4R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F4R1_FB10_Pos (10U)
#define CAN_F4R1_FB10_Msk (0x1U << CAN_F4R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F4R1_FB10 CAN_F4R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F4R1_FB11_Pos (11U)
#define CAN_F4R1_FB11_Msk (0x1U << CAN_F4R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F4R1_FB11 CAN_F4R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F4R1_FB12_Pos (12U)
#define CAN_F4R1_FB12_Msk (0x1U << CAN_F4R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F4R1_FB12 CAN_F4R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F4R1_FB13_Pos (13U)
#define CAN_F4R1_FB13_Msk (0x1U << CAN_F4R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F4R1_FB13 CAN_F4R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F4R1_FB14_Pos (14U)
#define CAN_F4R1_FB14_Msk (0x1U << CAN_F4R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F4R1_FB14 CAN_F4R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F4R1_FB15_Pos (15U)
#define CAN_F4R1_FB15_Msk (0x1U << CAN_F4R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F4R1_FB15 CAN_F4R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F4R1_FB16_Pos (16U)
#define CAN_F4R1_FB16_Msk (0x1U << CAN_F4R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F4R1_FB16 CAN_F4R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F4R1_FB17_Pos (17U)
#define CAN_F4R1_FB17_Msk (0x1U << CAN_F4R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F4R1_FB17 CAN_F4R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F4R1_FB18_Pos (18U)
#define CAN_F4R1_FB18_Msk (0x1U << CAN_F4R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F4R1_FB18 CAN_F4R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F4R1_FB19_Pos (19U)
#define CAN_F4R1_FB19_Msk (0x1U << CAN_F4R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F4R1_FB19 CAN_F4R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F4R1_FB20_Pos (20U)
#define CAN_F4R1_FB20_Msk (0x1U << CAN_F4R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F4R1_FB20 CAN_F4R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F4R1_FB21_Pos (21U)
#define CAN_F4R1_FB21_Msk (0x1U << CAN_F4R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F4R1_FB21 CAN_F4R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F4R1_FB22_Pos (22U)
#define CAN_F4R1_FB22_Msk (0x1U << CAN_F4R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F4R1_FB22 CAN_F4R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F4R1_FB23_Pos (23U)
#define CAN_F4R1_FB23_Msk (0x1U << CAN_F4R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F4R1_FB23 CAN_F4R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F4R1_FB24_Pos (24U)
#define CAN_F4R1_FB24_Msk (0x1U << CAN_F4R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F4R1_FB24 CAN_F4R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F4R1_FB25_Pos (25U)
#define CAN_F4R1_FB25_Msk (0x1U << CAN_F4R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F4R1_FB25 CAN_F4R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F4R1_FB26_Pos (26U)
#define CAN_F4R1_FB26_Msk (0x1U << CAN_F4R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F4R1_FB26 CAN_F4R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F4R1_FB27_Pos (27U)
#define CAN_F4R1_FB27_Msk (0x1U << CAN_F4R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F4R1_FB27 CAN_F4R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F4R1_FB28_Pos (28U)
#define CAN_F4R1_FB28_Msk (0x1U << CAN_F4R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F4R1_FB28 CAN_F4R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F4R1_FB29_Pos (29U)
#define CAN_F4R1_FB29_Msk (0x1U << CAN_F4R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F4R1_FB29 CAN_F4R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F4R1_FB30_Pos (30U)
#define CAN_F4R1_FB30_Msk (0x1U << CAN_F4R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F4R1_FB30 CAN_F4R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F4R1_FB31_Pos (31U)
#define CAN_F4R1_FB31_Msk (0x1U << CAN_F4R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F4R1_FB31 CAN_F4R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F5R1 register  *******************/
#define CAN_F5R1_FB0_Pos (0U)
#define CAN_F5R1_FB0_Msk (0x1U << CAN_F5R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F5R1_FB0 CAN_F5R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F5R1_FB1_Pos (1U)
#define CAN_F5R1_FB1_Msk (0x1U << CAN_F5R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F5R1_FB1 CAN_F5R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F5R1_FB2_Pos (2U)
#define CAN_F5R1_FB2_Msk (0x1U << CAN_F5R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F5R1_FB2 CAN_F5R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F5R1_FB3_Pos (3U)
#define CAN_F5R1_FB3_Msk (0x1U << CAN_F5R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F5R1_FB3 CAN_F5R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F5R1_FB4_Pos (4U)
#define CAN_F5R1_FB4_Msk (0x1U << CAN_F5R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F5R1_FB4 CAN_F5R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F5R1_FB5_Pos (5U)
#define CAN_F5R1_FB5_Msk (0x1U << CAN_F5R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F5R1_FB5 CAN_F5R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F5R1_FB6_Pos (6U)
#define CAN_F5R1_FB6_Msk (0x1U << CAN_F5R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F5R1_FB6 CAN_F5R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F5R1_FB7_Pos (7U)
#define CAN_F5R1_FB7_Msk (0x1U << CAN_F5R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F5R1_FB7 CAN_F5R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F5R1_FB8_Pos (8U)
#define CAN_F5R1_FB8_Msk (0x1U << CAN_F5R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F5R1_FB8 CAN_F5R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F5R1_FB9_Pos (9U)
#define CAN_F5R1_FB9_Msk (0x1U << CAN_F5R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F5R1_FB9 CAN_F5R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F5R1_FB10_Pos (10U)
#define CAN_F5R1_FB10_Msk (0x1U << CAN_F5R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F5R1_FB10 CAN_F5R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F5R1_FB11_Pos (11U)
#define CAN_F5R1_FB11_Msk (0x1U << CAN_F5R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F5R1_FB11 CAN_F5R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F5R1_FB12_Pos (12U)
#define CAN_F5R1_FB12_Msk (0x1U << CAN_F5R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F5R1_FB12 CAN_F5R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F5R1_FB13_Pos (13U)
#define CAN_F5R1_FB13_Msk (0x1U << CAN_F5R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F5R1_FB13 CAN_F5R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F5R1_FB14_Pos (14U)
#define CAN_F5R1_FB14_Msk (0x1U << CAN_F5R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F5R1_FB14 CAN_F5R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F5R1_FB15_Pos (15U)
#define CAN_F5R1_FB15_Msk (0x1U << CAN_F5R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F5R1_FB15 CAN_F5R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F5R1_FB16_Pos (16U)
#define CAN_F5R1_FB16_Msk (0x1U << CAN_F5R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F5R1_FB16 CAN_F5R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F5R1_FB17_Pos (17U)
#define CAN_F5R1_FB17_Msk (0x1U << CAN_F5R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F5R1_FB17 CAN_F5R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F5R1_FB18_Pos (18U)
#define CAN_F5R1_FB18_Msk (0x1U << CAN_F5R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F5R1_FB18 CAN_F5R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F5R1_FB19_Pos (19U)
#define CAN_F5R1_FB19_Msk (0x1U << CAN_F5R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F5R1_FB19 CAN_F5R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F5R1_FB20_Pos (20U)
#define CAN_F5R1_FB20_Msk (0x1U << CAN_F5R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F5R1_FB20 CAN_F5R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F5R1_FB21_Pos (21U)
#define CAN_F5R1_FB21_Msk (0x1U << CAN_F5R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F5R1_FB21 CAN_F5R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F5R1_FB22_Pos (22U)
#define CAN_F5R1_FB22_Msk (0x1U << CAN_F5R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F5R1_FB22 CAN_F5R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F5R1_FB23_Pos (23U)
#define CAN_F5R1_FB23_Msk (0x1U << CAN_F5R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F5R1_FB23 CAN_F5R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F5R1_FB24_Pos (24U)
#define CAN_F5R1_FB24_Msk (0x1U << CAN_F5R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F5R1_FB24 CAN_F5R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F5R1_FB25_Pos (25U)
#define CAN_F5R1_FB25_Msk (0x1U << CAN_F5R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F5R1_FB25 CAN_F5R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F5R1_FB26_Pos (26U)
#define CAN_F5R1_FB26_Msk (0x1U << CAN_F5R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F5R1_FB26 CAN_F5R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F5R1_FB27_Pos (27U)
#define CAN_F5R1_FB27_Msk (0x1U << CAN_F5R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F5R1_FB27 CAN_F5R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F5R1_FB28_Pos (28U)
#define CAN_F5R1_FB28_Msk (0x1U << CAN_F5R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F5R1_FB28 CAN_F5R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F5R1_FB29_Pos (29U)
#define CAN_F5R1_FB29_Msk (0x1U << CAN_F5R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F5R1_FB29 CAN_F5R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F5R1_FB30_Pos (30U)
#define CAN_F5R1_FB30_Msk (0x1U << CAN_F5R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F5R1_FB30 CAN_F5R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F5R1_FB31_Pos (31U)
#define CAN_F5R1_FB31_Msk (0x1U << CAN_F5R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F5R1_FB31 CAN_F5R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F6R1 register  *******************/
#define CAN_F6R1_FB0_Pos (0U)
#define CAN_F6R1_FB0_Msk (0x1U << CAN_F6R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F6R1_FB0 CAN_F6R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F6R1_FB1_Pos (1U)
#define CAN_F6R1_FB1_Msk (0x1U << CAN_F6R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F6R1_FB1 CAN_F6R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F6R1_FB2_Pos (2U)
#define CAN_F6R1_FB2_Msk (0x1U << CAN_F6R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F6R1_FB2 CAN_F6R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F6R1_FB3_Pos (3U)
#define CAN_F6R1_FB3_Msk (0x1U << CAN_F6R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F6R1_FB3 CAN_F6R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F6R1_FB4_Pos (4U)
#define CAN_F6R1_FB4_Msk (0x1U << CAN_F6R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F6R1_FB4 CAN_F6R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F6R1_FB5_Pos (5U)
#define CAN_F6R1_FB5_Msk (0x1U << CAN_F6R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F6R1_FB5 CAN_F6R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F6R1_FB6_Pos (6U)
#define CAN_F6R1_FB6_Msk (0x1U << CAN_F6R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F6R1_FB6 CAN_F6R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F6R1_FB7_Pos (7U)
#define CAN_F6R1_FB7_Msk (0x1U << CAN_F6R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F6R1_FB7 CAN_F6R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F6R1_FB8_Pos (8U)
#define CAN_F6R1_FB8_Msk (0x1U << CAN_F6R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F6R1_FB8 CAN_F6R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F6R1_FB9_Pos (9U)
#define CAN_F6R1_FB9_Msk (0x1U << CAN_F6R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F6R1_FB9 CAN_F6R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F6R1_FB10_Pos (10U)
#define CAN_F6R1_FB10_Msk (0x1U << CAN_F6R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F6R1_FB10 CAN_F6R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F6R1_FB11_Pos (11U)
#define CAN_F6R1_FB11_Msk (0x1U << CAN_F6R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F6R1_FB11 CAN_F6R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F6R1_FB12_Pos (12U)
#define CAN_F6R1_FB12_Msk (0x1U << CAN_F6R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F6R1_FB12 CAN_F6R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F6R1_FB13_Pos (13U)
#define CAN_F6R1_FB13_Msk (0x1U << CAN_F6R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F6R1_FB13 CAN_F6R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F6R1_FB14_Pos (14U)
#define CAN_F6R1_FB14_Msk (0x1U << CAN_F6R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F6R1_FB14 CAN_F6R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F6R1_FB15_Pos (15U)
#define CAN_F6R1_FB15_Msk (0x1U << CAN_F6R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F6R1_FB15 CAN_F6R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F6R1_FB16_Pos (16U)
#define CAN_F6R1_FB16_Msk (0x1U << CAN_F6R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F6R1_FB16 CAN_F6R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F6R1_FB17_Pos (17U)
#define CAN_F6R1_FB17_Msk (0x1U << CAN_F6R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F6R1_FB17 CAN_F6R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F6R1_FB18_Pos (18U)
#define CAN_F6R1_FB18_Msk (0x1U << CAN_F6R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F6R1_FB18 CAN_F6R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F6R1_FB19_Pos (19U)
#define CAN_F6R1_FB19_Msk (0x1U << CAN_F6R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F6R1_FB19 CAN_F6R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F6R1_FB20_Pos (20U)
#define CAN_F6R1_FB20_Msk (0x1U << CAN_F6R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F6R1_FB20 CAN_F6R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F6R1_FB21_Pos (21U)
#define CAN_F6R1_FB21_Msk (0x1U << CAN_F6R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F6R1_FB21 CAN_F6R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F6R1_FB22_Pos (22U)
#define CAN_F6R1_FB22_Msk (0x1U << CAN_F6R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F6R1_FB22 CAN_F6R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F6R1_FB23_Pos (23U)
#define CAN_F6R1_FB23_Msk (0x1U << CAN_F6R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F6R1_FB23 CAN_F6R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F6R1_FB24_Pos (24U)
#define CAN_F6R1_FB24_Msk (0x1U << CAN_F6R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F6R1_FB24 CAN_F6R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F6R1_FB25_Pos (25U)
#define CAN_F6R1_FB25_Msk (0x1U << CAN_F6R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F6R1_FB25 CAN_F6R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F6R1_FB26_Pos (26U)
#define CAN_F6R1_FB26_Msk (0x1U << CAN_F6R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F6R1_FB26 CAN_F6R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F6R1_FB27_Pos (27U)
#define CAN_F6R1_FB27_Msk (0x1U << CAN_F6R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F6R1_FB27 CAN_F6R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F6R1_FB28_Pos (28U)
#define CAN_F6R1_FB28_Msk (0x1U << CAN_F6R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F6R1_FB28 CAN_F6R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F6R1_FB29_Pos (29U)
#define CAN_F6R1_FB29_Msk (0x1U << CAN_F6R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F6R1_FB29 CAN_F6R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F6R1_FB30_Pos (30U)
#define CAN_F6R1_FB30_Msk (0x1U << CAN_F6R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F6R1_FB30 CAN_F6R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F6R1_FB31_Pos (31U)
#define CAN_F6R1_FB31_Msk (0x1U << CAN_F6R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F6R1_FB31 CAN_F6R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F7R1 register  *******************/
#define CAN_F7R1_FB0_Pos (0U)
#define CAN_F7R1_FB0_Msk (0x1U << CAN_F7R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F7R1_FB0 CAN_F7R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F7R1_FB1_Pos (1U)
#define CAN_F7R1_FB1_Msk (0x1U << CAN_F7R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F7R1_FB1 CAN_F7R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F7R1_FB2_Pos (2U)
#define CAN_F7R1_FB2_Msk (0x1U << CAN_F7R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F7R1_FB2 CAN_F7R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F7R1_FB3_Pos (3U)
#define CAN_F7R1_FB3_Msk (0x1U << CAN_F7R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F7R1_FB3 CAN_F7R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F7R1_FB4_Pos (4U)
#define CAN_F7R1_FB4_Msk (0x1U << CAN_F7R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F7R1_FB4 CAN_F7R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F7R1_FB5_Pos (5U)
#define CAN_F7R1_FB5_Msk (0x1U << CAN_F7R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F7R1_FB5 CAN_F7R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F7R1_FB6_Pos (6U)
#define CAN_F7R1_FB6_Msk (0x1U << CAN_F7R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F7R1_FB6 CAN_F7R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F7R1_FB7_Pos (7U)
#define CAN_F7R1_FB7_Msk (0x1U << CAN_F7R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F7R1_FB7 CAN_F7R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F7R1_FB8_Pos (8U)
#define CAN_F7R1_FB8_Msk (0x1U << CAN_F7R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F7R1_FB8 CAN_F7R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F7R1_FB9_Pos (9U)
#define CAN_F7R1_FB9_Msk (0x1U << CAN_F7R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F7R1_FB9 CAN_F7R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F7R1_FB10_Pos (10U)
#define CAN_F7R1_FB10_Msk (0x1U << CAN_F7R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F7R1_FB10 CAN_F7R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F7R1_FB11_Pos (11U)
#define CAN_F7R1_FB11_Msk (0x1U << CAN_F7R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F7R1_FB11 CAN_F7R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F7R1_FB12_Pos (12U)
#define CAN_F7R1_FB12_Msk (0x1U << CAN_F7R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F7R1_FB12 CAN_F7R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F7R1_FB13_Pos (13U)
#define CAN_F7R1_FB13_Msk (0x1U << CAN_F7R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F7R1_FB13 CAN_F7R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F7R1_FB14_Pos (14U)
#define CAN_F7R1_FB14_Msk (0x1U << CAN_F7R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F7R1_FB14 CAN_F7R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F7R1_FB15_Pos (15U)
#define CAN_F7R1_FB15_Msk (0x1U << CAN_F7R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F7R1_FB15 CAN_F7R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F7R1_FB16_Pos (16U)
#define CAN_F7R1_FB16_Msk (0x1U << CAN_F7R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F7R1_FB16 CAN_F7R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F7R1_FB17_Pos (17U)
#define CAN_F7R1_FB17_Msk (0x1U << CAN_F7R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F7R1_FB17 CAN_F7R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F7R1_FB18_Pos (18U)
#define CAN_F7R1_FB18_Msk (0x1U << CAN_F7R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F7R1_FB18 CAN_F7R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F7R1_FB19_Pos (19U)
#define CAN_F7R1_FB19_Msk (0x1U << CAN_F7R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F7R1_FB19 CAN_F7R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F7R1_FB20_Pos (20U)
#define CAN_F7R1_FB20_Msk (0x1U << CAN_F7R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F7R1_FB20 CAN_F7R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F7R1_FB21_Pos (21U)
#define CAN_F7R1_FB21_Msk (0x1U << CAN_F7R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F7R1_FB21 CAN_F7R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F7R1_FB22_Pos (22U)
#define CAN_F7R1_FB22_Msk (0x1U << CAN_F7R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F7R1_FB22 CAN_F7R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F7R1_FB23_Pos (23U)
#define CAN_F7R1_FB23_Msk (0x1U << CAN_F7R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F7R1_FB23 CAN_F7R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F7R1_FB24_Pos (24U)
#define CAN_F7R1_FB24_Msk (0x1U << CAN_F7R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F7R1_FB24 CAN_F7R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F7R1_FB25_Pos (25U)
#define CAN_F7R1_FB25_Msk (0x1U << CAN_F7R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F7R1_FB25 CAN_F7R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F7R1_FB26_Pos (26U)
#define CAN_F7R1_FB26_Msk (0x1U << CAN_F7R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F7R1_FB26 CAN_F7R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F7R1_FB27_Pos (27U)
#define CAN_F7R1_FB27_Msk (0x1U << CAN_F7R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F7R1_FB27 CAN_F7R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F7R1_FB28_Pos (28U)
#define CAN_F7R1_FB28_Msk (0x1U << CAN_F7R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F7R1_FB28 CAN_F7R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F7R1_FB29_Pos (29U)
#define CAN_F7R1_FB29_Msk (0x1U << CAN_F7R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F7R1_FB29 CAN_F7R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F7R1_FB30_Pos (30U)
#define CAN_F7R1_FB30_Msk (0x1U << CAN_F7R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F7R1_FB30 CAN_F7R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F7R1_FB31_Pos (31U)
#define CAN_F7R1_FB31_Msk (0x1U << CAN_F7R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F7R1_FB31 CAN_F7R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F8R1 register  *******************/
#define CAN_F8R1_FB0_Pos (0U)
#define CAN_F8R1_FB0_Msk (0x1U << CAN_F8R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F8R1_FB0 CAN_F8R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F8R1_FB1_Pos (1U)
#define CAN_F8R1_FB1_Msk (0x1U << CAN_F8R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F8R1_FB1 CAN_F8R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F8R1_FB2_Pos (2U)
#define CAN_F8R1_FB2_Msk (0x1U << CAN_F8R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F8R1_FB2 CAN_F8R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F8R1_FB3_Pos (3U)
#define CAN_F8R1_FB3_Msk (0x1U << CAN_F8R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F8R1_FB3 CAN_F8R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F8R1_FB4_Pos (4U)
#define CAN_F8R1_FB4_Msk (0x1U << CAN_F8R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F8R1_FB4 CAN_F8R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F8R1_FB5_Pos (5U)
#define CAN_F8R1_FB5_Msk (0x1U << CAN_F8R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F8R1_FB5 CAN_F8R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F8R1_FB6_Pos (6U)
#define CAN_F8R1_FB6_Msk (0x1U << CAN_F8R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F8R1_FB6 CAN_F8R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F8R1_FB7_Pos (7U)
#define CAN_F8R1_FB7_Msk (0x1U << CAN_F8R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F8R1_FB7 CAN_F8R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F8R1_FB8_Pos (8U)
#define CAN_F8R1_FB8_Msk (0x1U << CAN_F8R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F8R1_FB8 CAN_F8R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F8R1_FB9_Pos (9U)
#define CAN_F8R1_FB9_Msk (0x1U << CAN_F8R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F8R1_FB9 CAN_F8R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F8R1_FB10_Pos (10U)
#define CAN_F8R1_FB10_Msk (0x1U << CAN_F8R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F8R1_FB10 CAN_F8R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F8R1_FB11_Pos (11U)
#define CAN_F8R1_FB11_Msk (0x1U << CAN_F8R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F8R1_FB11 CAN_F8R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F8R1_FB12_Pos (12U)
#define CAN_F8R1_FB12_Msk (0x1U << CAN_F8R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F8R1_FB12 CAN_F8R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F8R1_FB13_Pos (13U)
#define CAN_F8R1_FB13_Msk (0x1U << CAN_F8R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F8R1_FB13 CAN_F8R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F8R1_FB14_Pos (14U)
#define CAN_F8R1_FB14_Msk (0x1U << CAN_F8R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F8R1_FB14 CAN_F8R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F8R1_FB15_Pos (15U)
#define CAN_F8R1_FB15_Msk (0x1U << CAN_F8R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F8R1_FB15 CAN_F8R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F8R1_FB16_Pos (16U)
#define CAN_F8R1_FB16_Msk (0x1U << CAN_F8R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F8R1_FB16 CAN_F8R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F8R1_FB17_Pos (17U)
#define CAN_F8R1_FB17_Msk (0x1U << CAN_F8R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F8R1_FB17 CAN_F8R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F8R1_FB18_Pos (18U)
#define CAN_F8R1_FB18_Msk (0x1U << CAN_F8R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F8R1_FB18 CAN_F8R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F8R1_FB19_Pos (19U)
#define CAN_F8R1_FB19_Msk (0x1U << CAN_F8R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F8R1_FB19 CAN_F8R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F8R1_FB20_Pos (20U)
#define CAN_F8R1_FB20_Msk (0x1U << CAN_F8R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F8R1_FB20 CAN_F8R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F8R1_FB21_Pos (21U)
#define CAN_F8R1_FB21_Msk (0x1U << CAN_F8R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F8R1_FB21 CAN_F8R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F8R1_FB22_Pos (22U)
#define CAN_F8R1_FB22_Msk (0x1U << CAN_F8R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F8R1_FB22 CAN_F8R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F8R1_FB23_Pos (23U)
#define CAN_F8R1_FB23_Msk (0x1U << CAN_F8R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F8R1_FB23 CAN_F8R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F8R1_FB24_Pos (24U)
#define CAN_F8R1_FB24_Msk (0x1U << CAN_F8R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F8R1_FB24 CAN_F8R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F8R1_FB25_Pos (25U)
#define CAN_F8R1_FB25_Msk (0x1U << CAN_F8R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F8R1_FB25 CAN_F8R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F8R1_FB26_Pos (26U)
#define CAN_F8R1_FB26_Msk (0x1U << CAN_F8R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F8R1_FB26 CAN_F8R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F8R1_FB27_Pos (27U)
#define CAN_F8R1_FB27_Msk (0x1U << CAN_F8R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F8R1_FB27 CAN_F8R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F8R1_FB28_Pos (28U)
#define CAN_F8R1_FB28_Msk (0x1U << CAN_F8R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F8R1_FB28 CAN_F8R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F8R1_FB29_Pos (29U)
#define CAN_F8R1_FB29_Msk (0x1U << CAN_F8R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F8R1_FB29 CAN_F8R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F8R1_FB30_Pos (30U)
#define CAN_F8R1_FB30_Msk (0x1U << CAN_F8R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F8R1_FB30 CAN_F8R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F8R1_FB31_Pos (31U)
#define CAN_F8R1_FB31_Msk (0x1U << CAN_F8R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F8R1_FB31 CAN_F8R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F9R1 register  *******************/
#define CAN_F9R1_FB0_Pos (0U)
#define CAN_F9R1_FB0_Msk (0x1U << CAN_F9R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F9R1_FB0 CAN_F9R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F9R1_FB1_Pos (1U)
#define CAN_F9R1_FB1_Msk (0x1U << CAN_F9R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F9R1_FB1 CAN_F9R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F9R1_FB2_Pos (2U)
#define CAN_F9R1_FB2_Msk (0x1U << CAN_F9R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F9R1_FB2 CAN_F9R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F9R1_FB3_Pos (3U)
#define CAN_F9R1_FB3_Msk (0x1U << CAN_F9R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F9R1_FB3 CAN_F9R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F9R1_FB4_Pos (4U)
#define CAN_F9R1_FB4_Msk (0x1U << CAN_F9R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F9R1_FB4 CAN_F9R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F9R1_FB5_Pos (5U)
#define CAN_F9R1_FB5_Msk (0x1U << CAN_F9R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F9R1_FB5 CAN_F9R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F9R1_FB6_Pos (6U)
#define CAN_F9R1_FB6_Msk (0x1U << CAN_F9R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F9R1_FB6 CAN_F9R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F9R1_FB7_Pos (7U)
#define CAN_F9R1_FB7_Msk (0x1U << CAN_F9R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F9R1_FB7 CAN_F9R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F9R1_FB8_Pos (8U)
#define CAN_F9R1_FB8_Msk (0x1U << CAN_F9R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F9R1_FB8 CAN_F9R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F9R1_FB9_Pos (9U)
#define CAN_F9R1_FB9_Msk (0x1U << CAN_F9R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F9R1_FB9 CAN_F9R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F9R1_FB10_Pos (10U)
#define CAN_F9R1_FB10_Msk (0x1U << CAN_F9R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F9R1_FB10 CAN_F9R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F9R1_FB11_Pos (11U)
#define CAN_F9R1_FB11_Msk (0x1U << CAN_F9R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F9R1_FB11 CAN_F9R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F9R1_FB12_Pos (12U)
#define CAN_F9R1_FB12_Msk (0x1U << CAN_F9R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F9R1_FB12 CAN_F9R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F9R1_FB13_Pos (13U)
#define CAN_F9R1_FB13_Msk (0x1U << CAN_F9R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F9R1_FB13 CAN_F9R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F9R1_FB14_Pos (14U)
#define CAN_F9R1_FB14_Msk (0x1U << CAN_F9R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F9R1_FB14 CAN_F9R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F9R1_FB15_Pos (15U)
#define CAN_F9R1_FB15_Msk (0x1U << CAN_F9R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F9R1_FB15 CAN_F9R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F9R1_FB16_Pos (16U)
#define CAN_F9R1_FB16_Msk (0x1U << CAN_F9R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F9R1_FB16 CAN_F9R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F9R1_FB17_Pos (17U)
#define CAN_F9R1_FB17_Msk (0x1U << CAN_F9R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F9R1_FB17 CAN_F9R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F9R1_FB18_Pos (18U)
#define CAN_F9R1_FB18_Msk (0x1U << CAN_F9R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F9R1_FB18 CAN_F9R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F9R1_FB19_Pos (19U)
#define CAN_F9R1_FB19_Msk (0x1U << CAN_F9R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F9R1_FB19 CAN_F9R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F9R1_FB20_Pos (20U)
#define CAN_F9R1_FB20_Msk (0x1U << CAN_F9R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F9R1_FB20 CAN_F9R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F9R1_FB21_Pos (21U)
#define CAN_F9R1_FB21_Msk (0x1U << CAN_F9R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F9R1_FB21 CAN_F9R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F9R1_FB22_Pos (22U)
#define CAN_F9R1_FB22_Msk (0x1U << CAN_F9R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F9R1_FB22 CAN_F9R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F9R1_FB23_Pos (23U)
#define CAN_F9R1_FB23_Msk (0x1U << CAN_F9R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F9R1_FB23 CAN_F9R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F9R1_FB24_Pos (24U)
#define CAN_F9R1_FB24_Msk (0x1U << CAN_F9R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F9R1_FB24 CAN_F9R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F9R1_FB25_Pos (25U)
#define CAN_F9R1_FB25_Msk (0x1U << CAN_F9R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F9R1_FB25 CAN_F9R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F9R1_FB26_Pos (26U)
#define CAN_F9R1_FB26_Msk (0x1U << CAN_F9R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F9R1_FB26 CAN_F9R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F9R1_FB27_Pos (27U)
#define CAN_F9R1_FB27_Msk (0x1U << CAN_F9R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F9R1_FB27 CAN_F9R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F9R1_FB28_Pos (28U)
#define CAN_F9R1_FB28_Msk (0x1U << CAN_F9R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F9R1_FB28 CAN_F9R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F9R1_FB29_Pos (29U)
#define CAN_F9R1_FB29_Msk (0x1U << CAN_F9R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F9R1_FB29 CAN_F9R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F9R1_FB30_Pos (30U)
#define CAN_F9R1_FB30_Msk (0x1U << CAN_F9R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F9R1_FB30 CAN_F9R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F9R1_FB31_Pos (31U)
#define CAN_F9R1_FB31_Msk (0x1U << CAN_F9R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F9R1_FB31 CAN_F9R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F10R1 register  ******************/
#define CAN_F10R1_FB0_Pos (0U)
#define CAN_F10R1_FB0_Msk (0x1U << CAN_F10R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F10R1_FB0 CAN_F10R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F10R1_FB1_Pos (1U)
#define CAN_F10R1_FB1_Msk (0x1U << CAN_F10R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F10R1_FB1 CAN_F10R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F10R1_FB2_Pos (2U)
#define CAN_F10R1_FB2_Msk (0x1U << CAN_F10R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F10R1_FB2 CAN_F10R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F10R1_FB3_Pos (3U)
#define CAN_F10R1_FB3_Msk (0x1U << CAN_F10R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F10R1_FB3 CAN_F10R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F10R1_FB4_Pos (4U)
#define CAN_F10R1_FB4_Msk (0x1U << CAN_F10R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F10R1_FB4 CAN_F10R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F10R1_FB5_Pos (5U)
#define CAN_F10R1_FB5_Msk (0x1U << CAN_F10R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F10R1_FB5 CAN_F10R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F10R1_FB6_Pos (6U)
#define CAN_F10R1_FB6_Msk (0x1U << CAN_F10R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F10R1_FB6 CAN_F10R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F10R1_FB7_Pos (7U)
#define CAN_F10R1_FB7_Msk (0x1U << CAN_F10R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F10R1_FB7 CAN_F10R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F10R1_FB8_Pos (8U)
#define CAN_F10R1_FB8_Msk (0x1U << CAN_F10R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F10R1_FB8 CAN_F10R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F10R1_FB9_Pos (9U)
#define CAN_F10R1_FB9_Msk (0x1U << CAN_F10R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F10R1_FB9 CAN_F10R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F10R1_FB10_Pos (10U)
#define CAN_F10R1_FB10_Msk (0x1U << CAN_F10R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F10R1_FB10 CAN_F10R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F10R1_FB11_Pos (11U)
#define CAN_F10R1_FB11_Msk (0x1U << CAN_F10R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F10R1_FB11 CAN_F10R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F10R1_FB12_Pos (12U)
#define CAN_F10R1_FB12_Msk (0x1U << CAN_F10R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F10R1_FB12 CAN_F10R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F10R1_FB13_Pos (13U)
#define CAN_F10R1_FB13_Msk (0x1U << CAN_F10R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F10R1_FB13 CAN_F10R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F10R1_FB14_Pos (14U)
#define CAN_F10R1_FB14_Msk (0x1U << CAN_F10R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F10R1_FB14 CAN_F10R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F10R1_FB15_Pos (15U)
#define CAN_F10R1_FB15_Msk (0x1U << CAN_F10R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F10R1_FB15 CAN_F10R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F10R1_FB16_Pos (16U)
#define CAN_F10R1_FB16_Msk (0x1U << CAN_F10R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F10R1_FB16 CAN_F10R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F10R1_FB17_Pos (17U)
#define CAN_F10R1_FB17_Msk (0x1U << CAN_F10R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F10R1_FB17 CAN_F10R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F10R1_FB18_Pos (18U)
#define CAN_F10R1_FB18_Msk (0x1U << CAN_F10R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F10R1_FB18 CAN_F10R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F10R1_FB19_Pos (19U)
#define CAN_F10R1_FB19_Msk (0x1U << CAN_F10R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F10R1_FB19 CAN_F10R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F10R1_FB20_Pos (20U)
#define CAN_F10R1_FB20_Msk (0x1U << CAN_F10R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F10R1_FB20 CAN_F10R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F10R1_FB21_Pos (21U)
#define CAN_F10R1_FB21_Msk (0x1U << CAN_F10R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F10R1_FB21 CAN_F10R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F10R1_FB22_Pos (22U)
#define CAN_F10R1_FB22_Msk (0x1U << CAN_F10R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F10R1_FB22 CAN_F10R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F10R1_FB23_Pos (23U)
#define CAN_F10R1_FB23_Msk (0x1U << CAN_F10R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F10R1_FB23 CAN_F10R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F10R1_FB24_Pos (24U)
#define CAN_F10R1_FB24_Msk (0x1U << CAN_F10R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F10R1_FB24 CAN_F10R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F10R1_FB25_Pos (25U)
#define CAN_F10R1_FB25_Msk (0x1U << CAN_F10R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F10R1_FB25 CAN_F10R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F10R1_FB26_Pos (26U)
#define CAN_F10R1_FB26_Msk (0x1U << CAN_F10R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F10R1_FB26 CAN_F10R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F10R1_FB27_Pos (27U)
#define CAN_F10R1_FB27_Msk (0x1U << CAN_F10R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F10R1_FB27 CAN_F10R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F10R1_FB28_Pos (28U)
#define CAN_F10R1_FB28_Msk (0x1U << CAN_F10R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F10R1_FB28 CAN_F10R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F10R1_FB29_Pos (29U)
#define CAN_F10R1_FB29_Msk (0x1U << CAN_F10R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F10R1_FB29 CAN_F10R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F10R1_FB30_Pos (30U)
#define CAN_F10R1_FB30_Msk (0x1U << CAN_F10R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F10R1_FB30 CAN_F10R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F10R1_FB31_Pos (31U)
#define CAN_F10R1_FB31_Msk (0x1U << CAN_F10R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F10R1_FB31 CAN_F10R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F11R1 register  ******************/
#define CAN_F11R1_FB0_Pos (0U)
#define CAN_F11R1_FB0_Msk (0x1U << CAN_F11R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F11R1_FB0 CAN_F11R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F11R1_FB1_Pos (1U)
#define CAN_F11R1_FB1_Msk (0x1U << CAN_F11R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F11R1_FB1 CAN_F11R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F11R1_FB2_Pos (2U)
#define CAN_F11R1_FB2_Msk (0x1U << CAN_F11R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F11R1_FB2 CAN_F11R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F11R1_FB3_Pos (3U)
#define CAN_F11R1_FB3_Msk (0x1U << CAN_F11R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F11R1_FB3 CAN_F11R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F11R1_FB4_Pos (4U)
#define CAN_F11R1_FB4_Msk (0x1U << CAN_F11R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F11R1_FB4 CAN_F11R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F11R1_FB5_Pos (5U)
#define CAN_F11R1_FB5_Msk (0x1U << CAN_F11R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F11R1_FB5 CAN_F11R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F11R1_FB6_Pos (6U)
#define CAN_F11R1_FB6_Msk (0x1U << CAN_F11R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F11R1_FB6 CAN_F11R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F11R1_FB7_Pos (7U)
#define CAN_F11R1_FB7_Msk (0x1U << CAN_F11R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F11R1_FB7 CAN_F11R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F11R1_FB8_Pos (8U)
#define CAN_F11R1_FB8_Msk (0x1U << CAN_F11R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F11R1_FB8 CAN_F11R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F11R1_FB9_Pos (9U)
#define CAN_F11R1_FB9_Msk (0x1U << CAN_F11R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F11R1_FB9 CAN_F11R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F11R1_FB10_Pos (10U)
#define CAN_F11R1_FB10_Msk (0x1U << CAN_F11R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F11R1_FB10 CAN_F11R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F11R1_FB11_Pos (11U)
#define CAN_F11R1_FB11_Msk (0x1U << CAN_F11R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F11R1_FB11 CAN_F11R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F11R1_FB12_Pos (12U)
#define CAN_F11R1_FB12_Msk (0x1U << CAN_F11R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F11R1_FB12 CAN_F11R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F11R1_FB13_Pos (13U)
#define CAN_F11R1_FB13_Msk (0x1U << CAN_F11R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F11R1_FB13 CAN_F11R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F11R1_FB14_Pos (14U)
#define CAN_F11R1_FB14_Msk (0x1U << CAN_F11R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F11R1_FB14 CAN_F11R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F11R1_FB15_Pos (15U)
#define CAN_F11R1_FB15_Msk (0x1U << CAN_F11R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F11R1_FB15 CAN_F11R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F11R1_FB16_Pos (16U)
#define CAN_F11R1_FB16_Msk (0x1U << CAN_F11R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F11R1_FB16 CAN_F11R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F11R1_FB17_Pos (17U)
#define CAN_F11R1_FB17_Msk (0x1U << CAN_F11R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F11R1_FB17 CAN_F11R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F11R1_FB18_Pos (18U)
#define CAN_F11R1_FB18_Msk (0x1U << CAN_F11R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F11R1_FB18 CAN_F11R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F11R1_FB19_Pos (19U)
#define CAN_F11R1_FB19_Msk (0x1U << CAN_F11R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F11R1_FB19 CAN_F11R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F11R1_FB20_Pos (20U)
#define CAN_F11R1_FB20_Msk (0x1U << CAN_F11R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F11R1_FB20 CAN_F11R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F11R1_FB21_Pos (21U)
#define CAN_F11R1_FB21_Msk (0x1U << CAN_F11R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F11R1_FB21 CAN_F11R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F11R1_FB22_Pos (22U)
#define CAN_F11R1_FB22_Msk (0x1U << CAN_F11R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F11R1_FB22 CAN_F11R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F11R1_FB23_Pos (23U)
#define CAN_F11R1_FB23_Msk (0x1U << CAN_F11R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F11R1_FB23 CAN_F11R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F11R1_FB24_Pos (24U)
#define CAN_F11R1_FB24_Msk (0x1U << CAN_F11R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F11R1_FB24 CAN_F11R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F11R1_FB25_Pos (25U)
#define CAN_F11R1_FB25_Msk (0x1U << CAN_F11R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F11R1_FB25 CAN_F11R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F11R1_FB26_Pos (26U)
#define CAN_F11R1_FB26_Msk (0x1U << CAN_F11R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F11R1_FB26 CAN_F11R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F11R1_FB27_Pos (27U)
#define CAN_F11R1_FB27_Msk (0x1U << CAN_F11R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F11R1_FB27 CAN_F11R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F11R1_FB28_Pos (28U)
#define CAN_F11R1_FB28_Msk (0x1U << CAN_F11R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F11R1_FB28 CAN_F11R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F11R1_FB29_Pos (29U)
#define CAN_F11R1_FB29_Msk (0x1U << CAN_F11R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F11R1_FB29 CAN_F11R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F11R1_FB30_Pos (30U)
#define CAN_F11R1_FB30_Msk (0x1U << CAN_F11R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F11R1_FB30 CAN_F11R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F11R1_FB31_Pos (31U)
#define CAN_F11R1_FB31_Msk (0x1U << CAN_F11R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F11R1_FB31 CAN_F11R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F12R1 register  ******************/
#define CAN_F12R1_FB0_Pos (0U)
#define CAN_F12R1_FB0_Msk (0x1U << CAN_F12R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F12R1_FB0 CAN_F12R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F12R1_FB1_Pos (1U)
#define CAN_F12R1_FB1_Msk (0x1U << CAN_F12R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F12R1_FB1 CAN_F12R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F12R1_FB2_Pos (2U)
#define CAN_F12R1_FB2_Msk (0x1U << CAN_F12R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F12R1_FB2 CAN_F12R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F12R1_FB3_Pos (3U)
#define CAN_F12R1_FB3_Msk (0x1U << CAN_F12R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F12R1_FB3 CAN_F12R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F12R1_FB4_Pos (4U)
#define CAN_F12R1_FB4_Msk (0x1U << CAN_F12R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F12R1_FB4 CAN_F12R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F12R1_FB5_Pos (5U)
#define CAN_F12R1_FB5_Msk (0x1U << CAN_F12R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F12R1_FB5 CAN_F12R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F12R1_FB6_Pos (6U)
#define CAN_F12R1_FB6_Msk (0x1U << CAN_F12R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F12R1_FB6 CAN_F12R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F12R1_FB7_Pos (7U)
#define CAN_F12R1_FB7_Msk (0x1U << CAN_F12R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F12R1_FB7 CAN_F12R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F12R1_FB8_Pos (8U)
#define CAN_F12R1_FB8_Msk (0x1U << CAN_F12R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F12R1_FB8 CAN_F12R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F12R1_FB9_Pos (9U)
#define CAN_F12R1_FB9_Msk (0x1U << CAN_F12R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F12R1_FB9 CAN_F12R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F12R1_FB10_Pos (10U)
#define CAN_F12R1_FB10_Msk (0x1U << CAN_F12R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F12R1_FB10 CAN_F12R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F12R1_FB11_Pos (11U)
#define CAN_F12R1_FB11_Msk (0x1U << CAN_F12R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F12R1_FB11 CAN_F12R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F12R1_FB12_Pos (12U)
#define CAN_F12R1_FB12_Msk (0x1U << CAN_F12R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F12R1_FB12 CAN_F12R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F12R1_FB13_Pos (13U)
#define CAN_F12R1_FB13_Msk (0x1U << CAN_F12R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F12R1_FB13 CAN_F12R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F12R1_FB14_Pos (14U)
#define CAN_F12R1_FB14_Msk (0x1U << CAN_F12R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F12R1_FB14 CAN_F12R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F12R1_FB15_Pos (15U)
#define CAN_F12R1_FB15_Msk (0x1U << CAN_F12R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F12R1_FB15 CAN_F12R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F12R1_FB16_Pos (16U)
#define CAN_F12R1_FB16_Msk (0x1U << CAN_F12R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F12R1_FB16 CAN_F12R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F12R1_FB17_Pos (17U)
#define CAN_F12R1_FB17_Msk (0x1U << CAN_F12R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F12R1_FB17 CAN_F12R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F12R1_FB18_Pos (18U)
#define CAN_F12R1_FB18_Msk (0x1U << CAN_F12R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F12R1_FB18 CAN_F12R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F12R1_FB19_Pos (19U)
#define CAN_F12R1_FB19_Msk (0x1U << CAN_F12R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F12R1_FB19 CAN_F12R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F12R1_FB20_Pos (20U)
#define CAN_F12R1_FB20_Msk (0x1U << CAN_F12R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F12R1_FB20 CAN_F12R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F12R1_FB21_Pos (21U)
#define CAN_F12R1_FB21_Msk (0x1U << CAN_F12R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F12R1_FB21 CAN_F12R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F12R1_FB22_Pos (22U)
#define CAN_F12R1_FB22_Msk (0x1U << CAN_F12R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F12R1_FB22 CAN_F12R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F12R1_FB23_Pos (23U)
#define CAN_F12R1_FB23_Msk (0x1U << CAN_F12R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F12R1_FB23 CAN_F12R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F12R1_FB24_Pos (24U)
#define CAN_F12R1_FB24_Msk (0x1U << CAN_F12R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F12R1_FB24 CAN_F12R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F12R1_FB25_Pos (25U)
#define CAN_F12R1_FB25_Msk (0x1U << CAN_F12R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F12R1_FB25 CAN_F12R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F12R1_FB26_Pos (26U)
#define CAN_F12R1_FB26_Msk (0x1U << CAN_F12R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F12R1_FB26 CAN_F12R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F12R1_FB27_Pos (27U)
#define CAN_F12R1_FB27_Msk (0x1U << CAN_F12R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F12R1_FB27 CAN_F12R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F12R1_FB28_Pos (28U)
#define CAN_F12R1_FB28_Msk (0x1U << CAN_F12R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F12R1_FB28 CAN_F12R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F12R1_FB29_Pos (29U)
#define CAN_F12R1_FB29_Msk (0x1U << CAN_F12R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F12R1_FB29 CAN_F12R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F12R1_FB30_Pos (30U)
#define CAN_F12R1_FB30_Msk (0x1U << CAN_F12R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F12R1_FB30 CAN_F12R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F12R1_FB31_Pos (31U)
#define CAN_F12R1_FB31_Msk (0x1U << CAN_F12R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F12R1_FB31 CAN_F12R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F13R1 register  ******************/
#define CAN_F13R1_FB0_Pos (0U)
#define CAN_F13R1_FB0_Msk (0x1U << CAN_F13R1_FB0_Pos) /*!< 0x00000001 */
#define CAN_F13R1_FB0 CAN_F13R1_FB0_Msk /*!< Filter bit 0 */
#define CAN_F13R1_FB1_Pos (1U)
#define CAN_F13R1_FB1_Msk (0x1U << CAN_F13R1_FB1_Pos) /*!< 0x00000002 */
#define CAN_F13R1_FB1 CAN_F13R1_FB1_Msk /*!< Filter bit 1 */
#define CAN_F13R1_FB2_Pos (2U)
#define CAN_F13R1_FB2_Msk (0x1U << CAN_F13R1_FB2_Pos) /*!< 0x00000004 */
#define CAN_F13R1_FB2 CAN_F13R1_FB2_Msk /*!< Filter bit 2 */
#define CAN_F13R1_FB3_Pos (3U)
#define CAN_F13R1_FB3_Msk (0x1U << CAN_F13R1_FB3_Pos) /*!< 0x00000008 */
#define CAN_F13R1_FB3 CAN_F13R1_FB3_Msk /*!< Filter bit 3 */
#define CAN_F13R1_FB4_Pos (4U)
#define CAN_F13R1_FB4_Msk (0x1U << CAN_F13R1_FB4_Pos) /*!< 0x00000010 */
#define CAN_F13R1_FB4 CAN_F13R1_FB4_Msk /*!< Filter bit 4 */
#define CAN_F13R1_FB5_Pos (5U)
#define CAN_F13R1_FB5_Msk (0x1U << CAN_F13R1_FB5_Pos) /*!< 0x00000020 */
#define CAN_F13R1_FB5 CAN_F13R1_FB5_Msk /*!< Filter bit 5 */
#define CAN_F13R1_FB6_Pos (6U)
#define CAN_F13R1_FB6_Msk (0x1U << CAN_F13R1_FB6_Pos) /*!< 0x00000040 */
#define CAN_F13R1_FB6 CAN_F13R1_FB6_Msk /*!< Filter bit 6 */
#define CAN_F13R1_FB7_Pos (7U)
#define CAN_F13R1_FB7_Msk (0x1U << CAN_F13R1_FB7_Pos) /*!< 0x00000080 */
#define CAN_F13R1_FB7 CAN_F13R1_FB7_Msk /*!< Filter bit 7 */
#define CAN_F13R1_FB8_Pos (8U)
#define CAN_F13R1_FB8_Msk (0x1U << CAN_F13R1_FB8_Pos) /*!< 0x00000100 */
#define CAN_F13R1_FB8 CAN_F13R1_FB8_Msk /*!< Filter bit 8 */
#define CAN_F13R1_FB9_Pos (9U)
#define CAN_F13R1_FB9_Msk (0x1U << CAN_F13R1_FB9_Pos) /*!< 0x00000200 */
#define CAN_F13R1_FB9 CAN_F13R1_FB9_Msk /*!< Filter bit 9 */
#define CAN_F13R1_FB10_Pos (10U)
#define CAN_F13R1_FB10_Msk (0x1U << CAN_F13R1_FB10_Pos) /*!< 0x00000400 */
#define CAN_F13R1_FB10 CAN_F13R1_FB10_Msk /*!< Filter bit 10 */
#define CAN_F13R1_FB11_Pos (11U)
#define CAN_F13R1_FB11_Msk (0x1U << CAN_F13R1_FB11_Pos) /*!< 0x00000800 */
#define CAN_F13R1_FB11 CAN_F13R1_FB11_Msk /*!< Filter bit 11 */
#define CAN_F13R1_FB12_Pos (12U)
#define CAN_F13R1_FB12_Msk (0x1U << CAN_F13R1_FB12_Pos) /*!< 0x00001000 */
#define CAN_F13R1_FB12 CAN_F13R1_FB12_Msk /*!< Filter bit 12 */
#define CAN_F13R1_FB13_Pos (13U)
#define CAN_F13R1_FB13_Msk (0x1U << CAN_F13R1_FB13_Pos) /*!< 0x00002000 */
#define CAN_F13R1_FB13 CAN_F13R1_FB13_Msk /*!< Filter bit 13 */
#define CAN_F13R1_FB14_Pos (14U)
#define CAN_F13R1_FB14_Msk (0x1U << CAN_F13R1_FB14_Pos) /*!< 0x00004000 */
#define CAN_F13R1_FB14 CAN_F13R1_FB14_Msk /*!< Filter bit 14 */
#define CAN_F13R1_FB15_Pos (15U)
#define CAN_F13R1_FB15_Msk (0x1U << CAN_F13R1_FB15_Pos) /*!< 0x00008000 */
#define CAN_F13R1_FB15 CAN_F13R1_FB15_Msk /*!< Filter bit 15 */
#define CAN_F13R1_FB16_Pos (16U)
#define CAN_F13R1_FB16_Msk (0x1U << CAN_F13R1_FB16_Pos) /*!< 0x00010000 */
#define CAN_F13R1_FB16 CAN_F13R1_FB16_Msk /*!< Filter bit 16 */
#define CAN_F13R1_FB17_Pos (17U)
#define CAN_F13R1_FB17_Msk (0x1U << CAN_F13R1_FB17_Pos) /*!< 0x00020000 */
#define CAN_F13R1_FB17 CAN_F13R1_FB17_Msk /*!< Filter bit 17 */
#define CAN_F13R1_FB18_Pos (18U)
#define CAN_F13R1_FB18_Msk (0x1U << CAN_F13R1_FB18_Pos) /*!< 0x00040000 */
#define CAN_F13R1_FB18 CAN_F13R1_FB18_Msk /*!< Filter bit 18 */
#define CAN_F13R1_FB19_Pos (19U)
#define CAN_F13R1_FB19_Msk (0x1U << CAN_F13R1_FB19_Pos) /*!< 0x00080000 */
#define CAN_F13R1_FB19 CAN_F13R1_FB19_Msk /*!< Filter bit 19 */
#define CAN_F13R1_FB20_Pos (20U)
#define CAN_F13R1_FB20_Msk (0x1U << CAN_F13R1_FB20_Pos) /*!< 0x00100000 */
#define CAN_F13R1_FB20 CAN_F13R1_FB20_Msk /*!< Filter bit 20 */
#define CAN_F13R1_FB21_Pos (21U)
#define CAN_F13R1_FB21_Msk (0x1U << CAN_F13R1_FB21_Pos) /*!< 0x00200000 */
#define CAN_F13R1_FB21 CAN_F13R1_FB21_Msk /*!< Filter bit 21 */
#define CAN_F13R1_FB22_Pos (22U)
#define CAN_F13R1_FB22_Msk (0x1U << CAN_F13R1_FB22_Pos) /*!< 0x00400000 */
#define CAN_F13R1_FB22 CAN_F13R1_FB22_Msk /*!< Filter bit 22 */
#define CAN_F13R1_FB23_Pos (23U)
#define CAN_F13R1_FB23_Msk (0x1U << CAN_F13R1_FB23_Pos) /*!< 0x00800000 */
#define CAN_F13R1_FB23 CAN_F13R1_FB23_Msk /*!< Filter bit 23 */
#define CAN_F13R1_FB24_Pos (24U)
#define CAN_F13R1_FB24_Msk (0x1U << CAN_F13R1_FB24_Pos) /*!< 0x01000000 */
#define CAN_F13R1_FB24 CAN_F13R1_FB24_Msk /*!< Filter bit 24 */
#define CAN_F13R1_FB25_Pos (25U)
#define CAN_F13R1_FB25_Msk (0x1U << CAN_F13R1_FB25_Pos) /*!< 0x02000000 */
#define CAN_F13R1_FB25 CAN_F13R1_FB25_Msk /*!< Filter bit 25 */
#define CAN_F13R1_FB26_Pos (26U)
#define CAN_F13R1_FB26_Msk (0x1U << CAN_F13R1_FB26_Pos) /*!< 0x04000000 */
#define CAN_F13R1_FB26 CAN_F13R1_FB26_Msk /*!< Filter bit 26 */
#define CAN_F13R1_FB27_Pos (27U)
#define CAN_F13R1_FB27_Msk (0x1U << CAN_F13R1_FB27_Pos) /*!< 0x08000000 */
#define CAN_F13R1_FB27 CAN_F13R1_FB27_Msk /*!< Filter bit 27 */
#define CAN_F13R1_FB28_Pos (28U)
#define CAN_F13R1_FB28_Msk (0x1U << CAN_F13R1_FB28_Pos) /*!< 0x10000000 */
#define CAN_F13R1_FB28 CAN_F13R1_FB28_Msk /*!< Filter bit 28 */
#define CAN_F13R1_FB29_Pos (29U)
#define CAN_F13R1_FB29_Msk (0x1U << CAN_F13R1_FB29_Pos) /*!< 0x20000000 */
#define CAN_F13R1_FB29 CAN_F13R1_FB29_Msk /*!< Filter bit 29 */
#define CAN_F13R1_FB30_Pos (30U)
#define CAN_F13R1_FB30_Msk (0x1U << CAN_F13R1_FB30_Pos) /*!< 0x40000000 */
#define CAN_F13R1_FB30 CAN_F13R1_FB30_Msk /*!< Filter bit 30 */
#define CAN_F13R1_FB31_Pos (31U)
#define CAN_F13R1_FB31_Msk (0x1U << CAN_F13R1_FB31_Pos) /*!< 0x80000000 */
#define CAN_F13R1_FB31 CAN_F13R1_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F0R2 register  *******************/
#define CAN_F0R2_FB0_Pos (0U)
#define CAN_F0R2_FB0_Msk (0x1U << CAN_F0R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F0R2_FB0 CAN_F0R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F0R2_FB1_Pos (1U)
#define CAN_F0R2_FB1_Msk (0x1U << CAN_F0R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F0R2_FB1 CAN_F0R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F0R2_FB2_Pos (2U)
#define CAN_F0R2_FB2_Msk (0x1U << CAN_F0R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F0R2_FB2 CAN_F0R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F0R2_FB3_Pos (3U)
#define CAN_F0R2_FB3_Msk (0x1U << CAN_F0R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F0R2_FB3 CAN_F0R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F0R2_FB4_Pos (4U)
#define CAN_F0R2_FB4_Msk (0x1U << CAN_F0R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F0R2_FB4 CAN_F0R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F0R2_FB5_Pos (5U)
#define CAN_F0R2_FB5_Msk (0x1U << CAN_F0R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F0R2_FB5 CAN_F0R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F0R2_FB6_Pos (6U)
#define CAN_F0R2_FB6_Msk (0x1U << CAN_F0R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F0R2_FB6 CAN_F0R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F0R2_FB7_Pos (7U)
#define CAN_F0R2_FB7_Msk (0x1U << CAN_F0R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F0R2_FB7 CAN_F0R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F0R2_FB8_Pos (8U)
#define CAN_F0R2_FB8_Msk (0x1U << CAN_F0R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F0R2_FB8 CAN_F0R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F0R2_FB9_Pos (9U)
#define CAN_F0R2_FB9_Msk (0x1U << CAN_F0R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F0R2_FB9 CAN_F0R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F0R2_FB10_Pos (10U)
#define CAN_F0R2_FB10_Msk (0x1U << CAN_F0R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F0R2_FB10 CAN_F0R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F0R2_FB11_Pos (11U)
#define CAN_F0R2_FB11_Msk (0x1U << CAN_F0R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F0R2_FB11 CAN_F0R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F0R2_FB12_Pos (12U)
#define CAN_F0R2_FB12_Msk (0x1U << CAN_F0R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F0R2_FB12 CAN_F0R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F0R2_FB13_Pos (13U)
#define CAN_F0R2_FB13_Msk (0x1U << CAN_F0R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F0R2_FB13 CAN_F0R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F0R2_FB14_Pos (14U)
#define CAN_F0R2_FB14_Msk (0x1U << CAN_F0R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F0R2_FB14 CAN_F0R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F0R2_FB15_Pos (15U)
#define CAN_F0R2_FB15_Msk (0x1U << CAN_F0R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F0R2_FB15 CAN_F0R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F0R2_FB16_Pos (16U)
#define CAN_F0R2_FB16_Msk (0x1U << CAN_F0R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F0R2_FB16 CAN_F0R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F0R2_FB17_Pos (17U)
#define CAN_F0R2_FB17_Msk (0x1U << CAN_F0R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F0R2_FB17 CAN_F0R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F0R2_FB18_Pos (18U)
#define CAN_F0R2_FB18_Msk (0x1U << CAN_F0R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F0R2_FB18 CAN_F0R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F0R2_FB19_Pos (19U)
#define CAN_F0R2_FB19_Msk (0x1U << CAN_F0R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F0R2_FB19 CAN_F0R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F0R2_FB20_Pos (20U)
#define CAN_F0R2_FB20_Msk (0x1U << CAN_F0R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F0R2_FB20 CAN_F0R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F0R2_FB21_Pos (21U)
#define CAN_F0R2_FB21_Msk (0x1U << CAN_F0R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F0R2_FB21 CAN_F0R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F0R2_FB22_Pos (22U)
#define CAN_F0R2_FB22_Msk (0x1U << CAN_F0R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F0R2_FB22 CAN_F0R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F0R2_FB23_Pos (23U)
#define CAN_F0R2_FB23_Msk (0x1U << CAN_F0R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F0R2_FB23 CAN_F0R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F0R2_FB24_Pos (24U)
#define CAN_F0R2_FB24_Msk (0x1U << CAN_F0R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F0R2_FB24 CAN_F0R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F0R2_FB25_Pos (25U)
#define CAN_F0R2_FB25_Msk (0x1U << CAN_F0R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F0R2_FB25 CAN_F0R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F0R2_FB26_Pos (26U)
#define CAN_F0R2_FB26_Msk (0x1U << CAN_F0R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F0R2_FB26 CAN_F0R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F0R2_FB27_Pos (27U)
#define CAN_F0R2_FB27_Msk (0x1U << CAN_F0R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F0R2_FB27 CAN_F0R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F0R2_FB28_Pos (28U)
#define CAN_F0R2_FB28_Msk (0x1U << CAN_F0R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F0R2_FB28 CAN_F0R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F0R2_FB29_Pos (29U)
#define CAN_F0R2_FB29_Msk (0x1U << CAN_F0R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F0R2_FB29 CAN_F0R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F0R2_FB30_Pos (30U)
#define CAN_F0R2_FB30_Msk (0x1U << CAN_F0R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F0R2_FB30 CAN_F0R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F0R2_FB31_Pos (31U)
#define CAN_F0R2_FB31_Msk (0x1U << CAN_F0R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F0R2_FB31 CAN_F0R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F1R2 register  *******************/
#define CAN_F1R2_FB0_Pos (0U)
#define CAN_F1R2_FB0_Msk (0x1U << CAN_F1R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F1R2_FB0 CAN_F1R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F1R2_FB1_Pos (1U)
#define CAN_F1R2_FB1_Msk (0x1U << CAN_F1R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F1R2_FB1 CAN_F1R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F1R2_FB2_Pos (2U)
#define CAN_F1R2_FB2_Msk (0x1U << CAN_F1R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F1R2_FB2 CAN_F1R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F1R2_FB3_Pos (3U)
#define CAN_F1R2_FB3_Msk (0x1U << CAN_F1R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F1R2_FB3 CAN_F1R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F1R2_FB4_Pos (4U)
#define CAN_F1R2_FB4_Msk (0x1U << CAN_F1R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F1R2_FB4 CAN_F1R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F1R2_FB5_Pos (5U)
#define CAN_F1R2_FB5_Msk (0x1U << CAN_F1R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F1R2_FB5 CAN_F1R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F1R2_FB6_Pos (6U)
#define CAN_F1R2_FB6_Msk (0x1U << CAN_F1R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F1R2_FB6 CAN_F1R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F1R2_FB7_Pos (7U)
#define CAN_F1R2_FB7_Msk (0x1U << CAN_F1R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F1R2_FB7 CAN_F1R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F1R2_FB8_Pos (8U)
#define CAN_F1R2_FB8_Msk (0x1U << CAN_F1R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F1R2_FB8 CAN_F1R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F1R2_FB9_Pos (9U)
#define CAN_F1R2_FB9_Msk (0x1U << CAN_F1R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F1R2_FB9 CAN_F1R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F1R2_FB10_Pos (10U)
#define CAN_F1R2_FB10_Msk (0x1U << CAN_F1R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F1R2_FB10 CAN_F1R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F1R2_FB11_Pos (11U)
#define CAN_F1R2_FB11_Msk (0x1U << CAN_F1R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F1R2_FB11 CAN_F1R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F1R2_FB12_Pos (12U)
#define CAN_F1R2_FB12_Msk (0x1U << CAN_F1R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F1R2_FB12 CAN_F1R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F1R2_FB13_Pos (13U)
#define CAN_F1R2_FB13_Msk (0x1U << CAN_F1R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F1R2_FB13 CAN_F1R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F1R2_FB14_Pos (14U)
#define CAN_F1R2_FB14_Msk (0x1U << CAN_F1R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F1R2_FB14 CAN_F1R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F1R2_FB15_Pos (15U)
#define CAN_F1R2_FB15_Msk (0x1U << CAN_F1R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F1R2_FB15 CAN_F1R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F1R2_FB16_Pos (16U)
#define CAN_F1R2_FB16_Msk (0x1U << CAN_F1R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F1R2_FB16 CAN_F1R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F1R2_FB17_Pos (17U)
#define CAN_F1R2_FB17_Msk (0x1U << CAN_F1R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F1R2_FB17 CAN_F1R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F1R2_FB18_Pos (18U)
#define CAN_F1R2_FB18_Msk (0x1U << CAN_F1R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F1R2_FB18 CAN_F1R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F1R2_FB19_Pos (19U)
#define CAN_F1R2_FB19_Msk (0x1U << CAN_F1R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F1R2_FB19 CAN_F1R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F1R2_FB20_Pos (20U)
#define CAN_F1R2_FB20_Msk (0x1U << CAN_F1R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F1R2_FB20 CAN_F1R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F1R2_FB21_Pos (21U)
#define CAN_F1R2_FB21_Msk (0x1U << CAN_F1R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F1R2_FB21 CAN_F1R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F1R2_FB22_Pos (22U)
#define CAN_F1R2_FB22_Msk (0x1U << CAN_F1R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F1R2_FB22 CAN_F1R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F1R2_FB23_Pos (23U)
#define CAN_F1R2_FB23_Msk (0x1U << CAN_F1R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F1R2_FB23 CAN_F1R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F1R2_FB24_Pos (24U)
#define CAN_F1R2_FB24_Msk (0x1U << CAN_F1R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F1R2_FB24 CAN_F1R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F1R2_FB25_Pos (25U)
#define CAN_F1R2_FB25_Msk (0x1U << CAN_F1R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F1R2_FB25 CAN_F1R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F1R2_FB26_Pos (26U)
#define CAN_F1R2_FB26_Msk (0x1U << CAN_F1R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F1R2_FB26 CAN_F1R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F1R2_FB27_Pos (27U)
#define CAN_F1R2_FB27_Msk (0x1U << CAN_F1R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F1R2_FB27 CAN_F1R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F1R2_FB28_Pos (28U)
#define CAN_F1R2_FB28_Msk (0x1U << CAN_F1R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F1R2_FB28 CAN_F1R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F1R2_FB29_Pos (29U)
#define CAN_F1R2_FB29_Msk (0x1U << CAN_F1R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F1R2_FB29 CAN_F1R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F1R2_FB30_Pos (30U)
#define CAN_F1R2_FB30_Msk (0x1U << CAN_F1R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F1R2_FB30 CAN_F1R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F1R2_FB31_Pos (31U)
#define CAN_F1R2_FB31_Msk (0x1U << CAN_F1R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F1R2_FB31 CAN_F1R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F2R2 register  *******************/
#define CAN_F2R2_FB0_Pos (0U)
#define CAN_F2R2_FB0_Msk (0x1U << CAN_F2R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F2R2_FB0 CAN_F2R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F2R2_FB1_Pos (1U)
#define CAN_F2R2_FB1_Msk (0x1U << CAN_F2R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F2R2_FB1 CAN_F2R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F2R2_FB2_Pos (2U)
#define CAN_F2R2_FB2_Msk (0x1U << CAN_F2R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F2R2_FB2 CAN_F2R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F2R2_FB3_Pos (3U)
#define CAN_F2R2_FB3_Msk (0x1U << CAN_F2R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F2R2_FB3 CAN_F2R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F2R2_FB4_Pos (4U)
#define CAN_F2R2_FB4_Msk (0x1U << CAN_F2R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F2R2_FB4 CAN_F2R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F2R2_FB5_Pos (5U)
#define CAN_F2R2_FB5_Msk (0x1U << CAN_F2R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F2R2_FB5 CAN_F2R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F2R2_FB6_Pos (6U)
#define CAN_F2R2_FB6_Msk (0x1U << CAN_F2R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F2R2_FB6 CAN_F2R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F2R2_FB7_Pos (7U)
#define CAN_F2R2_FB7_Msk (0x1U << CAN_F2R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F2R2_FB7 CAN_F2R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F2R2_FB8_Pos (8U)
#define CAN_F2R2_FB8_Msk (0x1U << CAN_F2R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F2R2_FB8 CAN_F2R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F2R2_FB9_Pos (9U)
#define CAN_F2R2_FB9_Msk (0x1U << CAN_F2R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F2R2_FB9 CAN_F2R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F2R2_FB10_Pos (10U)
#define CAN_F2R2_FB10_Msk (0x1U << CAN_F2R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F2R2_FB10 CAN_F2R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F2R2_FB11_Pos (11U)
#define CAN_F2R2_FB11_Msk (0x1U << CAN_F2R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F2R2_FB11 CAN_F2R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F2R2_FB12_Pos (12U)
#define CAN_F2R2_FB12_Msk (0x1U << CAN_F2R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F2R2_FB12 CAN_F2R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F2R2_FB13_Pos (13U)
#define CAN_F2R2_FB13_Msk (0x1U << CAN_F2R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F2R2_FB13 CAN_F2R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F2R2_FB14_Pos (14U)
#define CAN_F2R2_FB14_Msk (0x1U << CAN_F2R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F2R2_FB14 CAN_F2R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F2R2_FB15_Pos (15U)
#define CAN_F2R2_FB15_Msk (0x1U << CAN_F2R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F2R2_FB15 CAN_F2R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F2R2_FB16_Pos (16U)
#define CAN_F2R2_FB16_Msk (0x1U << CAN_F2R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F2R2_FB16 CAN_F2R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F2R2_FB17_Pos (17U)
#define CAN_F2R2_FB17_Msk (0x1U << CAN_F2R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F2R2_FB17 CAN_F2R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F2R2_FB18_Pos (18U)
#define CAN_F2R2_FB18_Msk (0x1U << CAN_F2R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F2R2_FB18 CAN_F2R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F2R2_FB19_Pos (19U)
#define CAN_F2R2_FB19_Msk (0x1U << CAN_F2R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F2R2_FB19 CAN_F2R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F2R2_FB20_Pos (20U)
#define CAN_F2R2_FB20_Msk (0x1U << CAN_F2R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F2R2_FB20 CAN_F2R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F2R2_FB21_Pos (21U)
#define CAN_F2R2_FB21_Msk (0x1U << CAN_F2R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F2R2_FB21 CAN_F2R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F2R2_FB22_Pos (22U)
#define CAN_F2R2_FB22_Msk (0x1U << CAN_F2R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F2R2_FB22 CAN_F2R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F2R2_FB23_Pos (23U)
#define CAN_F2R2_FB23_Msk (0x1U << CAN_F2R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F2R2_FB23 CAN_F2R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F2R2_FB24_Pos (24U)
#define CAN_F2R2_FB24_Msk (0x1U << CAN_F2R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F2R2_FB24 CAN_F2R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F2R2_FB25_Pos (25U)
#define CAN_F2R2_FB25_Msk (0x1U << CAN_F2R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F2R2_FB25 CAN_F2R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F2R2_FB26_Pos (26U)
#define CAN_F2R2_FB26_Msk (0x1U << CAN_F2R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F2R2_FB26 CAN_F2R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F2R2_FB27_Pos (27U)
#define CAN_F2R2_FB27_Msk (0x1U << CAN_F2R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F2R2_FB27 CAN_F2R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F2R2_FB28_Pos (28U)
#define CAN_F2R2_FB28_Msk (0x1U << CAN_F2R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F2R2_FB28 CAN_F2R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F2R2_FB29_Pos (29U)
#define CAN_F2R2_FB29_Msk (0x1U << CAN_F2R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F2R2_FB29 CAN_F2R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F2R2_FB30_Pos (30U)
#define CAN_F2R2_FB30_Msk (0x1U << CAN_F2R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F2R2_FB30 CAN_F2R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F2R2_FB31_Pos (31U)
#define CAN_F2R2_FB31_Msk (0x1U << CAN_F2R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F2R2_FB31 CAN_F2R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F3R2 register  *******************/
#define CAN_F3R2_FB0_Pos (0U)
#define CAN_F3R2_FB0_Msk (0x1U << CAN_F3R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F3R2_FB0 CAN_F3R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F3R2_FB1_Pos (1U)
#define CAN_F3R2_FB1_Msk (0x1U << CAN_F3R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F3R2_FB1 CAN_F3R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F3R2_FB2_Pos (2U)
#define CAN_F3R2_FB2_Msk (0x1U << CAN_F3R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F3R2_FB2 CAN_F3R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F3R2_FB3_Pos (3U)
#define CAN_F3R2_FB3_Msk (0x1U << CAN_F3R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F3R2_FB3 CAN_F3R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F3R2_FB4_Pos (4U)
#define CAN_F3R2_FB4_Msk (0x1U << CAN_F3R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F3R2_FB4 CAN_F3R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F3R2_FB5_Pos (5U)
#define CAN_F3R2_FB5_Msk (0x1U << CAN_F3R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F3R2_FB5 CAN_F3R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F3R2_FB6_Pos (6U)
#define CAN_F3R2_FB6_Msk (0x1U << CAN_F3R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F3R2_FB6 CAN_F3R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F3R2_FB7_Pos (7U)
#define CAN_F3R2_FB7_Msk (0x1U << CAN_F3R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F3R2_FB7 CAN_F3R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F3R2_FB8_Pos (8U)
#define CAN_F3R2_FB8_Msk (0x1U << CAN_F3R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F3R2_FB8 CAN_F3R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F3R2_FB9_Pos (9U)
#define CAN_F3R2_FB9_Msk (0x1U << CAN_F3R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F3R2_FB9 CAN_F3R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F3R2_FB10_Pos (10U)
#define CAN_F3R2_FB10_Msk (0x1U << CAN_F3R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F3R2_FB10 CAN_F3R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F3R2_FB11_Pos (11U)
#define CAN_F3R2_FB11_Msk (0x1U << CAN_F3R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F3R2_FB11 CAN_F3R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F3R2_FB12_Pos (12U)
#define CAN_F3R2_FB12_Msk (0x1U << CAN_F3R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F3R2_FB12 CAN_F3R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F3R2_FB13_Pos (13U)
#define CAN_F3R2_FB13_Msk (0x1U << CAN_F3R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F3R2_FB13 CAN_F3R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F3R2_FB14_Pos (14U)
#define CAN_F3R2_FB14_Msk (0x1U << CAN_F3R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F3R2_FB14 CAN_F3R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F3R2_FB15_Pos (15U)
#define CAN_F3R2_FB15_Msk (0x1U << CAN_F3R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F3R2_FB15 CAN_F3R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F3R2_FB16_Pos (16U)
#define CAN_F3R2_FB16_Msk (0x1U << CAN_F3R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F3R2_FB16 CAN_F3R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F3R2_FB17_Pos (17U)
#define CAN_F3R2_FB17_Msk (0x1U << CAN_F3R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F3R2_FB17 CAN_F3R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F3R2_FB18_Pos (18U)
#define CAN_F3R2_FB18_Msk (0x1U << CAN_F3R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F3R2_FB18 CAN_F3R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F3R2_FB19_Pos (19U)
#define CAN_F3R2_FB19_Msk (0x1U << CAN_F3R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F3R2_FB19 CAN_F3R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F3R2_FB20_Pos (20U)
#define CAN_F3R2_FB20_Msk (0x1U << CAN_F3R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F3R2_FB20 CAN_F3R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F3R2_FB21_Pos (21U)
#define CAN_F3R2_FB21_Msk (0x1U << CAN_F3R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F3R2_FB21 CAN_F3R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F3R2_FB22_Pos (22U)
#define CAN_F3R2_FB22_Msk (0x1U << CAN_F3R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F3R2_FB22 CAN_F3R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F3R2_FB23_Pos (23U)
#define CAN_F3R2_FB23_Msk (0x1U << CAN_F3R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F3R2_FB23 CAN_F3R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F3R2_FB24_Pos (24U)
#define CAN_F3R2_FB24_Msk (0x1U << CAN_F3R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F3R2_FB24 CAN_F3R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F3R2_FB25_Pos (25U)
#define CAN_F3R2_FB25_Msk (0x1U << CAN_F3R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F3R2_FB25 CAN_F3R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F3R2_FB26_Pos (26U)
#define CAN_F3R2_FB26_Msk (0x1U << CAN_F3R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F3R2_FB26 CAN_F3R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F3R2_FB27_Pos (27U)
#define CAN_F3R2_FB27_Msk (0x1U << CAN_F3R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F3R2_FB27 CAN_F3R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F3R2_FB28_Pos (28U)
#define CAN_F3R2_FB28_Msk (0x1U << CAN_F3R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F3R2_FB28 CAN_F3R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F3R2_FB29_Pos (29U)
#define CAN_F3R2_FB29_Msk (0x1U << CAN_F3R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F3R2_FB29 CAN_F3R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F3R2_FB30_Pos (30U)
#define CAN_F3R2_FB30_Msk (0x1U << CAN_F3R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F3R2_FB30 CAN_F3R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F3R2_FB31_Pos (31U)
#define CAN_F3R2_FB31_Msk (0x1U << CAN_F3R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F3R2_FB31 CAN_F3R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F4R2 register  *******************/
#define CAN_F4R2_FB0_Pos (0U)
#define CAN_F4R2_FB0_Msk (0x1U << CAN_F4R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F4R2_FB0 CAN_F4R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F4R2_FB1_Pos (1U)
#define CAN_F4R2_FB1_Msk (0x1U << CAN_F4R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F4R2_FB1 CAN_F4R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F4R2_FB2_Pos (2U)
#define CAN_F4R2_FB2_Msk (0x1U << CAN_F4R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F4R2_FB2 CAN_F4R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F4R2_FB3_Pos (3U)
#define CAN_F4R2_FB3_Msk (0x1U << CAN_F4R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F4R2_FB3 CAN_F4R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F4R2_FB4_Pos (4U)
#define CAN_F4R2_FB4_Msk (0x1U << CAN_F4R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F4R2_FB4 CAN_F4R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F4R2_FB5_Pos (5U)
#define CAN_F4R2_FB5_Msk (0x1U << CAN_F4R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F4R2_FB5 CAN_F4R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F4R2_FB6_Pos (6U)
#define CAN_F4R2_FB6_Msk (0x1U << CAN_F4R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F4R2_FB6 CAN_F4R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F4R2_FB7_Pos (7U)
#define CAN_F4R2_FB7_Msk (0x1U << CAN_F4R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F4R2_FB7 CAN_F4R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F4R2_FB8_Pos (8U)
#define CAN_F4R2_FB8_Msk (0x1U << CAN_F4R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F4R2_FB8 CAN_F4R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F4R2_FB9_Pos (9U)
#define CAN_F4R2_FB9_Msk (0x1U << CAN_F4R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F4R2_FB9 CAN_F4R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F4R2_FB10_Pos (10U)
#define CAN_F4R2_FB10_Msk (0x1U << CAN_F4R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F4R2_FB10 CAN_F4R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F4R2_FB11_Pos (11U)
#define CAN_F4R2_FB11_Msk (0x1U << CAN_F4R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F4R2_FB11 CAN_F4R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F4R2_FB12_Pos (12U)
#define CAN_F4R2_FB12_Msk (0x1U << CAN_F4R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F4R2_FB12 CAN_F4R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F4R2_FB13_Pos (13U)
#define CAN_F4R2_FB13_Msk (0x1U << CAN_F4R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F4R2_FB13 CAN_F4R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F4R2_FB14_Pos (14U)
#define CAN_F4R2_FB14_Msk (0x1U << CAN_F4R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F4R2_FB14 CAN_F4R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F4R2_FB15_Pos (15U)
#define CAN_F4R2_FB15_Msk (0x1U << CAN_F4R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F4R2_FB15 CAN_F4R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F4R2_FB16_Pos (16U)
#define CAN_F4R2_FB16_Msk (0x1U << CAN_F4R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F4R2_FB16 CAN_F4R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F4R2_FB17_Pos (17U)
#define CAN_F4R2_FB17_Msk (0x1U << CAN_F4R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F4R2_FB17 CAN_F4R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F4R2_FB18_Pos (18U)
#define CAN_F4R2_FB18_Msk (0x1U << CAN_F4R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F4R2_FB18 CAN_F4R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F4R2_FB19_Pos (19U)
#define CAN_F4R2_FB19_Msk (0x1U << CAN_F4R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F4R2_FB19 CAN_F4R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F4R2_FB20_Pos (20U)
#define CAN_F4R2_FB20_Msk (0x1U << CAN_F4R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F4R2_FB20 CAN_F4R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F4R2_FB21_Pos (21U)
#define CAN_F4R2_FB21_Msk (0x1U << CAN_F4R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F4R2_FB21 CAN_F4R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F4R2_FB22_Pos (22U)
#define CAN_F4R2_FB22_Msk (0x1U << CAN_F4R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F4R2_FB22 CAN_F4R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F4R2_FB23_Pos (23U)
#define CAN_F4R2_FB23_Msk (0x1U << CAN_F4R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F4R2_FB23 CAN_F4R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F4R2_FB24_Pos (24U)
#define CAN_F4R2_FB24_Msk (0x1U << CAN_F4R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F4R2_FB24 CAN_F4R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F4R2_FB25_Pos (25U)
#define CAN_F4R2_FB25_Msk (0x1U << CAN_F4R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F4R2_FB25 CAN_F4R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F4R2_FB26_Pos (26U)
#define CAN_F4R2_FB26_Msk (0x1U << CAN_F4R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F4R2_FB26 CAN_F4R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F4R2_FB27_Pos (27U)
#define CAN_F4R2_FB27_Msk (0x1U << CAN_F4R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F4R2_FB27 CAN_F4R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F4R2_FB28_Pos (28U)
#define CAN_F4R2_FB28_Msk (0x1U << CAN_F4R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F4R2_FB28 CAN_F4R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F4R2_FB29_Pos (29U)
#define CAN_F4R2_FB29_Msk (0x1U << CAN_F4R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F4R2_FB29 CAN_F4R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F4R2_FB30_Pos (30U)
#define CAN_F4R2_FB30_Msk (0x1U << CAN_F4R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F4R2_FB30 CAN_F4R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F4R2_FB31_Pos (31U)
#define CAN_F4R2_FB31_Msk (0x1U << CAN_F4R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F4R2_FB31 CAN_F4R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F5R2 register  *******************/
#define CAN_F5R2_FB0_Pos (0U)
#define CAN_F5R2_FB0_Msk (0x1U << CAN_F5R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F5R2_FB0 CAN_F5R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F5R2_FB1_Pos (1U)
#define CAN_F5R2_FB1_Msk (0x1U << CAN_F5R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F5R2_FB1 CAN_F5R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F5R2_FB2_Pos (2U)
#define CAN_F5R2_FB2_Msk (0x1U << CAN_F5R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F5R2_FB2 CAN_F5R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F5R2_FB3_Pos (3U)
#define CAN_F5R2_FB3_Msk (0x1U << CAN_F5R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F5R2_FB3 CAN_F5R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F5R2_FB4_Pos (4U)
#define CAN_F5R2_FB4_Msk (0x1U << CAN_F5R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F5R2_FB4 CAN_F5R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F5R2_FB5_Pos (5U)
#define CAN_F5R2_FB5_Msk (0x1U << CAN_F5R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F5R2_FB5 CAN_F5R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F5R2_FB6_Pos (6U)
#define CAN_F5R2_FB6_Msk (0x1U << CAN_F5R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F5R2_FB6 CAN_F5R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F5R2_FB7_Pos (7U)
#define CAN_F5R2_FB7_Msk (0x1U << CAN_F5R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F5R2_FB7 CAN_F5R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F5R2_FB8_Pos (8U)
#define CAN_F5R2_FB8_Msk (0x1U << CAN_F5R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F5R2_FB8 CAN_F5R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F5R2_FB9_Pos (9U)
#define CAN_F5R2_FB9_Msk (0x1U << CAN_F5R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F5R2_FB9 CAN_F5R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F5R2_FB10_Pos (10U)
#define CAN_F5R2_FB10_Msk (0x1U << CAN_F5R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F5R2_FB10 CAN_F5R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F5R2_FB11_Pos (11U)
#define CAN_F5R2_FB11_Msk (0x1U << CAN_F5R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F5R2_FB11 CAN_F5R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F5R2_FB12_Pos (12U)
#define CAN_F5R2_FB12_Msk (0x1U << CAN_F5R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F5R2_FB12 CAN_F5R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F5R2_FB13_Pos (13U)
#define CAN_F5R2_FB13_Msk (0x1U << CAN_F5R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F5R2_FB13 CAN_F5R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F5R2_FB14_Pos (14U)
#define CAN_F5R2_FB14_Msk (0x1U << CAN_F5R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F5R2_FB14 CAN_F5R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F5R2_FB15_Pos (15U)
#define CAN_F5R2_FB15_Msk (0x1U << CAN_F5R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F5R2_FB15 CAN_F5R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F5R2_FB16_Pos (16U)
#define CAN_F5R2_FB16_Msk (0x1U << CAN_F5R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F5R2_FB16 CAN_F5R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F5R2_FB17_Pos (17U)
#define CAN_F5R2_FB17_Msk (0x1U << CAN_F5R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F5R2_FB17 CAN_F5R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F5R2_FB18_Pos (18U)
#define CAN_F5R2_FB18_Msk (0x1U << CAN_F5R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F5R2_FB18 CAN_F5R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F5R2_FB19_Pos (19U)
#define CAN_F5R2_FB19_Msk (0x1U << CAN_F5R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F5R2_FB19 CAN_F5R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F5R2_FB20_Pos (20U)
#define CAN_F5R2_FB20_Msk (0x1U << CAN_F5R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F5R2_FB20 CAN_F5R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F5R2_FB21_Pos (21U)
#define CAN_F5R2_FB21_Msk (0x1U << CAN_F5R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F5R2_FB21 CAN_F5R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F5R2_FB22_Pos (22U)
#define CAN_F5R2_FB22_Msk (0x1U << CAN_F5R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F5R2_FB22 CAN_F5R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F5R2_FB23_Pos (23U)
#define CAN_F5R2_FB23_Msk (0x1U << CAN_F5R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F5R2_FB23 CAN_F5R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F5R2_FB24_Pos (24U)
#define CAN_F5R2_FB24_Msk (0x1U << CAN_F5R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F5R2_FB24 CAN_F5R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F5R2_FB25_Pos (25U)
#define CAN_F5R2_FB25_Msk (0x1U << CAN_F5R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F5R2_FB25 CAN_F5R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F5R2_FB26_Pos (26U)
#define CAN_F5R2_FB26_Msk (0x1U << CAN_F5R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F5R2_FB26 CAN_F5R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F5R2_FB27_Pos (27U)
#define CAN_F5R2_FB27_Msk (0x1U << CAN_F5R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F5R2_FB27 CAN_F5R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F5R2_FB28_Pos (28U)
#define CAN_F5R2_FB28_Msk (0x1U << CAN_F5R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F5R2_FB28 CAN_F5R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F5R2_FB29_Pos (29U)
#define CAN_F5R2_FB29_Msk (0x1U << CAN_F5R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F5R2_FB29 CAN_F5R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F5R2_FB30_Pos (30U)
#define CAN_F5R2_FB30_Msk (0x1U << CAN_F5R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F5R2_FB30 CAN_F5R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F5R2_FB31_Pos (31U)
#define CAN_F5R2_FB31_Msk (0x1U << CAN_F5R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F5R2_FB31 CAN_F5R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F6R2 register  *******************/
#define CAN_F6R2_FB0_Pos (0U)
#define CAN_F6R2_FB0_Msk (0x1U << CAN_F6R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F6R2_FB0 CAN_F6R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F6R2_FB1_Pos (1U)
#define CAN_F6R2_FB1_Msk (0x1U << CAN_F6R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F6R2_FB1 CAN_F6R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F6R2_FB2_Pos (2U)
#define CAN_F6R2_FB2_Msk (0x1U << CAN_F6R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F6R2_FB2 CAN_F6R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F6R2_FB3_Pos (3U)
#define CAN_F6R2_FB3_Msk (0x1U << CAN_F6R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F6R2_FB3 CAN_F6R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F6R2_FB4_Pos (4U)
#define CAN_F6R2_FB4_Msk (0x1U << CAN_F6R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F6R2_FB4 CAN_F6R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F6R2_FB5_Pos (5U)
#define CAN_F6R2_FB5_Msk (0x1U << CAN_F6R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F6R2_FB5 CAN_F6R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F6R2_FB6_Pos (6U)
#define CAN_F6R2_FB6_Msk (0x1U << CAN_F6R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F6R2_FB6 CAN_F6R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F6R2_FB7_Pos (7U)
#define CAN_F6R2_FB7_Msk (0x1U << CAN_F6R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F6R2_FB7 CAN_F6R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F6R2_FB8_Pos (8U)
#define CAN_F6R2_FB8_Msk (0x1U << CAN_F6R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F6R2_FB8 CAN_F6R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F6R2_FB9_Pos (9U)
#define CAN_F6R2_FB9_Msk (0x1U << CAN_F6R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F6R2_FB9 CAN_F6R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F6R2_FB10_Pos (10U)
#define CAN_F6R2_FB10_Msk (0x1U << CAN_F6R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F6R2_FB10 CAN_F6R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F6R2_FB11_Pos (11U)
#define CAN_F6R2_FB11_Msk (0x1U << CAN_F6R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F6R2_FB11 CAN_F6R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F6R2_FB12_Pos (12U)
#define CAN_F6R2_FB12_Msk (0x1U << CAN_F6R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F6R2_FB12 CAN_F6R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F6R2_FB13_Pos (13U)
#define CAN_F6R2_FB13_Msk (0x1U << CAN_F6R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F6R2_FB13 CAN_F6R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F6R2_FB14_Pos (14U)
#define CAN_F6R2_FB14_Msk (0x1U << CAN_F6R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F6R2_FB14 CAN_F6R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F6R2_FB15_Pos (15U)
#define CAN_F6R2_FB15_Msk (0x1U << CAN_F6R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F6R2_FB15 CAN_F6R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F6R2_FB16_Pos (16U)
#define CAN_F6R2_FB16_Msk (0x1U << CAN_F6R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F6R2_FB16 CAN_F6R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F6R2_FB17_Pos (17U)
#define CAN_F6R2_FB17_Msk (0x1U << CAN_F6R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F6R2_FB17 CAN_F6R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F6R2_FB18_Pos (18U)
#define CAN_F6R2_FB18_Msk (0x1U << CAN_F6R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F6R2_FB18 CAN_F6R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F6R2_FB19_Pos (19U)
#define CAN_F6R2_FB19_Msk (0x1U << CAN_F6R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F6R2_FB19 CAN_F6R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F6R2_FB20_Pos (20U)
#define CAN_F6R2_FB20_Msk (0x1U << CAN_F6R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F6R2_FB20 CAN_F6R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F6R2_FB21_Pos (21U)
#define CAN_F6R2_FB21_Msk (0x1U << CAN_F6R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F6R2_FB21 CAN_F6R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F6R2_FB22_Pos (22U)
#define CAN_F6R2_FB22_Msk (0x1U << CAN_F6R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F6R2_FB22 CAN_F6R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F6R2_FB23_Pos (23U)
#define CAN_F6R2_FB23_Msk (0x1U << CAN_F6R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F6R2_FB23 CAN_F6R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F6R2_FB24_Pos (24U)
#define CAN_F6R2_FB24_Msk (0x1U << CAN_F6R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F6R2_FB24 CAN_F6R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F6R2_FB25_Pos (25U)
#define CAN_F6R2_FB25_Msk (0x1U << CAN_F6R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F6R2_FB25 CAN_F6R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F6R2_FB26_Pos (26U)
#define CAN_F6R2_FB26_Msk (0x1U << CAN_F6R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F6R2_FB26 CAN_F6R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F6R2_FB27_Pos (27U)
#define CAN_F6R2_FB27_Msk (0x1U << CAN_F6R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F6R2_FB27 CAN_F6R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F6R2_FB28_Pos (28U)
#define CAN_F6R2_FB28_Msk (0x1U << CAN_F6R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F6R2_FB28 CAN_F6R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F6R2_FB29_Pos (29U)
#define CAN_F6R2_FB29_Msk (0x1U << CAN_F6R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F6R2_FB29 CAN_F6R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F6R2_FB30_Pos (30U)
#define CAN_F6R2_FB30_Msk (0x1U << CAN_F6R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F6R2_FB30 CAN_F6R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F6R2_FB31_Pos (31U)
#define CAN_F6R2_FB31_Msk (0x1U << CAN_F6R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F6R2_FB31 CAN_F6R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F7R2 register  *******************/
#define CAN_F7R2_FB0_Pos (0U)
#define CAN_F7R2_FB0_Msk (0x1U << CAN_F7R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F7R2_FB0 CAN_F7R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F7R2_FB1_Pos (1U)
#define CAN_F7R2_FB1_Msk (0x1U << CAN_F7R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F7R2_FB1 CAN_F7R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F7R2_FB2_Pos (2U)
#define CAN_F7R2_FB2_Msk (0x1U << CAN_F7R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F7R2_FB2 CAN_F7R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F7R2_FB3_Pos (3U)
#define CAN_F7R2_FB3_Msk (0x1U << CAN_F7R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F7R2_FB3 CAN_F7R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F7R2_FB4_Pos (4U)
#define CAN_F7R2_FB4_Msk (0x1U << CAN_F7R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F7R2_FB4 CAN_F7R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F7R2_FB5_Pos (5U)
#define CAN_F7R2_FB5_Msk (0x1U << CAN_F7R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F7R2_FB5 CAN_F7R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F7R2_FB6_Pos (6U)
#define CAN_F7R2_FB6_Msk (0x1U << CAN_F7R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F7R2_FB6 CAN_F7R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F7R2_FB7_Pos (7U)
#define CAN_F7R2_FB7_Msk (0x1U << CAN_F7R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F7R2_FB7 CAN_F7R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F7R2_FB8_Pos (8U)
#define CAN_F7R2_FB8_Msk (0x1U << CAN_F7R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F7R2_FB8 CAN_F7R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F7R2_FB9_Pos (9U)
#define CAN_F7R2_FB9_Msk (0x1U << CAN_F7R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F7R2_FB9 CAN_F7R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F7R2_FB10_Pos (10U)
#define CAN_F7R2_FB10_Msk (0x1U << CAN_F7R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F7R2_FB10 CAN_F7R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F7R2_FB11_Pos (11U)
#define CAN_F7R2_FB11_Msk (0x1U << CAN_F7R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F7R2_FB11 CAN_F7R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F7R2_FB12_Pos (12U)
#define CAN_F7R2_FB12_Msk (0x1U << CAN_F7R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F7R2_FB12 CAN_F7R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F7R2_FB13_Pos (13U)
#define CAN_F7R2_FB13_Msk (0x1U << CAN_F7R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F7R2_FB13 CAN_F7R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F7R2_FB14_Pos (14U)
#define CAN_F7R2_FB14_Msk (0x1U << CAN_F7R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F7R2_FB14 CAN_F7R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F7R2_FB15_Pos (15U)
#define CAN_F7R2_FB15_Msk (0x1U << CAN_F7R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F7R2_FB15 CAN_F7R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F7R2_FB16_Pos (16U)
#define CAN_F7R2_FB16_Msk (0x1U << CAN_F7R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F7R2_FB16 CAN_F7R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F7R2_FB17_Pos (17U)
#define CAN_F7R2_FB17_Msk (0x1U << CAN_F7R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F7R2_FB17 CAN_F7R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F7R2_FB18_Pos (18U)
#define CAN_F7R2_FB18_Msk (0x1U << CAN_F7R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F7R2_FB18 CAN_F7R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F7R2_FB19_Pos (19U)
#define CAN_F7R2_FB19_Msk (0x1U << CAN_F7R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F7R2_FB19 CAN_F7R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F7R2_FB20_Pos (20U)
#define CAN_F7R2_FB20_Msk (0x1U << CAN_F7R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F7R2_FB20 CAN_F7R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F7R2_FB21_Pos (21U)
#define CAN_F7R2_FB21_Msk (0x1U << CAN_F7R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F7R2_FB21 CAN_F7R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F7R2_FB22_Pos (22U)
#define CAN_F7R2_FB22_Msk (0x1U << CAN_F7R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F7R2_FB22 CAN_F7R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F7R2_FB23_Pos (23U)
#define CAN_F7R2_FB23_Msk (0x1U << CAN_F7R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F7R2_FB23 CAN_F7R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F7R2_FB24_Pos (24U)
#define CAN_F7R2_FB24_Msk (0x1U << CAN_F7R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F7R2_FB24 CAN_F7R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F7R2_FB25_Pos (25U)
#define CAN_F7R2_FB25_Msk (0x1U << CAN_F7R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F7R2_FB25 CAN_F7R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F7R2_FB26_Pos (26U)
#define CAN_F7R2_FB26_Msk (0x1U << CAN_F7R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F7R2_FB26 CAN_F7R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F7R2_FB27_Pos (27U)
#define CAN_F7R2_FB27_Msk (0x1U << CAN_F7R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F7R2_FB27 CAN_F7R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F7R2_FB28_Pos (28U)
#define CAN_F7R2_FB28_Msk (0x1U << CAN_F7R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F7R2_FB28 CAN_F7R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F7R2_FB29_Pos (29U)
#define CAN_F7R2_FB29_Msk (0x1U << CAN_F7R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F7R2_FB29 CAN_F7R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F7R2_FB30_Pos (30U)
#define CAN_F7R2_FB30_Msk (0x1U << CAN_F7R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F7R2_FB30 CAN_F7R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F7R2_FB31_Pos (31U)
#define CAN_F7R2_FB31_Msk (0x1U << CAN_F7R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F7R2_FB31 CAN_F7R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F8R2 register  *******************/
#define CAN_F8R2_FB0_Pos (0U)
#define CAN_F8R2_FB0_Msk (0x1U << CAN_F8R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F8R2_FB0 CAN_F8R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F8R2_FB1_Pos (1U)
#define CAN_F8R2_FB1_Msk (0x1U << CAN_F8R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F8R2_FB1 CAN_F8R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F8R2_FB2_Pos (2U)
#define CAN_F8R2_FB2_Msk (0x1U << CAN_F8R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F8R2_FB2 CAN_F8R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F8R2_FB3_Pos (3U)
#define CAN_F8R2_FB3_Msk (0x1U << CAN_F8R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F8R2_FB3 CAN_F8R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F8R2_FB4_Pos (4U)
#define CAN_F8R2_FB4_Msk (0x1U << CAN_F8R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F8R2_FB4 CAN_F8R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F8R2_FB5_Pos (5U)
#define CAN_F8R2_FB5_Msk (0x1U << CAN_F8R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F8R2_FB5 CAN_F8R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F8R2_FB6_Pos (6U)
#define CAN_F8R2_FB6_Msk (0x1U << CAN_F8R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F8R2_FB6 CAN_F8R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F8R2_FB7_Pos (7U)
#define CAN_F8R2_FB7_Msk (0x1U << CAN_F8R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F8R2_FB7 CAN_F8R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F8R2_FB8_Pos (8U)
#define CAN_F8R2_FB8_Msk (0x1U << CAN_F8R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F8R2_FB8 CAN_F8R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F8R2_FB9_Pos (9U)
#define CAN_F8R2_FB9_Msk (0x1U << CAN_F8R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F8R2_FB9 CAN_F8R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F8R2_FB10_Pos (10U)
#define CAN_F8R2_FB10_Msk (0x1U << CAN_F8R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F8R2_FB10 CAN_F8R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F8R2_FB11_Pos (11U)
#define CAN_F8R2_FB11_Msk (0x1U << CAN_F8R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F8R2_FB11 CAN_F8R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F8R2_FB12_Pos (12U)
#define CAN_F8R2_FB12_Msk (0x1U << CAN_F8R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F8R2_FB12 CAN_F8R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F8R2_FB13_Pos (13U)
#define CAN_F8R2_FB13_Msk (0x1U << CAN_F8R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F8R2_FB13 CAN_F8R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F8R2_FB14_Pos (14U)
#define CAN_F8R2_FB14_Msk (0x1U << CAN_F8R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F8R2_FB14 CAN_F8R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F8R2_FB15_Pos (15U)
#define CAN_F8R2_FB15_Msk (0x1U << CAN_F8R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F8R2_FB15 CAN_F8R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F8R2_FB16_Pos (16U)
#define CAN_F8R2_FB16_Msk (0x1U << CAN_F8R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F8R2_FB16 CAN_F8R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F8R2_FB17_Pos (17U)
#define CAN_F8R2_FB17_Msk (0x1U << CAN_F8R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F8R2_FB17 CAN_F8R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F8R2_FB18_Pos (18U)
#define CAN_F8R2_FB18_Msk (0x1U << CAN_F8R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F8R2_FB18 CAN_F8R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F8R2_FB19_Pos (19U)
#define CAN_F8R2_FB19_Msk (0x1U << CAN_F8R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F8R2_FB19 CAN_F8R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F8R2_FB20_Pos (20U)
#define CAN_F8R2_FB20_Msk (0x1U << CAN_F8R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F8R2_FB20 CAN_F8R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F8R2_FB21_Pos (21U)
#define CAN_F8R2_FB21_Msk (0x1U << CAN_F8R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F8R2_FB21 CAN_F8R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F8R2_FB22_Pos (22U)
#define CAN_F8R2_FB22_Msk (0x1U << CAN_F8R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F8R2_FB22 CAN_F8R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F8R2_FB23_Pos (23U)
#define CAN_F8R2_FB23_Msk (0x1U << CAN_F8R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F8R2_FB23 CAN_F8R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F8R2_FB24_Pos (24U)
#define CAN_F8R2_FB24_Msk (0x1U << CAN_F8R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F8R2_FB24 CAN_F8R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F8R2_FB25_Pos (25U)
#define CAN_F8R2_FB25_Msk (0x1U << CAN_F8R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F8R2_FB25 CAN_F8R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F8R2_FB26_Pos (26U)
#define CAN_F8R2_FB26_Msk (0x1U << CAN_F8R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F8R2_FB26 CAN_F8R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F8R2_FB27_Pos (27U)
#define CAN_F8R2_FB27_Msk (0x1U << CAN_F8R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F8R2_FB27 CAN_F8R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F8R2_FB28_Pos (28U)
#define CAN_F8R2_FB28_Msk (0x1U << CAN_F8R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F8R2_FB28 CAN_F8R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F8R2_FB29_Pos (29U)
#define CAN_F8R2_FB29_Msk (0x1U << CAN_F8R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F8R2_FB29 CAN_F8R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F8R2_FB30_Pos (30U)
#define CAN_F8R2_FB30_Msk (0x1U << CAN_F8R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F8R2_FB30 CAN_F8R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F8R2_FB31_Pos (31U)
#define CAN_F8R2_FB31_Msk (0x1U << CAN_F8R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F8R2_FB31 CAN_F8R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F9R2 register  *******************/
#define CAN_F9R2_FB0_Pos (0U)
#define CAN_F9R2_FB0_Msk (0x1U << CAN_F9R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F9R2_FB0 CAN_F9R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F9R2_FB1_Pos (1U)
#define CAN_F9R2_FB1_Msk (0x1U << CAN_F9R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F9R2_FB1 CAN_F9R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F9R2_FB2_Pos (2U)
#define CAN_F9R2_FB2_Msk (0x1U << CAN_F9R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F9R2_FB2 CAN_F9R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F9R2_FB3_Pos (3U)
#define CAN_F9R2_FB3_Msk (0x1U << CAN_F9R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F9R2_FB3 CAN_F9R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F9R2_FB4_Pos (4U)
#define CAN_F9R2_FB4_Msk (0x1U << CAN_F9R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F9R2_FB4 CAN_F9R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F9R2_FB5_Pos (5U)
#define CAN_F9R2_FB5_Msk (0x1U << CAN_F9R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F9R2_FB5 CAN_F9R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F9R2_FB6_Pos (6U)
#define CAN_F9R2_FB6_Msk (0x1U << CAN_F9R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F9R2_FB6 CAN_F9R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F9R2_FB7_Pos (7U)
#define CAN_F9R2_FB7_Msk (0x1U << CAN_F9R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F9R2_FB7 CAN_F9R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F9R2_FB8_Pos (8U)
#define CAN_F9R2_FB8_Msk (0x1U << CAN_F9R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F9R2_FB8 CAN_F9R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F9R2_FB9_Pos (9U)
#define CAN_F9R2_FB9_Msk (0x1U << CAN_F9R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F9R2_FB9 CAN_F9R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F9R2_FB10_Pos (10U)
#define CAN_F9R2_FB10_Msk (0x1U << CAN_F9R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F9R2_FB10 CAN_F9R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F9R2_FB11_Pos (11U)
#define CAN_F9R2_FB11_Msk (0x1U << CAN_F9R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F9R2_FB11 CAN_F9R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F9R2_FB12_Pos (12U)
#define CAN_F9R2_FB12_Msk (0x1U << CAN_F9R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F9R2_FB12 CAN_F9R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F9R2_FB13_Pos (13U)
#define CAN_F9R2_FB13_Msk (0x1U << CAN_F9R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F9R2_FB13 CAN_F9R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F9R2_FB14_Pos (14U)
#define CAN_F9R2_FB14_Msk (0x1U << CAN_F9R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F9R2_FB14 CAN_F9R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F9R2_FB15_Pos (15U)
#define CAN_F9R2_FB15_Msk (0x1U << CAN_F9R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F9R2_FB15 CAN_F9R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F9R2_FB16_Pos (16U)
#define CAN_F9R2_FB16_Msk (0x1U << CAN_F9R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F9R2_FB16 CAN_F9R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F9R2_FB17_Pos (17U)
#define CAN_F9R2_FB17_Msk (0x1U << CAN_F9R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F9R2_FB17 CAN_F9R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F9R2_FB18_Pos (18U)
#define CAN_F9R2_FB18_Msk (0x1U << CAN_F9R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F9R2_FB18 CAN_F9R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F9R2_FB19_Pos (19U)
#define CAN_F9R2_FB19_Msk (0x1U << CAN_F9R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F9R2_FB19 CAN_F9R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F9R2_FB20_Pos (20U)
#define CAN_F9R2_FB20_Msk (0x1U << CAN_F9R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F9R2_FB20 CAN_F9R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F9R2_FB21_Pos (21U)
#define CAN_F9R2_FB21_Msk (0x1U << CAN_F9R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F9R2_FB21 CAN_F9R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F9R2_FB22_Pos (22U)
#define CAN_F9R2_FB22_Msk (0x1U << CAN_F9R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F9R2_FB22 CAN_F9R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F9R2_FB23_Pos (23U)
#define CAN_F9R2_FB23_Msk (0x1U << CAN_F9R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F9R2_FB23 CAN_F9R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F9R2_FB24_Pos (24U)
#define CAN_F9R2_FB24_Msk (0x1U << CAN_F9R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F9R2_FB24 CAN_F9R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F9R2_FB25_Pos (25U)
#define CAN_F9R2_FB25_Msk (0x1U << CAN_F9R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F9R2_FB25 CAN_F9R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F9R2_FB26_Pos (26U)
#define CAN_F9R2_FB26_Msk (0x1U << CAN_F9R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F9R2_FB26 CAN_F9R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F9R2_FB27_Pos (27U)
#define CAN_F9R2_FB27_Msk (0x1U << CAN_F9R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F9R2_FB27 CAN_F9R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F9R2_FB28_Pos (28U)
#define CAN_F9R2_FB28_Msk (0x1U << CAN_F9R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F9R2_FB28 CAN_F9R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F9R2_FB29_Pos (29U)
#define CAN_F9R2_FB29_Msk (0x1U << CAN_F9R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F9R2_FB29 CAN_F9R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F9R2_FB30_Pos (30U)
#define CAN_F9R2_FB30_Msk (0x1U << CAN_F9R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F9R2_FB30 CAN_F9R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F9R2_FB31_Pos (31U)
#define CAN_F9R2_FB31_Msk (0x1U << CAN_F9R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F9R2_FB31 CAN_F9R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F10R2 register  ******************/
#define CAN_F10R2_FB0_Pos (0U)
#define CAN_F10R2_FB0_Msk (0x1U << CAN_F10R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F10R2_FB0 CAN_F10R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F10R2_FB1_Pos (1U)
#define CAN_F10R2_FB1_Msk (0x1U << CAN_F10R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F10R2_FB1 CAN_F10R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F10R2_FB2_Pos (2U)
#define CAN_F10R2_FB2_Msk (0x1U << CAN_F10R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F10R2_FB2 CAN_F10R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F10R2_FB3_Pos (3U)
#define CAN_F10R2_FB3_Msk (0x1U << CAN_F10R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F10R2_FB3 CAN_F10R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F10R2_FB4_Pos (4U)
#define CAN_F10R2_FB4_Msk (0x1U << CAN_F10R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F10R2_FB4 CAN_F10R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F10R2_FB5_Pos (5U)
#define CAN_F10R2_FB5_Msk (0x1U << CAN_F10R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F10R2_FB5 CAN_F10R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F10R2_FB6_Pos (6U)
#define CAN_F10R2_FB6_Msk (0x1U << CAN_F10R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F10R2_FB6 CAN_F10R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F10R2_FB7_Pos (7U)
#define CAN_F10R2_FB7_Msk (0x1U << CAN_F10R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F10R2_FB7 CAN_F10R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F10R2_FB8_Pos (8U)
#define CAN_F10R2_FB8_Msk (0x1U << CAN_F10R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F10R2_FB8 CAN_F10R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F10R2_FB9_Pos (9U)
#define CAN_F10R2_FB9_Msk (0x1U << CAN_F10R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F10R2_FB9 CAN_F10R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F10R2_FB10_Pos (10U)
#define CAN_F10R2_FB10_Msk (0x1U << CAN_F10R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F10R2_FB10 CAN_F10R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F10R2_FB11_Pos (11U)
#define CAN_F10R2_FB11_Msk (0x1U << CAN_F10R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F10R2_FB11 CAN_F10R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F10R2_FB12_Pos (12U)
#define CAN_F10R2_FB12_Msk (0x1U << CAN_F10R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F10R2_FB12 CAN_F10R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F10R2_FB13_Pos (13U)
#define CAN_F10R2_FB13_Msk (0x1U << CAN_F10R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F10R2_FB13 CAN_F10R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F10R2_FB14_Pos (14U)
#define CAN_F10R2_FB14_Msk (0x1U << CAN_F10R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F10R2_FB14 CAN_F10R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F10R2_FB15_Pos (15U)
#define CAN_F10R2_FB15_Msk (0x1U << CAN_F10R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F10R2_FB15 CAN_F10R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F10R2_FB16_Pos (16U)
#define CAN_F10R2_FB16_Msk (0x1U << CAN_F10R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F10R2_FB16 CAN_F10R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F10R2_FB17_Pos (17U)
#define CAN_F10R2_FB17_Msk (0x1U << CAN_F10R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F10R2_FB17 CAN_F10R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F10R2_FB18_Pos (18U)
#define CAN_F10R2_FB18_Msk (0x1U << CAN_F10R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F10R2_FB18 CAN_F10R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F10R2_FB19_Pos (19U)
#define CAN_F10R2_FB19_Msk (0x1U << CAN_F10R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F10R2_FB19 CAN_F10R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F10R2_FB20_Pos (20U)
#define CAN_F10R2_FB20_Msk (0x1U << CAN_F10R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F10R2_FB20 CAN_F10R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F10R2_FB21_Pos (21U)
#define CAN_F10R2_FB21_Msk (0x1U << CAN_F10R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F10R2_FB21 CAN_F10R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F10R2_FB22_Pos (22U)
#define CAN_F10R2_FB22_Msk (0x1U << CAN_F10R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F10R2_FB22 CAN_F10R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F10R2_FB23_Pos (23U)
#define CAN_F10R2_FB23_Msk (0x1U << CAN_F10R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F10R2_FB23 CAN_F10R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F10R2_FB24_Pos (24U)
#define CAN_F10R2_FB24_Msk (0x1U << CAN_F10R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F10R2_FB24 CAN_F10R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F10R2_FB25_Pos (25U)
#define CAN_F10R2_FB25_Msk (0x1U << CAN_F10R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F10R2_FB25 CAN_F10R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F10R2_FB26_Pos (26U)
#define CAN_F10R2_FB26_Msk (0x1U << CAN_F10R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F10R2_FB26 CAN_F10R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F10R2_FB27_Pos (27U)
#define CAN_F10R2_FB27_Msk (0x1U << CAN_F10R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F10R2_FB27 CAN_F10R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F10R2_FB28_Pos (28U)
#define CAN_F10R2_FB28_Msk (0x1U << CAN_F10R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F10R2_FB28 CAN_F10R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F10R2_FB29_Pos (29U)
#define CAN_F10R2_FB29_Msk (0x1U << CAN_F10R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F10R2_FB29 CAN_F10R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F10R2_FB30_Pos (30U)
#define CAN_F10R2_FB30_Msk (0x1U << CAN_F10R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F10R2_FB30 CAN_F10R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F10R2_FB31_Pos (31U)
#define CAN_F10R2_FB31_Msk (0x1U << CAN_F10R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F10R2_FB31 CAN_F10R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F11R2 register  ******************/
#define CAN_F11R2_FB0_Pos (0U)
#define CAN_F11R2_FB0_Msk (0x1U << CAN_F11R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F11R2_FB0 CAN_F11R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F11R2_FB1_Pos (1U)
#define CAN_F11R2_FB1_Msk (0x1U << CAN_F11R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F11R2_FB1 CAN_F11R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F11R2_FB2_Pos (2U)
#define CAN_F11R2_FB2_Msk (0x1U << CAN_F11R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F11R2_FB2 CAN_F11R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F11R2_FB3_Pos (3U)
#define CAN_F11R2_FB3_Msk (0x1U << CAN_F11R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F11R2_FB3 CAN_F11R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F11R2_FB4_Pos (4U)
#define CAN_F11R2_FB4_Msk (0x1U << CAN_F11R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F11R2_FB4 CAN_F11R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F11R2_FB5_Pos (5U)
#define CAN_F11R2_FB5_Msk (0x1U << CAN_F11R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F11R2_FB5 CAN_F11R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F11R2_FB6_Pos (6U)
#define CAN_F11R2_FB6_Msk (0x1U << CAN_F11R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F11R2_FB6 CAN_F11R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F11R2_FB7_Pos (7U)
#define CAN_F11R2_FB7_Msk (0x1U << CAN_F11R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F11R2_FB7 CAN_F11R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F11R2_FB8_Pos (8U)
#define CAN_F11R2_FB8_Msk (0x1U << CAN_F11R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F11R2_FB8 CAN_F11R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F11R2_FB9_Pos (9U)
#define CAN_F11R2_FB9_Msk (0x1U << CAN_F11R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F11R2_FB9 CAN_F11R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F11R2_FB10_Pos (10U)
#define CAN_F11R2_FB10_Msk (0x1U << CAN_F11R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F11R2_FB10 CAN_F11R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F11R2_FB11_Pos (11U)
#define CAN_F11R2_FB11_Msk (0x1U << CAN_F11R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F11R2_FB11 CAN_F11R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F11R2_FB12_Pos (12U)
#define CAN_F11R2_FB12_Msk (0x1U << CAN_F11R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F11R2_FB12 CAN_F11R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F11R2_FB13_Pos (13U)
#define CAN_F11R2_FB13_Msk (0x1U << CAN_F11R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F11R2_FB13 CAN_F11R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F11R2_FB14_Pos (14U)
#define CAN_F11R2_FB14_Msk (0x1U << CAN_F11R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F11R2_FB14 CAN_F11R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F11R2_FB15_Pos (15U)
#define CAN_F11R2_FB15_Msk (0x1U << CAN_F11R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F11R2_FB15 CAN_F11R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F11R2_FB16_Pos (16U)
#define CAN_F11R2_FB16_Msk (0x1U << CAN_F11R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F11R2_FB16 CAN_F11R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F11R2_FB17_Pos (17U)
#define CAN_F11R2_FB17_Msk (0x1U << CAN_F11R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F11R2_FB17 CAN_F11R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F11R2_FB18_Pos (18U)
#define CAN_F11R2_FB18_Msk (0x1U << CAN_F11R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F11R2_FB18 CAN_F11R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F11R2_FB19_Pos (19U)
#define CAN_F11R2_FB19_Msk (0x1U << CAN_F11R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F11R2_FB19 CAN_F11R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F11R2_FB20_Pos (20U)
#define CAN_F11R2_FB20_Msk (0x1U << CAN_F11R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F11R2_FB20 CAN_F11R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F11R2_FB21_Pos (21U)
#define CAN_F11R2_FB21_Msk (0x1U << CAN_F11R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F11R2_FB21 CAN_F11R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F11R2_FB22_Pos (22U)
#define CAN_F11R2_FB22_Msk (0x1U << CAN_F11R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F11R2_FB22 CAN_F11R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F11R2_FB23_Pos (23U)
#define CAN_F11R2_FB23_Msk (0x1U << CAN_F11R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F11R2_FB23 CAN_F11R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F11R2_FB24_Pos (24U)
#define CAN_F11R2_FB24_Msk (0x1U << CAN_F11R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F11R2_FB24 CAN_F11R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F11R2_FB25_Pos (25U)
#define CAN_F11R2_FB25_Msk (0x1U << CAN_F11R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F11R2_FB25 CAN_F11R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F11R2_FB26_Pos (26U)
#define CAN_F11R2_FB26_Msk (0x1U << CAN_F11R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F11R2_FB26 CAN_F11R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F11R2_FB27_Pos (27U)
#define CAN_F11R2_FB27_Msk (0x1U << CAN_F11R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F11R2_FB27 CAN_F11R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F11R2_FB28_Pos (28U)
#define CAN_F11R2_FB28_Msk (0x1U << CAN_F11R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F11R2_FB28 CAN_F11R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F11R2_FB29_Pos (29U)
#define CAN_F11R2_FB29_Msk (0x1U << CAN_F11R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F11R2_FB29 CAN_F11R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F11R2_FB30_Pos (30U)
#define CAN_F11R2_FB30_Msk (0x1U << CAN_F11R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F11R2_FB30 CAN_F11R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F11R2_FB31_Pos (31U)
#define CAN_F11R2_FB31_Msk (0x1U << CAN_F11R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F11R2_FB31 CAN_F11R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F12R2 register  ******************/
#define CAN_F12R2_FB0_Pos (0U)
#define CAN_F12R2_FB0_Msk (0x1U << CAN_F12R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F12R2_FB0 CAN_F12R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F12R2_FB1_Pos (1U)
#define CAN_F12R2_FB1_Msk (0x1U << CAN_F12R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F12R2_FB1 CAN_F12R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F12R2_FB2_Pos (2U)
#define CAN_F12R2_FB2_Msk (0x1U << CAN_F12R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F12R2_FB2 CAN_F12R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F12R2_FB3_Pos (3U)
#define CAN_F12R2_FB3_Msk (0x1U << CAN_F12R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F12R2_FB3 CAN_F12R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F12R2_FB4_Pos (4U)
#define CAN_F12R2_FB4_Msk (0x1U << CAN_F12R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F12R2_FB4 CAN_F12R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F12R2_FB5_Pos (5U)
#define CAN_F12R2_FB5_Msk (0x1U << CAN_F12R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F12R2_FB5 CAN_F12R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F12R2_FB6_Pos (6U)
#define CAN_F12R2_FB6_Msk (0x1U << CAN_F12R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F12R2_FB6 CAN_F12R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F12R2_FB7_Pos (7U)
#define CAN_F12R2_FB7_Msk (0x1U << CAN_F12R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F12R2_FB7 CAN_F12R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F12R2_FB8_Pos (8U)
#define CAN_F12R2_FB8_Msk (0x1U << CAN_F12R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F12R2_FB8 CAN_F12R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F12R2_FB9_Pos (9U)
#define CAN_F12R2_FB9_Msk (0x1U << CAN_F12R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F12R2_FB9 CAN_F12R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F12R2_FB10_Pos (10U)
#define CAN_F12R2_FB10_Msk (0x1U << CAN_F12R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F12R2_FB10 CAN_F12R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F12R2_FB11_Pos (11U)
#define CAN_F12R2_FB11_Msk (0x1U << CAN_F12R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F12R2_FB11 CAN_F12R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F12R2_FB12_Pos (12U)
#define CAN_F12R2_FB12_Msk (0x1U << CAN_F12R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F12R2_FB12 CAN_F12R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F12R2_FB13_Pos (13U)
#define CAN_F12R2_FB13_Msk (0x1U << CAN_F12R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F12R2_FB13 CAN_F12R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F12R2_FB14_Pos (14U)
#define CAN_F12R2_FB14_Msk (0x1U << CAN_F12R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F12R2_FB14 CAN_F12R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F12R2_FB15_Pos (15U)
#define CAN_F12R2_FB15_Msk (0x1U << CAN_F12R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F12R2_FB15 CAN_F12R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F12R2_FB16_Pos (16U)
#define CAN_F12R2_FB16_Msk (0x1U << CAN_F12R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F12R2_FB16 CAN_F12R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F12R2_FB17_Pos (17U)
#define CAN_F12R2_FB17_Msk (0x1U << CAN_F12R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F12R2_FB17 CAN_F12R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F12R2_FB18_Pos (18U)
#define CAN_F12R2_FB18_Msk (0x1U << CAN_F12R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F12R2_FB18 CAN_F12R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F12R2_FB19_Pos (19U)
#define CAN_F12R2_FB19_Msk (0x1U << CAN_F12R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F12R2_FB19 CAN_F12R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F12R2_FB20_Pos (20U)
#define CAN_F12R2_FB20_Msk (0x1U << CAN_F12R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F12R2_FB20 CAN_F12R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F12R2_FB21_Pos (21U)
#define CAN_F12R2_FB21_Msk (0x1U << CAN_F12R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F12R2_FB21 CAN_F12R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F12R2_FB22_Pos (22U)
#define CAN_F12R2_FB22_Msk (0x1U << CAN_F12R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F12R2_FB22 CAN_F12R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F12R2_FB23_Pos (23U)
#define CAN_F12R2_FB23_Msk (0x1U << CAN_F12R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F12R2_FB23 CAN_F12R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F12R2_FB24_Pos (24U)
#define CAN_F12R2_FB24_Msk (0x1U << CAN_F12R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F12R2_FB24 CAN_F12R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F12R2_FB25_Pos (25U)
#define CAN_F12R2_FB25_Msk (0x1U << CAN_F12R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F12R2_FB25 CAN_F12R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F12R2_FB26_Pos (26U)
#define CAN_F12R2_FB26_Msk (0x1U << CAN_F12R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F12R2_FB26 CAN_F12R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F12R2_FB27_Pos (27U)
#define CAN_F12R2_FB27_Msk (0x1U << CAN_F12R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F12R2_FB27 CAN_F12R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F12R2_FB28_Pos (28U)
#define CAN_F12R2_FB28_Msk (0x1U << CAN_F12R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F12R2_FB28 CAN_F12R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F12R2_FB29_Pos (29U)
#define CAN_F12R2_FB29_Msk (0x1U << CAN_F12R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F12R2_FB29 CAN_F12R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F12R2_FB30_Pos (30U)
#define CAN_F12R2_FB30_Msk (0x1U << CAN_F12R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F12R2_FB30 CAN_F12R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F12R2_FB31_Pos (31U)
#define CAN_F12R2_FB31_Msk (0x1U << CAN_F12R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F12R2_FB31 CAN_F12R2_FB31_Msk /*!< Filter bit 31 */

/*******************  Bit definition for CAN_F13R2 register  ******************/
#define CAN_F13R2_FB0_Pos (0U)
#define CAN_F13R2_FB0_Msk (0x1U << CAN_F13R2_FB0_Pos) /*!< 0x00000001 */
#define CAN_F13R2_FB0 CAN_F13R2_FB0_Msk /*!< Filter bit 0 */
#define CAN_F13R2_FB1_Pos (1U)
#define CAN_F13R2_FB1_Msk (0x1U << CAN_F13R2_FB1_Pos) /*!< 0x00000002 */
#define CAN_F13R2_FB1 CAN_F13R2_FB1_Msk /*!< Filter bit 1 */
#define CAN_F13R2_FB2_Pos (2U)
#define CAN_F13R2_FB2_Msk (0x1U << CAN_F13R2_FB2_Pos) /*!< 0x00000004 */
#define CAN_F13R2_FB2 CAN_F13R2_FB2_Msk /*!< Filter bit 2 */
#define CAN_F13R2_FB3_Pos (3U)
#define CAN_F13R2_FB3_Msk (0x1U << CAN_F13R2_FB3_Pos) /*!< 0x00000008 */
#define CAN_F13R2_FB3 CAN_F13R2_FB3_Msk /*!< Filter bit 3 */
#define CAN_F13R2_FB4_Pos (4U)
#define CAN_F13R2_FB4_Msk (0x1U << CAN_F13R2_FB4_Pos) /*!< 0x00000010 */
#define CAN_F13R2_FB4 CAN_F13R2_FB4_Msk /*!< Filter bit 4 */
#define CAN_F13R2_FB5_Pos (5U)
#define CAN_F13R2_FB5_Msk (0x1U << CAN_F13R2_FB5_Pos) /*!< 0x00000020 */
#define CAN_F13R2_FB5 CAN_F13R2_FB5_Msk /*!< Filter bit 5 */
#define CAN_F13R2_FB6_Pos (6U)
#define CAN_F13R2_FB6_Msk (0x1U << CAN_F13R2_FB6_Pos) /*!< 0x00000040 */
#define CAN_F13R2_FB6 CAN_F13R2_FB6_Msk /*!< Filter bit 6 */
#define CAN_F13R2_FB7_Pos (7U)
#define CAN_F13R2_FB7_Msk (0x1U << CAN_F13R2_FB7_Pos) /*!< 0x00000080 */
#define CAN_F13R2_FB7 CAN_F13R2_FB7_Msk /*!< Filter bit 7 */
#define CAN_F13R2_FB8_Pos (8U)
#define CAN_F13R2_FB8_Msk (0x1U << CAN_F13R2_FB8_Pos) /*!< 0x00000100 */
#define CAN_F13R2_FB8 CAN_F13R2_FB8_Msk /*!< Filter bit 8 */
#define CAN_F13R2_FB9_Pos (9U)
#define CAN_F13R2_FB9_Msk (0x1U << CAN_F13R2_FB9_Pos) /*!< 0x00000200 */
#define CAN_F13R2_FB9 CAN_F13R2_FB9_Msk /*!< Filter bit 9 */
#define CAN_F13R2_FB10_Pos (10U)
#define CAN_F13R2_FB10_Msk (0x1U << CAN_F13R2_FB10_Pos) /*!< 0x00000400 */
#define CAN_F13R2_FB10 CAN_F13R2_FB10_Msk /*!< Filter bit 10 */
#define CAN_F13R2_FB11_Pos (11U)
#define CAN_F13R2_FB11_Msk (0x1U << CAN_F13R2_FB11_Pos) /*!< 0x00000800 */
#define CAN_F13R2_FB11 CAN_F13R2_FB11_Msk /*!< Filter bit 11 */
#define CAN_F13R2_FB12_Pos (12U)
#define CAN_F13R2_FB12_Msk (0x1U << CAN_F13R2_FB12_Pos) /*!< 0x00001000 */
#define CAN_F13R2_FB12 CAN_F13R2_FB12_Msk /*!< Filter bit 12 */
#define CAN_F13R2_FB13_Pos (13U)
#define CAN_F13R2_FB13_Msk (0x1U << CAN_F13R2_FB13_Pos) /*!< 0x00002000 */
#define CAN_F13R2_FB13 CAN_F13R2_FB13_Msk /*!< Filter bit 13 */
#define CAN_F13R2_FB14_Pos (14U)
#define CAN_F13R2_FB14_Msk (0x1U << CAN_F13R2_FB14_Pos) /*!< 0x00004000 */
#define CAN_F13R2_FB14 CAN_F13R2_FB14_Msk /*!< Filter bit 14 */
#define CAN_F13R2_FB15_Pos (15U)
#define CAN_F13R2_FB15_Msk (0x1U << CAN_F13R2_FB15_Pos) /*!< 0x00008000 */
#define CAN_F13R2_FB15 CAN_F13R2_FB15_Msk /*!< Filter bit 15 */
#define CAN_F13R2_FB16_Pos (16U)
#define CAN_F13R2_FB16_Msk (0x1U << CAN_F13R2_FB16_Pos) /*!< 0x00010000 */
#define CAN_F13R2_FB16 CAN_F13R2_FB16_Msk /*!< Filter bit 16 */
#define CAN_F13R2_FB17_Pos (17U)
#define CAN_F13R2_FB17_Msk (0x1U << CAN_F13R2_FB17_Pos) /*!< 0x00020000 */
#define CAN_F13R2_FB17 CAN_F13R2_FB17_Msk /*!< Filter bit 17 */
#define CAN_F13R2_FB18_Pos (18U)
#define CAN_F13R2_FB18_Msk (0x1U << CAN_F13R2_FB18_Pos) /*!< 0x00040000 */
#define CAN_F13R2_FB18 CAN_F13R2_FB18_Msk /*!< Filter bit 18 */
#define CAN_F13R2_FB19_Pos (19U)
#define CAN_F13R2_FB19_Msk (0x1U << CAN_F13R2_FB19_Pos) /*!< 0x00080000 */
#define CAN_F13R2_FB19 CAN_F13R2_FB19_Msk /*!< Filter bit 19 */
#define CAN_F13R2_FB20_Pos (20U)
#define CAN_F13R2_FB20_Msk (0x1U << CAN_F13R2_FB20_Pos) /*!< 0x00100000 */
#define CAN_F13R2_FB20 CAN_F13R2_FB20_Msk /*!< Filter bit 20 */
#define CAN_F13R2_FB21_Pos (21U)
#define CAN_F13R2_FB21_Msk (0x1U << CAN_F13R2_FB21_Pos) /*!< 0x00200000 */
#define CAN_F13R2_FB21 CAN_F13R2_FB21_Msk /*!< Filter bit 21 */
#define CAN_F13R2_FB22_Pos (22U)
#define CAN_F13R2_FB22_Msk (0x1U << CAN_F13R2_FB22_Pos) /*!< 0x00400000 */
#define CAN_F13R2_FB22 CAN_F13R2_FB22_Msk /*!< Filter bit 22 */
#define CAN_F13R2_FB23_Pos (23U)
#define CAN_F13R2_FB23_Msk (0x1U << CAN_F13R2_FB23_Pos) /*!< 0x00800000 */
#define CAN_F13R2_FB23 CAN_F13R2_FB23_Msk /*!< Filter bit 23 */
#define CAN_F13R2_FB24_Pos (24U)
#define CAN_F13R2_FB24_Msk (0x1U << CAN_F13R2_FB24_Pos) /*!< 0x01000000 */
#define CAN_F13R2_FB24 CAN_F13R2_FB24_Msk /*!< Filter bit 24 */
#define CAN_F13R2_FB25_Pos (25U)
#define CAN_F13R2_FB25_Msk (0x1U << CAN_F13R2_FB25_Pos) /*!< 0x02000000 */
#define CAN_F13R2_FB25 CAN_F13R2_FB25_Msk /*!< Filter bit 25 */
#define CAN_F13R2_FB26_Pos (26U)
#define CAN_F13R2_FB26_Msk (0x1U << CAN_F13R2_FB26_Pos) /*!< 0x04000000 */
#define CAN_F13R2_FB26 CAN_F13R2_FB26_Msk /*!< Filter bit 26 */
#define CAN_F13R2_FB27_Pos (27U)
#define CAN_F13R2_FB27_Msk (0x1U << CAN_F13R2_FB27_Pos) /*!< 0x08000000 */
#define CAN_F13R2_FB27 CAN_F13R2_FB27_Msk /*!< Filter bit 27 */
#define CAN_F13R2_FB28_Pos (28U)
#define CAN_F13R2_FB28_Msk (0x1U << CAN_F13R2_FB28_Pos) /*!< 0x10000000 */
#define CAN_F13R2_FB28 CAN_F13R2_FB28_Msk /*!< Filter bit 28 */
#define CAN_F13R2_FB29_Pos (29U)
#define CAN_F13R2_FB29_Msk (0x1U << CAN_F13R2_FB29_Pos) /*!< 0x20000000 */
#define CAN_F13R2_FB29 CAN_F13R2_FB29_Msk /*!< Filter bit 29 */
#define CAN_F13R2_FB30_Pos (30U)
#define CAN_F13R2_FB30_Msk (0x1U << CAN_F13R2_FB30_Pos) /*!< 0x40000000 */
#define CAN_F13R2_FB30 CAN_F13R2_FB30_Msk /*!< Filter bit 30 */
#define CAN_F13R2_FB31_Pos (31U)
#define CAN_F13R2_FB31_Msk (0x1U << CAN_F13R2_FB31_Pos) /*!< 0x80000000 */
#define CAN_F13R2_FB31 CAN_F13R2_FB31_Msk /*!< Filter bit 31 */

/******************************************************************************/
/*                                                                            */
/*                        Serial Peripheral Interface                         */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for SPI_CR1 register  ********************/
#define SPI_CR1_CPHA_Pos (0U)
#define SPI_CR1_CPHA_Msk (0x1U << SPI_CR1_CPHA_Pos) /*!< 0x00000001 */
#define SPI_CR1_CPHA SPI_CR1_CPHA_Msk /*!< Clock Phase */
#define SPI_CR1_CPOL_Pos (1U)
#define SPI_CR1_CPOL_Msk (0x1U << SPI_CR1_CPOL_Pos) /*!< 0x00000002 */
#define SPI_CR1_CPOL SPI_CR1_CPOL_Msk /*!< Clock Polarity */
#define SPI_CR1_MSTR_Pos (2U)
#define SPI_CR1_MSTR_Msk (0x1U << SPI_CR1_MSTR_Pos) /*!< 0x00000004 */
#define SPI_CR1_MSTR SPI_CR1_MSTR_Msk /*!< Master Selection */

#define SPI_CR1_BR_Pos (3U)
#define SPI_CR1_BR_Msk (0x7U << SPI_CR1_BR_Pos) /*!< 0x00000038 */
#define SPI_CR1_BR SPI_CR1_BR_Msk /*!< BR[2:0] bits (Baud Rate Control) */
#define SPI_CR1_BR_0 (0x1U << SPI_CR1_BR_Pos) /*!< 0x00000008 */
#define SPI_CR1_BR_1 (0x2U << SPI_CR1_BR_Pos) /*!< 0x00000010 */
#define SPI_CR1_BR_2 (0x4U << SPI_CR1_BR_Pos) /*!< 0x00000020 */

#define SPI_CR1_SPE_Pos (6U)
#define SPI_CR1_SPE_Msk (0x1U << SPI_CR1_SPE_Pos) /*!< 0x00000040 */
#define SPI_CR1_SPE SPI_CR1_SPE_Msk /*!< SPI Enable */
#define SPI_CR1_LSBFIRST_Pos (7U)
#define SPI_CR1_LSBFIRST_Msk (0x1U << SPI_CR1_LSBFIRST_Pos) /*!< 0x00000080 */
#define SPI_CR1_LSBFIRST SPI_CR1_LSBFIRST_Msk /*!< Frame Format */
#define SPI_CR1_SSI_Pos (8U)
#define SPI_CR1_SSI_Msk (0x1U << SPI_CR1_SSI_Pos) /*!< 0x00000100 */
#define SPI_CR1_SSI SPI_CR1_SSI_Msk /*!< Internal slave select */
#define SPI_CR1_SSM_Pos (9U)
#define SPI_CR1_SSM_Msk (0x1U << SPI_CR1_SSM_Pos) /*!< 0x00000200 */
#define SPI_CR1_SSM SPI_CR1_SSM_Msk /*!< Software slave management */
#define SPI_CR1_RXONLY_Pos (10U)
#define SPI_CR1_RXONLY_Msk (0x1U << SPI_CR1_RXONLY_Pos) /*!< 0x00000400 */
#define SPI_CR1_RXONLY SPI_CR1_RXONLY_Msk /*!< Receive only */
#define SPI_CR1_DFF_Pos (11U)
#define SPI_CR1_DFF_Msk (0x1U << SPI_CR1_DFF_Pos) /*!< 0x00000800 */
#define SPI_CR1_DFF SPI_CR1_DFF_Msk /*!< Data Frame Format */
#define SPI_CR1_CRCNEXT_Pos (12U)
#define SPI_CR1_CRCNEXT_Msk (0x1U << SPI_CR1_CRCNEXT_Pos) /*!< 0x00001000 */
#define SPI_CR1_CRCNEXT SPI_CR1_CRCNEXT_Msk /*!< Transmit CRC next */
#define SPI_CR1_CRCEN_Pos (13U)
#define SPI_CR1_CRCEN_Msk (0x1U << SPI_CR1_CRCEN_Pos) /*!< 0x00002000 */
#define SPI_CR1_CRCEN SPI_CR1_CRCEN_Msk /*!< Hardware CRC calculation enable */
#define SPI_CR1_BIDIOE_Pos (14U)
#define SPI_CR1_BIDIOE_Msk (0x1U << SPI_CR1_BIDIOE_Pos) /*!< 0x00004000 */
#define SPI_CR1_BIDIOE SPI_CR1_BIDIOE_Msk /*!< Output enable in bidirectional mode */
#define SPI_CR1_BIDIMODE_Pos (15U)
#define SPI_CR1_BIDIMODE_Msk (0x1U << SPI_CR1_BIDIMODE_Pos) /*!< 0x00008000 */
#define SPI_CR1_BIDIMODE SPI_CR1_BIDIMODE_Msk /*!< Bidirectional data mode enable */

/*******************  Bit definition for SPI_CR2 register  ********************/
#define SPI_CR2_RXDMAEN_Pos (0U)
#define SPI_CR2_RXDMAEN_Msk (0x1U << SPI_CR2_RXDMAEN_Pos) /*!< 0x00000001 */
#define SPI_CR2_RXDMAEN SPI_CR2_RXDMAEN_Msk /*!< Rx Buffer DMA Enable */
#define SPI_CR2_TXDMAEN_Pos (1U)
#define SPI_CR2_TXDMAEN_Msk (0x1U << SPI_CR2_TXDMAEN_Pos) /*!< 0x00000002 */
#define SPI_CR2_TXDMAEN SPI_CR2_TXDMAEN_Msk /*!< Tx Buffer DMA Enable */
#define SPI_CR2_SSOE_Pos (2U)
#define SPI_CR2_SSOE_Msk (0x1U << SPI_CR2_SSOE_Pos) /*!< 0x00000004 */
#define SPI_CR2_SSOE SPI_CR2_SSOE_Msk /*!< SS Output Enable */
#define SPI_CR2_ERRIE_Pos (5U)
#define SPI_CR2_ERRIE_Msk (0x1U << SPI_CR2_ERRIE_Pos) /*!< 0x00000020 */
#define SPI_CR2_ERRIE SPI_CR2_ERRIE_Msk /*!< Error Interrupt Enable */
#define SPI_CR2_RXNEIE_Pos (6U)
#define SPI_CR2_RXNEIE_Msk (0x1U << SPI_CR2_RXNEIE_Pos) /*!< 0x00000040 */
#define SPI_CR2_RXNEIE SPI_CR2_RXNEIE_Msk /*!< RX buffer Not Empty Interrupt Enable */
#define SPI_CR2_TXEIE_Pos (7U)
#define SPI_CR2_TXEIE_Msk (0x1U << SPI_CR2_TXEIE_Pos) /*!< 0x00000080 */
#define SPI_CR2_TXEIE SPI_CR2_TXEIE_Msk /*!< Tx buffer Empty Interrupt Enable */

/********************  Bit definition for SPI_SR register  ********************/
#define SPI_SR_RXNE_Pos (0U)
#define SPI_SR_RXNE_Msk (0x1U << SPI_SR_RXNE_Pos) /*!< 0x00000001 */
#define SPI_SR_RXNE SPI_SR_RXNE_Msk /*!< Receive buffer Not Empty */
#define SPI_SR_TXE_Pos (1U)
#define SPI_SR_TXE_Msk (0x1U << SPI_SR_TXE_Pos) /*!< 0x00000002 */
#define SPI_SR_TXE SPI_SR_TXE_Msk /*!< Transmit buffer Empty */
#define SPI_SR_CHSIDE_Pos (2U)
#define SPI_SR_CHSIDE_Msk (0x1U << SPI_SR_CHSIDE_Pos) /*!< 0x00000004 */
#define SPI_SR_CHSIDE SPI_SR_CHSIDE_Msk /*!< Channel side */
#define SPI_SR_UDR_Pos (3U)
#define SPI_SR_UDR_Msk (0x1U << SPI_SR_UDR_Pos) /*!< 0x00000008 */
#define SPI_SR_UDR SPI_SR_UDR_Msk /*!< Underrun flag */
#define SPI_SR_CRCERR_Pos (4U)
#define SPI_SR_CRCERR_Msk (0x1U << SPI_SR_CRCERR_Pos) /*!< 0x00000010 */
#define SPI_SR_CRCERR SPI_SR_CRCERR_Msk /*!< CRC Error flag */
#define SPI_SR_MODF_Pos (5U)
#define SPI_SR_MODF_Msk (0x1U << SPI_SR_MODF_Pos) /*!< 0x00000020 */
#define SPI_SR_MODF SPI_SR_MODF_Msk /*!< Mode fault */
#define SPI_SR_OVR_Pos (6U)
#define SPI_SR_OVR_Msk (0x1U << SPI_SR_OVR_Pos) /*!< 0x00000040 */
#define SPI_SR_OVR SPI_SR_OVR_Msk /*!< Overrun flag */
#define SPI_SR_BSY_Pos (7U)
#define SPI_SR_BSY_Msk (0x1U << SPI_SR_BSY_Pos) /*!< 0x00000080 */
#define SPI_SR_BSY SPI_SR_BSY_Msk /*!< Busy flag */

/********************  Bit definition for SPI_DR register  ********************/
#define SPI_DR_DR_Pos (0U)
#define SPI_DR_DR_Msk (0xFFFFU << SPI_DR_DR_Pos) /*!< 0x0000FFFF */
#define SPI_DR_DR SPI_DR_DR_Msk /*!< Data Register */

/*******************  Bit definition for SPI_CRCPR register  ******************/
#define SPI_CRCPR_CRCPOLY_Pos (0U)
#define SPI_CRCPR_CRCPOLY_Msk (0xFFFFU << SPI_CRCPR_CRCPOLY_Pos) /*!< 0x0000FFFF */
#define SPI_CRCPR_CRCPOLY SPI_CRCPR_CRCPOLY_Msk /*!< CRC polynomial register */

/******************  Bit definition for SPI_RXCRCR register  ******************/
#define SPI_RXCRCR_RXCRC_Pos (0U)
#define SPI_RXCRCR_RXCRC_Msk (0xFFFFU << SPI_RXCRCR_RXCRC_Pos) /*!< 0x0000FFFF */
#define SPI_RXCRCR_RXCRC SPI_RXCRCR_RXCRC_Msk /*!< Rx CRC Register */

/******************  Bit definition for SPI_TXCRCR register  ******************/
#define SPI_TXCRCR_TXCRC_Pos (0U)
#define SPI_TXCRCR_TXCRC_Msk (0xFFFFU << SPI_TXCRCR_TXCRC_Pos) /*!< 0x0000FFFF */
#define SPI_TXCRCR_TXCRC SPI_TXCRCR_TXCRC_Msk /*!< Tx CRC Register */

/******************  Bit definition for SPI_I2SCFGR register  *****************/
#define SPI_I2SCFGR_I2SMOD_Pos (11U)
#define SPI_I2SCFGR_I2SMOD_Msk (0x1U << SPI_I2SCFGR_I2SMOD_Pos) /*!< 0x00000800 */
#define SPI_I2SCFGR_I2SMOD SPI_I2SCFGR_I2SMOD_Msk /*!< I2S mode selection */


/******************************************************************************/
/*                                                                            */
/*                      Inter-integrated Circuit Interface                    */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for I2C_CR1 register  ********************/
#define I2C_CR1_PE_Pos (0U)
#define I2C_CR1_PE_Msk (0x1U << I2C_CR1_PE_Pos) /*!< 0x00000001 */
#define I2C_CR1_PE I2C_CR1_PE_Msk /*!< Peripheral Enable */
#define I2C_CR1_SMBUS_Pos (1U)
#define I2C_CR1_SMBUS_Msk (0x1U << I2C_CR1_SMBUS_Pos) /*!< 0x00000002 */
#define I2C_CR1_SMBUS I2C_CR1_SMBUS_Msk /*!< SMBus Mode */
#define I2C_CR1_SMBTYPE_Pos (3U)
#define I2C_CR1_SMBTYPE_Msk (0x1U << I2C_CR1_SMBTYPE_Pos) /*!< 0x00000008 */
#define I2C_CR1_SMBTYPE I2C_CR1_SMBTYPE_Msk /*!< SMBus Type */
#define I2C_CR1_ENARP_Pos (4U)
#define I2C_CR1_ENARP_Msk (0x1U << I2C_CR1_ENARP_Pos) /*!< 0x00000010 */
#define I2C_CR1_ENARP I2C_CR1_ENARP_Msk /*!< ARP Enable */
#define I2C_CR1_ENPEC_Pos (5U)
#define I2C_CR1_ENPEC_Msk (0x1U << I2C_CR1_ENPEC_Pos) /*!< 0x00000020 */
#define I2C_CR1_ENPEC I2C_CR1_ENPEC_Msk /*!< PEC Enable */
#define I2C_CR1_ENGC_Pos (6U)
#define I2C_CR1_ENGC_Msk (0x1U << I2C_CR1_ENGC_Pos) /*!< 0x00000040 */
#define I2C_CR1_ENGC I2C_CR1_ENGC_Msk /*!< General Call Enable */
#define I2C_CR1_NOSTRETCH_Pos (7U)
#define I2C_CR1_NOSTRETCH_Msk (0x1U << I2C_CR1_NOSTRETCH_Pos) /*!< 0x00000080 */
#define I2C_CR1_NOSTRETCH I2C_CR1_NOSTRETCH_Msk /*!< Clock Stretching Disable (Slave mode) */
#define I2C_CR1_START_Pos (8U)
#define I2C_CR1_START_Msk (0x1U << I2C_CR1_START_Pos) /*!< 0x00000100 */
#define I2C_CR1_START I2C_CR1_START_Msk /*!< Start Generation */
#define I2C_CR1_STOP_Pos (9U)
#define I2C_CR1_STOP_Msk (0x1U << I2C_CR1_STOP_Pos) /*!< 0x00000200 */
#define I2C_CR1_STOP I2C_CR1_STOP_Msk /*!< Stop Generation */
#define I2C_CR1_ACK_Pos (10U)
#define I2C_CR1_ACK_Msk (0x1U << I2C_CR1_ACK_Pos) /*!< 0x00000400 */
#define I2C_CR1_ACK I2C_CR1_ACK_Msk /*!< Acknowledge Enable */
#define I2C_CR1_POS_Pos (11U)
#define I2C_CR1_POS_Msk (0x1U << I2C_CR1_POS_Pos) /*!< 0x00000800 */
#define I2C_CR1_POS I2C_CR1_POS_Msk /*!< Acknowledge/PEC Position (for data reception) */
#define I2C_CR1_PEC_Pos (12U)
#define I2C_CR1_PEC_Msk (0x1U << I2C_CR1_PEC_Pos) /*!< 0x00001000 */
#define I2C_CR1_PEC I2C_CR1_PEC_Msk /*!< Packet Error Checking */
#define I2C_CR1_ALERT_Pos (13U)
#define I2C_CR1_ALERT_Msk (0x1U << I2C_CR1_ALERT_Pos) /*!< 0x00002000 */
#define I2C_CR1_ALERT I2C_CR1_ALERT_Msk /*!< SMBus Alert */
#define I2C_CR1_SWRST_Pos (15U)
#define I2C_CR1_SWRST_Msk (0x1U << I2C_CR1_SWRST_Pos) /*!< 0x00008000 */
#define I2C_CR1_SWRST I2C_CR1_SWRST_Msk /*!< Software Reset */

/*******************  Bit definition for I2C_CR2 register  ********************/
#define I2C_CR2_FREQ_Pos (0U)
#define I2C_CR2_FREQ_Msk (0x3FU << I2C_CR2_FREQ_Pos) /*!< 0x0000003F */
#define I2C_CR2_FREQ I2C_CR2_FREQ_Msk /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */
#define I2C_CR2_FREQ_0 (0x01U << I2C_CR2_FREQ_Pos) /*!< 0x00000001 */
#define I2C_CR2_FREQ_1 (0x02U << I2C_CR2_FREQ_Pos) /*!< 0x00000002 */
#define I2C_CR2_FREQ_2 (0x04U << I2C_CR2_FREQ_Pos) /*!< 0x00000004 */
#define I2C_CR2_FREQ_3 (0x08U << I2C_CR2_FREQ_Pos) /*!< 0x00000008 */
#define I2C_CR2_FREQ_4 (0x10U << I2C_CR2_FREQ_Pos) /*!< 0x00000010 */
#define I2C_CR2_FREQ_5 (0x20U << I2C_CR2_FREQ_Pos) /*!< 0x00000020 */

#define I2C_CR2_ITERREN_Pos (8U)
#define I2C_CR2_ITERREN_Msk (0x1U << I2C_CR2_ITERREN_Pos) /*!< 0x00000100 */
#define I2C_CR2_ITERREN I2C_CR2_ITERREN_Msk /*!< Error Interrupt Enable */
#define I2C_CR2_ITEVTEN_Pos (9U)
#define I2C_CR2_ITEVTEN_Msk (0x1U << I2C_CR2_ITEVTEN_Pos) /*!< 0x00000200 */
#define I2C_CR2_ITEVTEN I2C_CR2_ITEVTEN_Msk /*!< Event Interrupt Enable */
#define I2C_CR2_ITBUFEN_Pos (10U)
#define I2C_CR2_ITBUFEN_Msk (0x1U << I2C_CR2_ITBUFEN_Pos) /*!< 0x00000400 */
#define I2C_CR2_ITBUFEN I2C_CR2_ITBUFEN_Msk /*!< Buffer Interrupt Enable */
#define I2C_CR2_DMAEN_Pos (11U)
#define I2C_CR2_DMAEN_Msk (0x1U << I2C_CR2_DMAEN_Pos) /*!< 0x00000800 */
#define I2C_CR2_DMAEN I2C_CR2_DMAEN_Msk /*!< DMA Requests Enable */
#define I2C_CR2_LAST_Pos (12U)
#define I2C_CR2_LAST_Msk (0x1U << I2C_CR2_LAST_Pos) /*!< 0x00001000 */
#define I2C_CR2_LAST I2C_CR2_LAST_Msk /*!< DMA Last Transfer */

/*******************  Bit definition for I2C_OAR1 register  *******************/
#define I2C_OAR1_ADD1_7 0x000000FEU /*!< Interface Address */
#define I2C_OAR1_ADD8_9 0x00000300U /*!< Interface Address */

#define I2C_OAR1_ADD0_Pos (0U)
#define I2C_OAR1_ADD0_Msk (0x1U << I2C_OAR1_ADD0_Pos) /*!< 0x00000001 */
#define I2C_OAR1_ADD0 I2C_OAR1_ADD0_Msk /*!< Bit 0 */
#define I2C_OAR1_ADD1_Pos (1U)
#define I2C_OAR1_ADD1_Msk (0x1U << I2C_OAR1_ADD1_Pos) /*!< 0x00000002 */
#define I2C_OAR1_ADD1 I2C_OAR1_ADD1_Msk /*!< Bit 1 */
#define I2C_OAR1_ADD2_Pos (2U)
#define I2C_OAR1_ADD2_Msk (0x1U << I2C_OAR1_ADD2_Pos) /*!< 0x00000004 */
#define I2C_OAR1_ADD2 I2C_OAR1_ADD2_Msk /*!< Bit 2 */
#define I2C_OAR1_ADD3_Pos (3U)
#define I2C_OAR1_ADD3_Msk (0x1U << I2C_OAR1_ADD3_Pos) /*!< 0x00000008 */
#define I2C_OAR1_ADD3 I2C_OAR1_ADD3_Msk /*!< Bit 3 */
#define I2C_OAR1_ADD4_Pos (4U)
#define I2C_OAR1_ADD4_Msk (0x1U << I2C_OAR1_ADD4_Pos) /*!< 0x00000010 */
#define I2C_OAR1_ADD4 I2C_OAR1_ADD4_Msk /*!< Bit 4 */
#define I2C_OAR1_ADD5_Pos (5U)
#define I2C_OAR1_ADD5_Msk (0x1U << I2C_OAR1_ADD5_Pos) /*!< 0x00000020 */
#define I2C_OAR1_ADD5 I2C_OAR1_ADD5_Msk /*!< Bit 5 */
#define I2C_OAR1_ADD6_Pos (6U)
#define I2C_OAR1_ADD6_Msk (0x1U << I2C_OAR1_ADD6_Pos) /*!< 0x00000040 */
#define I2C_OAR1_ADD6 I2C_OAR1_ADD6_Msk /*!< Bit 6 */
#define I2C_OAR1_ADD7_Pos (7U)
#define I2C_OAR1_ADD7_Msk (0x1U << I2C_OAR1_ADD7_Pos) /*!< 0x00000080 */
#define I2C_OAR1_ADD7 I2C_OAR1_ADD7_Msk /*!< Bit 7 */
#define I2C_OAR1_ADD8_Pos (8U)
#define I2C_OAR1_ADD8_Msk (0x1U << I2C_OAR1_ADD8_Pos) /*!< 0x00000100 */
#define I2C_OAR1_ADD8 I2C_OAR1_ADD8_Msk /*!< Bit 8 */
#define I2C_OAR1_ADD9_Pos (9U)
#define I2C_OAR1_ADD9_Msk (0x1U << I2C_OAR1_ADD9_Pos) /*!< 0x00000200 */
#define I2C_OAR1_ADD9 I2C_OAR1_ADD9_Msk /*!< Bit 9 */

#define I2C_OAR1_ADDMODE_Pos (15U)
#define I2C_OAR1_ADDMODE_Msk (0x1U << I2C_OAR1_ADDMODE_Pos) /*!< 0x00008000 */
#define I2C_OAR1_ADDMODE I2C_OAR1_ADDMODE_Msk /*!< Addressing Mode (Slave mode) */

/*******************  Bit definition for I2C_OAR2 register  *******************/
#define I2C_OAR2_ENDUAL_Pos (0U)
#define I2C_OAR2_ENDUAL_Msk (0x1U << I2C_OAR2_ENDUAL_Pos) /*!< 0x00000001 */
#define I2C_OAR2_ENDUAL I2C_OAR2_ENDUAL_Msk /*!< Dual addressing mode enable */
#define I2C_OAR2_ADD2_Pos (1U)
#define I2C_OAR2_ADD2_Msk (0x7FU << I2C_OAR2_ADD2_Pos) /*!< 0x000000FE */
#define I2C_OAR2_ADD2 I2C_OAR2_ADD2_Msk /*!< Interface address */

/********************  Bit definition for I2C_DR register  ********************/
#define I2C_DR_DR_Pos (0U)
#define I2C_DR_DR_Msk (0xFFU << I2C_DR_DR_Pos) /*!< 0x000000FF */
#define I2C_DR_DR I2C_DR_DR_Msk /*!< 8-bit Data Register         */

/*******************  Bit definition for I2C_SR1 register  ********************/
#define I2C_SR1_SB_Pos (0U)
#define I2C_SR1_SB_Msk (0x1U << I2C_SR1_SB_Pos) /*!< 0x00000001 */
#define I2C_SR1_SB I2C_SR1_SB_Msk /*!< Start Bit (Master mode) */
#define I2C_SR1_ADDR_Pos (1U)
#define I2C_SR1_ADDR_Msk (0x1U << I2C_SR1_ADDR_Pos) /*!< 0x00000002 */
#define I2C_SR1_ADDR I2C_SR1_ADDR_Msk /*!< Address sent (master mode)/matched (slave mode) */
#define I2C_SR1_BTF_Pos (2U)
#define I2C_SR1_BTF_Msk (0x1U << I2C_SR1_BTF_Pos) /*!< 0x00000004 */
#define I2C_SR1_BTF I2C_SR1_BTF_Msk /*!< Byte Transfer Finished */
#define I2C_SR1_ADD10_Pos (3U)
#define I2C_SR1_ADD10_Msk (0x1U << I2C_SR1_ADD10_Pos) /*!< 0x00000008 */
#define I2C_SR1_ADD10 I2C_SR1_ADD10_Msk /*!< 10-bit header sent (Master mode) */
#define I2C_SR1_STOPF_Pos (4U)
#define I2C_SR1_STOPF_Msk (0x1U << I2C_SR1_STOPF_Pos) /*!< 0x00000010 */
#define I2C_SR1_STOPF I2C_SR1_STOPF_Msk /*!< Stop detection (Slave mode) */
#define I2C_SR1_RXNE_Pos (6U)
#define I2C_SR1_RXNE_Msk (0x1U << I2C_SR1_RXNE_Pos) /*!< 0x00000040 */
#define I2C_SR1_RXNE I2C_SR1_RXNE_Msk /*!< Data Register not Empty (receivers) */
#define I2C_SR1_TXE_Pos (7U)
#define I2C_SR1_TXE_Msk (0x1U << I2C_SR1_TXE_Pos) /*!< 0x00000080 */
#define I2C_SR1_TXE I2C_SR1_TXE_Msk /*!< Data Register Empty (transmitters) */
#define I2C_SR1_BERR_Pos (8U)
#define I2C_SR1_BERR_Msk (0x1U << I2C_SR1_BERR_Pos) /*!< 0x00000100 */
#define I2C_SR1_BERR I2C_SR1_BERR_Msk /*!< Bus Error */
#define I2C_SR1_ARLO_Pos (9U)
#define I2C_SR1_ARLO_Msk (0x1U << I2C_SR1_ARLO_Pos) /*!< 0x00000200 */
#define I2C_SR1_ARLO I2C_SR1_ARLO_Msk /*!< Arbitration Lost (master mode) */
#define I2C_SR1_AF_Pos (10U)
#define I2C_SR1_AF_Msk (0x1U << I2C_SR1_AF_Pos) /*!< 0x00000400 */
#define I2C_SR1_AF I2C_SR1_AF_Msk /*!< Acknowledge Failure */
#define I2C_SR1_OVR_Pos (11U)
#define I2C_SR1_OVR_Msk (0x1U << I2C_SR1_OVR_Pos) /*!< 0x00000800 */
#define I2C_SR1_OVR I2C_SR1_OVR_Msk /*!< Overrun/Underrun */
#define I2C_SR1_PECERR_Pos (12U)
#define I2C_SR1_PECERR_Msk (0x1U << I2C_SR1_PECERR_Pos) /*!< 0x00001000 */
#define I2C_SR1_PECERR I2C_SR1_PECERR_Msk /*!< PEC Error in reception */
#define I2C_SR1_TIMEOUT_Pos (14U)
#define I2C_SR1_TIMEOUT_Msk (0x1U << I2C_SR1_TIMEOUT_Pos) /*!< 0x00004000 */
#define I2C_SR1_TIMEOUT I2C_SR1_TIMEOUT_Msk /*!< Timeout or Tlow Error */
#define I2C_SR1_SMBALERT_Pos (15U)
#define I2C_SR1_SMBALERT_Msk (0x1U << I2C_SR1_SMBALERT_Pos) /*!< 0x00008000 */
#define I2C_SR1_SMBALERT I2C_SR1_SMBALERT_Msk /*!< SMBus Alert */

/*******************  Bit definition for I2C_SR2 register  ********************/
#define I2C_SR2_MSL_Pos (0U)
#define I2C_SR2_MSL_Msk (0x1U << I2C_SR2_MSL_Pos) /*!< 0x00000001 */
#define I2C_SR2_MSL I2C_SR2_MSL_Msk /*!< Master/Slave */
#define I2C_SR2_BUSY_Pos (1U)
#define I2C_SR2_BUSY_Msk (0x1U << I2C_SR2_BUSY_Pos) /*!< 0x00000002 */
#define I2C_SR2_BUSY I2C_SR2_BUSY_Msk /*!< Bus Busy */
#define I2C_SR2_TRA_Pos (2U)
#define I2C_SR2_TRA_Msk (0x1U << I2C_SR2_TRA_Pos) /*!< 0x00000004 */
#define I2C_SR2_TRA I2C_SR2_TRA_Msk /*!< Transmitter/Receiver */
#define I2C_SR2_GENCALL_Pos (4U)
#define I2C_SR2_GENCALL_Msk (0x1U << I2C_SR2_GENCALL_Pos) /*!< 0x00000010 */
#define I2C_SR2_GENCALL I2C_SR2_GENCALL_Msk /*!< General Call Address (Slave mode) */
#define I2C_SR2_SMBDEFAULT_Pos (5U)
#define I2C_SR2_SMBDEFAULT_Msk (0x1U << I2C_SR2_SMBDEFAULT_Pos) /*!< 0x00000020 */
#define I2C_SR2_SMBDEFAULT I2C_SR2_SMBDEFAULT_Msk /*!< SMBus Device Default Address (Slave mode) */
#define I2C_SR2_SMBHOST_Pos (6U)
#define I2C_SR2_SMBHOST_Msk (0x1U << I2C_SR2_SMBHOST_Pos) /*!< 0x00000040 */
#define I2C_SR2_SMBHOST I2C_SR2_SMBHOST_Msk /*!< SMBus Host Header (Slave mode) */
#define I2C_SR2_DUALF_Pos (7U)
#define I2C_SR2_DUALF_Msk (0x1U << I2C_SR2_DUALF_Pos) /*!< 0x00000080 */
#define I2C_SR2_DUALF I2C_SR2_DUALF_Msk /*!< Dual Flag (Slave mode) */
#define I2C_SR2_PEC_Pos (8U)
#define I2C_SR2_PEC_Msk (0xFFU << I2C_SR2_PEC_Pos) /*!< 0x0000FF00 */
#define I2C_SR2_PEC I2C_SR2_PEC_Msk /*!< Packet Error Checking Register */

/*******************  Bit definition for I2C_CCR register  ********************/
#define I2C_CCR_CCR_Pos (0U)
#define I2C_CCR_CCR_Msk (0xFFFU << I2C_CCR_CCR_Pos) /*!< 0x00000FFF */
#define I2C_CCR_CCR I2C_CCR_CCR_Msk /*!< Clock Control Register in Fast/Standard mode (Master mode) */
#define I2C_CCR_DUTY_Pos (14U)
#define I2C_CCR_DUTY_Msk (0x1U << I2C_CCR_DUTY_Pos) /*!< 0x00004000 */
#define I2C_CCR_DUTY I2C_CCR_DUTY_Msk /*!< Fast Mode Duty Cycle */
#define I2C_CCR_FS_Pos (15U)
#define I2C_CCR_FS_Msk (0x1U << I2C_CCR_FS_Pos) /*!< 0x00008000 */
#define I2C_CCR_FS I2C_CCR_FS_Msk /*!< I2C Master Mode Selection */

/******************  Bit definition for I2C_TRISE register  *******************/
#define I2C_TRISE_TRISE_Pos (0U)
#define I2C_TRISE_TRISE_Msk (0x3FU << I2C_TRISE_TRISE_Pos) /*!< 0x0000003F */
#define I2C_TRISE_TRISE I2C_TRISE_TRISE_Msk /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */

/******************************************************************************/
/*                                                                            */
/*         Universal Synchronous Asynchronous Receiver Transmitter            */
/*                                                                            */
/******************************************************************************/

/*******************  Bit definition for USART_SR register  *******************/
#define USART_SR_PE_Pos (0U)
#define USART_SR_PE_Msk (0x1U << USART_SR_PE_Pos) /*!< 0x00000001 */
#define USART_SR_PE USART_SR_PE_Msk /*!< Parity Error */
#define USART_SR_FE_Pos (1U)
#define USART_SR_FE_Msk (0x1U << USART_SR_FE_Pos) /*!< 0x00000002 */
#define USART_SR_FE USART_SR_FE_Msk /*!< Framing Error */
#define USART_SR_NE_Pos (2U)
#define USART_SR_NE_Msk (0x1U << USART_SR_NE_Pos) /*!< 0x00000004 */
#define USART_SR_NE USART_SR_NE_Msk /*!< Noise Error Flag */
#define USART_SR_ORE_Pos (3U)
#define USART_SR_ORE_Msk (0x1U << USART_SR_ORE_Pos) /*!< 0x00000008 */
#define USART_SR_ORE USART_SR_ORE_Msk /*!< OverRun Error */
#define USART_SR_IDLE_Pos (4U)
#define USART_SR_IDLE_Msk (0x1U << USART_SR_IDLE_Pos) /*!< 0x00000010 */
#define USART_SR_IDLE USART_SR_IDLE_Msk /*!< IDLE line detected */
#define USART_SR_RXNE_Pos (5U)
#define USART_SR_RXNE_Msk (0x1U << USART_SR_RXNE_Pos) /*!< 0x00000020 */
#define USART_SR_RXNE USART_SR_RXNE_Msk /*!< Read Data Register Not Empty */
#define USART_SR_TC_Pos (6U)
#define USART_SR_TC_Msk (0x1U << USART_SR_TC_Pos) /*!< 0x00000040 */
#define USART_SR_TC USART_SR_TC_Msk /*!< Transmission Complete */
#define USART_SR_TXE_Pos (7U)
#define USART_SR_TXE_Msk (0x1U << USART_SR_TXE_Pos) /*!< 0x00000080 */
#define USART_SR_TXE USART_SR_TXE_Msk /*!< Transmit Data Register Empty */
#define USART_SR_LBD_Pos (8U)
#define USART_SR_LBD_Msk (0x1U << USART_SR_LBD_Pos) /*!< 0x00000100 */
#define USART_SR_LBD USART_SR_LBD_Msk /*!< LIN Break Detection Flag */
#define USART_SR_CTS_Pos (9U)
#define USART_SR_CTS_Msk (0x1U << USART_SR_CTS_Pos) /*!< 0x00000200 */
#define USART_SR_CTS USART_SR_CTS_Msk /*!< CTS Flag */

/*******************  Bit definition for USART_DR register  *******************/
#define USART_DR_DR_Pos (0U)
#define USART_DR_DR_Msk (0x1FFU << USART_DR_DR_Pos) /*!< 0x000001FF */
#define USART_DR_DR USART_DR_DR_Msk /*!< Data value */

/******************  Bit definition for USART_BRR register  *******************/
#define USART_BRR_DIV_Fraction_Pos (0U)
#define USART_BRR_DIV_Fraction_Msk (0xFU << USART_BRR_DIV_Fraction_Pos) /*!< 0x0000000F */
#define USART_BRR_DIV_Fraction USART_BRR_DIV_Fraction_Msk /*!< Fraction of USARTDIV */
#define USART_BRR_DIV_Mantissa_Pos (4U)
#define USART_BRR_DIV_Mantissa_Msk (0xFFFU << USART_BRR_DIV_Mantissa_Pos) /*!< 0x0000FFF0 */
#define USART_BRR_DIV_Mantissa USART_BRR_DIV_Mantissa_Msk /*!< Mantissa of USARTDIV */

/******************  Bit definition for USART_CR1 register  *******************/
#define USART_CR1_SBK_Pos (0U)
#define USART_CR1_SBK_Msk (0x1U << USART_CR1_SBK_Pos) /*!< 0x00000001 */
#define USART_CR1_SBK USART_CR1_SBK_Msk /*!< Send Break */
#define USART_CR1_RWU_Pos (1U)
#define USART_CR1_RWU_Msk (0x1U << USART_CR1_RWU_Pos) /*!< 0x00000002 */
#define USART_CR1_RWU USART_CR1_RWU_Msk /*!< Receiver wakeup */
#define USART_CR1_RE_Pos (2U)
#define USART_CR1_RE_Msk (0x1U << USART_CR1_RE_Pos) /*!< 0x00000004 */
#define USART_CR1_RE USART_CR1_RE_Msk /*!< Receiver Enable */
#define USART_CR1_TE_Pos (3U)
#define USART_CR1_TE_Msk (0x1U << USART_CR1_TE_Pos) /*!< 0x00000008 */
#define USART_CR1_TE USART_CR1_TE_Msk /*!< Transmitter Enable */
#define USART_CR1_IDLEIE_Pos (4U)
#define USART_CR1_IDLEIE_Msk (0x1U << USART_CR1_IDLEIE_Pos) /*!< 0x00000010 */
#define USART_CR1_IDLEIE USART_CR1_IDLEIE_Msk /*!< IDLE Interrupt Enable */
#define USART_CR1_RXNEIE_Pos (5U)
#define USART_CR1_RXNEIE_Msk (0x1U << USART_CR1_RXNEIE_Pos) /*!< 0x00000020 */
#define USART_CR1_RXNEIE USART_CR1_RXNEIE_Msk /*!< RXNE Interrupt Enable */
#define USART_CR1_TCIE_Pos (6U)
#define USART_CR1_TCIE_Msk (0x1U << USART_CR1_TCIE_Pos) /*!< 0x00000040 */
#define USART_CR1_TCIE USART_CR1_TCIE_Msk /*!< Transmission Complete Interrupt Enable */
#define USART_CR1_TXEIE_Pos (7U)
#define USART_CR1_TXEIE_Msk (0x1U << USART_CR1_TXEIE_Pos) /*!< 0x00000080 */
#define USART_CR1_TXEIE USART_CR1_TXEIE_Msk /*!< PE Interrupt Enable */
#define USART_CR1_PEIE_Pos (8U)
#define USART_CR1_PEIE_Msk (0x1U << USART_CR1_PEIE_Pos) /*!< 0x00000100 */
#define USART_CR1_PEIE USART_CR1_PEIE_Msk /*!< PE Interrupt Enable */
#define USART_CR1_PS_Pos (9U)
#define USART_CR1_PS_Msk (0x1U << USART_CR1_PS_Pos) /*!< 0x00000200 */
#define USART_CR1_PS USART_CR1_PS_Msk /*!< Parity Selection */
#define USART_CR1_PCE_Pos (10U)
#define USART_CR1_PCE_Msk (0x1U << USART_CR1_PCE_Pos) /*!< 0x00000400 */
#define USART_CR1_PCE USART_CR1_PCE_Msk /*!< Parity Control Enable */
#define USART_CR1_WAKE_Pos (11U)
#define USART_CR1_WAKE_Msk (0x1U << USART_CR1_WAKE_Pos) /*!< 0x00000800 */
#define USART_CR1_WAKE USART_CR1_WAKE_Msk /*!< Wakeup method */
#define USART_CR1_M_Pos (12U)
#define USART_CR1_M_Msk (0x1U << USART_CR1_M_Pos) /*!< 0x00001000 */
#define USART_CR1_M USART_CR1_M_Msk /*!< Word length */
#define USART_CR1_UE_Pos (13U)
#define USART_CR1_UE_Msk (0x1U << USART_CR1_UE_Pos) /*!< 0x00002000 */
#define USART_CR1_UE USART_CR1_UE_Msk /*!< USART Enable */

/******************  Bit definition for USART_CR2 register  *******************/
#define USART_CR2_ADD_Pos (0U)
#define USART_CR2_ADD_Msk (0xFU << USART_CR2_ADD_Pos) /*!< 0x0000000F */
#define USART_CR2_ADD USART_CR2_ADD_Msk /*!< Address of the USART node */
#define USART_CR2_LBDL_Pos (5U)
#define USART_CR2_LBDL_Msk (0x1U << USART_CR2_LBDL_Pos) /*!< 0x00000020 */
#define USART_CR2_LBDL USART_CR2_LBDL_Msk /*!< LIN Break Detection Length */
#define USART_CR2_LBDIE_Pos (6U)
#define USART_CR2_LBDIE_Msk (0x1U << USART_CR2_LBDIE_Pos) /*!< 0x00000040 */
#define USART_CR2_LBDIE USART_CR2_LBDIE_Msk /*!< LIN Break Detection Interrupt Enable */
#define USART_CR2_LBCL_Pos (8U)
#define USART_CR2_LBCL_Msk (0x1U << USART_CR2_LBCL_Pos) /*!< 0x00000100 */
#define USART_CR2_LBCL USART_CR2_LBCL_Msk /*!< Last Bit Clock pulse */
#define USART_CR2_CPHA_Pos (9U)
#define USART_CR2_CPHA_Msk (0x1U << USART_CR2_CPHA_Pos) /*!< 0x00000200 */
#define USART_CR2_CPHA USART_CR2_CPHA_Msk /*!< Clock Phase */
#define USART_CR2_CPOL_Pos (10U)
#define USART_CR2_CPOL_Msk (0x1U << USART_CR2_CPOL_Pos) /*!< 0x00000400 */
#define USART_CR2_CPOL USART_CR2_CPOL_Msk /*!< Clock Polarity */
#define USART_CR2_CLKEN_Pos (11U)
#define USART_CR2_CLKEN_Msk (0x1U << USART_CR2_CLKEN_Pos) /*!< 0x00000800 */
#define USART_CR2_CLKEN USART_CR2_CLKEN_Msk /*!< Clock Enable */

#define USART_CR2_STOP_Pos (12U)
#define USART_CR2_STOP_Msk (0x3U << USART_CR2_STOP_Pos) /*!< 0x00003000 */
#define USART_CR2_STOP USART_CR2_STOP_Msk /*!< STOP[1:0] bits (STOP bits) */
#define USART_CR2_STOP_0 (0x1U << USART_CR2_STOP_Pos) /*!< 0x00001000 */
#define USART_CR2_STOP_1 (0x2U << USART_CR2_STOP_Pos) /*!< 0x00002000 */

#define USART_CR2_LINEN_Pos (14U)
#define USART_CR2_LINEN_Msk (0x1U << USART_CR2_LINEN_Pos) /*!< 0x00004000 */
#define USART_CR2_LINEN USART_CR2_LINEN_Msk /*!< LIN mode enable */

/******************  Bit definition for USART_CR3 register  *******************/
#define USART_CR3_EIE_Pos (0U)
#define USART_CR3_EIE_Msk (0x1U << USART_CR3_EIE_Pos) /*!< 0x00000001 */
#define USART_CR3_EIE USART_CR3_EIE_Msk /*!< Error Interrupt Enable */
#define USART_CR3_IREN_Pos (1U)
#define USART_CR3_IREN_Msk (0x1U << USART_CR3_IREN_Pos) /*!< 0x00000002 */
#define USART_CR3_IREN USART_CR3_IREN_Msk /*!< IrDA mode Enable */
#define USART_CR3_IRLP_Pos (2U)
#define USART_CR3_IRLP_Msk (0x1U << USART_CR3_IRLP_Pos) /*!< 0x00000004 */
#define USART_CR3_IRLP USART_CR3_IRLP_Msk /*!< IrDA Low-Power */
#define USART_CR3_HDSEL_Pos (3U)
#define USART_CR3_HDSEL_Msk (0x1U << USART_CR3_HDSEL_Pos) /*!< 0x00000008 */
#define USART_CR3_HDSEL USART_CR3_HDSEL_Msk /*!< Half-Duplex Selection */
#define USART_CR3_NACK_Pos (4U)
#define USART_CR3_NACK_Msk (0x1U << USART_CR3_NACK_Pos) /*!< 0x00000010 */
#define USART_CR3_NACK USART_CR3_NACK_Msk /*!< Smartcard NACK enable */
#define USART_CR3_SCEN_Pos (5U)
#define USART_CR3_SCEN_Msk (0x1U << USART_CR3_SCEN_Pos) /*!< 0x00000020 */
#define USART_CR3_SCEN USART_CR3_SCEN_Msk /*!< Smartcard mode enable */
#define USART_CR3_DMAR_Pos (6U)
#define USART_CR3_DMAR_Msk (0x1U << USART_CR3_DMAR_Pos) /*!< 0x00000040 */
#define USART_CR3_DMAR USART_CR3_DMAR_Msk /*!< DMA Enable Receiver */
#define USART_CR3_DMAT_Pos (7U)
#define USART_CR3_DMAT_Msk (0x1U << USART_CR3_DMAT_Pos) /*!< 0x00000080 */
#define USART_CR3_DMAT USART_CR3_DMAT_Msk /*!< DMA Enable Transmitter */
#define USART_CR3_RTSE_Pos (8U)
#define USART_CR3_RTSE_Msk (0x1U << USART_CR3_RTSE_Pos) /*!< 0x00000100 */
#define USART_CR3_RTSE USART_CR3_RTSE_Msk /*!< RTS Enable */
#define USART_CR3_CTSE_Pos (9U)
#define USART_CR3_CTSE_Msk (0x1U << USART_CR3_CTSE_Pos) /*!< 0x00000200 */
#define USART_CR3_CTSE USART_CR3_CTSE_Msk /*!< CTS Enable */
#define USART_CR3_CTSIE_Pos (10U)
#define USART_CR3_CTSIE_Msk (0x1U << USART_CR3_CTSIE_Pos) /*!< 0x00000400 */
#define USART_CR3_CTSIE USART_CR3_CTSIE_Msk /*!< CTS Interrupt Enable */

/******************  Bit definition for USART_GTPR register  ******************/
#define USART_GTPR_PSC_Pos (0U)
#define USART_GTPR_PSC_Msk (0xFFU << USART_GTPR_PSC_Pos) /*!< 0x000000FF */
#define USART_GTPR_PSC USART_GTPR_PSC_Msk /*!< PSC[7:0] bits (Prescaler value) */
#define USART_GTPR_PSC_0 (0x01U << USART_GTPR_PSC_Pos) /*!< 0x00000001 */
#define USART_GTPR_PSC_1 (0x02U << USART_GTPR_PSC_Pos) /*!< 0x00000002 */
#define USART_GTPR_PSC_2 (0x04U << USART_GTPR_PSC_Pos) /*!< 0x00000004 */
#define USART_GTPR_PSC_3 (0x08U << USART_GTPR_PSC_Pos) /*!< 0x00000008 */
#define USART_GTPR_PSC_4 (0x10U << USART_GTPR_PSC_Pos) /*!< 0x00000010 */
#define USART_GTPR_PSC_5 (0x20U << USART_GTPR_PSC_Pos) /*!< 0x00000020 */
#define USART_GTPR_PSC_6 (0x40U << USART_GTPR_PSC_Pos) /*!< 0x00000040 */
#define USART_GTPR_PSC_7 (0x80U << USART_GTPR_PSC_Pos) /*!< 0x00000080 */

#define USART_GTPR_GT_Pos (8U)
#define USART_GTPR_GT_Msk (0xFFU << USART_GTPR_GT_Pos) /*!< 0x0000FF00 */
#define USART_GTPR_GT USART_GTPR_GT_Msk /*!< Guard time value */

/******************************************************************************/
/*                                                                            */
/*                                 Debug MCU                                  */
/*                                                                            */
/******************************************************************************/

/****************  Bit definition for DBGMCU_IDCODE register  *****************/
#define DBGMCU_IDCODE_DEV_ID_Pos (0U)
#define DBGMCU_IDCODE_DEV_ID_Msk (0xFFFU << DBGMCU_IDCODE_DEV_ID_Pos) /*!< 0x00000FFF */
#define DBGMCU_IDCODE_DEV_ID DBGMCU_IDCODE_DEV_ID_Msk /*!< Device Identifier */

#define DBGMCU_IDCODE_REV_ID_Pos (16U)
#define DBGMCU_IDCODE_REV_ID_Msk (0xFFFFU << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0xFFFF0000 */
#define DBGMCU_IDCODE_REV_ID DBGMCU_IDCODE_REV_ID_Msk /*!< REV_ID[15:0] bits (Revision Identifier) */
#define DBGMCU_IDCODE_REV_ID_0 (0x0001U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00010000 */
#define DBGMCU_IDCODE_REV_ID_1 (0x0002U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00020000 */
#define DBGMCU_IDCODE_REV_ID_2 (0x0004U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00040000 */
#define DBGMCU_IDCODE_REV_ID_3 (0x0008U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00080000 */
#define DBGMCU_IDCODE_REV_ID_4 (0x0010U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00100000 */
#define DBGMCU_IDCODE_REV_ID_5 (0x0020U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00200000 */
#define DBGMCU_IDCODE_REV_ID_6 (0x0040U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00400000 */
#define DBGMCU_IDCODE_REV_ID_7 (0x0080U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x00800000 */
#define DBGMCU_IDCODE_REV_ID_8 (0x0100U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x01000000 */
#define DBGMCU_IDCODE_REV_ID_9 (0x0200U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x02000000 */
#define DBGMCU_IDCODE_REV_ID_10 (0x0400U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x04000000 */
#define DBGMCU_IDCODE_REV_ID_11 (0x0800U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x08000000 */
#define DBGMCU_IDCODE_REV_ID_12 (0x1000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x10000000 */
#define DBGMCU_IDCODE_REV_ID_13 (0x2000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x20000000 */
#define DBGMCU_IDCODE_REV_ID_14 (0x4000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x40000000 */
#define DBGMCU_IDCODE_REV_ID_15 (0x8000U << DBGMCU_IDCODE_REV_ID_Pos) /*!< 0x80000000 */

/******************  Bit definition for DBGMCU_CR register  *******************/
#define DBGMCU_CR_DBG_SLEEP_Pos (0U)
#define DBGMCU_CR_DBG_SLEEP_Msk (0x1U << DBGMCU_CR_DBG_SLEEP_Pos) /*!< 0x00000001 */
#define DBGMCU_CR_DBG_SLEEP DBGMCU_CR_DBG_SLEEP_Msk /*!< Debug Sleep Mode */
#define DBGMCU_CR_DBG_STOP_Pos (1U)
#define DBGMCU_CR_DBG_STOP_Msk (0x1U << DBGMCU_CR_DBG_STOP_Pos) /*!< 0x00000002 */
#define DBGMCU_CR_DBG_STOP DBGMCU_CR_DBG_STOP_Msk /*!< Debug Stop Mode */
#define DBGMCU_CR_DBG_STANDBY_Pos (2U)
#define DBGMCU_CR_DBG_STANDBY_Msk (0x1U << DBGMCU_CR_DBG_STANDBY_Pos) /*!< 0x00000004 */
#define DBGMCU_CR_DBG_STANDBY DBGMCU_CR_DBG_STANDBY_Msk /*!< Debug Standby mode */
#define DBGMCU_CR_TRACE_IOEN_Pos (5U)
#define DBGMCU_CR_TRACE_IOEN_Msk (0x1U << DBGMCU_CR_TRACE_IOEN_Pos) /*!< 0x00000020 */
#define DBGMCU_CR_TRACE_IOEN DBGMCU_CR_TRACE_IOEN_Msk /*!< Trace Pin Assignment Control */

#define DBGMCU_CR_TRACE_MODE_Pos (6U)
#define DBGMCU_CR_TRACE_MODE_Msk (0x3U << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x000000C0 */
#define DBGMCU_CR_TRACE_MODE DBGMCU_CR_TRACE_MODE_Msk /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */
#define DBGMCU_CR_TRACE_MODE_0 (0x1U << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000040 */
#define DBGMCU_CR_TRACE_MODE_1 (0x2U << DBGMCU_CR_TRACE_MODE_Pos) /*!< 0x00000080 */

#define DBGMCU_CR_DBG_IWDG_STOP_Pos (8U)
#define DBGMCU_CR_DBG_IWDG_STOP_Msk (0x1U << DBGMCU_CR_DBG_IWDG_STOP_Pos) /*!< 0x00000100 */
#define DBGMCU_CR_DBG_IWDG_STOP DBGMCU_CR_DBG_IWDG_STOP_Msk /*!< Debug Independent Watchdog stopped when Core is halted */
#define DBGMCU_CR_DBG_WWDG_STOP_Pos (9U)
#define DBGMCU_CR_DBG_WWDG_STOP_Msk (0x1U << DBGMCU_CR_DBG_WWDG_STOP_Pos) /*!< 0x00000200 */
#define DBGMCU_CR_DBG_WWDG_STOP DBGMCU_CR_DBG_WWDG_STOP_Msk /*!< Debug Window Watchdog stopped when Core is halted */
#define DBGMCU_CR_DBG_TIM1_STOP_Pos (10U)
#define DBGMCU_CR_DBG_TIM1_STOP_Msk (0x1U << DBGMCU_CR_DBG_TIM1_STOP_Pos) /*!< 0x00000400 */
#define DBGMCU_CR_DBG_TIM1_STOP DBGMCU_CR_DBG_TIM1_STOP_Msk /*!< TIM1 counter stopped when core is halted */
#define DBGMCU_CR_DBG_TIM2_STOP_Pos (11U)
#define DBGMCU_CR_DBG_TIM2_STOP_Msk (0x1U << DBGMCU_CR_DBG_TIM2_STOP_Pos) /*!< 0x00000800 */
#define DBGMCU_CR_DBG_TIM2_STOP DBGMCU_CR_DBG_TIM2_STOP_Msk /*!< TIM2 counter stopped when core is halted */
#define DBGMCU_CR_DBG_TIM3_STOP_Pos (12U)
#define DBGMCU_CR_DBG_TIM3_STOP_Msk (0x1U << DBGMCU_CR_DBG_TIM3_STOP_Pos) /*!< 0x00001000 */
#define DBGMCU_CR_DBG_TIM3_STOP DBGMCU_CR_DBG_TIM3_STOP_Msk /*!< TIM3 counter stopped when core is halted */
#define DBGMCU_CR_DBG_TIM4_STOP_Pos (13U)
#define DBGMCU_CR_DBG_TIM4_STOP_Msk (0x1U << DBGMCU_CR_DBG_TIM4_STOP_Pos) /*!< 0x00002000 */
#define DBGMCU_CR_DBG_TIM4_STOP DBGMCU_CR_DBG_TIM4_STOP_Msk /*!< TIM4 counter stopped when core is halted */
#define DBGMCU_CR_DBG_CAN1_STOP_Pos (14U)
#define DBGMCU_CR_DBG_CAN1_STOP_Msk (0x1U << DBGMCU_CR_DBG_CAN1_STOP_Pos) /*!< 0x00004000 */
#define DBGMCU_CR_DBG_CAN1_STOP DBGMCU_CR_DBG_CAN1_STOP_Msk /*!< Debug CAN1 stopped when Core is halted */
#define DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT_Pos (15U)
#define DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT_Msk (0x1U << DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT_Pos) /*!< 0x00008000 */
#define DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT_Msk /*!< SMBUS timeout mode stopped when Core is halted */
#define DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT_Pos (16U)
#define DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT_Msk (0x1U << DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT_Pos) /*!< 0x00010000 */
#define DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT_Msk /*!< SMBUS timeout mode stopped when Core is halted */

/******************************************************************************/
/*                                                                            */
/*                      FLASH and Option Bytes Registers                      */
/*                                                                            */
/******************************************************************************/
/*******************  Bit definition for FLASH_ACR register  ******************/
#define FLASH_ACR_LATENCY_Pos (0U)
#define FLASH_ACR_LATENCY_Msk (0x7U << FLASH_ACR_LATENCY_Pos) /*!< 0x00000007 */
#define FLASH_ACR_LATENCY FLASH_ACR_LATENCY_Msk /*!< LATENCY[2:0] bits (Latency) */
#define FLASH_ACR_LATENCY_0 (0x1U << FLASH_ACR_LATENCY_Pos) /*!< 0x00000001 */
#define FLASH_ACR_LATENCY_1 (0x2U << FLASH_ACR_LATENCY_Pos) /*!< 0x00000002 */
#define FLASH_ACR_LATENCY_2 (0x4U << FLASH_ACR_LATENCY_Pos) /*!< 0x00000004 */

#define FLASH_ACR_HLFCYA_Pos (3U)
#define FLASH_ACR_HLFCYA_Msk (0x1U << FLASH_ACR_HLFCYA_Pos) /*!< 0x00000008 */
#define FLASH_ACR_HLFCYA FLASH_ACR_HLFCYA_Msk /*!< Flash Half Cycle Access Enable */
#define FLASH_ACR_PRFTBE_Pos (4U)
#define FLASH_ACR_PRFTBE_Msk (0x1U << FLASH_ACR_PRFTBE_Pos) /*!< 0x00000010 */
#define FLASH_ACR_PRFTBE FLASH_ACR_PRFTBE_Msk /*!< Prefetch Buffer Enable */
#define FLASH_ACR_PRFTBS_Pos (5U)
#define FLASH_ACR_PRFTBS_Msk (0x1U << FLASH_ACR_PRFTBS_Pos) /*!< 0x00000020 */
#define FLASH_ACR_PRFTBS FLASH_ACR_PRFTBS_Msk /*!< Prefetch Buffer Status */

/******************  Bit definition for FLASH_KEYR register  ******************/
#define FLASH_KEYR_FKEYR_Pos (0U)
#define FLASH_KEYR_FKEYR_Msk (0xFFFFFFFFU << FLASH_KEYR_FKEYR_Pos) /*!< 0xFFFFFFFF */
#define FLASH_KEYR_FKEYR FLASH_KEYR_FKEYR_Msk /*!< FPEC Key */

#define RDP_KEY_Pos (0U)
#define RDP_KEY_Msk (0xA5U << RDP_KEY_Pos) /*!< 0x000000A5 */
#define RDP_KEY RDP_KEY_Msk /*!< RDP Key */
#define FLASH_KEY1_Pos (0U)
#define FLASH_KEY1_Msk (0x45670123U << FLASH_KEY1_Pos) /*!< 0x45670123 */
#define FLASH_KEY1 FLASH_KEY1_Msk /*!< FPEC Key1 */
#define FLASH_KEY2_Pos (0U)
#define FLASH_KEY2_Msk (0xCDEF89ABU << FLASH_KEY2_Pos) /*!< 0xCDEF89AB */
#define FLASH_KEY2 FLASH_KEY2_Msk /*!< FPEC Key2 */

/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
#define FLASH_OPTKEYR_OPTKEYR_Pos (0U)
#define FLASH_OPTKEYR_OPTKEYR_Msk (0xFFFFFFFFU << FLASH_OPTKEYR_OPTKEYR_Pos) /*!< 0xFFFFFFFF */
#define FLASH_OPTKEYR_OPTKEYR FLASH_OPTKEYR_OPTKEYR_Msk /*!< Option Byte Key */

#define FLASH_OPTKEY1 FLASH_KEY1 /*!< Option Byte Key1 */
#define FLASH_OPTKEY2 FLASH_KEY2 /*!< Option Byte Key2 */

/******************  Bit definition for FLASH_SR register  ********************/
#define FLASH_SR_BSY_Pos (0U)
#define FLASH_SR_BSY_Msk (0x1U << FLASH_SR_BSY_Pos) /*!< 0x00000001 */
#define FLASH_SR_BSY FLASH_SR_BSY_Msk /*!< Busy */
#define FLASH_SR_PGERR_Pos (2U)
#define FLASH_SR_PGERR_Msk (0x1U << FLASH_SR_PGERR_Pos) /*!< 0x00000004 */
#define FLASH_SR_PGERR FLASH_SR_PGERR_Msk /*!< Programming Error */
#define FLASH_SR_WRPRTERR_Pos (4U)
#define FLASH_SR_WRPRTERR_Msk (0x1U << FLASH_SR_WRPRTERR_Pos) /*!< 0x00000010 */
#define FLASH_SR_WRPRTERR FLASH_SR_WRPRTERR_Msk /*!< Write Protection Error */
#define FLASH_SR_EOP_Pos (5U)
#define FLASH_SR_EOP_Msk (0x1U << FLASH_SR_EOP_Pos) /*!< 0x00000020 */
#define FLASH_SR_EOP FLASH_SR_EOP_Msk /*!< End of operation */

/*******************  Bit definition for FLASH_CR register  *******************/
#define FLASH_CR_PG_Pos (0U)
#define FLASH_CR_PG_Msk (0x1U << FLASH_CR_PG_Pos) /*!< 0x00000001 */
#define FLASH_CR_PG FLASH_CR_PG_Msk /*!< Programming */
#define FLASH_CR_PER_Pos (1U)
#define FLASH_CR_PER_Msk (0x1U << FLASH_CR_PER_Pos) /*!< 0x00000002 */
#define FLASH_CR_PER FLASH_CR_PER_Msk /*!< Page Erase */
#define FLASH_CR_MER_Pos (2U)
#define FLASH_CR_MER_Msk (0x1U << FLASH_CR_MER_Pos) /*!< 0x00000004 */
#define FLASH_CR_MER FLASH_CR_MER_Msk /*!< Mass Erase */
#define FLASH_CR_OPTPG_Pos (4U)
#define FLASH_CR_OPTPG_Msk (0x1U << FLASH_CR_OPTPG_Pos) /*!< 0x00000010 */
#define FLASH_CR_OPTPG FLASH_CR_OPTPG_Msk /*!< Option Byte Programming */
#define FLASH_CR_OPTER_Pos (5U)
#define FLASH_CR_OPTER_Msk (0x1U << FLASH_CR_OPTER_Pos) /*!< 0x00000020 */
#define FLASH_CR_OPTER FLASH_CR_OPTER_Msk /*!< Option Byte Erase */
#define FLASH_CR_STRT_Pos (6U)
#define FLASH_CR_STRT_Msk (0x1U << FLASH_CR_STRT_Pos) /*!< 0x00000040 */
#define FLASH_CR_STRT FLASH_CR_STRT_Msk /*!< Start */
#define FLASH_CR_LOCK_Pos (7U)
#define FLASH_CR_LOCK_Msk (0x1U << FLASH_CR_LOCK_Pos) /*!< 0x00000080 */
#define FLASH_CR_LOCK FLASH_CR_LOCK_Msk /*!< Lock */
#define FLASH_CR_OPTWRE_Pos (9U)
#define FLASH_CR_OPTWRE_Msk (0x1U << FLASH_CR_OPTWRE_Pos) /*!< 0x00000200 */
#define FLASH_CR_OPTWRE FLASH_CR_OPTWRE_Msk /*!< Option Bytes Write Enable */
#define FLASH_CR_ERRIE_Pos (10U)
#define FLASH_CR_ERRIE_Msk (0x1U << FLASH_CR_ERRIE_Pos) /*!< 0x00000400 */
#define FLASH_CR_ERRIE FLASH_CR_ERRIE_Msk /*!< Error Interrupt Enable */
#define FLASH_CR_EOPIE_Pos (12U)
#define FLASH_CR_EOPIE_Msk (0x1U << FLASH_CR_EOPIE_Pos) /*!< 0x00001000 */
#define FLASH_CR_EOPIE FLASH_CR_EOPIE_Msk /*!< End of operation interrupt enable */

/*******************  Bit definition for FLASH_AR register  *******************/
#define FLASH_AR_FAR_Pos (0U)
#define FLASH_AR_FAR_Msk (0xFFFFFFFFU << FLASH_AR_FAR_Pos) /*!< 0xFFFFFFFF */
#define FLASH_AR_FAR FLASH_AR_FAR_Msk /*!< Flash Address */

/******************  Bit definition for FLASH_OBR register  *******************/
#define FLASH_OBR_OPTERR_Pos (0U)
#define FLASH_OBR_OPTERR_Msk (0x1U << FLASH_OBR_OPTERR_Pos) /*!< 0x00000001 */
#define FLASH_OBR_OPTERR FLASH_OBR_OPTERR_Msk /*!< Option Byte Error */
#define FLASH_OBR_RDPRT_Pos (1U)
#define FLASH_OBR_RDPRT_Msk (0x1U << FLASH_OBR_RDPRT_Pos) /*!< 0x00000002 */
#define FLASH_OBR_RDPRT FLASH_OBR_RDPRT_Msk /*!< Read protection */

#define FLASH_OBR_IWDG_SW_Pos (2U)
#define FLASH_OBR_IWDG_SW_Msk (0x1U << FLASH_OBR_IWDG_SW_Pos) /*!< 0x00000004 */
#define FLASH_OBR_IWDG_SW FLASH_OBR_IWDG_SW_Msk /*!< IWDG SW */
#define FLASH_OBR_nRST_STOP_Pos (3U)
#define FLASH_OBR_nRST_STOP_Msk (0x1U << FLASH_OBR_nRST_STOP_Pos) /*!< 0x00000008 */
#define FLASH_OBR_nRST_STOP FLASH_OBR_nRST_STOP_Msk /*!< nRST_STOP */
#define FLASH_OBR_nRST_STDBY_Pos (4U)
#define FLASH_OBR_nRST_STDBY_Msk (0x1U << FLASH_OBR_nRST_STDBY_Pos) /*!< 0x00000010 */
#define FLASH_OBR_nRST_STDBY FLASH_OBR_nRST_STDBY_Msk /*!< nRST_STDBY */
#define FLASH_OBR_USER_Pos (2U)
#define FLASH_OBR_USER_Msk (0x7U << FLASH_OBR_USER_Pos) /*!< 0x0000001C */
#define FLASH_OBR_USER FLASH_OBR_USER_Msk /*!< User Option Bytes */
#define FLASH_OBR_DATA0_Pos (10U)
#define FLASH_OBR_DATA0_Msk (0xFFU << FLASH_OBR_DATA0_Pos) /*!< 0x0003FC00 */
#define FLASH_OBR_DATA0 FLASH_OBR_DATA0_Msk /*!< Data0 */
#define FLASH_OBR_DATA1_Pos (18U)
#define FLASH_OBR_DATA1_Msk (0xFFU << FLASH_OBR_DATA1_Pos) /*!< 0x03FC0000 */
#define FLASH_OBR_DATA1 FLASH_OBR_DATA1_Msk /*!< Data1 */

/******************  Bit definition for FLASH_WRPR register  ******************/
#define FLASH_WRPR_WRP_Pos (0U)
#define FLASH_WRPR_WRP_Msk (0xFFFFFFFFU << FLASH_WRPR_WRP_Pos) /*!< 0xFFFFFFFF */
#define FLASH_WRPR_WRP FLASH_WRPR_WRP_Msk /*!< Write Protect */

/*----------------------------------------------------------------------------*/

/******************  Bit definition for FLASH_RDP register  *******************/
#define FLASH_RDP_RDP_Pos (0U)
#define FLASH_RDP_RDP_Msk (0xFFU << FLASH_RDP_RDP_Pos) /*!< 0x000000FF */
#define FLASH_RDP_RDP FLASH_RDP_RDP_Msk /*!< Read protection option byte */
#define FLASH_RDP_nRDP_Pos (8U)
#define FLASH_RDP_nRDP_Msk (0xFFU << FLASH_RDP_nRDP_Pos) /*!< 0x0000FF00 */
#define FLASH_RDP_nRDP FLASH_RDP_nRDP_Msk /*!< Read protection complemented option byte */

/******************  Bit definition for FLASH_USER register  ******************/
#define FLASH_USER_USER_Pos (16U)
#define FLASH_USER_USER_Msk (0xFFU << FLASH_USER_USER_Pos) /*!< 0x00FF0000 */
#define FLASH_USER_USER FLASH_USER_USER_Msk /*!< User option byte */
#define FLASH_USER_nUSER_Pos (24U)
#define FLASH_USER_nUSER_Msk (0xFFU << FLASH_USER_nUSER_Pos) /*!< 0xFF000000 */
#define FLASH_USER_nUSER FLASH_USER_nUSER_Msk /*!< User complemented option byte */

/******************  Bit definition for FLASH_Data0 register  *****************/
#define FLASH_DATA0_DATA0_Pos (0U)
#define FLASH_DATA0_DATA0_Msk (0xFFU << FLASH_DATA0_DATA0_Pos) /*!< 0x000000FF */
#define FLASH_DATA0_DATA0 FLASH_DATA0_DATA0_Msk /*!< User data storage option byte */
#define FLASH_DATA0_nDATA0_Pos (8U)
#define FLASH_DATA0_nDATA0_Msk (0xFFU << FLASH_DATA0_nDATA0_Pos) /*!< 0x0000FF00 */
#define FLASH_DATA0_nDATA0 FLASH_DATA0_nDATA0_Msk /*!< User data storage complemented option byte */

/******************  Bit definition for FLASH_Data1 register  *****************/
#define FLASH_DATA1_DATA1_Pos (16U)
#define FLASH_DATA1_DATA1_Msk (0xFFU << FLASH_DATA1_DATA1_Pos) /*!< 0x00FF0000 */
#define FLASH_DATA1_DATA1 FLASH_DATA1_DATA1_Msk /*!< User data storage option byte */
#define FLASH_DATA1_nDATA1_Pos (24U)
#define FLASH_DATA1_nDATA1_Msk (0xFFU << FLASH_DATA1_nDATA1_Pos) /*!< 0xFF000000 */
#define FLASH_DATA1_nDATA1 FLASH_DATA1_nDATA1_Msk /*!< User data storage complemented option byte */

/******************  Bit definition for FLASH_WRP0 register  ******************/
#define FLASH_WRP0_WRP0_Pos (0U)
#define FLASH_WRP0_WRP0_Msk (0xFFU << FLASH_WRP0_WRP0_Pos) /*!< 0x000000FF */
#define FLASH_WRP0_WRP0 FLASH_WRP0_WRP0_Msk /*!< Flash memory write protection option bytes */
#define FLASH_WRP0_nWRP0_Pos (8U)
#define FLASH_WRP0_nWRP0_Msk (0xFFU << FLASH_WRP0_nWRP0_Pos) /*!< 0x0000FF00 */
#define FLASH_WRP0_nWRP0 FLASH_WRP0_nWRP0_Msk /*!< Flash memory write protection complemented option bytes */

/******************  Bit definition for FLASH_WRP1 register  ******************/
#define FLASH_WRP1_WRP1_Pos (16U)
#define FLASH_WRP1_WRP1_Msk (0xFFU << FLASH_WRP1_WRP1_Pos) /*!< 0x00FF0000 */
#define FLASH_WRP1_WRP1 FLASH_WRP1_WRP1_Msk /*!< Flash memory write protection option bytes */
#define FLASH_WRP1_nWRP1_Pos (24U)
#define FLASH_WRP1_nWRP1_Msk (0xFFU << FLASH_WRP1_nWRP1_Pos) /*!< 0xFF000000 */
#define FLASH_WRP1_nWRP1 FLASH_WRP1_nWRP1_Msk /*!< Flash memory write protection complemented option bytes */

/******************  Bit definition for FLASH_WRP2 register  ******************/
#define FLASH_WRP2_WRP2_Pos (0U)
#define FLASH_WRP2_WRP2_Msk (0xFFU << FLASH_WRP2_WRP2_Pos) /*!< 0x000000FF */
#define FLASH_WRP2_WRP2 FLASH_WRP2_WRP2_Msk /*!< Flash memory write protection option bytes */
#define FLASH_WRP2_nWRP2_Pos (8U)
#define FLASH_WRP2_nWRP2_Msk (0xFFU << FLASH_WRP2_nWRP2_Pos) /*!< 0x0000FF00 */
#define FLASH_WRP2_nWRP2 FLASH_WRP2_nWRP2_Msk /*!< Flash memory write protection complemented option bytes */

/******************  Bit definition for FLASH_WRP3 register  ******************/
#define FLASH_WRP3_WRP3_Pos (16U)
#define FLASH_WRP3_WRP3_Msk (0xFFU << FLASH_WRP3_WRP3_Pos) /*!< 0x00FF0000 */
#define FLASH_WRP3_WRP3 FLASH_WRP3_WRP3_Msk /*!< Flash memory write protection option bytes */
#define FLASH_WRP3_nWRP3_Pos (24U)
#define FLASH_WRP3_nWRP3_Msk (0xFFU << FLASH_WRP3_nWRP3_Pos) /*!< 0xFF000000 */
#define FLASH_WRP3_nWRP3 FLASH_WRP3_nWRP3_Msk /*!< Flash memory write protection complemented option bytes */



/**

  * @}

*/
# 10280 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/**

  * @}

*/
# 10284 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/** @addtogroup Exported_macro

  * @{

  */
# 10288 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/****************************** ADC Instances *********************************/
#define IS_ADC_ALL_INSTANCE(INSTANCE) (((INSTANCE) == ADC1) || ((INSTANCE) == ADC2))


#define IS_ADC_COMMON_INSTANCE(INSTANCE) ((INSTANCE) == ADC12_COMMON)

#define IS_ADC_MULTIMODE_MASTER_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)

#define IS_ADC_DMA_CAPABILITY_INSTANCE(INSTANCE) ((INSTANCE) == ADC1)

/****************************** CAN Instances *********************************/
#define IS_CAN_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CAN1)

/****************************** CRC Instances *********************************/
#define IS_CRC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == CRC)

/****************************** DAC Instances *********************************/

/****************************** DMA Instances *********************************/
#define IS_DMA_ALL_INSTANCE(INSTANCE) (((INSTANCE) == DMA1_Channel1) || ((INSTANCE) == DMA1_Channel2) || ((INSTANCE) == DMA1_Channel3) || ((INSTANCE) == DMA1_Channel4) || ((INSTANCE) == DMA1_Channel5) || ((INSTANCE) == DMA1_Channel6) || ((INSTANCE) == DMA1_Channel7))







/******************************* GPIO Instances *******************************/
#define IS_GPIO_ALL_INSTANCE(INSTANCE) (((INSTANCE) == GPIOA) || ((INSTANCE) == GPIOB) || ((INSTANCE) == GPIOC) || ((INSTANCE) == GPIOD) || ((INSTANCE) == GPIOE))





/**************************** GPIO Alternate Function Instances ***************/
#define IS_GPIO_AF_INSTANCE(INSTANCE) IS_GPIO_ALL_INSTANCE(INSTANCE)

/**************************** GPIO Lock Instances *****************************/
#define IS_GPIO_LOCK_INSTANCE(INSTANCE) IS_GPIO_ALL_INSTANCE(INSTANCE)

/******************************** I2C Instances *******************************/
#define IS_I2C_ALL_INSTANCE(INSTANCE) (((INSTANCE) == I2C1) || ((INSTANCE) == I2C2))


/******************************* SMBUS Instances ******************************/
#define IS_SMBUS_ALL_INSTANCE IS_I2C_ALL_INSTANCE

/****************************** IWDG Instances ********************************/
#define IS_IWDG_ALL_INSTANCE(INSTANCE) ((INSTANCE) == IWDG)

/******************************** SPI Instances *******************************/
#define IS_SPI_ALL_INSTANCE(INSTANCE) (((INSTANCE) == SPI1) || ((INSTANCE) == SPI2))


/****************************** START TIM Instances ***************************/
/****************************** TIM Instances *********************************/
#define IS_TIM_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_ADVANCED_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)

#define IS_TIM_CC1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CC2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CC3_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CC4_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CLOCKSOURCE_TIX_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_OCXREF_CLEAR_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_ENCODER_INTERFACE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_XOR_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_MASTER_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_SLAVE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_DMABURST_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_BREAK_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)


#define IS_TIM_CCX_INSTANCE(INSTANCE,CHANNEL) ((((INSTANCE) == TIM1) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM2) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM3) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))) || (((INSTANCE) == TIM4) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3) || ((CHANNEL) == TIM_CHANNEL_4))))
# 10464 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
#define IS_TIM_CCXN_INSTANCE(INSTANCE,CHANNEL) (((INSTANCE) == TIM1) && (((CHANNEL) == TIM_CHANNEL_1) || ((CHANNEL) == TIM_CHANNEL_2) || ((CHANNEL) == TIM_CHANNEL_3)))





#define IS_TIM_COUNTER_MODE_SELECT_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_REPETITION_COUNTER_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)


#define IS_TIM_CLOCK_DIVISION_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_DMA_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_DMA_CC_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))





#define IS_TIM_COMMUTATION_EVENT_INSTANCE(INSTANCE) ((INSTANCE) == TIM1)


#define IS_TIM_ETR_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))




#define IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(INSTANCE) (((INSTANCE) == TIM1) || ((INSTANCE) == TIM2) || ((INSTANCE) == TIM3) || ((INSTANCE) == TIM4))




#define IS_TIM_32B_COUNTER_INSTANCE(INSTANCE) 0U

/****************************** END TIM Instances *****************************/


/******************** USART Instances : Synchronous mode **********************/
#define IS_USART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/******************** UART Instances : Asynchronous mode **********************/
#define IS_UART_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/******************** UART Instances : Half-Duplex mode **********************/
#define IS_UART_HALFDUPLEX_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/******************** UART Instances : LIN mode **********************/
#define IS_UART_LIN_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/****************** UART Instances : Hardware Flow control ********************/
#define IS_UART_HWFLOW_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/********************* UART Instances : Smard card mode ***********************/
#define IS_SMARTCARD_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/*********************** UART Instances : IRDA mode ***************************/
#define IS_IRDA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/***************** UART Instances : Multi-Processor mode **********************/
#define IS_UART_MULTIPROCESSOR_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/***************** UART Instances : DMA mode available **********************/
#define IS_UART_DMA_INSTANCE(INSTANCE) (((INSTANCE) == USART1) || ((INSTANCE) == USART2) || ((INSTANCE) == USART3))



/****************************** RTC Instances *********************************/
#define IS_RTC_ALL_INSTANCE(INSTANCE) ((INSTANCE) == RTC)

/**************************** WWDG Instances *****************************/
#define IS_WWDG_ALL_INSTANCE(INSTANCE) ((INSTANCE) == WWDG)

/****************************** USB Instances ********************************/
#define IS_USB_ALL_INSTANCE(INSTANCE) ((INSTANCE) == USB)



#define RCC_HSE_MIN 4000000U
#define RCC_HSE_MAX 16000000U

#define RCC_MAX_FREQUENCY 72000000U

/**

  * @}

  */
# 10579 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/******************************************************************************/
/*  For a painless codes migration between the STM32F1xx device product       */
/*  lines, the aliases defined below are put in place to overcome the         */
/*  differences in the interrupt handlers and IRQn definitions.               */
/*  No need to update developed interrupt code when moving across             */
/*  product lines within the same STM32F1 Family                              */
/******************************************************************************/

/* Aliases for __IRQn */
#define ADC1_IRQn ADC1_2_IRQn
#define TIM9_IRQn TIM1_BRK_IRQn
#define TIM1_BRK_TIM9_IRQn TIM1_BRK_IRQn
#define TIM1_BRK_TIM15_IRQn TIM1_BRK_IRQn
#define TIM1_TRG_COM_TIM17_IRQn TIM1_TRG_COM_IRQn
#define TIM1_TRG_COM_TIM11_IRQn TIM1_TRG_COM_IRQn
#define TIM11_IRQn TIM1_TRG_COM_IRQn
#define TIM1_UP_TIM10_IRQn TIM1_UP_IRQn
#define TIM1_UP_TIM16_IRQn TIM1_UP_IRQn
#define TIM10_IRQn TIM1_UP_IRQn
#define OTG_FS_WKUP_IRQn USBWakeUp_IRQn
#define CEC_IRQn USBWakeUp_IRQn
#define USB_HP_IRQn USB_HP_CAN1_TX_IRQn
#define CAN1_TX_IRQn USB_HP_CAN1_TX_IRQn
#define CAN1_RX0_IRQn USB_LP_CAN1_RX0_IRQn
#define USB_LP_IRQn USB_LP_CAN1_RX0_IRQn


/* Aliases for __IRQHandler */
#define ADC1_IRQHandler ADC1_2_IRQHandler
#define TIM9_IRQHandler TIM1_BRK_IRQHandler
#define TIM1_BRK_TIM9_IRQHandler TIM1_BRK_IRQHandler
#define TIM1_BRK_TIM15_IRQHandler TIM1_BRK_IRQHandler
#define TIM1_TRG_COM_TIM17_IRQHandler TIM1_TRG_COM_IRQHandler
#define TIM1_TRG_COM_TIM11_IRQHandler TIM1_TRG_COM_IRQHandler
#define TIM11_IRQHandler TIM1_TRG_COM_IRQHandler
#define TIM1_UP_TIM10_IRQHandler TIM1_UP_IRQHandler
#define TIM1_UP_TIM16_IRQHandler TIM1_UP_IRQHandler
#define TIM10_IRQHandler TIM1_UP_IRQHandler
#define OTG_FS_WKUP_IRQHandler USBWakeUp_IRQHandler
#define CEC_IRQHandler USBWakeUp_IRQHandler
#define USB_HP_IRQHandler USB_HP_CAN1_TX_IRQHandler
#define CAN1_TX_IRQHandler USB_HP_CAN1_TX_IRQHandler
#define CAN1_RX0_IRQHandler USB_LP_CAN1_RX0_IRQHandler
#define USB_LP_IRQHandler USB_LP_CAN1_RX0_IRQHandler


/**

  * @}

  */
# 10629 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
/**

  * @}

  */
# 10642 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
  /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
# 150 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h" 2
# 162 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/**

  * @}

  */
# 166 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/** @addtogroup Exported_types

  * @{

  */
# 169 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
typedef enum
{
  RESET = 0,
  SET = !RESET
} FlagStatus, ITStatus;

typedef enum
{
  DISABLE = 0,
  ENABLE = !DISABLE
} FunctionalState;
#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))

typedef enum
{
  ERROR = 0,
  SUCCESS = !ERROR
} ErrorStatus;

/**

  * @}

  */
/** @addtogroup Exported_macros

  * @{

  */
# 196 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
#define SET_BIT(REG,BIT) ((REG) |= (BIT))

#define CLEAR_BIT(REG,BIT) ((REG) &= ~(BIT))

#define READ_BIT(REG,BIT) ((REG) & (BIT))

#define CLEAR_REG(REG) ((REG) = (0x0))

#define WRITE_REG(REG,VAL) ((REG) = (VAL))

#define READ_REG(REG) ((REG))

#define MODIFY_REG(REG,CLEARMASK,SETMASK) WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))

#define POSITION_VAL(VAL) (__CLZ(__RBIT(VAL)))


/**

  * @}

  */
# 227 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/**

  * @}

  */
# 231 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/**

  * @}

  */


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
# 16 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/include/mcu/cmsis_nvic.h" 2





void NVIC_Relocate(void);
void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector);
uint32_t __NVIC_GetVector(IRQn_Type IRQn);
# 26 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h" 2
# 1 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/include/mcu/cortex_m3.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define __MCU_CORTEX_M3_H__ 

# 1 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h" 1
/**

  ******************************************************************************

  * @file    stm32f1xx.h

  * @author  MCD Application Team

  * @version V4.2.0

  * @date    31-March-2017

  * @brief   CMSIS STM32F1xx Device Peripheral Access Layer Header File. 

  *

  *          The file is the unique include file that the application programmer

  *          is using in the C source code, usually in main.c. This file contains:

  *            - Configuration section that allows to select:

  *              - The STM32F1xx device used in the target application

  *              - To use or not the peripherals drivers in application code(i.e. 

  *                code will be based on direct access to peripherals registers 

  *                rather than drivers API), this option is controlled by 

  *                "#define USE_HAL_DRIVER"

  *  

  ******************************************************************************

  * @attention

  *

  * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>

  *

  * Redistribution and use in source and binary forms, with or without modification,

  * are permitted provided that the following conditions are met:

  *   1. Redistributions of source code must retain the above copyright notice,

  *      this list of conditions and the following disclaimer.

  *   2. Redistributions in binary form must reproduce the above copyright notice,

  *      this list of conditions and the following disclaimer in the documentation

  *      and/or other materials provided with the distribution.

  *   3. Neither the name of STMicroelectronics nor the names of its contributors

  *      may be used to endorse or promote products derived from this software

  *      without specific prior written permission.

  *

  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE

  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE

  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR

  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER

  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,

  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  *

  ******************************************************************************

  */
# 48 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/** @addtogroup CMSIS

  * @{

  */
# 52 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/** @addtogroup stm32f1xx

  * @{

  */
# 227 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/**

  * @}

  */
# 231 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/src/ext/Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f1xx.h"
/**

  * @}

  */


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
# 24 "repos/apache-mynewt-core/hw/mcu/stm/stm32f1xx/include/mcu/cortex_m3.h" 2





#define OS_TICKS_PER_SEC (1000)
# 27 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h" 2





/* CPU status register */
typedef uint32_t os_sr_t;

/* Stack element */
typedef uint32_t os_stack_t;

/* Stack sizes for common OS tasks */
#define OS_SANITY_STACK_SIZE (64)



#define OS_IDLE_STACK_SIZE (64)


static inline int
os_arch_in_isr(void)
{
    return (((SCB_Type *) ((0xE000E000UL) /*!< System Control Space Base Address */ + 0x0D00UL) /*!< System Control Block Base Address */ ) /*!< SCB configuration struct */->ICSR & (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/) /*!< SCB ICSR: VECTACTIVE Mask */) != 0;
}

/* Include common arch definitions and APIs */
# 1 "repos/apache-mynewt-core/kernel/os/include/os/arch/common.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _OS_ARCH_COMMON_H 


# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_error.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_OS_ERROR_ 

# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 24 "repos/apache-mynewt-core/kernel/os/include/os/os_error.h" 2





/* OS error enumerations */
enum os_error {
    OS_OK = 0,
    OS_ENOMEM = 1,
    OS_EINVAL = 2,
    OS_INVALID_PARM = 3,
    OS_MEM_NOT_ALIGNED = 4,
    OS_BAD_MUTEX = 5,
    OS_TIMEOUT = 6,
    OS_ERR_IN_ISR = 7, /* Function cannot be called from ISR */
    OS_ERR_PRIV = 8, /* Privileged access error */
    OS_NOT_STARTED = 9, /* OS must be started to call this function, but isn't */
    OS_ENOENT = 10, /* No such thing */
    OS_EBUSY = 11, /* Resource busy */
    OS_ERROR = 12, /* Generic Error */
};

typedef enum os_error os_error_t;
# 25 "repos/apache-mynewt-core/kernel/os/include/os/arch/common.h" 2





struct os_stack;
struct os_task;


#define OS_STACK_PATTERN (0xdeadbeef)



#define OS_ALIGNMENT (4)



#define OS_STACK_ALIGNMENT (8)



#define OS_STACK_ALIGN(__len) (OS_ALIGN((__len), OS_STACK_ALIGNMENT))



#define OS_ENTER_CRITICAL(__os_sr) (__os_sr = os_arch_save_sr())



#define OS_EXIT_CRITICAL(__os_sr) (os_arch_restore_sr(__os_sr))



#define OS_ASSERT_CRITICAL() (assert(os_arch_in_critical()))


os_stack_t *os_arch_task_stack_init(struct os_task *, os_stack_t *, int);
void os_arch_ctx_sw(struct os_task *);
os_sr_t os_arch_save_sr(void);
void os_arch_restore_sr(os_sr_t);
int os_arch_in_critical(void);
void os_arch_init(void);
uint32_t os_arch_start(void);
os_error_t os_arch_os_init(void);
os_error_t os_arch_os_start(void);
void os_set_env(os_stack_t *);
void os_arch_init_task_stack(os_stack_t *sf);
void os_default_irq_asm(void);
# 54 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h" 2
# 66 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _QUEUE_H 

# 1 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h" 1
/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)queue.h	8.5 (Berkeley) 8/20/94
 * $FreeBSD: src/sys/sys/queue.h,v 1.32.2.7 2002/04/17 14:21:02 des Exp $
 */


#define _SYS_QUEUE_H_ 





/*
 * This file defines five types of data structures: singly-linked lists,
 * singly-linked tail queues, lists, tail queues, and circular queues.
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A singly-linked tail queue is headed by a pair of pointers, one to the
 * head of the list and the other to the tail of the list. The elements are
 * singly linked for minimum space and pointer manipulation overhead at the
 * expense of O(n) removal for arbitrary elements. New elements can be added
 * to the list after an existing element, at the head of the list, or at the
 * end of the list. Elements being removed from the head of the tail queue
 * should use the explicit macro for this purpose for optimum efficiency.
 * A singly-linked tail queue may only be traversed in the forward direction.
 * Singly-linked tail queues are ideal for applications with large datasets
 * and few or no removals or for implementing a FIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 *
 *
 *                      SLIST   LIST    STAILQ  TAILQ   CIRCLEQ
 * _HEAD                +       +       +       +       +
 * _HEAD_INITIALIZER    +       +       +       +       +
 * _ENTRY               +       +       +       +       +
 * _INIT                +       +       +       +       +
 * _EMPTY               +       +       +       +       +
 * _FIRST               +       +       +       +       +
 * _NEXT                +       +       +       +       +
 * _PREV                -       -       -       +       +
 * _LAST                -       -       +       +       +
 * _FOREACH             +       +       +       +       +
 * _FOREACH_REVERSE     -       -       -       +       +
 * _INSERT_HEAD         +       +       +       +       +
 * _INSERT_BEFORE       -       +       -       +       +
 * _INSERT_AFTER        +       +       +       +       +
 * _INSERT_TAIL         -       -       +       +       +
 * _REMOVE_HEAD         +       -       +       -       -
 * _REMOVE              +       +       +       +       +
 *
 */

/*
 * Singly-linked List declarations.
 */
#define SLIST_HEAD(name,type) struct name { struct type *slh_first; /* first element */ }




#define SLIST_HEAD_INITIALIZER(head) { NULL }


#define SLIST_ENTRY(type) struct { struct type *sle_next; /* next element */ }




/*
 * Singly-linked List functions.
 */
#define SLIST_EMPTY(head) ((head)->slh_first == NULL)

#define SLIST_FIRST(head) ((head)->slh_first)

#define SLIST_FOREACH(var,head,field) for ((var) = SLIST_FIRST((head)); (var); (var) = SLIST_NEXT((var), field))




#define SLIST_INIT(head) do { SLIST_FIRST((head)) = NULL; } while (0)



#define SLIST_INSERT_AFTER(slistelm,elm,field) do { SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field); SLIST_NEXT((slistelm), field) = (elm); } while (0)




#define SLIST_INSERT_HEAD(head,elm,field) do { SLIST_NEXT((elm), field) = SLIST_FIRST((head)); SLIST_FIRST((head)) = (elm); } while (0)




#define SLIST_NEXT(elm,field) ((elm)->field.sle_next)

#define SLIST_REMOVE(head,elm,type,field) do { if (SLIST_FIRST((head)) == (elm)) { SLIST_REMOVE_HEAD((head), field); } else { struct type *curelm = SLIST_FIRST((head)); while (SLIST_NEXT(curelm, field) != (elm)) curelm = SLIST_NEXT(curelm, field); SLIST_NEXT(curelm, field) = SLIST_NEXT(SLIST_NEXT(curelm, field), field); } } while (0)
# 168 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define SLIST_REMOVE_HEAD(head,field) do { SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field); } while (0)



/*
 * Singly-linked Tail queue declarations.
 */
#define STAILQ_HEAD(name,type) struct name { struct type *stqh_first;/* first element */ struct type **stqh_last;/* addr of last next element */ }





#define STAILQ_HEAD_INITIALIZER(head) { NULL, &(head).stqh_first }


#define STAILQ_ENTRY(type) struct { struct type *stqe_next; /* next element */ }




/*
 * Singly-linked Tail queue functions.
 */
#define STAILQ_EMPTY(head) ((head)->stqh_first == NULL)

#define STAILQ_FIRST(head) ((head)->stqh_first)

#define STAILQ_FOREACH(var,head,field) for((var) = STAILQ_FIRST((head)); (var); (var) = STAILQ_NEXT((var), field))




#define STAILQ_INIT(head) do { STAILQ_FIRST((head)) = NULL; (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)




#define STAILQ_INSERT_AFTER(head,tqelm,elm,field) do { if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_NEXT((tqelm), field) = (elm); } while (0)





#define STAILQ_INSERT_HEAD(head,elm,field) do { if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_FIRST((head)) = (elm); } while (0)





#define STAILQ_INSERT_TAIL(head,elm,field) do { STAILQ_NEXT((elm), field) = NULL; *(head)->stqh_last = (elm); (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)





#define STAILQ_LAST(head,type,field) (STAILQ_EMPTY(head) ? NULL : ((struct type *) ((char *)((head)->stqh_last) - offsetof(struct type, field))))





#define STAILQ_NEXT(elm,field) ((elm)->field.stqe_next)

#define STAILQ_REMOVE(head,elm,type,field) do { if (STAILQ_FIRST((head)) == (elm)) { STAILQ_REMOVE_HEAD(head, field); } else { struct type *curelm = STAILQ_FIRST((head)); while (STAILQ_NEXT(curelm, field) != (elm)) curelm = STAILQ_NEXT(curelm, field); if ((STAILQ_NEXT(curelm, field) = STAILQ_NEXT(STAILQ_NEXT(curelm, field), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((curelm), field); } } while (0)
# 246 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define STAILQ_REMOVE_HEAD(head,field) do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)





#define STAILQ_REMOVE_HEAD_UNTIL(head,elm,field) do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)




#define STAILQ_REMOVE_AFTER(head,elm,field) do { if ((STAILQ_NEXT(elm, field) = STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)





/*
 * List declarations.
 */
#define LIST_HEAD(name,type) struct name { struct type *lh_first; /* first element */ }




#define LIST_HEAD_INITIALIZER(head) { NULL }


#define LIST_ENTRY(type) struct { struct type *le_next; /* next element */ struct type **le_prev; /* address of previous next element */ }





/*
 * List functions.
 */

#define LIST_EMPTY(head) ((head)->lh_first == NULL)

#define LIST_FIRST(head) ((head)->lh_first)

#define LIST_FOREACH(var,head,field) for ((var) = LIST_FIRST((head)); (var); (var) = LIST_NEXT((var), field))




#define LIST_INIT(head) do { LIST_FIRST((head)) = NULL; } while (0)



#define LIST_INSERT_AFTER(listelm,elm,field) do { if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL) LIST_NEXT((listelm), field)->field.le_prev = &LIST_NEXT((elm), field); LIST_NEXT((listelm), field) = (elm); (elm)->field.le_prev = &LIST_NEXT((listelm), field); } while (0)







#define LIST_INSERT_BEFORE(listelm,elm,field) do { (elm)->field.le_prev = (listelm)->field.le_prev; LIST_NEXT((elm), field) = (listelm); *(listelm)->field.le_prev = (elm); (listelm)->field.le_prev = &LIST_NEXT((elm), field); } while (0)






#define LIST_INSERT_HEAD(head,elm,field) do { if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL) LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field); LIST_FIRST((head)) = (elm); (elm)->field.le_prev = &LIST_FIRST((head)); } while (0)






#define LIST_NEXT(elm,field) ((elm)->field.le_next)

#define LIST_REMOVE(elm,field) do { if (LIST_NEXT((elm), field) != NULL) LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev; *(elm)->field.le_prev = LIST_NEXT((elm), field); } while (0)






/*
 * Tail queue declarations.
 */
#define TAILQ_HEAD(name,type) struct name { struct type *tqh_first; /* first element */ struct type **tqh_last; /* addr of last next element */ }





#define TAILQ_HEAD_INITIALIZER(head) { NULL, &(head).tqh_first }


#define TAILQ_ENTRY(type) struct { struct type *tqe_next; /* next element */ struct type **tqe_prev; /* address of previous next element */ }





/*
 * Tail queue functions.
 */
#define TAILQ_EMPTY(head) ((head)->tqh_first == NULL)

#define TAILQ_FIRST(head) ((head)->tqh_first)

#define TAILQ_FOREACH(var,head,field) for ((var) = TAILQ_FIRST((head)); (var); (var) = TAILQ_NEXT((var), field))




#define TAILQ_FOREACH_REVERSE(var,head,headname,field) for ((var) = TAILQ_LAST((head), headname); (var); (var) = TAILQ_PREV((var), headname, field))




#define TAILQ_INIT(head) do { TAILQ_FIRST((head)) = NULL; (head)->tqh_last = &TAILQ_FIRST((head)); } while (0)




#define TAILQ_INSERT_AFTER(head,listelm,elm,field) do { if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = &TAILQ_NEXT((elm), field); else (head)->tqh_last = &TAILQ_NEXT((elm), field); TAILQ_NEXT((listelm), field) = (elm); (elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field); } while (0)
# 378 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define TAILQ_INSERT_BEFORE(listelm,elm,field) do { (elm)->field.tqe_prev = (listelm)->field.tqe_prev; TAILQ_NEXT((elm), field) = (listelm); *(listelm)->field.tqe_prev = (elm); (listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field); } while (0)






#define TAILQ_INSERT_HEAD(head,elm,field) do { if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL) TAILQ_FIRST((head))->field.tqe_prev = &TAILQ_NEXT((elm), field); else (head)->tqh_last = &TAILQ_NEXT((elm), field); TAILQ_FIRST((head)) = (elm); (elm)->field.tqe_prev = &TAILQ_FIRST((head)); } while (0)
# 395 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define TAILQ_INSERT_TAIL(head,elm,field) do { TAILQ_NEXT((elm), field) = NULL; (elm)->field.tqe_prev = (head)->tqh_last; *(head)->tqh_last = (elm); (head)->tqh_last = &TAILQ_NEXT((elm), field); } while (0)






#define TAILQ_LAST(head,headname) (*(((struct headname *)((head)->tqh_last))->tqh_last))


#define TAILQ_NEXT(elm,field) ((elm)->field.tqe_next)

#define TAILQ_PREV(elm,headname,field) (*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))


#define TAILQ_REMOVE(head,elm,field) do { if ((TAILQ_NEXT((elm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = (elm)->field.tqe_prev; else (head)->tqh_last = (elm)->field.tqe_prev; *(elm)->field.tqe_prev = TAILQ_NEXT((elm), field); } while (0)
# 419 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
/*
 * Circular queue declarations.
 */
#define CIRCLEQ_HEAD(name,type) struct name { struct type *cqh_first; /* first element */ struct type *cqh_last; /* last element */ }





#define CIRCLEQ_HEAD_INITIALIZER(head) { (void *)&(head), (void *)&(head) }


#define CIRCLEQ_ENTRY(type) struct { struct type *cqe_next; /* next element */ struct type *cqe_prev; /* previous element */ }





/*
 * Circular queue functions.
 */
#define CIRCLEQ_EMPTY(head) ((head)->cqh_first == (void *)(head))

#define CIRCLEQ_FIRST(head) ((head)->cqh_first)

#define CIRCLEQ_FOREACH(var,head,field) for ((var) = CIRCLEQ_FIRST((head)); (var) != (void *)(head) || ((var) = NULL); (var) = CIRCLEQ_NEXT((var), field))




#define CIRCLEQ_FOREACH_REVERSE(var,head,field) for ((var) = CIRCLEQ_LAST((head)); (var) != (void *)(head) || ((var) = NULL); (var) = CIRCLEQ_PREV((var), field))




#define CIRCLEQ_INIT(head) do { CIRCLEQ_FIRST((head)) = (void *)(head); CIRCLEQ_LAST((head)) = (void *)(head); } while (0)




#define CIRCLEQ_INSERT_AFTER(head,listelm,elm,field) do { CIRCLEQ_NEXT((elm), field) = CIRCLEQ_NEXT((listelm), field); CIRCLEQ_PREV((elm), field) = (listelm); if (CIRCLEQ_NEXT((listelm), field) == (void *)(head)) CIRCLEQ_LAST((head)) = (elm); else CIRCLEQ_PREV(CIRCLEQ_NEXT((listelm), field), field) = (elm); CIRCLEQ_NEXT((listelm), field) = (elm); } while (0)
# 469 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define CIRCLEQ_INSERT_BEFORE(head,listelm,elm,field) do { CIRCLEQ_NEXT((elm), field) = (listelm); CIRCLEQ_PREV((elm), field) = CIRCLEQ_PREV((listelm), field); if (CIRCLEQ_PREV((listelm), field) == (void *)(head)) CIRCLEQ_FIRST((head)) = (elm); else CIRCLEQ_NEXT(CIRCLEQ_PREV((listelm), field), field) = (elm); CIRCLEQ_PREV((listelm), field) = (elm); } while (0)
# 479 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define CIRCLEQ_INSERT_HEAD(head,elm,field) do { CIRCLEQ_NEXT((elm), field) = CIRCLEQ_FIRST((head)); CIRCLEQ_PREV((elm), field) = (void *)(head); if (CIRCLEQ_LAST((head)) == (void *)(head)) CIRCLEQ_LAST((head)) = (elm); else CIRCLEQ_PREV(CIRCLEQ_FIRST((head)), field) = (elm); CIRCLEQ_FIRST((head)) = (elm); } while (0)
# 489 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define CIRCLEQ_INSERT_TAIL(head,elm,field) do { CIRCLEQ_NEXT((elm), field) = (void *)(head); CIRCLEQ_PREV((elm), field) = CIRCLEQ_LAST((head)); if (CIRCLEQ_FIRST((head)) == (void *)(head)) CIRCLEQ_FIRST((head)) = (elm); else CIRCLEQ_NEXT(CIRCLEQ_LAST((head)), field) = (elm); CIRCLEQ_LAST((head)) = (elm); } while (0)
# 499 "repos/apache-mynewt-core/sys/sys/include/sys/queue.h"
#define CIRCLEQ_LAST(head) ((head)->cqh_last)

#define CIRCLEQ_NEXT(elm,field) ((elm)->field.cqe_next)

#define CIRCLEQ_PREV(elm,field) ((elm)->field.cqe_prev)

#define CIRCLEQ_REMOVE(head,elm,field) do { if (CIRCLEQ_NEXT((elm), field) == (void *)(head)) CIRCLEQ_LAST((head)) = CIRCLEQ_PREV((elm), field); else CIRCLEQ_PREV(CIRCLEQ_NEXT((elm), field), field) = CIRCLEQ_PREV((elm), field); if (CIRCLEQ_PREV((elm), field) == (void *)(head)) CIRCLEQ_FIRST((head)) = CIRCLEQ_NEXT((elm), field); else CIRCLEQ_NEXT(CIRCLEQ_PREV((elm), field), field) = CIRCLEQ_NEXT((elm), field); } while (0)
# 24 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 2
# 67 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 2
# 80 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
typedef uint32_t os_time_t;
typedef int32_t os_stime_t;
#define OS_TIME_MAX UINT32_MAX
#define OS_STIME_MAX INT32_MAX

/* Used to wait forever for events and mutexs */
#define OS_TIMEOUT_NEVER (OS_TIME_MAX)


/**
 * Get the current OS time in ticks
 *
 * @return OS time in ticks
 */
os_time_t os_time_get(void);

/**
 * Move OS time forward ticks.
 *
 * @param ticks The number of ticks to move time forward.
 */
void os_time_advance(int ticks);

/**
 * Puts the current task to sleep for the specified number of os ticks. There
 * is no delay if ticks is 0.
 *
 * @param osticks Number of ticks to delay (0 means no delay).
 */
void os_time_delay(os_time_t osticks);

#define OS_TIME_TICK_LT(__t1,__t2) ((os_stime_t) ((__t1) - (__t2)) < 0)
#define OS_TIME_TICK_GT(__t1,__t2) ((os_stime_t) ((__t1) - (__t2)) > 0)
#define OS_TIME_TICK_GEQ(__t1,__t2) ((os_stime_t) ((__t1) - (__t2)) >= 0)

#define OS_TIMEVAL_LT(__t1,__t2) (((__t1).tv_sec < (__t2).tv_sec) || (((__t1).tv_sec == (__t2).tv_sec) && ((__t1).tv_usec < (__t2).tv_usec)))


#define OS_TIMEVAL_LEQ(__t1,__t2) (((__t1).tv_sec < (__t2).tv_sec) || (((__t1).tv_sec == (__t2).tv_sec) && ((__t1).tv_usec <= (__t2).tv_usec)))


#define OS_TIMEVAL_GT(__t1,__t2) (((__t1).tv_sec > (__t2).tv_sec) || (((__t1).tv_sec == (__t2).tv_sec) && ((__t1).tv_usec > (__t2).tv_usec)))


#define OS_TIMEVAL_GEQ(__t1,__t2) (((__t1).tv_sec > (__t2).tv_sec) || (((__t1).tv_sec == (__t2).tv_sec) && ((__t1).tv_usec >= (__t2).tv_usec)))



/**
 * Structure representing time since Jan 1 1970 with microsecond
 * granularity
 */
struct os_timeval {
    /* Seconds */
    int64_t tv_sec;
    /* Microseconds within the second */
    int32_t tv_usec;
};

/** Structure representing a timezone offset */
struct os_timezone {
    /** Minutes west of GMT */
    int16_t tz_minuteswest;
    /** Daylight savings time correction (if any) */
    int16_t tz_dsttime;
};

/**
 * Represents a time change.  Passed to time change listeners when the current
 * time-of-day is set.
 */
struct os_time_change_info {
    /** UTC time prior to change. */
    const struct os_timeval *tci_prev_tv;
    /** Time zone prior to change. */
    const struct os_timezone *tci_prev_tz;
    /** UTC time after change. */
    const struct os_timeval *tci_cur_tv;
    /** Time zone after change. */
    const struct os_timezone *tci_cur_tz;
    /** True if the time was not set prior to change. */
    
# 161 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 3 4
   _Bool 
# 161 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
        tci_newly_synced;
};

/**
 * Callback that is executed when the time-of-day is set.
 *
 * @param info                  Describes the time change that just occurred.
 * @param arg                   Optional argument correponding to listener.
 */
typedef void os_time_change_fn(const struct os_time_change_info *info,
                               void *arg);

/**
 * Time change listener.  Notified when the time-of-day is set.
 */
struct os_time_change_listener {
    /*** Public. */
    os_time_change_fn *tcl_fn;
    void *tcl_arg;

    /*** Internal. */
    struct { struct os_time_change_listener *stqe_next; /* next element */ } tcl_next;
};

/**
 * Add first two timeval arguments and place results in third timeval
 * argument.
 */
#define os_timeradd(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0)
# 200 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
/**
 * Subtract first two timeval arguments and place results in third timeval
 * argument.
 */
#define os_timersub(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0)
# 215 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
/**
 * Set the time of day.  This does not modify os time, but rather just modifies
 * the offset by which we are tracking real time against os time.  This
 * function notifies all registered time change listeners.
 *
 * @param utctime A timeval representing the UTC time we are setting
 * @param tz The time-zone to apply against the utctime being set.
 *
 * @return 0 on success, non-zero on failure.
 */
int os_settimeofday(struct os_timeval *utctime, struct os_timezone *tz);

/**
 * Get the current time of day.  Returns the time of day in UTC
 * into the tv argument, and returns the timezone (if set) into
 * tz.
 *
 * @param tv The structure to put the UTC time of day into
 * @param tz The structure to put the timezone information into
 *
 * @return 0 on success, non-zero on failure
 */
int os_gettimeofday(struct os_timeval *utctime, struct os_timezone *tz);

/**
 * Indicates whether the time has been set.
 *
 * @return                      true if time is set; false otherwise.
 */

# 244 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 3 4
_Bool 
# 244 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
    os_time_is_set(void);

/**
 * Get time since boot in microseconds.
 *
 * @return time since boot in microseconds
 */
int64_t os_get_uptime_usec(void);

/**
 * Get time since boot as os_timeval.
 *
 * @param tv Structure to put the time since boot.
 */
void os_get_uptime(struct os_timeval *tvp);

/**
 * Converts milliseconds to OS ticks.
 *
 * @param ms                    The milliseconds input.
 * @param out_ticks             The OS ticks output.
 *
 * @return                      0 on success; OS_EINVAL if the result is too
 *                                  large to fit in a uint32_t.
 */
int os_time_ms_to_ticks(uint32_t ms, os_time_t *out_ticks);

/**
 * Converts OS ticks to milliseconds.
 *
 * @param ticks                 The OS ticks input.
 * @param out_ms                The milliseconds output.
 *
 * @return                      0 on success; OS_EINVAL if the result is too
 *                                  large to fit in a uint32_t.
 */
int os_time_ticks_to_ms(os_time_t ticks, uint32_t *out_ms);


/**
 * Converts milliseconds to OS ticks.
 *
 * This function does not check if conversion overflows and should be only used
 * in cases where input is known to be small enough not to overflow.
 *
 * @param ms                    The milliseconds input.
 *
 * @return                      result on success
 */
static inline os_time_t
os_time_ms_to_ticks32(uint32_t ms)
{

    return ms;



}

/**
 * Converts OS ticks to milliseconds.
 *
 * This function does not check if conversion overflows and should be only used
 * in cases where input is known to be small enough not to overflow.
 *
 * @param ticks                 The OS ticks input.
 *
 * @return                      result on success
 */
static inline uint32_t
os_time_ticks_to_ms32(os_time_t ticks)
{

    return ticks;



}

/**
 * Registers a time change listener.  Whenever the time is set, all registered
 * listeners are notified.  The provided pointer is added to an internal list,
 * so the listener's lifetime must extend indefinitely (or until the listener
 * is removed).
 *
 * NOTE: This function is not thread safe.  The following operations must be
 * kept exclusive:
 *     o Addition of listener
 *     o Removal of listener
 *     o Setting time
 *
 * @param listener              The listener to register.
 */
void os_time_change_listen(struct os_time_change_listener *listener);

/**
 * Unregisters a time change listener.
 *
 * NOTE: This function is not thread safe.  The following operations must be
 * kept exclusive:
 *     o Addition of listener
 *     o Removal of listener
 *     o Setting time
 *
 * @param listener              The listener to unregister.
 */
int os_time_change_remove(const struct os_time_change_listener *listener);
# 359 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
/**
 *   @} OSKernel
 * @} OSTime
 */
# 34 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 35 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 2





struct os_event;
typedef void os_event_fn(struct os_event *ev);

/**
 * Structure representing an OS event.  OS events get placed onto the
 * event queues and are consumed by tasks.
 */
struct os_event {
    /** Whether this OS event is queued on an event queue. */
    uint8_t ev_queued;
    /**
     * Callback to call when the event is taken off of an event queue.
     * APIs, except for os_eventq_run(), assume this callback will be called by
     * the user.
     */
    os_event_fn *ev_cb;
    /** Argument to pass to the event queue callback. */
    void *ev_arg;

    struct { struct os_event *stqe_next; /* next element */ } ev_next;
};

/** Return whether or not the given event is queued. */
#define OS_EVENT_QUEUED(__ev) ((__ev)->ev_queued)
# 81 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h"
struct os_eventq {
    /** Pointer to task that "owns" this event queue. */
    struct os_task *evq_owner;
    /**
     * Pointer to the task that is sleeping on this event queue, either NULL,
     * or the owner task.
     */
    struct os_task *evq_task;

    struct { struct os_event *stqh_first;/* first element */ struct os_event **stqh_last;/* addr of last next element */ } evq_list;
# 100 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h"
};

/**
 * Initialize the event queue
 *
 * @param evq The event queue to initialize
 */
void os_eventq_init(struct os_eventq *);

/**
 * Check whether the event queue is initialized.
 *
 * @param evq The event queue to check
 */
int os_eventq_inited(const struct os_eventq *evq);

/**
 * Put an event on the event queue.
 *
 * @param evq The event queue to put an event on
 * @param ev The event to put on the queue
 */
void os_eventq_put(struct os_eventq *, struct os_event *);

/**
 * Poll an event from the event queue and return it immediately.
 * If no event is available, don't block, just return NULL.
 *
 * @return Event from the queue, or NULL if none available.
 */
struct os_event *os_eventq_get_no_wait(struct os_eventq *evq);

/**
 * Pull a single item from an event queue.  This function blocks until there
 * is an item on the event queue to read.
 *
 * @param evq The event queue to pull an event from
 *
 * @return The event from the queue
 */
struct os_event *os_eventq_get(struct os_eventq *);

/**
 * Pull a single item off the event queue and call it's event
 * callback.
 *
 * @param evq The event queue to pull the item off.
 */
void os_eventq_run(struct os_eventq *evq);


/**
 * Poll the list of event queues specified by the evq parameter
 * (size nevqs), and return the "first" event available on any of
 * the queues.  Event queues are searched in the order that they
 * are passed in the array.
 *
 * @param evq Array of event queues
 * @param nevqs Number of event queues in evq
 * @param timo Timeout, forever if OS_WAIT_FOREVER is passed to poll.
 *
 * @return An event, or NULL if no events available
 */
struct os_event *os_eventq_poll(struct os_eventq **, int, os_time_t);

/**
 * Remove an event from the queue.
 *
 * @param evq The event queue to remove the event from
 * @param ev  The event to remove from the queue
 */
void os_eventq_remove(struct os_eventq *, struct os_event *);

/**
 * Retrieves the default event queue processed by OS main task.
 *
 * @return                      The default event queue.
 */
struct os_eventq *os_eventq_dflt_get(void);
# 210 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h"
/**
 * @cond INTERNAL_HIDDEN
 * [DEPRECATED]
 */
void os_eventq_designate(struct os_eventq **dst, struct os_eventq *val,
                         struct os_event *start_ev);

/**
 * @endcond
 */
# 228 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h"
/**
 *   @} OSEvent
 * @} OSKernel
 */
# 35 "repos/apache-mynewt-core/kernel/os/include/os/os_callout.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 36 "repos/apache-mynewt-core/kernel/os/include/os/os_callout.h" 2


# 37 "repos/apache-mynewt-core/kernel/os/include/os/os_callout.h"
/**
 * Structure containing the definition of a callout, initialized
 * by os_callout_init() and passed to callout functions.
 */
struct os_callout {
    /** Event to post when the callout expires. */
    struct os_event c_ev;
    /** Pointer to the event queue to post the event to */
    struct os_eventq *c_evq;
    /** Number of ticks in the future to expire the callout */
    os_time_t c_ticks;


    struct { struct os_callout *tqe_next; /* next element */ struct os_callout **tqe_prev; /* address of previous next element */ } c_next;
};

/**
 * @cond INTERNAL_HIDDEN
 */

struct os_callout_list { struct os_callout *tqh_first; /* first element */ struct os_callout **tqh_last; /* addr of last next element */ };

/**
 * @endcond
 */

/**
 * Initialize a callout.
 *
 * Callouts are used to schedule events in the future onto a task's event
 * queue.  Callout timers are scheduled using the os_callout_reset()
 * function.  When the timer expires, an event is posted to the event
 * queue specified in os_callout_init().  The event argument given here
 * is posted in the ev_arg field of that event.
 *
 * @param c The callout to initialize
 * @param evq The event queue to post an OS_EVENT_T_TIMER event to
 * @param timo_func The function to call on this callout for the host task
 *                  used to provide multiple timer events to a task
 *                  (this can be NULL.)
 * @param ev_arg The argument to provide to the event when posting the
 *               timer.
 */
void os_callout_init(struct os_callout *cf, struct os_eventq *evq,
                     os_event_fn *ev_cb, void *ev_arg);


/**
 * Stop the callout from firing off, any pending events will be cleared.
 *
 * @param c The callout to stop
 */
void os_callout_stop(struct os_callout *);


/**
 * Reset the callout to fire off in 'ticks' ticks.
 *
 * @param c The callout to reset
 * @param ticks The number of ticks to wait before posting an event
 *
 * @return 0 on success, non-zero on failure
 */
int os_callout_reset(struct os_callout *, os_time_t);

/**
 * Returns the number of ticks which remains to callout.
 *
 * @param c The callout to check
 * @param now The current time in OS ticks
 *
 * @return Number of ticks to first pending callout
 */
os_time_t os_callout_remaining_ticks(struct os_callout *, os_time_t);

/**
 * Returns whether the callout is pending or not.
 *
 * @param c The callout to check
 *
 * @return 1 if queued, 0 if not queued.
 */
static inline int
os_callout_queued(struct os_callout *c)
{
    return c->c_next.tqe_prev != 
# 122 "repos/apache-mynewt-core/kernel/os/include/os/os_callout.h" 3 4
                                ((void *)0)
# 122 "repos/apache-mynewt-core/kernel/os/include/os/os_callout.h"
                                    ;
}

/**
 * @cond INTERNAL_HIDDEN
 */

void os_callout_tick(void);
os_time_t os_callout_wakeup_ticks(os_time_t now);

/**
 * @endcond
 */







/**
 *   @} OSCallouts
 * @} OS Kernel
 */
# 123 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_cfg.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */



#define _OS_CFG_H_ 
# 124 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_cputime.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

 /**
  * @addtogroup OSKernel
  * @{
  *   @defgroup OSCPUTime High Resolution Timers
  *   @{
  */


#define H_OS_CPUTIME_ 





# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 35 "repos/apache-mynewt-core/kernel/os/include/os/os_cputime.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 36 "repos/apache-mynewt-core/kernel/os/include/os/os_cputime.h" 2
# 1 "repos/apache-mynewt-core/hw/hal/include/hal/hal_timer.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup HAL
 * @{
 *   @defgroup HALTimer HAL Timer
 *   @{
 */


#define H_HAL_TIMER_ 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 32 "repos/apache-mynewt-core/hw/hal/include/hal/hal_timer.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 33 "repos/apache-mynewt-core/hw/hal/include/hal/hal_timer.h" 2





/* HAL timer callback */
typedef void (*hal_timer_cb)(void *arg);

/**
 * The HAL timer structure. The user can declare as many of these structures
 * as desired. They are enqueued on a particular HW timer queue when the user
 * calls the :c:func:`hal_timer_start()` or :c:func:`hal_timer_start_at()` API.
 * The user must have called :c:func:`hal_timer_set_cb()` before starting a
 * timer.
 *
 * NOTE: the user should not have to modify/examine the contents of this
 * structure; the hal timer API should be used.
 */
struct hal_timer {
    /** Internal platform specific pointer */
    void *bsp_timer;
    /** Callback function */
    hal_timer_cb cb_func;
    /** Callback argument */
    void *cb_arg;
    /** Tick at which timer should expire */
    uint32_t expiry;
    struct { struct hal_timer *tqe_next; /* next element */ struct hal_timer **tqe_prev; /* address of previous next element */ } link; /* Queue linked list structure */
};

/**
 * Initialize a HW timer.
 *
 * @param timer_num The number of the HW timer to initialize
 * @param cfg       Hardware specific timer configuration.  This is
 *                  passed from BSP directly to the MCU specific driver.
 */
int hal_timer_init(int timer_num, void *cfg);

/**
 * Un-initialize a HW timer.
 *
 * @param timer_num The number of the HW timer to un-initialize
 */
int hal_timer_deinit(int timer_num);

/**
 * Config a HW timer at the given frequency and start it. If the exact
 * frequency is not obtainable the closest obtainable frequency is set.
 *
 * @param timer_num The number of the HW timer to configure
 * @param freq_hz   The frequency in Hz to configure the timer at
 *
 * @return 0 on success, non-zero error code on failure
 */
int hal_timer_config(int timer_num, uint32_t freq_hz);

/**
 * Returns the resolution of the HW timer. NOTE: the frequency may not be
 * obtainable so the caller can use this to determine the resolution.
 * Returns resolution in nanoseconds. A return value of 0 indicates an invalid
 * timer was used.
 *
 * @param timer_num The number of the HW timer to get resolution for
 *
 * @return The resolution of the timer
 */
uint32_t hal_timer_get_resolution(int timer_num);

/**
 * Returns the HW timer current tick value
 *
 * @param timer_num The HW timer to read the tick value from
 *
 * @return The current tick value
 */
uint32_t hal_timer_read(int timer_num);

/**
 * Perform a blocking delay for a number of ticks.
 *
 * @param timer_num The timer number to use for the blocking delay
 * @param ticks The number of ticks to delay for
 *
 * @return 0 on success, non-zero error code on failure
 */
int hal_timer_delay(int timer_num, uint32_t ticks);

/**
 * Set the timer structure prior to use. Should not be called if the timer
 * is running. Must be called at least once prior to using timer.
 *
 * @param timer_num The number of the HW timer to configure the callback on
 * @param tmr       The timer structure to use for this timer
 * @param cb_func   The timer callback to call when the timer fires
 * @param arg       An opaque argument to provide the timer callback
 *
 * @return 0  on success, non-zero error code on failure.
 */
int hal_timer_set_cb(int timer_num, struct hal_timer *tmr, hal_timer_cb cb_func,
                     void *arg);

/**
 * Start a timer that will expire in 'ticks' ticks. Ticks cannot be 0
 *
 * @param tmr   The timer to start
 * @param ticks The number of ticks to expire the timer in
 *
 * @return 0 on success, non-zero error code on failure.
 */
int hal_timer_start(struct hal_timer *tmr, uint32_t ticks);

/**
 * Start a timer that will expire when the timer reaches 'tick'. If tick
 * has already passed the timer callback will be called "immediately" (at
 * interrupt context).
 *
 * @param tmr  The timer to start
 * @param tick The absolute tick value to fire the timer at
 *
 * @return 0 on success, non-zero error code on failure.
 */
int hal_timer_start_at(struct hal_timer *tmr, uint32_t tick);

/**
 * Stop a currently running timer; associated callback will NOT be called
 *
 * @param tmr The timer to stop
 */
int hal_timer_stop(struct hal_timer *tmr);







/**
 *   @} HALTimer
 * @} HAL
 */
# 37 "repos/apache-mynewt-core/kernel/os/include/os/os_cputime.h" 2

/*
 * NOTE: these definitions allow one to override the cputime frequency used.
 * The reason these definitions exist is to make the code more
 * efficient/smaller when CPUTIME counts at 1 MHz.
 *
 * For those who want a different cputime frequency, you can set the config
 * definition for OS_CPUTIME_FREQ to the desired frequency in your project,
 * target or bsp.
 */


#define OS_CPUTIME_FREQ_1MHZ 
# 86 "repos/apache-mynewt-core/kernel/os/include/os/os_cputime.h"
/* Helpful macros to compare cputimes */
/** evaluates to true if t1 is before t2 in time */
#define CPUTIME_LT(__t1,__t2) ((int32_t) ((__t1) - (__t2)) < 0)
/** evaluates to true if t1 is after t2 in time */
#define CPUTIME_GT(__t1,__t2) ((int32_t) ((__t1) - (__t2)) > 0)
/** evaluates to true if t1 is after t2 in time */
#define CPUTIME_GEQ(__t1,__t2) ((int32_t) ((__t1) - (__t2)) >= 0)
/** evaluates to true if t1 is on or after t2 in time */
#define CPUTIME_LEQ(__t1,__t2) ((int32_t) ((__t1) - (__t2)) <= 0)

/**
 * Initialize the cputime module. This must be called after os_init is called
 * and before any other timer API are used. This should be called only once
 * and should be called before the hardware timer is used.
 *
 * @param clock_freq The desired cputime frequency, in hertz (Hz).
 *
 * @return int 0 on success; -1 on error.
 */
int os_cputime_init(uint32_t clock_freq);

/**
 * Returns the low 32 bits of cputime.
 *
 * @return uint32_t The lower 32 bits of cputime
 */
uint32_t os_cputime_get32(void);


/**
 * Converts the given number of nanoseconds into cputime ticks.
 * Not defined if OS_CPUTIME_FREQ_PWR2 is defined.
 *
 * @param usecs The number of nanoseconds to convert to ticks
 *
 * @return uint32_t The number of ticks corresponding to 'nsecs'
 */
uint32_t os_cputime_nsecs_to_ticks(uint32_t nsecs);

/**
 * Convert the given number of ticks into nanoseconds.
 * Not defined if OS_CPUTIME_FREQ_PWR2 is defined.
 *
 * @param ticks The number of ticks to convert to nanoseconds.
 *
 * @return uint32_t The number of nanoseconds corresponding to 'ticks'
 */
uint32_t os_cputime_ticks_to_nsecs(uint32_t ticks);

/**
 * Wait until 'nsecs' nanoseconds has elapsed. This is a blocking delay.
 * Not defined if OS_CPUTIME_FREQ_PWR2 is defined.
 *
 *
 * @param nsecs The number of nanoseconds to wait.
 */
void os_cputime_delay_nsecs(uint32_t nsecs);



#define os_cputime_usecs_to_ticks(x) (x)
#define os_cputime_ticks_to_usecs(x) (x)
# 169 "repos/apache-mynewt-core/kernel/os/include/os/os_cputime.h"
/**
 * Wait until the number of ticks has elapsed. This is a blocking delay.
 *
 * @param ticks The number of ticks to wait.
 */
void os_cputime_delay_ticks(uint32_t ticks);

/**
 * Wait until 'usecs' microseconds has elapsed. This is a blocking delay.
 *
 * @param usecs The number of usecs to wait.
 */
void os_cputime_delay_usecs(uint32_t usecs);

/**
 * Initialize a CPU timer, using the given HAL timer.
 *
 * @param timer The timer to initialize. Cannot be NULL.
 * @param fp    The timer callback function. Cannot be NULL.
 * @param arg   Pointer to data object to pass to timer.
 */
void os_cputime_timer_init(struct hal_timer *timer, hal_timer_cb fp,
        void *arg);

/**
 * Start a cputimer that will expire at 'cputime'. If cputime has already
 * passed, the timer callback will still be called (at interrupt context).
 *
 * NOTE: This must be called when the timer is stopped.
 *
 * @param timer     Pointer to timer to start. Cannot be NULL.
 * @param cputime   The cputime at which the timer should expire.
 *
 * @return int 0 on success; EINVAL if timer already started or timer struct
 *         invalid
 *
 */
int os_cputime_timer_start(struct hal_timer *timer, uint32_t cputime);

/**
 * Sets a cpu timer that will expire 'usecs' microseconds from the current
 * cputime.
 *
 * NOTE: This must be called when the timer is stopped.
 *
 * @param timer Pointer to timer. Cannot be NULL.
 * @param usecs The number of usecs from now at which the timer will expire.
 *
 * @return int 0 on success; EINVAL if timer already started or timer struct
 *         invalid
 */
int os_cputime_timer_relative(struct hal_timer *timer, uint32_t usecs);

/**
 * Stops a cputimer from running. The timer is removed from the timer queue
 * and interrupts are disabled if no timers are left on the queue. Can be
 * called even if timer is not running.
 *
 * @param timer Pointer to cputimer to stop. Cannot be NULL.
 */
void os_cputime_timer_stop(struct hal_timer *timer);







/**
 *   @} OSCPUTime
 * @} OSKernel
 */
# 125 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_dev.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _OS_DEV_H 

/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSDevice Device Framework
 *   @{
 */

# 1 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 31 "repos/apache-mynewt-core/kernel/os/include/os/os_dev.h" 2

# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_dev.h" 2





struct os_dev;

/*
 * Initialization order, defines when a device should be initialized
 * by the Mynewt kernel.
 *
 */
/* Primary is initialized during OS init, after the initialization
 * of OS memory and architecture specific functions, but before the
 * OS gets started.
 */
#define OS_DEV_INIT_PRIMARY (1)
/** Secondary is initialized directly after primary. */
#define OS_DEV_INIT_SECONDARY (2)
/** Initialize device in the main task, after the kernel has started. */
#define OS_DEV_INIT_KERNEL (3)

/**
 * This device initializing is critical, fail device init if it does
 * not successfully initialize.
 */
#define OS_DEV_INIT_F_CRITICAL (1 << 0)

#define OS_DEV_INIT_PRIO_DEFAULT (0xff)

/** Device is initialized, and ready to be accessed. */
#define OS_DEV_F_STATUS_READY (1 << 0)
/** Device is open */
#define OS_DEV_F_STATUS_OPEN (1 << 1)
/** Device is in suspended state. */
#define OS_DEV_F_STATUS_SUSPENDED (1 << 2)
/**
 * It is critical to the system operation that this device successfully
 * initialized.  Fail device init if it does not.
 */
#define OS_DEV_F_INIT_CRITICAL (1 << 3)

/**
 * Initialize a device.
 *
 * @param dev The device to initialize.
 * @param arg User defined argument to pass to the device initalization
 *
 * @return 0 on success, non-zero error code on failure.
 */
typedef int (*os_dev_init_func_t)(struct os_dev *, void *);

typedef int (*os_dev_open_func_t)(struct os_dev *, uint32_t,
        void *);
typedef int (*os_dev_suspend_func_t)(struct os_dev *, os_time_t, int);
typedef int (*os_dev_resume_func_t)(struct os_dev *);
typedef int (*os_dev_close_func_t)(struct os_dev *);

/**
 * Device handlers, implementers of device drivers should fill these
 * out to control device operation.
 */
struct os_dev_handlers {
    /**
     * Device open handler, called when the user opens the device.
     * Any locking of the device should be done within the open handler.
     */
    os_dev_open_func_t od_open;
    /**
     * Suspend handler, called when the device is being suspended.
     * Up to the implementer to save device state before power down,
     * so that the device can be cleanly resumed -- or error out and
     * delay suspension.
     */
    os_dev_suspend_func_t od_suspend;
    /**
     * Resume handler, restores device state after a suspend operation.
     */
    os_dev_resume_func_t od_resume;
    /**
     * Close handler, releases the device, including any locks that
     * may have been taken by open().
     */
    os_dev_close_func_t od_close;
};

/*
 * Device structure.
 */
struct os_dev {
    /** Device handlers.  Implementation of base device functions. */
    struct os_dev_handlers od_handlers;
    /** Device initialization function. */
    os_dev_init_func_t od_init;
    /** Argument to pass to device initialization function. */
    void *od_init_arg;
    /** Stage during which to initialize this device. */
    uint8_t od_stage;
    /** Priority within a given stage to initialize a device. */
    uint8_t od_priority;
    /**
     * Number of references to a device being open before marking
     * the device closed.
     */
    uint8_t od_open_ref;
    /** Device flags.  */
    uint8_t od_flags;
    /** Device name */
    const char *od_name;
    struct { struct os_dev *stqe_next; /* next element */ } od_next;
};

#define OS_DEV_SETHANDLERS(__dev,__open,__close) (__dev)->od_handlers.od_open = (__open); (__dev)->od_handlers.od_close = (__close);




/**
 * Suspend the operation of the device.
 *
 * @param dev The device to suspend.
 * @param suspend_t When the device should be suspended.
 * @param force Whether not the suspend operation can be overridden by the
 *        device handler.
 *
 * @return 0 on success, non-zero error code on failure.
 */
int os_dev_suspend(struct os_dev *dev, os_time_t suspend_t, uint8_t force);

/**
 * Resume the device operation.
 *
 * @param dev The device to resume
 *
 * @return 0 on success, non-zero error code on failure.
 */
int os_dev_resume(struct os_dev *dev);

/**
 * Create a new device in the kernel.
 *
 * @param dev The device to create.
 * @param name The name of the device to create.
 * @param stage The stage to initialize that device to.
 * @param priority The priority of initializing that device
 * @param od_init The initialization function to call for this
 *                device.
 * @param arg The argument to provide this device initialization
 *            function.
 *
 * @return 0 on success, non-zero on failure.
 */
int os_dev_create(struct os_dev *dev, const char *name, uint8_t stage,
        uint8_t priority, os_dev_init_func_t od_init, void *arg);

/**
 * Lookup a device by name.
 *
 * WARNING: This should be called before any locking on the device is done, or
 * the device list itself is modified in any context.  There is no locking.
 *
 * @param name The name of the device to look up.
 *
 * @return A pointer to the device corresponding to name, or NULL if not found.
 */
struct os_dev *os_dev_lookup(const char *name);

/**
 * Initialize all devices for a given state.
 *
 * @param stage The stage to initialize.
 *
 * @return 0 on success, non-zero on failure.
 */
int os_dev_initialize_all(uint8_t);


/**
 * Suspend all devices.
 *
 * @param suspend_t The number of ticks to suspend this device for
 * @param force Whether or not to force suspending the device
 *
 * @return 0 on success, or a non-zero error code if one of the devices
 *                       returned it.
 */
int os_dev_suspend_all(os_time_t, uint8_t);

/**
 * Resume all the devices that were suspended.
 *
 * @return 0 on success, -1 if any of the devices have failed to resume.
 */
int os_dev_resume_all(void);

/**
 * Open a device.
 *
 * @param dev The device to open
 * @param timo The timeout to open the device, if not specified.
 * @param arg The argument to the device open() call.
 *
 * @return 0 on success, non-zero on failure.
 */
struct os_dev *os_dev_open(const char *devname, uint32_t timo, void *arg);

/**
 * Close a device.
 *
 * @param dev The device to close
 *
 * @return 0 on success, non-zero on failure.
 */
int os_dev_close(struct os_dev *dev);


/**
 * Clears the device list.  This function does not close any devices or free
 * any resources; its purpose is to allow a full system reset between unit
 * tests.
 */
void os_dev_reset(void);

/**
 * Walk through all devices, calling callback for every device.
 *
 * @param walk_func Function to call
 * @aparm arg       Argument to pass to walk_func
 */
void os_dev_walk(int (*walk_func)(struct os_dev *, void *), void *arg);
# 271 "repos/apache-mynewt-core/kernel/os/include/os/os_dev.h"
/**
 *   @} OSDevice
 * @} OSKernel
 */
# 126 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_error.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 127 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSEvent Event Queues
 *   @{
 */
# 228 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h"
/**
 *   @} OSEvent
 * @} OSKernel
 */
# 128 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_fault.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 129 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_heap.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSGeneral
 *   @{
 */



#define H_OS_HEAP_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_heap.h" 2







# 39 "repos/apache-mynewt-core/kernel/os/include/os/os_heap.h"
/**
 * Operating system level malloc().   This ensures that a safe malloc occurs
 * within the context of the OS.  Depending on platform, the OS may rely on
 * libc's malloc() implementation, which is not guaranteed to be thread-safe.
 * This malloc() will always be thread-safe.
 *
 * @param size The number of bytes to allocate
 *
 * @return A pointer to the memory region allocated.
 */
void *os_malloc(size_t size);


/**
 * Operating system level free().  See description of os_malloc() for reasoning.
 *
 * Free's memory allocated by malloc.
 *
 * @param mem The memory to free.
 */
void os_free(void *mem);

/**
 * Operating system level realloc(). See description of os_malloc() for reasoning.
 *
 * Reallocates the memory at ptr, to be size contiguouos bytes.
 *
 * @param ptr A pointer to the memory to allocate
 * @param size The number of contiguouos bytes to allocate at that location
 *
 * @return A pointer to memory of size, or NULL on failure to allocate
 */
void *os_realloc(void *ptr, size_t size);
# 80 "repos/apache-mynewt-core/kernel/os/include/os/os_heap.h"
/**
 *   @} OSGeneral
 * @} OS Kernel
 */
# 130 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_mbuf.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSMbuf Chained Memory Buffers
 *   @{
 */



#define _OS_MBUF_H 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_mbuf.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSEvent Event Queues
 *   @{
 */
# 228 "repos/apache-mynewt-core/kernel/os/include/os/os_eventq.h"
/**
 *   @} OSEvent
 * @} OSKernel
 */
# 34 "repos/apache-mynewt-core/kernel/os/include/os/os_mbuf.h" 2





/**
 * A mbuf pool from which to allocate mbufs. This contains a pointer to the os
 * mempool to allocate mbufs out of, the total number of elements in the pool,
 * and the amount of "user" data in a non-packet header mbuf. The total pool
 * size, in bytes, should be:
 *  os_mbuf_count * (omp_databuf_len + sizeof(struct os_mbuf))
 */
struct os_mbuf_pool {
    /**
     * Total length of the databuf in each mbuf.  This is the size of the
     * mempool block, minus the mbuf header
     */
    uint16_t omp_databuf_len;
    /**
     * The memory pool which to allocate mbufs out of
     */
    struct os_mempool *omp_pool;

    struct { struct os_mbuf_pool *stqe_next; /* next element */ } omp_next;
};


/**
 * A packet header structure that preceeds the mbuf packet headers.
 */
struct os_mbuf_pkthdr {
    /**
     * Overall length of the packet.
     */
    uint16_t omp_len;
    /**
     * Flags
     */
    uint16_t omp_flags;

    struct { struct os_mbuf_pkthdr *stqe_next; /* next element */ } omp_next;
};

/**
 * Chained memory buffer.
 */
struct os_mbuf {
    /**
     * Current pointer to data in the structure
     */
    uint8_t *om_data;
    /**
     * Flags associated with this buffer, see OS_MBUF_F_* defintions
     */
    uint8_t om_flags;
    /**
     * Length of packet header
     */
    uint8_t om_pkthdr_len;
    /**
     * Length of data in this buffer
     */
    uint16_t om_len;

    /**
     * The mbuf pool this mbuf was allocated out of
     */
    struct os_mbuf_pool *om_omp;

    struct { struct os_mbuf *sle_next; /* next element */ } om_next;

    /**
     * Pointer to the beginning of the data, after this buffer
     */
    uint8_t om_databuf[0];
};

/**
 * Structure representing a queue of mbufs.
 */
struct os_mqueue {
    struct { struct os_mbuf_pkthdr *stqh_first;/* first element */ struct os_mbuf_pkthdr **stqh_last;/* addr of last next element */ } mq_head;
    /** Event to post when new buffers are available on the queue. */
    struct os_event mq_ev;
};

/*
 * Given a flag number, provide the mask for it
 *
 * @param __n The number of the flag in the mask
 */
#define OS_MBUF_F_MASK(__n) (1 << (__n))

/*
 * Checks whether a given mbuf is a packet header mbuf
 *
 * @param __om The mbuf to check
 */
#define OS_MBUF_IS_PKTHDR(__om) ((__om)->om_pkthdr_len >= sizeof (struct os_mbuf_pkthdr))


/** Get a packet header pointer given an mbuf pointer */
#define OS_MBUF_PKTHDR(__om) ((struct os_mbuf_pkthdr *) ((uint8_t *)&(__om)->om_data + sizeof(struct os_mbuf)))


/** Given a mbuf packet header pointer, return a pointer to the mbuf */
#define OS_MBUF_PKTHDR_TO_MBUF(__hdr) (struct os_mbuf *)((uint8_t *)(__hdr) - sizeof(struct os_mbuf))


/**
 * Gets the length of an entire mbuf chain.  The specified mbuf must have a
 * packet header.
 */
#define OS_MBUF_PKTLEN(__om) (OS_MBUF_PKTHDR(__om)->omp_len)

/**
 * Access the data of a mbuf, and cast it to type
 *
 * @param __om The mbuf to access, and cast
 * @param __type The type to cast it to
 */
#define OS_MBUF_DATA(__om,__type) (__type) ((__om)->om_data)


/**
 * Access the "user header" in the head of an mbuf chain.
 *
 * @param om                    Pointer to the head of an mbuf chain.
 */
#define OS_MBUF_USRHDR(om) (void *)((uint8_t *)om + sizeof (struct os_mbuf) + sizeof (struct os_mbuf_pkthdr))



/**
 * Retrieves the length of the user header in an mbuf.
 *
 * @param om                    Pointer to the mbuf to query.
 */
#define OS_MBUF_USRHDR_LEN(om) ((om)->om_pkthdr_len - sizeof (struct os_mbuf_pkthdr))



/** @cond INTERNAL_HIDDEN */

/*
 * Called by OS_MBUF_LEADINGSPACE() macro
 */
static inline uint16_t
_os_mbuf_leadingspace(struct os_mbuf *om)
{
    uint16_t startoff;
    uint16_t leadingspace;

    startoff = 0;
    if (((om)->om_pkthdr_len >= sizeof (struct os_mbuf_pkthdr))) {
        startoff = om->om_pkthdr_len;
    }

    leadingspace = (uint16_t) ((uint8_t *) ((om)->om_data) -
        ((uint8_t *) &om->om_databuf[0] + startoff));

    return (leadingspace);
}

/** @endcond */

/**
 * Returns the leading space (space at the beginning) of the mbuf.
 * Works on both packet header, and regular mbufs, as it accounts
 * for the additional space allocated to the packet header.
 *
 * @param __omp Is the mbuf pool (which contains packet header length.)
 * @param __om  Is the mbuf in that pool to get the leadingspace for
 *
 * @return Amount of leading space available in the mbuf
 */
#define OS_MBUF_LEADINGSPACE(__om) _os_mbuf_leadingspace(__om)


/** @cond INTERNAL_HIDDEN */

/* Called by OS_MBUF_TRAILINGSPACE() macro. */
static inline uint16_t
_os_mbuf_trailingspace(struct os_mbuf *om)
{
    struct os_mbuf_pool *omp;

    omp = om->om_omp;

    return (&om->om_databuf[0] + omp->omp_databuf_len) -
      (om->om_data + om->om_len);
}

/** @endcond */

/**
 * Returns the trailing space (space at the end) of the mbuf.
 * Works on both packet header and regular mbufs.
 *
 * @param __omp The mbuf pool for this mbuf
 * @param __om  Is the mbuf in that pool to get trailing space for
 *
 * @return The amount of trailing space available in the mbuf
 */
#define OS_MBUF_TRAILINGSPACE(__om) _os_mbuf_trailingspace(__om)


/**
 * Initializes an mqueue.  An mqueue is a queue of mbufs that ties to a
 * particular task's event queue.  Mqueues form a helper API around a common
 * paradigm: wait on an event queue until at least one packet is available,
 * then process a queue of packets.
 *
 * When mbufs are available on the queue, an event OS_EVENT_T_MQUEUE_DATA
 * will be posted to the task's mbuf queue.
 *
 * @param mq                    The mqueue to initialize
 * @param ev_cb                 The callback to associate with the mqeueue
 *                                  event.  Typically, this callback pulls each
 *                                  packet off the mqueue and processes them.
 * @param arg                   The argument to associate with the mqueue event.
 *
 * @return                      0 on success, non-zero on failure.
 */
int os_mqueue_init(struct os_mqueue *mq, os_event_fn *ev_cb, void *arg);

/**
 * Remove and return a single mbuf from the mbuf queue.  Does not block.
 *
 * @param mq The mbuf queue to pull an element off of.
 *
 * @return The next mbuf in the queue, or NULL if queue has no mbufs.
 */
struct os_mbuf *os_mqueue_get(struct os_mqueue *);

/**
 * Adds a packet (i.e. packet header mbuf) to an mqueue. The event associated
 * with the mqueue gets posted to the specified eventq.
 *
 * @param mq                    The mbuf queue to append the mbuf to.
 * @param evq                   The event queue to post an event to.
 * @param m                     The mbuf to append to the mbuf queue.
 *
 * @return 0 on success, non-zero on failure.
 */
int os_mqueue_put(struct os_mqueue *, struct os_eventq *, struct os_mbuf *);

/**
 * MSYS is a system level mbuf registry.  Allows the system to share
 * packet buffers amongst the various networking stacks that can be running
 * simultaeneously.
 *
 * Mbuf pools are created in the system initialization code, and then when
 * a mbuf is allocated out of msys, it will try and find the best fit based
 * upon estimated mbuf size.
 *
 * os_msys_register() registers a mbuf pool with MSYS, and allows MSYS to
 * allocate mbufs out of it.
 *
 * @param new_pool The pool to register with MSYS
 *
 * @return 0 on success, non-zero on failure
 */
int os_msys_register(struct os_mbuf_pool *);

/**
 * Allocate a mbuf from msys.  Based upon the data size requested,
 * os_msys_get() will choose the mbuf pool that has the best fit.
 *
 * @param dsize The estimated size of the data being stored in the mbuf
 * @param leadingspace The amount of leadingspace to allocate in the mbuf
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *os_msys_get(uint16_t dsize, uint16_t leadingspace);

/**
 * De-registers all mbuf pools from msys.
 */
void os_msys_reset(void);

/**
 * Allocate a packet header structure from the MSYS pool.  See
 * os_msys_register() for a description of MSYS.
 *
 * @param dsize The estimated size of the data being stored in the mbuf
 * @param user_hdr_len The length to allocate for the packet header structure
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *os_msys_get_pkthdr(uint16_t dsize, uint16_t user_hdr_len);

/**
 * Count the number of blocks in all the mbuf pools that are allocated.
 *
 * @return total number of blocks allocated in Msys
 */
int os_msys_count(void);

/**
 * Return the number of free blocks in Msys
 *
 * @return Number of free blocks available in Msys
 */
int os_msys_num_free(void);

/**
 * Initialize a pool of mbufs.
 *
 * @param omp     The mbuf pool to initialize
 * @param mp      The memory pool that will hold this mbuf pool
 * @param buf_len The length of the buffer itself.
 * @param nbufs   The number of buffers in the pool
 *
 * @return 0 on success, error code on failure.
 */
int os_mbuf_pool_init(struct os_mbuf_pool *, struct os_mempool *mp,
        uint16_t, uint16_t);

/**
 * Get an mbuf from the mbuf pool.  The mbuf is allocated, and initialized
 * prior to being returned.
 *
 * @param omp The mbuf pool to return the packet from
 * @param leadingspace The amount of leadingspace to put before the data
 *     section by default.
 *
 * @return An initialized mbuf on success, and NULL on failure.
 */
struct os_mbuf *os_mbuf_get(struct os_mbuf_pool *omp, uint16_t);

/**
 * Allocate a new packet header mbuf out of the os_mbuf_pool.
 *
 * @param omp The mbuf pool to allocate out of
 * @param user_pkthdr_len The packet header length to reserve for the caller.
 *
 * @return A freshly allocated mbuf on success, NULL on failure.
 */
struct os_mbuf *os_mbuf_get_pkthdr(struct os_mbuf_pool *omp,
        uint8_t pkthdr_len);

/**
 * Duplicate a chain of mbufs.  Return the start of the duplicated chain.
 *
 * @param omp The mbuf pool to duplicate out of
 * @param om  The mbuf chain to duplicate
 *
 * @return A pointer to the new chain of mbufs
 */
struct os_mbuf *os_mbuf_dup(struct os_mbuf *m);

/**
 * Locates the specified absolute offset within an mbuf chain.  The offset
 * can be one past than the total length of the chain, but no greater.
 *
 * @param om                    The start of the mbuf chain to seek within.
 * @param off                   The absolute address to find.
 * @param out_off               On success, this points to the relative offset
 *                                  within the returned mbuf.
 *
 * @return                      The mbuf containing the specified offset on
 *                                  success.
 *                              NULL if the specified offset is out of bounds.
 */
struct os_mbuf *os_mbuf_off(const struct os_mbuf *om, int off,
                            uint16_t *out_off);


/*
 * Copy data from an mbuf chain starting "off" bytes from the beginning,
 * continuing for "len" bytes, into the indicated buffer.
 *
 * @param m The mbuf chain to copy from
 * @param off The offset into the mbuf chain to begin copying from
 * @param len The length of the data to copy
 * @param dst The destination buffer to copy into
 *
 * @return                      0 on success;
 *                              -1 if the mbuf does not contain enough data.
 */
int os_mbuf_copydata(const struct os_mbuf *m, int off, int len, void *dst);

/**
 * @brief Calculates the length of an mbuf chain.
 *
 * Calculates the length of an mbuf chain.  If the mbuf contains a packet
 * header, you should use `OS_MBUF_PKTLEN()` as a more efficient alternative to
 * this function.
 *
 * @param om                    The mbuf to measure.
 *
 * @return                      The length, in bytes, of the provided mbuf
 *                                  chain.
 */
uint16_t os_mbuf_len(const struct os_mbuf *om);

/**
 * Append data onto a mbuf
 *
 * @param om   The mbuf to append the data onto
 * @param data The data to append onto the mbuf
 * @param len  The length of the data to append
 *
 * @return 0 on success, and an error code on failure
 */
int os_mbuf_append(struct os_mbuf *m, const void *, uint16_t);

/**
 * Reads data from one mbuf and appends it to another.  On error, the specified
 * data range may be partially appended.  Neither mbuf is required to contain
 * an mbuf packet header.
 *
 * @param dst                   The mbuf to append to.
 * @param src                   The mbuf to copy data from.
 * @param src_off               The absolute offset within the source mbuf
 *                                  chain to read from.
 * @param len                   The number of bytes to append.
 *
 * @return                      0 on success;
 *                              OS_EINVAL if the specified range extends beyond
 *                                  the end of the source mbuf chain.
 */
int os_mbuf_appendfrom(struct os_mbuf *dst, const struct os_mbuf *src,
                       uint16_t src_off, uint16_t len);

/**
 * Release a mbuf back to the pool
 *
 * @param omp The Mbuf pool to release back to
 * @param om  The Mbuf to release back to the pool
 *
 * @return 0 on success, -1 on failure
 */
int os_mbuf_free(struct os_mbuf *mb);

/**
 * Free a chain of mbufs
 *
 * @param omp The mbuf pool to free the chain of mbufs into
 * @param om  The starting mbuf of the chain to free back into the pool
 *
 * @return 0 on success, -1 on failure
 */
int os_mbuf_free_chain(struct os_mbuf *om);

/**
 * Adjust the length of a mbuf, trimming either from the head or the tail
 * of the mbuf.
 *
 * @param mp The mbuf chain to adjust
 * @param req_len The length to trim from the mbuf.  If positive, trims
 *                from the head of the mbuf, if negative, trims from the
 *                tail of the mbuf.
 */
void os_mbuf_adj(struct os_mbuf *mp, int req_len);


/**
 * Performs a memory compare of the specified region of an mbuf chain against a
 * flat buffer.
 *
 * @param om                    The start of the mbuf chain to compare.
 * @param off                   The offset within the mbuf chain to start the
 *                                  comparison.
 * @param data                  The flat buffer to compare.
 * @param len                   The length of the flat buffer.
 *
 * @return                      0 if both memory regions are identical;
 *                              A memcmp return code if there is a mismatch;
 *                              INT_MAX if the mbuf is too short.
 */
int os_mbuf_cmpf(const struct os_mbuf *om, int off, const void *data, int len);

/**
 * Compares the contents of two mbuf chains.  The ranges of the two chains to
 * be compared are specified via the two offset parameters and the len
 * parameter.  Neither mbuf chain is required to contain a packet header.
 *
 * @param om1                   The first mbuf chain to compare.
 * @param offset1               The absolute offset within om1 at which to
 *                                  start the comparison.
 * @param om2                   The second mbuf chain to compare.
 * @param offset2               The absolute offset within om2 at which to
 *                                  start the comparison.
 * @param len                   The number of bytes to compare.
 *
 * @return                      0 if both mbuf segments are identical;
 *                              A memcmp() return code if the segment contents
 *                                  differ;
 *                              INT_MAX if a specified range extends beyond the
 *                                  end of its corresponding mbuf chain.
 */
int os_mbuf_cmpm(const struct os_mbuf *om1, uint16_t offset1,
                 const struct os_mbuf *om2, uint16_t offset2,
                 uint16_t len);

/**
 * Increases the length of an mbuf chain by adding data to the front.  If there
 * is insufficient room in the leading mbuf, additional mbufs are allocated and
 * prepended as necessary.  If this function fails to allocate an mbuf, the
 * entire chain is freed.
 *
 * The specified mbuf chain does not need to contain a packet header.
 *
 * @param omp                   The mbuf pool to allocate from.
 * @param om                    The head of the mbuf chain.
 * @param len                   The number of bytes to prepend.
 *
 * @return                      The new head of the chain on success;
 *                              NULL on failure.
 */
struct os_mbuf *os_mbuf_prepend(struct os_mbuf *om, int len);

/**
 * Prepends a chunk of empty data to the specified mbuf chain and ensures the
 * chunk is contiguous.  If either operation fails, the specified mbuf chain is
 * freed and NULL is returned.
 *
 * @param om                    The mbuf chain to prepend to.
 * @param len                   The number of bytes to prepend and pullup.
 *
 * @return                      The modified mbuf on success;
 *                              NULL on failure (and the mbuf chain is freed).
 */
struct os_mbuf *os_mbuf_prepend_pullup(struct os_mbuf *om, uint16_t len);

/**
 * Copies the contents of a flat buffer into an mbuf chain, starting at the
 * specified destination offset.  If the mbuf is too small for the source data,
 * it is extended as necessary.  If the destination mbuf contains a packet
 * header, the header length is updated.
 *
 * @param omp                   The mbuf pool to allocate from.
 * @param om                    The mbuf chain to copy into.
 * @param off                   The offset within the chain to copy to.
 * @param src                   The source buffer to copy from.
 * @param len                   The number of bytes to copy.
 *
 * @return                      0 on success; nonzero on failure.
 */
int os_mbuf_copyinto(struct os_mbuf *om, int off, const void *src, int len);

/**
 * Attaches a second mbuf chain onto the end of the first.  If the first chain
 * contains a packet header, the header's length is updated.  If the second
 * chain has a packet header, its header is cleared.
 *
 * @param first                 The mbuf chain being attached to.
 * @param second                The mbuf chain that gets attached.
 */
void os_mbuf_concat(struct os_mbuf *first, struct os_mbuf *second);


/**
 * Increases the length of an mbuf chain by the specified amount.  If there is
 * not sufficient room in the last buffer, a new buffer is allocated and
 * appended to the chain.  It is an error to request more data than can fit in
 * a single buffer.
 *
 * @param omp
 * @param om                    The head of the chain to extend.
 * @param len                   The number of bytes to extend by.
 *
 * @return                      A pointer to the new data on success;
 *                              NULL on failure.
 */
void *os_mbuf_extend(struct os_mbuf *om, uint16_t len);

/**
 * Rearrange a mbuf chain so that len bytes are contiguous,
 * and in the data area of an mbuf (so that OS_MBUF_DATA() will
 * work on a structure of size len.)  Returns the resulting
 * mbuf chain on success, free's it and returns NULL on failure.
 *
 * If there is room, it will add up to "max_protohdr - len"
 * extra bytes to the contiguous region, in an attempt to avoid being
 * called next time.
 *
 * @param omp The mbuf pool to take the mbufs out of
 * @param om The mbuf chain to make contiguous
 * @param len The number of bytes in the chain to make contiguous
 *
 * @return The contiguous mbuf chain on success, NULL on failure.
 */
struct os_mbuf *os_mbuf_pullup(struct os_mbuf *om, uint16_t len);


/**
 * Removes and frees empty mbufs from the front of a chain.  If the chain
 * contains a packet header, it is preserved.
 *
 * @param om                    The mbuf chain to trim.
 *
 * @return                      The head of the trimmed mbuf chain.
 */
struct os_mbuf *os_mbuf_trim_front(struct os_mbuf *om);

/**
 * Increases the length of an mbuf chain by inserting a gap at the specified
 * offset.  The contents of the gap are indeterminate.  If the mbuf chain
 * contains a packet header, its total length is increased accordingly.
 *
 * This function never frees the provided mbuf chain.
 *
 * @param om                    The mbuf chain to widen.
 * @param off                   The offset at which to insert the gap.
 * @param len                   The size of the gap to insert.
 *
 * @return                      0 on success; SYS_[...] error code on failure.
 */
int os_mbuf_widen(struct os_mbuf *om, uint16_t off, uint16_t len);
# 654 "repos/apache-mynewt-core/kernel/os/include/os/os_mbuf.h"
/**
 *   @} OSMbuf
 * @} OSKernel
 */
# 131 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_mempool.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSMempool Memory Pools
 *   @{
 */



#define _OS_MEMPOOL_H_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 32 "repos/apache-mynewt-core/kernel/os/include/os/os_mempool.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_mempool.h" 2





/**
 * A memory block structure. This simply contains a pointer to the free list
 * chain and is only used when the block is on the free list. When the block
 * has been removed from the free list the entire memory block is usable by the
 * caller.
 */
struct os_memblock {
    struct { struct os_memblock *sle_next; /* next element */ } mb_next;
};

/* XXX: Change this structure so that we keep the first address in the pool? */
/* XXX: add memory debug structure and associated code */
/* XXX: Change how I coded the SLIST_HEAD here. It should be named:
   SLIST_HEAD(,os_memblock) mp_head; */

/**
 * Memory pool
 */
struct os_mempool {
    /** Size of the memory blocks, in bytes. */
    uint32_t mp_block_size;
    /** The number of memory blocks. */
    uint16_t mp_num_blocks;
    /** The number of free blocks left */
    uint16_t mp_num_free;
    /** The lowest number of free blocks seen */
    uint16_t mp_min_free;
    /** Bitmap of OS_MEMPOOL_F_[...] values. */
    uint8_t mp_flags;
    /** Address of memory buffer used by pool */
    uint32_t mp_membuf_addr;
    struct { struct os_mempool *stqe_next; /* next element */ } mp_list;
    struct { struct os_memblock *slh_first; /* first element */ };
    /** Name for memory block */
    char *name;
};

/**
 * Indicates an extended mempool.  Address can be safely cast to
 * (struct os_mempool_ext *).
 */
#define OS_MEMPOOL_F_EXT 0x01

struct os_mempool_ext;

/**
 * Block put callback function.  If configured, this callback gets executed
 * whenever a block is freed to the corresponding extended mempool.  Note: The
 * os_memblock_put() function calls this callback instead of freeing the block
 * itself.  Therefore, it is the callback's responsibility to free the block
 * via a call to os_memblock_put_from_cb().
 *
 * @param ome                   The extended mempool that a block is being
 *                                  freed back to.
 * @param data                  The block being freed.
 * @param arg                   Optional argument configured along with the
 *                                  callback.
 *
 * @return                      Indicates whether the block was successfully
 *                                  freed.  A non-zero value should only be
 *                                  returned if the block was not successfully
 *                                  released back to its pool.
 */
typedef os_error_t os_mempool_put_fn(struct os_mempool_ext *ome, void *data,
                                     void *arg);

struct os_mempool_ext {
    struct os_mempool mpe_mp;

    /* Callback that is executed immediately when a block is freed. */
    os_mempool_put_fn *mpe_put_cb;
    void *mpe_put_arg;
};

#define OS_MEMPOOL_INFO_NAME_LEN (32)

/**
 * Information describing a memory pool, used to return OS information
 * to the management layer.
 */
struct os_mempool_info {
    /** Size of the memory blocks in the pool */
    int omi_block_size;
    /** Number of memory blocks in the pool */
    int omi_num_blocks;
    /** Number of free memory blocks */
    int omi_num_free;
    /** Minimum number of free memory blocks ever */
    int omi_min_free;
    /** Name of the memory pool */
    char omi_name[(32)];
};

/**
 * Get information about the next system memory pool.
 *
 * @param mempool The current memory pool, or NULL if starting iteration.
 * @param info    A pointer to the structure to return memory pool information
 *                into.
 *
 * @return The next memory pool in the list to get information about, or NULL
 *         when at the last memory pool.
 */
struct os_mempool *os_mempool_info_get_next(struct os_mempool *,
        struct os_mempool_info *);

/*
 * To calculate size of the memory buffer needed for the pool. NOTE: This size
 * is NOT in bytes! The size is the number of os_membuf_t elements required for
 * the memory pool.
 */






#define OS_MEMPOOL_BLOCK_SZ(sz) (sz)


#define OS_MEMPOOL_SIZE(n,blksize) (((OS_MEMPOOL_BLOCK_SZ(blksize) + 3) / 4) * (n))

typedef uint32_t os_membuf_t;






/** Calculates the number of bytes required to initialize a memory pool. */
#define OS_MEMPOOL_BYTES(n,blksize) (sizeof (os_membuf_t) * OS_MEMPOOL_SIZE((n), (blksize)))



/**
 * Initialize a memory pool.
 *
 * @param mp            Pointer to a pointer to a mempool
 * @param blocks        The number of blocks in the pool
 * @param blocks_size   The size of the block, in bytes.
 * @param membuf        Pointer to memory to contain blocks.
 * @param name          Name of the pool.
 *
 * @return os_error_t
 */
os_error_t os_mempool_init(struct os_mempool *mp, uint16_t blocks,
                           uint32_t block_size, void *membuf, char *name);

/**
 * Initializes an extended memory pool.  Extended attributes (e.g., callbacks)
 * are not specified when this function is called; they are assigned manually
 * after initialization.
 *
 * @param mpe           The extended memory pool to initialize.
 * @param blocks        The number of blocks in the pool.
 * @param block_size    The size of each block, in bytes.
 * @param membuf        Pointer to memory to contain blocks.
 * @param name          Name of the pool.
 *
 * @return os_error_t
 */
os_error_t os_mempool_ext_init(struct os_mempool_ext *mpe, uint16_t blocks,
                               uint32_t block_size, void *membuf, char *name);

/**
 * Removes the specified mempool from the list of initialized mempools.
 *
 * @param mp                    The mempool to unregister.
 *
 * @return                      0 on success;
 *                              OS_INVALID_PARM if the mempool is not
 *                                  registered.
 */
os_error_t os_mempool_unregister(struct os_mempool *mp);

/**
 * Clears a memory pool.
 *
 * @param mp            The mempool to clear.
 *
 * @return os_error_t
 */
os_error_t os_mempool_clear(struct os_mempool *mp);

/**
 * Performs an integrity check of the specified mempool.  This function
 * attempts to detect memory corruption in the specified memory pool.
 *
 * @param mp                    The mempool to check.
 *
 * @return                      true if the memory pool passes the integrity
 *                                  check;
 *                              false if the memory pool is corrupt.
 */

# 232 "repos/apache-mynewt-core/kernel/os/include/os/os_mempool.h" 3 4
_Bool 
# 232 "repos/apache-mynewt-core/kernel/os/include/os/os_mempool.h"
    os_mempool_is_sane(const struct os_mempool *mp);

/**
 * Checks if a memory block was allocated from the specified mempool.
 *
 * @param mp                    The mempool to check as parent.
 * @param block_addr            The memory block to check as child.
 *
 * @return                      0 if the block does not belong to the mempool;
 *                              1 if the block does belong to the mempool.
 */
int os_memblock_from(const struct os_mempool *mp, const void *block_addr);

/**
 * Get a memory block from a memory pool
 *
 * @param mp Pointer to the memory pool
 *
 * @return void* Pointer to block if available; NULL otherwise
 */
void *os_memblock_get(struct os_mempool *mp);

/**
 * Puts the memory block back into the pool, ignoring the put callback, if any.
 * This function should only be called from a put callback to free a block
 * without causing infinite recursion.
 *
 * @param mp Pointer to memory pool
 * @param block_addr Pointer to memory block
 *
 * @return os_error_t
 */
os_error_t os_memblock_put_from_cb(struct os_mempool *mp, void *block_addr);

/**
 * Puts the memory block back into the pool
 *
 * @param mp Pointer to memory pool
 * @param block_addr Pointer to memory block
 *
 * @return os_error_t
 */
os_error_t os_memblock_put(struct os_mempool *mp, void *block_addr);
# 283 "repos/apache-mynewt-core/kernel/os/include/os/os_mempool.h"
/**
 *   @} OSMempool
 * @} OSKernel
 */
# 132 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_mutex.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSMutex Mutexes
 *   @{
 */


#define _OS_MUTEX_H_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 31 "repos/apache-mynewt-core/kernel/os/include/os/os_mutex.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 32 "repos/apache-mynewt-core/kernel/os/include/os/os_mutex.h" 2





/**
 * OS mutex structure
 */
struct os_mutex {
    struct { struct os_task *slh_first; /* first element */ } mu_head;
    uint8_t _pad;
    /** Mutex owner's default priority */
    uint8_t mu_prio;
    /** Mutex call nesting level */
    uint16_t mu_level;
    /** Task that owns the mutex */
    struct os_task *mu_owner;
};

/*
  XXX: NOTES
    -> Should we add a magic number or flag to the mutex structure so
    that we know that this is a mutex? We can use it for double checking
    that a proper mutex was passed in to the API.
    -> What debug information should we add to this structure? Who last
    acquired the mutex? File/line where it was released?
    -> Should we add a name to the mutex?
    -> Should we add a "os_mutex_inspect() api?
*/

/* XXX: api to create
os_mutex_inspect();
*/

/**
 * Create a mutex and initialize it.
 *
 * @param mu Pointer to mutex
 *
 * @return os_error_t
 *      OS_INVALID_PARM     Mutex passed in was NULL.
 *      OS_OK               no error.
 */
os_error_t os_mutex_init(struct os_mutex *mu);

/**
 * Release a mutex.
 *
 * @param mu Pointer to the mutex to be released
 *
 * @return os_error_t
 *      OS_INVALID_PARM Mutex passed in was NULL.
 *      OS_BAD_MUTEX    Mutex was not granted to current task (not owner).
 *      OS_OK           No error
 */
os_error_t os_mutex_release(struct os_mutex *mu);

/**
 * Pend (wait) for a mutex.
 *
 * @param mu Pointer to mutex.
 * @param timeout Timeout, in os ticks.
 *                A timeout of 0 means do not wait if not available.
 *                A timeout of OS_TIMEOUT_NEVER means wait forever.
 *
 *
 * @return os_error_t
 *      OS_INVALID_PARM     Mutex passed in was NULL.
 *      OS_TIMEOUT          Mutex was owned by another task and timeout=0
 *      OS_OK               no error.
 */
os_error_t os_mutex_pend(struct os_mutex *mu, os_time_t timeout);

/**
 * Get mutex lock count.
 *
 * @note Function should be called from task owning the mutex (one that
 * successfully called os_mutex_pend). Calling function from other task
 * that does not own the mutex will return value that has little value
 * to the caller since value can change at any time by other task.
 *
 * It can also be called from interrupt context to check if given mutex
 * is taken.
 *
 * @param mu Pointer to mutex.
 *
 * @return number of times lock was called from current task
 */
static inline os_error_t os_mutex_get_level(struct os_mutex *mu)
{
    return (os_error_t) mu->mu_level;
}
# 133 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_sanity.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSSanity Sanity
 *   @{
 */


#define _OS_SANITY_H 



# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*-
 * Copyright (c) 1982, 1986, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)time.h      8.5 (Berkeley) 5/4/95
 * $FreeBSD$
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSTime Time
 *   @{
 */
# 359 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
/**
 *   @} OSKernel
 * @} OSTime
 */
# 34 "repos/apache-mynewt-core/kernel/os/include/os/os_sanity.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 35 "repos/apache-mynewt-core/kernel/os/include/os/os_sanity.h" 2





struct os_sanity_check;
typedef int (*os_sanity_check_func_t)(struct os_sanity_check *, void *);

struct os_sanity_check {
    /** Time this check last ran successfully. */
    os_time_t sc_checkin_last;
    /** Interval this task should check in at */
    os_time_t sc_checkin_itvl;
    /** Sanity check to run */
    os_sanity_check_func_t sc_func;
    /** Argument to pass to sanity check */
    void *sc_arg;

    struct { struct os_sanity_check *sle_next; /* next element */ } sc_next;

};

#define OS_SANITY_CHECK_SETFUNC(__sc,__f,__arg,__itvl) (__sc)->sc_func = (__f); (__sc)->sc_arg = (__arg); (__sc)->sc_checkin_itvl = (__itvl) * OS_TICKS_PER_SEC;




/** @cond INTERNAL_HIDDEN */
int os_sanity_init(void);
void os_sanity_run(void);
/** @endcond */

struct os_task;

/**
 * Provide a "task checkin" for the sanity task.
 *
 * @param t The task to check in
 *
 * @return 0 on success, error code on failure
 */
int os_sanity_task_checkin(struct os_task *);

/**
 * Initialize a sanity check
 *
 * @param sc The sanity check to initialize
 *
 * @return 0 on success, error code on failure.
 */
int os_sanity_check_init(struct os_sanity_check *);

/**
 * Register a sanity check
 *
 * @param sc The sanity check to register
 *
 * @return 0 on success, error code on failure
 */
int os_sanity_check_register(struct os_sanity_check *);

/**
 * Reset the os sanity check, so that it doesn't trip up the
 * sanity timer.
 *
 * @param sc The sanity check to reset
 *
 * @return 0 on success, error code on failure
 */
int os_sanity_check_reset(struct os_sanity_check *);
# 113 "repos/apache-mynewt-core/kernel/os/include/os/os_sanity.h"
/**
 *   @} OSSanity
 * @} OSKernel
 */
# 134 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_sched.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

 /**
  * @addtogroup OSKernel
  * @{
  *   @defgroup OSSched Scheduler
  *   @{
  */


#define _OS_SCHED_H 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSTask Tasks
 *   @{
 */


#define _OS_TASK_H 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 32 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_sanity.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSSanity Sanity
 *   @{
 */
# 113 "repos/apache-mynewt-core/kernel/os/include/os/os_sanity.h"
/**
 *   @} OSSanity
 * @} OSKernel
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/arch/cortex_m3/os/os_arch.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 34 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 35 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h" 2





#define OS_TASK_STACK_DEFINE_NOSTATIC(__name,__size) os_stack_t __name [OS_STACK_ALIGN(__size)] __attribute__((aligned(OS_STACK_ALIGNMENT)))



#define OS_TASK_STACK_DEFINE(__name,__size) static OS_TASK_STACK_DEFINE_NOSTATIC(__name, __size);


/** Highest priority task */
#define OS_TASK_PRI_HIGHEST (0)
/** Lowest priority task */
#define OS_TASK_PRI_LOWEST (0xff)

/*
 * Generic "object" structure. All objects that a task can wait on must
 * have a SLIST_HEAD(, os_task) head_name as the first element in the object
 * structure. The element 'head_name' can be any name. See os_mutex.h or
 * os_sem.h for an example.
 */
struct os_task_obj {
    struct { struct os_task *slh_first; /* first element */ } obj_head; /* chain of waiting tasks */
};

/** Task states */
typedef enum os_task_state {
    /** Task is ready to run */
    OS_TASK_READY = 1,
    /** Task is sleeping */
    OS_TASK_SLEEP = 2,
} os_task_state_t;

/* Task flags */
#define OS_TASK_FLAG_NO_TIMEOUT (0x01U)
/** Task waiting on a semaphore */
#define OS_TASK_FLAG_SEM_WAIT (0x02U)
/** Task waiting on a mutex */
#define OS_TASK_FLAG_MUTEX_WAIT (0x04U)
/** Task waiting on a event queue */
#define OS_TASK_FLAG_EVQ_WAIT (0x08U)

typedef void (*os_task_func_t)(void *);

#define OS_TASK_MAX_NAME_LEN (32)

/**
 * Structure containing information about a running task
 */
struct os_task {
    /** Current stack pointer for this task */
    os_stack_t *t_stackptr;
    /** Pointer to top of this task's stack */
    os_stack_t *t_stacktop;
    /** Size of this task's stack */
    uint16_t t_stacksize;
    /** Task ID */
    uint8_t t_taskid;
    /** Task Priority */
    uint8_t t_prio;
    /* Task state, either READY or SLEEP */
    uint8_t t_state;
    /** Task flags, bitmask */
    uint8_t t_flags;
    uint8_t t_lockcnt;
    uint8_t t_pad;

    /** Task name */
    const char *t_name;
    /** Task function that executes */
    os_task_func_t t_func;
    /** Argument to pass to task function when called */
    void *t_arg;

    /** Current object task is waiting on, either a semaphore or mutex */
    void *t_obj;

    /** Default sanity check for this task */
    struct os_sanity_check t_sanity_check;

    /** Next scheduled wakeup if this task is sleeping */
    os_time_t t_next_wakeup;
    /** Total task run time */
    os_time_t t_run_time;
    /**
     * Total number of times this task has been context switched during
     * execution.
     */
    uint32_t t_ctx_sw_cnt;

    struct { struct os_task *stqe_next; /* next element */ } t_os_task_list;
    struct { struct os_task *tqe_next; /* next element */ struct os_task **tqe_prev; /* address of previous next element */ } t_os_list;
    struct { struct os_task *sle_next; /* next element */ } t_obj_list;
};

/** @cond INTERNAL_HIDDEN */
struct os_task_stailq { struct os_task *stqh_first;/* first element */ struct os_task **stqh_last;/* addr of last next element */ };

extern struct os_task_stailq g_os_task_list;
/** @endcond */

/**
 * Initialize a task.
 *
 * This function initializes the task structure pointed to by t,
 * clearing and setting it's stack pointer, provides sane defaults
 * and sets the task as ready to run, and inserts it into the operating
 * system scheduler.
 *
 * @param t The task to initialize
 * @param name The name of the task to initialize
 * @param func The task function to call
 * @param arg The argument to pass to this task function
 * @param prio The priority at which to run this task
 * @param sanity_itvl The time at which this task should check in with the
 *                    sanity task.  OS_WAIT_FOREVER means never check in
 *                    here.
 * @param stack_bottom A pointer to the bottom of a task's stack
 * @param stack_size The overall size of the task's stack.
 *
 * @return 0 on success, non-zero on failure.
 */
int os_task_init(struct os_task *, const char *, os_task_func_t, void *,
        uint8_t, os_time_t, os_stack_t *, uint16_t);

/**
 * Removes specified task
 * XXX
 * NOTE: This interface is currently experimental and not ready for common use
 */
int os_task_remove(struct os_task *t);

/**
 * Return the number of tasks initialized.
 *
 * @return number of tasks initialized
 */
uint8_t os_task_count(void);

/**
 * Information about an individual task, returned for management APIs.
 */
struct os_task_info {
    /** Task priority */
    uint8_t oti_prio;
    /** Task identifier */
    uint8_t oti_taskid;
    /** Task state, either READY or SLEEP */
    uint8_t oti_state;
    /** Task stack usage */
    uint16_t oti_stkusage;
    /** Task stack size */
    uint16_t oti_stksize;
    /** Task context switch count */
    uint32_t oti_cswcnt;
    /** Task runtime */
    uint32_t oti_runtime;
    /** Last time this task checked in with sanity */
    os_time_t oti_last_checkin;
    /** Next time this task is scheduled to check-in with sanity */
    os_time_t oti_next_checkin;
    /** Name of this task */
    char oti_name[(32)];
};

/**
 * Iterate through tasks, and return the following information about them:
 *
 * - Priority
 * - Task ID
 * - State (READY, SLEEP)
 * - Total Stack Usage
 * - Stack Size
 * - Context Switch Count
 * - Runtime
 * - Last & Next Sanity checkin
 * - Task Name
 *
 * To get the first task in the list, call os_task_info_get_next() with a
 * NULL pointer in the prev argument, and os_task_info_get_next() will
 * return a pointer to the task structure, and fill out the os_task_info
 * structure pointed to by oti.
 *
 * To get the next task in the list, provide the task structure returned
 * by the previous call to os_task_info_get_next(), and os_task_info_get_next()
 * will fill out the task structure pointed to by oti again, and return
 * the next task in the list.
 *
 * @param prev The previous task returned by os_task_info_get_next(), or NULL
 *             to begin iteration.
 * @param oti  The OS task info structure to fill out.
 *
 * @return A pointer to the OS task that has been read, or NULL when finished
 *         iterating through all tasks.
 */
struct os_task *os_task_info_get_next(const struct os_task *,
        struct os_task_info *);
# 242 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h"
/**
 *   @} OSTask
 * @} OSKernel
 */
# 31 "repos/apache-mynewt-core/kernel/os/include/os/os_sched.h" 2






/** @cond INTERNAL_HIDDEN */
struct os_task;

struct os_task_list { struct os_task *tqh_first; /* first element */ struct os_task **tqh_last; /* addr of last next element */ };

extern struct os_task *g_current_task;
extern struct os_task_list g_os_run_list;
extern struct os_task_list g_os_sleep_list;

void os_sched_ctx_sw_hook(struct os_task *);

/** @endcond */

/**
 * Returns the currently running task. Note that this task may or may not be
 * the highest priority task ready to run.
 *
 * @return The currently running task.
 */
struct os_task *os_sched_get_current_task(void);
void os_sched_set_current_task(struct os_task *);
struct os_task *os_sched_next_task(void);

/**
 * Performs context switch if needed. If next_t is set, that task will be made
 * running. If next_t is NULL, highest priority ready to run is swapped in. This
 * function can be called when new tasks were made ready to run or if the current
 * task is moved to sleeping state.
 *
 * This function will call the architecture specific routine to swap in the new task.
 *
 * @param next_t Pointer to task which must run next (optional)
 *
 * @return n/a
 *
 * @note Interrupts must be disabled when calling this.
 *
 * @code{.c}
 * // example
 * os_error_t
 * os_mutex_release(struct os_mutex *mu)
 * {
 *     ...
 *     OS_EXIT_CRITICAL(sr);
 *
 *     // Re-schedule if needed
 *     if (resched) {
 *         os_sched(rdy);
 *     }
 *
 *     return OS_OK;
 *
 * }
 * @endcode
 */
void os_sched(struct os_task *);

/** @cond INTERNAL_HIDDEN */
void os_sched_os_timer_exp(void);
os_error_t os_sched_insert(struct os_task *);
int os_sched_sleep(struct os_task *, os_time_t nticks);
int os_sched_wakeup(struct os_task *);
int os_sched_remove(struct os_task *);
void os_sched_resort(struct os_task *);
os_time_t os_sched_wakeup_ticks(os_time_t now);

/** @endcond */







/**
 *   @} OSSched
 * @} OSKernel
 */
# 135 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_sem.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSSem Semaphores
 *   @{
 */


#define _OS_SEM_H_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 31 "repos/apache-mynewt-core/kernel/os/include/os/os_sem.h" 2





/**
 * Structure representing an OS semaphore.
 */
struct os_sem {
    struct { struct os_task *slh_first; /* first element */ } sem_head;
    uint16_t _pad;
    /** Number of tokens */
    uint16_t sem_tokens;
};

/*
  XXX: NOTES
    -> Should we add a magic number or flag to the semaphore structure so
    that we know that this is a semaphore? We can use it for double checking
    that a proper semaphore was passed in to the API.
    -> What debug information should we add to this structure? Who last
    acquired the semaphore? File/line where it was released?
    -> Should we add a name to the semaphore?
    -> Should we add a "os_sem_inspect() api, like ucos?
*/

/**
 * Initialize a semaphore
 *
 * @param sem Pointer to semaphore
 *        tokens: # of tokens the semaphore should contain initially.
 *
 * @return os_error_t
 *      OS_INVALID_PARM     Semaphore passed in was NULL.
 *      OS_OK               no error.
 */
os_error_t os_sem_init(struct os_sem *sem, uint16_t tokens);

/**
 * Release a semaphore.
 *
 * @param sem Pointer to the semaphore to be released
 *
 * @return os_error_t
 *      OS_INVALID_PARM Semaphore passed in was NULL.
 *      OS_OK No error
 */
os_error_t os_sem_release(struct os_sem *sem);

/**
 * os sem pend
 *
 * Pend (wait) for a semaphore.
 *
 * @param mu Pointer to semaphore.
 * @param timeout Timeout, in os ticks.
 *                A timeout of 0 means do not wait if not available.
 *                A timeout of OS_TIMEOUT_NEVER means wait forever.
 *
 *
 * @return os_error_t
 *      OS_INVALID_PARM     Semaphore passed in was NULL.
 *      OS_TIMEOUT          Semaphore was owned by another task and timeout=0
 *      OS_OK               no error.
 */
os_error_t os_sem_pend(struct os_sem *sem, os_time_t timeout);

/**
 * Get current semaphore's count
 */
static inline uint16_t os_sem_get_count(struct os_sem *sem)
{
    return sem->sem_tokens;
}
# 113 "repos/apache-mynewt-core/kernel/os/include/os/os_sem.h"
/**
 *   @} OSSem
 * @} OSKernel
 */
# 136 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSTask Tasks
 *   @{
 */
# 242 "repos/apache-mynewt-core/kernel/os/include/os/os_task.h"
/**
 *   @} OSTask
 * @} OSKernel
 */
# 137 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*-
 * Copyright (c) 1982, 1986, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)time.h      8.5 (Berkeley) 5/4/95
 * $FreeBSD$
 */


/**
 * @addtogroup OSKernel
 * @{
 *   @defgroup OSTime Time
 *   @{
 */
# 359 "repos/apache-mynewt-core/kernel/os/include/os/os_time.h"
/**
 *   @} OSKernel
 * @} OSTime
 */
# 138 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define OS_TRACE_API_H 
# 31 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h"
# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 1
/*
 * stdio.h
 */


#define _STDIO_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/extern.h" 1
/*
 * klibc/extern.h
 */
# 9 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/inline.h" 1
/*
 * klibc/inline.h
 */
# 10 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdarg.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdarg.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */




#define _STDARG_H 
#define _ANSI_STDARG_H_ 

#undef __need___va_list

/* Define __gnuc_va_list.  */


#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;


/* Define the standard macros for the user,
   if this invocation was from the user program.  */


#define va_start(v,l) __builtin_va_start(v,l)
#define va_end(v) __builtin_va_end(v)
#define va_arg(v,l) __builtin_va_arg(v,l)


#define va_copy(d,s) __builtin_va_copy(d,s)

#define __va_copy(d,s) __builtin_va_copy(d,s)

/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */
# 86 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdarg.h" 3 4
/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */

/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */

/* The macro _VA_LIST is used in SCO Unix 3.2.  */

/* The macro _VA_LIST_T_H is used in the Bull dpx2  */

/* The macro __va_list__ is used by BeOS.  */

typedef __gnuc_va_list va_list;





#define _VA_LIST_ 


#define _VA_LIST 


#define _VA_LIST_DEFINED 


#define _VA_LIST_T_H 


#define __va_list__ 
# 11 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 12 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/string.h" 1

# 1 "repos/apache-mynewt-core/libc/baselibc/include/string.h"
/*
 * string.h
 */


#define _STRING_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/extern.h" 1
/*
 * klibc/extern.h
 */
# 9 "repos/apache-mynewt-core/libc/baselibc/include/string.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 10 "repos/apache-mynewt-core/libc/baselibc/include/string.h" 2






# 15 "repos/apache-mynewt-core/libc/baselibc/include/string.h"
extern void *memccpy(void *, const void *, int, size_t);
extern void *memchr(const void *, int, size_t);
extern void *memrchr(const void *, int, size_t);
extern int memcmp(const void *, const void *, size_t);
extern void *memcpy(void *, const void *, size_t);
extern void *memmove(void *, const void *, size_t);
extern void *memset(void *, int, size_t);
extern void *memmem(const void *, size_t, const void *, size_t);
extern void memswap(void *, void *, size_t);
extern void bzero(void *, size_t);
extern int strcasecmp(const char *, const char *);
extern int strncasecmp(const char *, const char *, size_t);
extern char *strcat(char *, const char *);
extern char *strchr(const char *, int);
extern char *index(const char *, int);
extern char *strrchr(const char *, int);
extern char *rindex(const char *, int);
extern int strcmp(const char *, const char *);
extern char *strcpy(char *, const char *);
extern size_t strcspn(const char *, const char *);
extern char *strdup(const char *);
extern char *strndup(const char *, size_t);
extern size_t strlen(const char *);
extern size_t strnlen(const char *, size_t);
extern char *strncat(char *, const char *, size_t);
extern size_t strlcat(char *, const char *, size_t);
extern int strncmp(const char *, const char *, size_t);
extern char *strncpy(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);
extern char *strpbrk(const char *, const char *);
extern char *strsep(char **, const char *);
extern size_t strspn(const char *, const char *);
extern char *strstr(const char *, const char *);
extern char *strnstr(const char *, const char *, size_t);
extern char *strtok(char *, const char *);
extern char *strtok_r(char *, const char *, char **);

/* Some dummy functions to avoid errors with C++ cstring */
inline static int strcoll(const char *s1, const char *s2)
{
 return strcmp(s1, s2);
}

inline static size_t strxfrm(char *dest, const char *src, size_t n)
{
 strncpy(dest, src, n);
 return strlen(src);
}
# 13 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 2





/* The File structure is designed to be compatible with ChibiOS/RT type
 * BaseSequentialStream.
 */
struct File;

typedef struct File FILE;

struct File_methods
{
    size_t (*write)(FILE* instance, const char *bp, size_t n);
    size_t (*read)(FILE* instance, char *bp, size_t n);
};

struct File
{
    const struct File_methods *vmt;
};


#define EOF (-1)



#define BUFSIZ 1


/* Standard file descriptors - implement these globals yourself. */
extern FILE* const stdin;
extern FILE* const stdout;
extern FILE* const stderr;

/* Wrappers around stream write and read */
extern inline __attribute__((gnu_inline)) size_t fread(void *buf, size_t size, size_t nmemb, FILE *stream)
{
    if (stream->vmt->read == 
# 52 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 3 4
                            ((void *)0)
# 52 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h"
                                ) return 0;
    return stream->vmt->read(stream, (char*)buf, size*nmemb) / size;
}

extern inline __attribute__((gnu_inline)) size_t fwrite(const void *buf, size_t size, size_t nmemb, FILE *stream)
{
    if (stream->vmt->write == 
# 58 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 3 4
                             ((void *)0)
# 58 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h"
                                 ) return 0;
    return stream->vmt->write(stream, (char*)buf, size*nmemb) / size;
}

extern inline __attribute__((gnu_inline)) int fputs(const char *s, FILE *f)
{
 return fwrite(s, 1, strlen(s), f);
}

extern inline __attribute__((gnu_inline)) int puts(const char *s)
{
 return fwrite(s, 1, strlen(s), stdout) + fwrite("\n", 1, 1, stdout);
}

extern inline __attribute__((gnu_inline)) int fputc(int c, FILE *f)
{
 unsigned char ch = c;
 return fwrite(&ch, 1, 1, f) == 1 ? ch : (-1);
}

extern char *fgets(char *, int, FILE *);
extern inline __attribute__((gnu_inline)) int fgetc(FILE *f)
{
 unsigned char ch;
 return fread(&ch, 1, 1, f) == 1 ? ch : (-1);
}

extern int errno;
extern inline __attribute__((gnu_inline)) char *strerror(int errnum)
{
 return (char*)"error_str";
}

#define putc(c,f) fputc((c),(f))
#define putchar(c) fputc((c),stdout)
#define getc(f) fgetc(f)
#define getchar() fgetc(stdin)

extern inline __attribute__((gnu_inline)) int fflush(FILE *stream)
{
 return 0;
}

extern int printf(const char *, ...);
extern int vprintf(const char *, va_list);
extern int fprintf(FILE *, const char *, ...);
extern int vfprintf(FILE *, const char *, va_list);
extern int sprintf(char *, const char *, ...);
extern int vsprintf(char *, const char *, va_list);
extern int snprintf(char *, size_t n, const char *, ...);
extern int vsnprintf(char *, size_t n, const char *, va_list);
extern int asprintf(char **, const char *, ...);
extern int vasprintf(char **, const char *, va_list);

extern int sscanf(const char *, const char *, ...);
extern int vsscanf(const char *, const char *, va_list);

/* Open a memory buffer for writing.
 Note: Does not write null terminator.*/
struct MemFile
{
    struct File file;
    char *buffer;
    size_t bytes_written;
    size_t size;
};

FILE *fmemopen_w(struct MemFile* storage, char *buffer, size_t size);
# 32 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/string.h" 1
/*
 * string.h
 */
# 33 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h" 2
# 1 "bin/targets/bluepill_my_sensor/generated/include/syscfg/syscfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */
# 34 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h" 2



# 1 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 38 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h" 2

#define OS_TRACE_ID_EVENTQ_PUT (40)
#define OS_TRACE_ID_EVENTQ_GET_NO_WAIT (41)
#define OS_TRACE_ID_EVENTQ_GET (42)
#define OS_TRACE_ID_EVENTQ_REMOVE (43)
#define OS_TRACE_ID_EVENTQ_POLL_0TIMO (44)
#define OS_TRACE_ID_EVENTQ_POLL (45)
#define OS_TRACE_ID_MUTEX_INIT (50)
#define OS_TRACE_ID_MUTEX_RELEASE (51)
#define OS_TRACE_ID_MUTEX_PEND (52)
#define OS_TRACE_ID_SEM_INIT (60)
#define OS_TRACE_ID_SEM_RELEASE (61)
#define OS_TRACE_ID_SEM_PEND (62)
#define OS_TRACE_ID_CALLOUT_INIT (70)
#define OS_TRACE_ID_CALLOUT_STOP (71)
#define OS_TRACE_ID_CALLOUT_RESET (72)
#define OS_TRACE_ID_CALLOUT_TICK (73)
#define OS_TRACE_ID_MEMBLOCK_GET (80)
#define OS_TRACE_ID_MEMBLOCK_PUT_FROM_CB (81)
#define OS_TRACE_ID_MEMBLOCK_PUT (82)
#define OS_TRACE_ID_MBUF_GET (90)
#define OS_TRACE_ID_MBUF_GET_PKTHDR (91)
#define OS_TRACE_ID_MBUF_FREE (92)
#define OS_TRACE_ID_MBUF_FREE_CHAIN (93)
# 209 "repos/apache-mynewt-core/kernel/os/include/os/os_trace_api.h"
static inline void
os_trace_isr_enter(void)
{
}

static inline void
os_trace_isr_exit(void)
{
}

static inline void
os_trace_task_info(const struct os_task *t)
{
}

static inline void
os_trace_task_create(const struct os_task *t)
{
}

static inline void
os_trace_task_start_exec(const struct os_task *t)
{
}

static inline void
os_trace_task_stop_exec(void)
{
}

static inline void
os_trace_task_start_ready(const struct os_task *t)
{
}

static inline void
os_trace_task_stop_ready(const struct os_task *t, unsigned reason)
{
}

static inline void
os_trace_idle(void)
{
}

static inline void
os_trace_user_start(unsigned id)
{
}

static inline void
os_trace_user_stop(unsigned id)
{
}





static inline void
os_trace_api_void(unsigned id)
{
}

static inline void
os_trace_api_u32(unsigned id, uint32_t p0)
{
}

static inline void
os_trace_api_u32x2(unsigned id, uint32_t p0, uint32_t p1)
{
}

static inline void
os_trace_api_u32x3(unsigned id, uint32_t p0, uint32_t p1, uint32_t p2)
{
}

static inline void
os_trace_api_ret(unsigned id)
{
}

static inline void
os_trace_api_ret_u32(unsigned id, uint32_t return_value)
{
}
# 139 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/queue.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 140 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/util.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_OS_UTIL_ 

/* Helpers to pass integers as pointers and vice-versa */
#define POINTER_TO_UINT(p) ((unsigned int) ((uintptr_t) (p)))
#define UINT_TO_POINTER(u) ((void *) ((uintptr_t) (u)))
#define POINTER_TO_INT(p) ((int) ((intptr_t) (p)))
#define INT_TO_POINTER(u) ((void *) ((intptr_t) (u)))

/* Helper to retrieve pointer to "parent" object in structure */
#define CONTAINER_OF(ptr,type,field) ((type *)(((char *)(ptr)) - offsetof(type, field)))


/* Helper to calculate number of elements in array */

#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
# 141 "repos/apache-mynewt-core/kernel/os/include/os/os.h" 2
# 28 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 1 "repos/apache-mynewt-core/sys/defs/include/defs/error.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_DEFS_ERROR_ 





#define SYS_EOK (0)
#define SYS_ENOMEM (-1)
#define SYS_EINVAL (-2)
#define SYS_ETIMEOUT (-3)
#define SYS_ENOENT (-4)
#define SYS_EIO (-5)
#define SYS_EAGAIN (-6)
#define SYS_EACCES (-7)
#define SYS_EBUSY (-8)
#define SYS_ENODEV (-9)
#define SYS_ERANGE (-10)
#define SYS_EALREADY (-11)
#define SYS_ENOTSUP (-12)
#define SYS_EUNKNOWN (-13)
#define SYS_EREMOTEIO (-14)
#define SYS_EDONE (-15)

#define SYS_EPERUSER (-65535)
# 29 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 1 "repos/apache-mynewt-core/sys/sys/include/sys/debug_panic.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_DEBUG_PANIC_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 24 "repos/apache-mynewt-core/sys/sys/include/sys/debug_panic.h" 2


#define DEBUG_PANIC() OS_CRASH()





#define DEBUG_ASSERT(expr) ((expr) ? (void)0 : OS_CRASH())
# 30 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2

/* Only include the logcfg header if this version of newt can generate it. */

# 1 "bin/targets/bluepill_my_sensor/generated/include/logcfg/logcfg.h" 1
/**
 * This file was generated by Apache newt version: 1.6.0
 */


#define H_MYNEWT_LOGCFG_ 
# 34 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 2
# 22 "libs/sensor_coap/src/sensor_coap.c" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/config.h" 1

#define CONFIG_H 






/* Time resolution */
# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 11 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/config.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 12 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/config.h" 2

# 1 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#define __SYS_LOG_STUB_H__ 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 23 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 24 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 2
# 1 "repos/apache-mynewt-core/sys/log/common/include/log_common/log_common.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_LOG_COMMON_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 24 "repos/apache-mynewt-core/sys/log/common/include/log_common/log_common.h" 2
# 1 "repos/apache-mynewt-core/sys/log/common/include/log_common/ignore.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define H_IGNORE_ 





/**
 * These macros prevent the "set but not used" warnings for log writes below
 * the log level.
 */

#define IGN_1(X) ((void)(X))
#define IGN_2(X,...) ((void)(X));IGN_1(__VA_ARGS__)
#define IGN_3(X,...) ((void)(X));IGN_2(__VA_ARGS__)
#define IGN_4(X,...) ((void)(X));IGN_3(__VA_ARGS__)
#define IGN_5(X,...) ((void)(X));IGN_4(__VA_ARGS__)
#define IGN_6(X,...) ((void)(X));IGN_5(__VA_ARGS__)
#define IGN_7(X,...) ((void)(X));IGN_6(__VA_ARGS__)
#define IGN_8(X,...) ((void)(X));IGN_7(__VA_ARGS__)
#define IGN_9(X,...) ((void)(X));IGN_8(__VA_ARGS__)
#define IGN_10(X,...) ((void)(X));IGN_9(__VA_ARGS__)
#define IGN_11(X,...) ((void)(X));IGN_10(__VA_ARGS__)
#define IGN_12(X,...) ((void)(X));IGN_11(__VA_ARGS__)
#define IGN_13(X,...) ((void)(X));IGN_12(__VA_ARGS__)
#define IGN_14(X,...) ((void)(X));IGN_13(__VA_ARGS__)
#define IGN_15(X,...) ((void)(X));IGN_14(__VA_ARGS__)
#define IGN_16(X,...) ((void)(X));IGN_15(__VA_ARGS__)
#define IGN_17(X,...) ((void)(X));IGN_16(__VA_ARGS__)
#define IGN_18(X,...) ((void)(X));IGN_17(__VA_ARGS__)
#define IGN_19(X,...) ((void)(X));IGN_18(__VA_ARGS__)
#define IGN_20(X,...) ((void)(X));IGN_19(__VA_ARGS__)

#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,NAME,...) NAME

#define IGNORE(...) GET_MACRO(__VA_ARGS__, IGN_20, IGN_19, IGN_18, IGN_17, IGN_16, IGN_15, IGN_14, IGN_13, IGN_12, IGN_11, IGN_10, IGN_9, IGN_8, IGN_7, IGN_6, IGN_5, IGN_4, IGN_3, IGN_2, IGN_1)(__VA_ARGS__)
# 25 "repos/apache-mynewt-core/sys/log/common/include/log_common/log_common.h" 2





struct log;

#define LOG_VERSION_V3 3
#define LOG_VERSION_V2 2
#define LOG_VERSION_V1 1

#define LOG_TYPE_STREAM (0)
#define LOG_TYPE_MEMORY (1)
#define LOG_TYPE_STORAGE (2)

#define LOG_LEVEL_DEBUG (0)
#define LOG_LEVEL_INFO (1)
#define LOG_LEVEL_WARN (2)
#define LOG_LEVEL_ERROR (3)
#define LOG_LEVEL_CRITICAL (4)
/* Up to 7 custom log levels. */
#define LOG_LEVEL_MAX (UINT8_MAX)

#define LOG_LEVEL_STR(level) (LOG_LEVEL_DEBUG == level ? "DEBUG" : (LOG_LEVEL_INFO == level ? "INFO" : (LOG_LEVEL_WARN == level ? "WARN" : (LOG_LEVEL_ERROR == level ? "ERROR" : (LOG_LEVEL_CRITICAL == level ? "CRITICAL" : "UNKNOWN")))))







/* Log module, eventually this can be a part of the filter. */
#define LOG_MODULE_DEFAULT (0)
#define LOG_MODULE_OS (1)
#define LOG_MODULE_NEWTMGR (2)
#define LOG_MODULE_NIMBLE_CTLR (3)
#define LOG_MODULE_NIMBLE_HOST (4)
#define LOG_MODULE_NFFS (5)
#define LOG_MODULE_REBOOT (6)
#define LOG_MODULE_IOTIVITY (7)
#define LOG_MODULE_TEST (8)
#define LOG_MODULE_PERUSER (64)
#define LOG_MODULE_MAX (255)

#define LOG_ETYPE_STRING (0)





/* Logging medium */
#define LOG_STORE_CONSOLE 1
#define LOG_STORE_CBMEM 2
#define LOG_STORE_FCB 3

/* UTC Timestamp for Jan 2016 00:00:00 */
#define UTC01_01_2016 1451606400

#define LOG_NAME_MAX_LEN (64)




#define LOG_SYSLEVEL ((uint8_t)MYNEWT_VAL_LOG_LEVEL)


/* Newtmgr Log opcodes */
#define LOGS_NMGR_OP_READ (0)
#define LOGS_NMGR_OP_CLEAR (1)
#define LOGS_NMGR_OP_APPEND (2)
#define LOGS_NMGR_OP_MODULE_LIST (3)
#define LOGS_NMGR_OP_LEVEL_LIST (4)
#define LOGS_NMGR_OP_LOGS_LIST (5)
#define LOGS_NMGR_OP_SET_WATERMARK (6)
#define LOGS_NMGR_OP_MODLEVEL (8)

#define LOG_PRINTF_MAX_ENTRY_LEN (128)

/* Global log info */
struct log_info {
    uint32_t li_next_index;
    uint8_t li_version;
};

extern struct log_info g_log_info;

/** @typedef log_append_cb
 * @brief Callback that is executed each time the corresponding log is appended
 * to.
 *
 * @param log                   The log that was just appended to.
 * @param idx                   The index of newly appended log entry.
 */
typedef void log_append_cb(struct log *log, uint32_t idx);
# 25 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 2





#define LOG_DEBUG(__l,__mod,...) IGNORE(__VA_ARGS__)
#define LOG_INFO(__l,__mod,...) IGNORE(__VA_ARGS__)
#define LOG_WARN(__l,__mod,...) IGNORE(__VA_ARGS__)
#define LOG_ERROR(__l,__mod,...) IGNORE(__VA_ARGS__)
#define LOG_CRITICAL(__l,__mod,...) IGNORE(__VA_ARGS__)

struct log {
};

struct log_handler {
};

static inline int
log_register(char *name, struct log *log, const struct log_handler *h,
             void *arg, uint8_t level)
{
    return 0;
}

static inline void
log_set_append_cb(struct log *log, log_append_cb *cb)
{
}

static inline struct log *
log_find(const char *name)
{
    return 
# 57 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 3 4
          ((void *)0)
# 57 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h"
              ;
}

static inline int
log_append_typed(struct log *log, uint8_t module, uint8_t level, uint8_t etype,
                 void *data, uint16_t len)
{
    return 0;
}

static inline int
log_append_mbuf_typed_no_free(struct log *log, uint8_t module, uint8_t level,
                              uint8_t etype, struct os_mbuf **om_ptr)
{
    return 0;
}

static inline int
log_append_mbuf_typed(struct log *log, uint8_t module, uint8_t level,
                      uint8_t etype, struct os_mbuf *om)
{
    os_mbuf_free_chain(om);
    return 0;
}

static inline int
log_append_mbuf_body_no_free(struct log *log, uint8_t module, uint8_t level,
                             uint8_t etype, struct os_mbuf *om)
{
    return 0;
}

static inline int
log_append_mbuf_body(struct log *log, uint8_t module, uint8_t level,
                     uint8_t etype, struct os_mbuf *om)
{
    os_mbuf_free_chain(om);
    return 0;
}

static inline void
log_init(void)
{
}

static inline void log_set_level(struct log *log, uint8_t level)
{
    return;
}

static inline uint8_t log_get_level(const struct log *log)
{
    return 0;
}

#define log_printf(...) 

/*
 * Dummy handler exports.
 */
extern const struct log_handler log_console_handler;
extern const struct log_handler log_cbmem_handler;
extern const struct log_handler log_fcb_handler;





static inline struct log *
log_console_get(void)
{
    return 
# 128 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 3 4
          ((void *)0)
# 128 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h"
              ;
}
# 14 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/config.h" 2

/* rather than change all their source files, just translate the mynewt
 * package defines into their defines here */





#define OC_CLIENT 






typedef os_time_t oc_clock_time_t;
#define OC_CLOCK_CONF_TICKS_PER_SECOND (OS_TICKS_PER_SEC)



#define OC_CLK_FMT "%lu"


/* Server-side parameters */
/* Maximum number of server resources */
#define MAX_APP_RESOURCES MYNEWT_VAL(OC_APP_RESOURCES)

/* Common paramters */
/* Maximum number of concurrent requests */
#define MAX_NUM_CONCURRENT_REQUESTS MYNEWT_VAL(OC_CONCURRENT_REQUESTS)

/* Estimated number of nodes in payload tree structure */
#define EST_NUM_REP_OBJECTS MYNEWT_VAL(OC_NUM_REP_OBJECTS)

/* Maximum size of request/response PDUs */
#define MAX_PAYLOAD_SIZE MYNEWT_VAL(OC_MAX_PAYLOAD_SIZE)

/* Number of devices on the OCF platform */
#define MAX_NUM_DEVICES MYNEWT_VAL(OC_NUM_DEVICES)

/* Platform payload size */
#define MAX_PLATFORM_PAYLOAD_SIZE MYNEWT_VAL(OC_MAX_PAYLOAD)

/* Device payload size */
#define MAX_DEVICE_PAYLOAD_SIZE MYNEWT_VAL(OC_MAX_PAYLOAD)

/* Security layer */
/* Maximum number of authorized clients */
//#define MAX_NUM_SUBJECTS (2)

/* Maximum number of concurrent DTLS sessions */
//#define MAX_DTLS_PEERS (1)

/* Max inactivity timeout before tearing down DTLS connection */
//#define DTLS_INACTIVITY_TIMEOUT (10)
# 23 "libs/sensor_coap/src/sensor_coap.c" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 1
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * Copyright (c) 2013, Institute for Pervasive Computing, ETH Zurich
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 */


#define COAP_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 38 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2


# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1

# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h"
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 41 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2

# 1 "repos/apache-mynewt-core/sys/stats/stub/include/stats/stats.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#define __UTIL_STATS_H__ 


# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 24 "repos/apache-mynewt-core/sys/stats/stub/include/stats/stats.h" 2





struct stats_name_map {
    uint16_t snm_off;
    char *snm_name;
} __attribute__((packed));

struct stats_hdr {
    const char *s_name;
    uint8_t s_size;
    uint8_t s_cnt;
    uint16_t s_pad1;




    struct { struct stats_hdr *stqe_next; /* next element */ } s_next;
};

#define STATS_SECT_DECL(__name) struct stats_ ## __name

#define STATS_SECT_END };

#define STATS_SECT_START(__name) STATS_SECT_DECL(__name) {

#define STATS_SECT_VAR(__var) 

#define STATS_HDR(__sectname) 

#define STATS_SECT_ENTRY(__var) 
#define STATS_SECT_ENTRY16(__var) 
#define STATS_SECT_ENTRY32(__var) 
#define STATS_SECT_ENTRY64(__var) 
#define STATS_RESET(__var) 

#define STATS_SIZE_INIT_PARMS(__sectvarname,__size) 0, 0

#define STATS_GET(__sectvarname,__var) 
#define STATS_INC(__sectvarname,__var) 
#define STATS_INCN(__sectvarname,__var,__n) 
#define STATS_CLEAR(__sectvarname,__var) 

#define STATS_NAME_START(__name) 
#define STATS_NAME(__name,__entry) 
#define STATS_NAME_END(__name) 
#define STATS_NAME_INIT_PARMS(__name) NULL, 0

#define stats_init(...) 0
#define stats_register(name,shdr) 0
#define stats_init_and_reg(...) 0
#define stats_reset(shdr) 
# 43 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2


# 1 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/conf.h" 1
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * Copyright (c) 2013, Institute for Pervasive Computing, ETH Zurich
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 */


#define CONF_H 







/* Features that can be disabled to achieve smaller memory footprint */
#define COAP_LINK_FORMAT_FILTERING 0
#define COAP_PROXY_OPTION_PROCESSING 0

/* The number of concurrent messages that can be stored for retransmission in
 * the transaction layer. */

#define COAP_MAX_OPEN_TRANSACTIONS (MAX_NUM_CONCURRENT_REQUESTS)


/* Maximum number of failed request attempts before action */

#define COAP_MAX_ATTEMPTS 2


/* Conservative size limit, as not all options have to be set at the same time.
 * Check when Proxy-Uri option is used */


#define COAP_MAX_HEADER_SIZE (4 + COAP_TOKEN_LEN + 3 + 1 + COAP_ETAG_LEN + 4 + 4 + 30) /* 65 */



/* Number of observer slots (each takes abot xxx bytes) */

#define COAP_MAX_OBSERVERS (MAX_APP_RESOURCES + MAX_NUM_CONCURRENT_REQUESTS)


/* Interval in notifies in which NON notifies are changed to CON notifies to
 * check client. */
#define COAP_OBSERVE_REFRESH_INTERVAL 20
# 46 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/constants.h" 1
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * Copyright (c) 2013, Institute for Pervasive Computing, ETH Zurich
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 */


#define CONSTANTS_H 





#define COAP_DEFAULT_PORT 5683

#define COAP_DEFAULT_MAX_AGE 60
#define COAP_RESPONSE_TIMEOUT MYNEWT_VAL(OC_COAP_RESPONSE_TIMEOUT)
#define COAP_RESPONSE_RANDOM_FACTOR 1.5
#define COAP_MAX_RETRANSMIT 4

#define COAP_HEADER_LEN 4 /* | version:0x03 type:0x0C tkl:0xF0 | code | mid:0x00FF | mid:0xFF00 | */

#define COAP_TOKEN_LEN 8 /* The maximum number of bytes for the Token */
#define COAP_ETAG_LEN 8 /* The maximum number of bytes for the ETag */
#define COAP_MAX_URI 32 /* The max number of bytes for URI */
#define COAP_MAX_URI_QUERY 32 /* The max number of bytes for URI-query */

/*
 * Standard COAP header
 */
struct coap_udp_hdr {





    uint8_t token_len:4; /* length of token */
    uint8_t type:2; /* type flag */
    uint8_t version:2; /* protocol version */

    uint8_t code; /* request (1-10) or response (value 40-255) */
    uint16_t id; /* transaction id */
};

/*
 * Header used by Iotivity for TCP-like transports.
 * 4 different kinds of headers.
 */
#define COAP_TCP_LENGTH8_OFF 13
#define COAP_TCP_LENGTH16_OFF 269
#define COAP_TCP_LENGTH32_OFF 65805

#define COAP_TCP_TYPE0 0
#define COAP_TCP_TYPE8 13
#define COAP_TCP_TYPE16 14
#define COAP_TCP_TYPE32 15

struct coap_tcp_hdr0 {




    uint8_t token_len:4; /* length of token */
    uint8_t data_len:4; /* packet length */

    uint8_t code;
};

struct coap_tcp_hdr8 {




    uint8_t token_len:4; /* length of token */
    uint8_t type:4; /* header type == 13*/

    uint8_t data_len; /* packet size - 13 */
    uint8_t code;
};

struct coap_tcp_hdr16 {




    uint8_t token_len:4; /* length of token */
    uint8_t type:4; /* header type == 14 */

    uint16_t data_len; /* packet size - 269 */
    uint8_t code;
} __attribute__((packed));

struct coap_tcp_hdr32 {




    uint8_t token_len:4; /* length of token */
    uint8_t type:4; /* header type == 15*/

    uint32_t data_len; /* packet size - 65805 */
    uint8_t code;
} __attribute__((packed));

#define COAP_TCP_TYPE8 13
#define COAP_TCP_TYPE16 14
#define COAP_TCP_TYPE32 15


#define COAP_HEADER_OPTION_DELTA_MASK 0xF0
#define COAP_HEADER_OPTION_SHORT_LENGTH_MASK 0x0F

/* CoAP message types */
typedef enum {
  COAP_TYPE_CON, /* confirmables */
  COAP_TYPE_NON, /* non-confirmables */
  COAP_TYPE_ACK, /* acknowledgements */
  COAP_TYPE_RST /* reset */
} coap_message_type_t;

/* CoAP request method codes */
typedef enum { COAP_GET = 1, COAP_POST, COAP_PUT, COAP_DELETE } coap_method_t;

/* CoAP response codes */
typedef enum {
  NO_ERROR = 0,

  CREATED_2_01 = 65, /* CREATED */
  DELETED_2_02 = 66, /* DELETED */
  VALID_2_03 = 67, /* NOT_MODIFIED */
  CHANGED_2_04 = 68, /* CHANGED */
  CONTENT_2_05 = 69, /* OK */
  CONTINUE_2_31 = 95, /* CONTINUE */

  BAD_REQUEST_4_00 = 128, /* BAD_REQUEST */
  UNAUTHORIZED_4_01 = 129, /* UNAUTHORIZED */
  BAD_OPTION_4_02 = 130, /* BAD_OPTION */
  FORBIDDEN_4_03 = 131, /* FORBIDDEN */
  NOT_FOUND_4_04 = 132, /* NOT_FOUND */
  METHOD_NOT_ALLOWED_4_05 = 133, /* METHOD_NOT_ALLOWED */
  NOT_ACCEPTABLE_4_06 = 134, /* NOT_ACCEPTABLE */
  PRECONDITION_FAILED_4_12 = 140, /* BAD_REQUEST */
  REQUEST_ENTITY_TOO_LARGE_4_13 = 141, /* REQUEST_ENTITY_TOO_LARGE */
  UNSUPPORTED_MEDIA_TYPE_4_15 = 143, /* UNSUPPORTED_MEDIA_TYPE */

  INTERNAL_SERVER_ERROR_5_00 = 160, /* INTERNAL_SERVER_ERROR */
  NOT_IMPLEMENTED_5_01 = 161, /* NOT_IMPLEMENTED */
  BAD_GATEWAY_5_02 = 162, /* BAD_GATEWAY */
  SERVICE_UNAVAILABLE_5_03 = 163, /* SERVICE_UNAVAILABLE */
  GATEWAY_TIMEOUT_5_04 = 164, /* GATEWAY_TIMEOUT */
  PROXYING_NOT_SUPPORTED_5_05 = 165, /* PROXYING_NOT_SUPPORTED */

  /* Erbium errors */
  MEMORY_ALLOCATION_ERROR = 192,
  PACKET_SERIALIZATION_ERROR,

  /* Erbium hooks */
  CLEAR_TRANSACTION,
  EMPTY_ACK_RESPONSE
} coap_status_t;

/* CoAP header option numbers */
typedef enum {
  COAP_OPTION_IF_MATCH = 1, /* 0-8 B */
  COAP_OPTION_URI_HOST = 3, /* 1-255 B */
  COAP_OPTION_ETAG = 4, /* 1-8 B */
  COAP_OPTION_IF_NONE_MATCH = 5, /* 0 B */
  COAP_OPTION_OBSERVE = 6, /* 0-3 B */
  COAP_OPTION_URI_PORT = 7, /* 0-2 B */
  COAP_OPTION_LOCATION_PATH = 8, /* 0-255 B */
  COAP_OPTION_URI_PATH = 11, /* 0-255 B */
  COAP_OPTION_CONTENT_FORMAT = 12, /* 0-2 B */
  COAP_OPTION_MAX_AGE = 14, /* 0-4 B */
  COAP_OPTION_URI_QUERY = 15, /* 0-255 B */
  COAP_OPTION_ACCEPT = 17, /* 0-2 B */
  COAP_OPTION_LOCATION_QUERY = 20, /* 0-255 B */
  COAP_OPTION_BLOCK2 = 23, /* 1-3 B */
  COAP_OPTION_BLOCK1 = 27, /* 1-3 B */
  COAP_OPTION_SIZE2 = 28, /* 0-4 B */
  COAP_OPTION_PROXY_URI = 35, /* 1-1034 B */
  COAP_OPTION_PROXY_SCHEME = 39, /* 1-255 B */
  COAP_OPTION_SIZE1 = 60, /* 0-4 B */
} coap_option_t;

/* CoAP Content-Formats */
typedef enum {
  TEXT_PLAIN = 0,
  TEXT_XML = 1,
  TEXT_CSV = 2,
  TEXT_HTML = 3,
  IMAGE_GIF = 21,
  IMAGE_JPEG = 22,
  IMAGE_PNG = 23,
  IMAGE_TIFF = 24,
  AUDIO_RAW = 25,
  VIDEO_RAW = 26,
  APPLICATION_LINK_FORMAT = 40,
  APPLICATION_XML = 41,
  APPLICATION_OCTET_STREAM = 42,
  APPLICATION_RDF_XML = 43,
  APPLICATION_SOAP_XML = 44,
  APPLICATION_ATOM_XML = 45,
  APPLICATION_XMPP_XML = 46,
  APPLICATION_EXI = 47,
  APPLICATION_FASTINFOSET = 48,
  APPLICATION_SOAP_FASTINFOSET = 49,
  APPLICATION_JSON = 50,
  APPLICATION_X_OBIX_BINARY = 51,
  APPLICATION_CBOR = 60
} coap_content_format_t;
# 47 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_log.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_LOG_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 1
/*
 * stdio.h
 */
# 21 "repos/apache-mynewt-core/net/oic/include/oic/oc_log.h" 2
# 1 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * @file
 * @brief modlog - Module-mapped logging.
 *
 * The modlog facility allows log entries to be written to numeric modules
 * identifiers.  In typical usage, startup code maps 8-bit module IDs to one or
 * more log objects, while other parts of the application log events by write
 * entries to modules IDs.  This usage differs from the underlying `sys/log`
 * facility, which requires clients to provide a log object to write to
 * rather than just a module identifier.
 *
 * Benefits provided by the modlog package are:
 *     o Improved modularity - configuration and usage are distinct.
 *     o Ability to write to several logs with a single function call.  If one
 *       module ID is mapped to several logs, a write to that ID causes all
 *       mapped logs to be written.
 *     o Default mappings.  Writes to unmapped module IDs get written to an
 *       optional set of default logs.
 *     o Minimum log level per mapping.  Writes specifying a log level less
 *       than the module's minimum level are discarded.
 *
 * Costs of using modlog rather than the bare `sys/log` facility are:
 *     o Increased RAM usage (`MODLOG_MAX_MAPPINGS` * 12).
 *     o Increased CPU usage - each log write requires a lookup in the set
 *       of configured modlog mappings.
 */


#define H_MODLOG_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 51 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h" 2
# 1 "repos/apache-mynewt-core/sys/log/stub/include/log/log.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 52 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h" 2

#define MODLOG_MODULE_DFLT 255

/**
 * @brief Modlog mapping descriptor.
 *
 * Describes an individual mapping of module ID to log.
 */
struct modlog_desc {
    /** The log being mapped. */
    struct log *log;

    /** Unique identifier for this mapping. */
    uint8_t handle;

    /** The numeric module ID being mapped. */
    uint8_t module;

    /** Log writes with a level less than this are discarded. */
    uint8_t min_level;
};

/** @typedef modlog_foreach_fn
 * @brief Function applied to each modlog mapping during a `modlog_foreach`
 *        traversal.
 *
 * @param desc                  The modlog mapping to operate on.
 * @param arg                   Optional user argument.
 *
 * @return                      0 if the traversal should continue;
 *                              nonzero to abort the traversal with the
 *                                  specified return code.
 */
typedef int modlog_foreach_fn(const struct modlog_desc *desc, void *arg);

/* Only enable modlog if logging is also enabled. */
# 193 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h"
static inline int
modlog_get(uint8_t handle, struct modlog_desc *out_desc)
{
    return (-12);
}

static inline int
modlog_register(uint8_t module, struct log *log, uint8_t min_level,
                uint8_t *out_handle)
{
    return 0;
}

static inline int
modlog_delete(uint8_t handle)
{
    return (-12);
}

static inline void
modlog_clear(void)
{ }

static inline int
modlog_append(uint8_t module, uint8_t level, uint8_t etype, void *data,
              uint16_t len)
{
    return 0;
}

static inline int
modlog_append_mbuf(uint8_t module, uint8_t level, uint8_t etype,
                   struct os_mbuf *om)
{
    os_mbuf_free_chain(om);
    return 0;
}

static inline int
modlog_foreach(modlog_foreach_fn *fn, void *arg)
{
    return (-12);
}

static inline void
modlog_printf(uint8_t module, uint8_t level, const char *msg, ...)
{ }
# 256 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h"
#define MODLOG_DEBUG(ml_mod_,...) IGNORE(__VA_ARGS__)
# 272 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h"
#define MODLOG_INFO(ml_mod_,...) IGNORE(__VA_ARGS__)
# 288 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h"
#define MODLOG_WARN(ml_mod_,...) IGNORE(__VA_ARGS__)
# 304 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h"
#define MODLOG_ERROR(ml_mod_,...) IGNORE(__VA_ARGS__)
# 320 "repos/apache-mynewt-core/sys/log/modlog/include/modlog/modlog.h"
#define MODLOG_CRITICAL(ml_mod_,...) IGNORE(__VA_ARGS__)


/**
 * @brief Writes a formatted text entry with the specified level to the
 * specified log module.
 *
 * The provided log level must be one of the following tokens:
 *     o CRITICAL
 *     o ERROR
 *     o WARN
 *     o INFO
 *     o DEBUG
 *
 * This expands to nothing if the global log level is greater than
 * the specified level.
 *
 * @param ml_lvl_               The log level of the entry to write.
 * @param ml_mod_               The log module to write to.
 */
#define MODLOG(ml_lvl_,ml_mod_,...) MODLOG_ ## ml_lvl_((ml_mod_), __VA_ARGS__)


/**
 * @brief Writes a formatted text entry with the specified level to the
 * default log module.
 *
 * The provided log level must be one of the following tokens:
 *     o CRITICAL
 *     o ERROR
 *     o WARN
 *     o INFO
 *     o DEBUG
 *
 * This expands to nothing if the global log level is greater than
 * the specified level.
 *
 * @param ml_lvl_               The log level of the entry to write.
 */
#define MODLOG_DFLT(ml_lvl_,...) MODLOG(ml_lvl_, LOG_MODULE_DEFAULT, __VA_ARGS__)


/* If `MODLOG_LOG_MACROS` in enabled, retire the old `LOG_[...]` macros and
 * redefine them to use modlog.
 */
# 22 "repos/apache-mynewt-core/net/oic/include/oic/oc_log.h" 2





/*
 * XXX, this should not be needed.
 * Figure out why logging takes so much space even with LOG_LEVEL set to 4
 */
# 79 "repos/apache-mynewt-core/net/oic/include/oic/oc_log.h"
#define OC_LOG(lvl_,...) 
#define OC_LOG_ENDPOINT(...) 
#define OC_LOG_STR(...) 
#define OC_LOG_STR_MBUF(...) 
#define OC_LOG_HEX(...) 
#define OC_LOG_HEX_MBUF(...) 
# 48 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_CONNECTIVITY_H 


# 1 "repos/apache-mynewt-core/libc/baselibc/include/assert.h" 1
/*
 * assert.h
 */
# 22 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 2


# 1 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/transport.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define __MYNEWT_TRANSPORT_H_ 

# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 24 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/transport.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_RI_H 


# 1 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
# 22 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_REP_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 21 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 2


# 1 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 1

# 1 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
/****************************************************************************
**
** Copyright (C) 2015 Intel Corporation
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
** copies of the Software, and to permit persons to whom the Software is
** furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
** THE SOFTWARE.
**
****************************************************************************/


#define CBOR_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/assert.h" 1
/*
 * assert.h
 */
# 29 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 3 4
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */

#define _GCC_LIMITS_H_ 


/* Use "..." so that we find syslimits.h only in this same directory.  */
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/syslimits.h" 1 3 4
/* syslimits.h stands for the system's own limits.h file.
   If we can use it ok unmodified, then we install this text.
   If fixincludes fixes it, then the fixed version is installed
   instead of this text.  */

#define _GCC_NEXT_LIMITS_H /* tell gcc's limits.h to recurse */
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 1 3 4
/* Copyright (C) 1992-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* This administrivia gets added to the beginning of limits.h
   if the system has its own version of limits.h.  */

/* We use _GCC_LIMITS_H_ because we want this not to match
   any macros that the system's limits.h uses for its own purposes.  */
# 194 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/limits.h" 1 3 4

#define _LIBC_LIMITS_H_ 1

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/newlib.h" 1 3 4
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */


#define __NEWLIB_H__ 1

/* EL/IX level */
/* #undef _ELIX_LEVEL */

/* Newlib version */
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_newlib_version.h" 1 3 4
/* _newlib_version.h.  Generated from _newlib_version.hin by configure.  */
/* Version macros for internal and downstream use. */
# 15 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/newlib.h" 2 3 4

/* C99 formats support (such as %a, %zu, ...) in IO functions like
 * printf/scanf enabled */
#define _WANT_IO_C99_FORMATS 1

/* long long type support in IO functions like printf/scanf enabled */
#define _WANT_IO_LONG_LONG 1

/* Register application finalization function using atexit. */
#define _WANT_REGISTER_FINI 1

/* long double type support in IO functions like printf/scanf enabled */
/* #undef _WANT_IO_LONG_DOUBLE */

/* Positional argument support in printf functions enabled.  */
/* #undef _WANT_IO_POS_ARGS */

/* Optional reentrant struct support.  Used mostly on platforms with
   very restricted storage.  */
/* #undef _WANT_REENT_SMALL */

/* Multibyte supported */
/* #undef _MB_CAPABLE */

/* MB_LEN_MAX */
#define _MB_LEN_MAX 1

/* ICONV enabled */
/* #undef _ICONV_ENABLED */

/* Enable ICONV external CCS files loading capabilities */
/* #undef _ICONV_ENABLE_EXTERNAL_CCS */

/* Define if the linker supports .preinit_array/.init_array/.fini_array
 * sections.  */
#define HAVE_INITFINI_ARRAY 1

/* True if atexit() may dynamically allocate space for cleanup
   functions.  */
#define _ATEXIT_DYNAMIC_ALLOC 1

/* True if long double supported.  */
#define _HAVE_LONG_DOUBLE 1

/* Define if compiler supports -fno-tree-loop-distribute-patterns. */
#define _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL 1

/* True if long double supported and it is equal to double.  */
#define _LDBL_EQ_DBL 1

/* Define if ivo supported in streamio.  */
#define _FVWRITE_IN_STREAMIO 1

/* Define if fseek functions support seek optimization.  */
#define _FSEEK_OPTIMIZATION 1

/* Define if wide char orientation is supported.  */
#define _WIDE_ORIENT 1

/* Define if unbuffered stream file optimization is supported.  */
#define _UNBUF_STREAM_OPT 1

/* Define if lite version of exit supported.  */
/* #undef _LITE_EXIT */

/* Define if declare atexit data as global.  */
/* #undef _REENT_GLOBAL_ATEXIT */

/* Define to move the stdio stream FILE objects out of struct _reent and make
   them global.  The stdio stream pointers of struct _reent are initialized to
   point to the global stdio FILE stream objects. */
/* #undef _WANT_REENT_GLOBAL_STDIO_STREAMS */

/* Define if small footprint nano-formatted-IO implementation used.  */
/* #undef _NANO_FORMATTED_IO */

/* Define if using retargetable functions for default lock routines.  */
#define _RETARGETABLE_LOCKING 1

/* Define to use type long for time_t.  */
/* #undef _WANT_USE_LONG_TIME_T */

/*
 * Iconv encodings enabled ("to" direction)
 */
/* #undef _ICONV_TO_ENCODING_BIG5 */
/* #undef _ICONV_TO_ENCODING_CP775 */
/* #undef _ICONV_TO_ENCODING_CP850 */
/* #undef _ICONV_TO_ENCODING_CP852 */
/* #undef _ICONV_TO_ENCODING_CP855 */
/* #undef _ICONV_TO_ENCODING_CP866 */
/* #undef _ICONV_TO_ENCODING_EUC_JP */
/* #undef _ICONV_TO_ENCODING_EUC_TW */
/* #undef _ICONV_TO_ENCODING_EUC_KR */
/* #undef _ICONV_TO_ENCODING_ISO_8859_1 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_10 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_11 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_13 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_14 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_15 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_2 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_3 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_4 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_5 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_6 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_7 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_8 */
/* #undef _ICONV_TO_ENCODING_ISO_8859_9 */
/* #undef _ICONV_TO_ENCODING_ISO_IR_111 */
/* #undef _ICONV_TO_ENCODING_KOI8_R */
/* #undef _ICONV_TO_ENCODING_KOI8_RU */
/* #undef _ICONV_TO_ENCODING_KOI8_U */
/* #undef _ICONV_TO_ENCODING_KOI8_UNI */
/* #undef _ICONV_TO_ENCODING_UCS_2 */
/* #undef _ICONV_TO_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_2BE */
/* #undef _ICONV_TO_ENCODING_UCS_2LE */
/* #undef _ICONV_TO_ENCODING_UCS_4 */
/* #undef _ICONV_TO_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_TO_ENCODING_UCS_4BE */
/* #undef _ICONV_TO_ENCODING_UCS_4LE */
/* #undef _ICONV_TO_ENCODING_US_ASCII */
/* #undef _ICONV_TO_ENCODING_UTF_16 */
/* #undef _ICONV_TO_ENCODING_UTF_16BE */
/* #undef _ICONV_TO_ENCODING_UTF_16LE */
/* #undef _ICONV_TO_ENCODING_UTF_8 */
/* #undef _ICONV_TO_ENCODING_WIN_1250 */
/* #undef _ICONV_TO_ENCODING_WIN_1251 */
/* #undef _ICONV_TO_ENCODING_WIN_1252 */
/* #undef _ICONV_TO_ENCODING_WIN_1253 */
/* #undef _ICONV_TO_ENCODING_WIN_1254 */
/* #undef _ICONV_TO_ENCODING_WIN_1255 */
/* #undef _ICONV_TO_ENCODING_WIN_1256 */
/* #undef _ICONV_TO_ENCODING_WIN_1257 */
/* #undef _ICONV_TO_ENCODING_WIN_1258 */

/*
 * Iconv encodings enabled ("from" direction)
 */
/* #undef _ICONV_FROM_ENCODING_BIG5 */
/* #undef _ICONV_FROM_ENCODING_CP775 */
/* #undef _ICONV_FROM_ENCODING_CP850 */
/* #undef _ICONV_FROM_ENCODING_CP852 */
/* #undef _ICONV_FROM_ENCODING_CP855 */
/* #undef _ICONV_FROM_ENCODING_CP866 */
/* #undef _ICONV_FROM_ENCODING_EUC_JP */
/* #undef _ICONV_FROM_ENCODING_EUC_TW */
/* #undef _ICONV_FROM_ENCODING_EUC_KR */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_1 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_10 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_11 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_13 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_14 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_15 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_2 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_3 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_4 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_5 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_6 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_7 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_8 */
/* #undef _ICONV_FROM_ENCODING_ISO_8859_9 */
/* #undef _ICONV_FROM_ENCODING_ISO_IR_111 */
/* #undef _ICONV_FROM_ENCODING_KOI8_R */
/* #undef _ICONV_FROM_ENCODING_KOI8_RU */
/* #undef _ICONV_FROM_ENCODING_KOI8_U */
/* #undef _ICONV_FROM_ENCODING_KOI8_UNI */
/* #undef _ICONV_FROM_ENCODING_UCS_2 */
/* #undef _ICONV_FROM_ENCODING_UCS_2_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_2BE */
/* #undef _ICONV_FROM_ENCODING_UCS_2LE */
/* #undef _ICONV_FROM_ENCODING_UCS_4 */
/* #undef _ICONV_FROM_ENCODING_UCS_4_INTERNAL */
/* #undef _ICONV_FROM_ENCODING_UCS_4BE */
/* #undef _ICONV_FROM_ENCODING_UCS_4LE */
/* #undef _ICONV_FROM_ENCODING_US_ASCII */
/* #undef _ICONV_FROM_ENCODING_UTF_16 */
/* #undef _ICONV_FROM_ENCODING_UTF_16BE */
/* #undef _ICONV_FROM_ENCODING_UTF_16LE */
/* #undef _ICONV_FROM_ENCODING_UTF_8 */
/* #undef _ICONV_FROM_ENCODING_WIN_1250 */
/* #undef _ICONV_FROM_ENCODING_WIN_1251 */
/* #undef _ICONV_FROM_ENCODING_WIN_1252 */
/* #undef _ICONV_FROM_ENCODING_WIN_1253 */
/* #undef _ICONV_FROM_ENCODING_WIN_1254 */
/* #undef _ICONV_FROM_ENCODING_WIN_1255 */
/* #undef _ICONV_FROM_ENCODING_WIN_1256 */
/* #undef _ICONV_FROM_ENCODING_WIN_1257 */
/* #undef _ICONV_FROM_ENCODING_WIN_1258 */
# 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/limits.h" 2 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 1 3 4
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */


#define _SYS_CDEFS_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 1 3 4
/*
 *  $Id$
 */
# 44 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 2 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 1 3 4
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
# 45 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 2 3 4
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 46 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 2 3 4

#define __PMT(args) args
#define __DOTS , ...
#define __THROW 


#define __ASMNAME(cname) __XSTRING (__USER_LABEL_PREFIX__) cname


#define __ptr_t void *
#define __long_double_t long double

#define __attribute_malloc__ 
#define __attribute_pure__ 
#define __attribute_format_strfmon__(a,b) 
#define __flexarr [0]


#define __bounded /* nothing */
#define __unbounded /* nothing */
#define __ptrvalue /* nothing */


/*
 * Testing against Clang-specific extensions.
 */




#define __has_extension __has_feature


#define __has_feature(x) 0
# 92 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
#define __BEGIN_DECLS 
#define __END_DECLS 


/*
 * This code has been put in place to help reduce the addition of
 * compiler specific defines in FreeBSD code.  It helps to aid in
 * having a compiler-agnostic source tree.
 */




#define __GNUCLIKE_ASM 3
#define __GNUCLIKE_MATH_BUILTIN_CONSTANTS 



#define __GNUCLIKE___TYPEOF 1
#define __GNUCLIKE___OFFSETOF 1
#define __GNUCLIKE___SECTION 1


#define __GNUCLIKE_CTOR_SECTION_HANDLING 1


#define __GNUCLIKE_BUILTIN_CONSTANT_P 1






#define __GNUCLIKE_BUILTIN_VARARGS 1
#define __GNUCLIKE_BUILTIN_STDARG 1
#define __GNUCLIKE_BUILTIN_VAALIST 1



#define __GNUC_VA_LIST_COMPATIBILITY 1


/*
 * Compiler memory barriers, specific to gcc and clang.
 */

#define __compiler_membar() __asm __volatile(" " : : : "memory")



#define __GNUCLIKE_BUILTIN_NEXT_ARG 1
#define __GNUCLIKE_MATH_BUILTIN_RELOPS 


#define __GNUCLIKE_BUILTIN_MEMCPY 1

/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
#define __CC_SUPPORTS_INLINE 1
#define __CC_SUPPORTS___INLINE 1
#define __CC_SUPPORTS___INLINE__ 1

#define __CC_SUPPORTS___FUNC__ 1
#define __CC_SUPPORTS_WARNING 1

#define __CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */

#define __CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1



/*
 * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
 * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
 * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
 * mode -- there must be no spaces between its arguments, and for nested
 * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
 * concatenate double-quoted strings produced by the __STRING macro, but
 * this only works with ANSI C.
 *
 * __XSTRING is like __STRING, but it expands any macros in its argument
 * first.  It is only available with ANSI C.
 */

#define __P(protos) protos /* full-blown ANSI C */
#define __CONCAT1(x,y) x ## y
#define __CONCAT(x,y) __CONCAT1(x,y)
#define __STRING(x) #x /* stringify without expanding x */
#define __XSTRING(x) __STRING(x) /* expand x, then stringify */

#define __const const /* define reserved names to standard */
#define __signed signed
#define __volatile volatile
# 219 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
/*
 * Compiler-dependent macros to help declare dead (non-returning) and
 * pure (no side effects) functions, and unused variables.  They are
 * null except for versions of gcc that are known to support the features
 * properly (old versions of gcc-2 supported the dead and pure features
 * in a different (wrong) way).  If we do not provide an implementation
 * for a given compiler, let the compile fail if it is told to use
 * a feature that we cannot live without.
 */
# 239 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
#define __weak_symbol __attribute__((__weak__))
# 252 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
#define __dead2 __attribute__((__noreturn__))
#define __pure2 __attribute__((__const__))
#define __unused __attribute__((__unused__))
#define __used __attribute__((__used__))
#define __packed __attribute__((__packed__))
#define __aligned(x) __attribute__((__aligned__(x)))
#define __section(x) __attribute__((__section__(x)))


#define __alloc_size(x) __attribute__((__alloc_size__(x)))




#define __alloc_align(x) __attribute__((__alloc_align__(x)))
# 276 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
/*
 * Keywords added in C11.
 */
# 345 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
/*
 * Emulation of C11 _Generic().  Unlike the previously defined C11
 * keywords, it is not possible to implement this using exactly the same
 * syntax.  Therefore implement something similar under the name
 * __generic().  Unlike _Generic(), this macro can only distinguish
 * between a single type, so it requires nested invocations to
 * distinguish multiple cases.
 */



#define __generic(expr,t,yes,no) _Generic(expr, t: yes, default: no)







/*
 * C99 Static array indices in function parameter declarations.  Syntax such as:
 * void bar(int myArray[static 10]);
 * is allowed in C99 but not in C++.  Define __min_size appropriately so
 * headers using it can be compiled in either language.  Use like this:
 * void bar(int myArray[__min_size(10)]);
 */



#define __min_size(x) static (x)





#define __malloc_like __attribute__((__malloc__))
#define __pure __attribute__((__pure__))






#define __always_inline __inline__ __attribute__((__always_inline__))





#define __noinline __attribute__ ((__noinline__))





#define __nonnull(x) __attribute__((__nonnull__ x))
#define __nonnull_all __attribute__((__nonnull__))






#define __fastcall __attribute__((__fastcall__))
#define __result_use_check __attribute__((__warn_unused_result__))






#define __returns_twice __attribute__((__returns_twice__))





#define __unreachable() __builtin_unreachable()




/* XXX: should use `#if __STDC_VERSION__ < 199901'. */




/*
 * GCC 2.95 provides `__restrict' as an extension to C90 to support the
 * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
 * a way to define the `restrict' type qualifier without disturbing older
 * software that is unaware of C99 keywords.
 */




#define __restrict restrict



/*
 * GNU C version 2.96 adds explicit branch prediction so that
 * the CPU back-end can hint the processor and also so that
 * code blocks can be reordered such that the predicted path
 * sees a more linear flow, thus improving cache behavior, etc.
 *
 * The following two macros provide us with a way to utilize this
 * compiler feature.  Use __predict_true() if you expect the expression
 * to evaluate to true, and __predict_false() if you expect the
 * expression to evaluate to false.
 *
 * A few notes about usage:
 *
 *	* Generally, __predict_false() error condition checks (unless
 *	  you have some _strong_ reason to do otherwise, in which case
 *	  document it), and/or __predict_true() `no-error' condition
 *	  checks, assuming you want to optimize for the no-error case.
 *
 *	* Other than that, if you don't know the likelihood of a test
 *	  succeeding from empirical or other `hard' evidence, don't
 *	  make predictions.
 *
 *	* These are meant to be used in places that are run `a lot'.
 *	  It is wasteful to make predictions in code that is run
 *	  seldomly (e.g. at subsystem initialization time) as the
 *	  basic block reordering that this affects can often generate
 *	  larger code.
 */

#define __predict_true(exp) __builtin_expect((exp), 1)
#define __predict_false(exp) __builtin_expect((exp), 0)






#define __null_sentinel __attribute__((__sentinel__))
#define __exported __attribute__((__visibility__("default")))
/* Only default visibility is supported on PE/COFF targets. */

#define __hidden __attribute__((__visibility__("hidden")))
# 497 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
#define __offsetof(type,field) offsetof(type, field)
#define __rangeof(type,start,end) (__offsetof(type, end) - __offsetof(type, start))


/*
 * Given the pointer x to the member m of the struct s, return
 * a pointer to the containing structure.  When using GCC, we first
 * assign pointer x to a local variable, to check that its type is
 * compatible with member m.
 */

#define __containerof(x,s,m) ({ const volatile __typeof(((s *)0)->m) *__x = (x); __DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));})
# 517 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
/*
 * Compiler-dependent macros to declare that functions take printf-like
 * or scanf-like arguments.  They are null except for versions of gcc
 * that are known to support the features properly (old versions of gcc-2
 * didn't permit keeping the keywords out of the application namespace).
 */







#define __printflike(fmtarg,firstvararg) __attribute__((__format__ (__printf__, fmtarg, firstvararg)))

#define __scanflike(fmtarg,firstvararg) __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))

#define __format_arg(fmtarg) __attribute__((__format_arg__ (fmtarg)))
#define __strfmonlike(fmtarg,firstvararg) __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))

#define __strftimelike(fmtarg,firstvararg) __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))



/* Compiler-dependent macros that rely on FreeBSD-specific extensions. */





#define __printf0like(fmtarg,firstvararg) 




#define __strong_reference(sym,aliassym) extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))




#define __weak_reference(sym,alias) __asm__(".weak " #alias); __asm__(".equ " #alias ", " #sym)


#define __warn_references(sym,msg) __asm__(".section .gnu.warning." #sym); __asm__(".asciz \"" msg "\""); __asm__(".previous")



#define __sym_compat(sym,impl,verid) __asm__(".symver " #impl ", " #sym "@" #verid)

#define __sym_default(sym,impl,verid) __asm__(".symver " #impl ", " #sym "@@" #verid)
# 601 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
#define __FBSDID(s) struct __hack



#define __RCSID(s) struct __hack



#define __RCSID_SOURCE(s) struct __hack



#define __SCCSID(s) struct __hack



#define __COPYRIGHT(s) struct __hack



#define __DECONST(type,var) ((type)(__uintptr_t)(const void *)(var))



#define __DEVOLATILE(type,var) ((type)(__uintptr_t)(volatile void *)(var))



#define __DEQUALIFY(type,var) ((type)(__uintptr_t)(const volatile void *)(var))


/*
 * Nullability qualifiers: currently only supported by Clang.
 */

#define _Nonnull 
#define _Nullable 
#define _Null_unspecified 
#define __NULLABILITY_PRAGMA_PUSH 
#define __NULLABILITY_PRAGMA_POP 






/*
 * Type Safety Checking
 *
 * Clang provides additional attributes to enable checking type safety
 * properties that cannot be enforced by the C type system. 
 */
# 661 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 3 4
#define __arg_type_tag(arg_kind,arg_idx,type_tag_idx) 
#define __datatype_type_tag(kind,type) 


/*
 * Lock annotations.
 *
 * Clang provides support for doing basic thread-safety tests at
 * compile-time, by marking which locks will/should be held when
 * entering/leaving a functions.
 *
 * Furthermore, it is also possible to annotate variables and structure
 * members to enforce that they are only accessed when certain locks are
 * held.
 */




#define __lock_annotate(x) 


/* Structure implements a lock. */
/* FIXME: Use __lockable__, etc. to avoid colliding with user namespace macros,
 * once clang is fixed: https://bugs.llvm.org/show_bug.cgi?id=34319 */
#define __lockable __lock_annotate(lockable)

/* Function acquires an exclusive or shared lock. */
#define __locks_exclusive(...) __lock_annotate(exclusive_lock_function(__VA_ARGS__))

#define __locks_shared(...) __lock_annotate(shared_lock_function(__VA_ARGS__))


/* Function attempts to acquire an exclusive or shared lock. */
#define __trylocks_exclusive(...) __lock_annotate(exclusive_trylock_function(__VA_ARGS__))

#define __trylocks_shared(...) __lock_annotate(shared_trylock_function(__VA_ARGS__))


/* Function releases a lock. */
#define __unlocks(...) __lock_annotate(unlock_function(__VA_ARGS__))

/* Function asserts that an exclusive or shared lock is held. */
#define __asserts_exclusive(...) __lock_annotate(assert_exclusive_lock(__VA_ARGS__))

#define __asserts_shared(...) __lock_annotate(assert_shared_lock(__VA_ARGS__))


/* Function requires that an exclusive or shared lock is or is not held. */
#define __requires_exclusive(...) __lock_annotate(exclusive_locks_required(__VA_ARGS__))

#define __requires_shared(...) __lock_annotate(shared_locks_required(__VA_ARGS__))

#define __requires_unlocked(...) __lock_annotate(locks_excluded(__VA_ARGS__))


/* Function should not be analyzed. */
#define __no_lock_analysis __lock_annotate(no_thread_safety_analysis)

/* Guard variables and structure members by lock. */
#define __guarded_by(x) __lock_annotate(guarded_by(x))
#define __pt_guarded_by(x) __lock_annotate(pt_guarded_by(x))
# 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/limits.h" 2 3 4


#define MB_LEN_MAX _MB_LEN_MAX




/* Maximum number of positional arguments, if _WANT_IO_POS_ARGS.  */

#define NL_ARGMAX 32


/* if do not have #include_next support, then we
   have to define the limits here. */
# 135 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/limits.h" 3 4
/* The maximum number of repeated occurrences of a regular expression
 *    permitted when using the interval notation `\{M,N\}'.  */
#define _POSIX2_RE_DUP_MAX 255



#define ARG_MAX 4096



#define PATH_MAX 4096
# 195 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 2 3 4
# 8 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/syslimits.h" 2 3 4
#undef _GCC_NEXT_LIMITS_H
# 35 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 2 3 4

/* Copyright (C) 1991-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */


#define _LIMITS_H___ 

/* Number of bits in a `char'.  */
#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__

/* Maximum length of a multibyte character.  */




/* Minimum and maximum values a `signed char' can hold.  */
#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__

/* Maximum value an `unsigned char' can hold.  (Minimum is 0).  */
#undef UCHAR_MAX



#define UCHAR_MAX (SCHAR_MAX * 2 + 1)


/* Minimum and maximum values a `char' can hold.  */

#undef CHAR_MIN



#define CHAR_MIN 0

#undef CHAR_MAX
#define CHAR_MAX UCHAR_MAX







/* Minimum and maximum values a `signed short int' can hold.  */
#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__

/* Maximum value an `unsigned short int' can hold.  (Minimum is 0).  */
#undef USHRT_MAX



#define USHRT_MAX (SHRT_MAX * 2 + 1)


/* Minimum and maximum values a `signed int' can hold.  */
#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__

/* Maximum value an `unsigned int' can hold.  (Minimum is 0).  */
#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)

/* Minimum and maximum values a `signed long int' can hold.
   (Same as `int').  */
#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__

/* Maximum value an `unsigned long int' can hold.  (Minimum is 0).  */
#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)


/* Minimum and maximum values a `signed long long int' can hold.  */
#undef LLONG_MIN
#define LLONG_MIN (-LLONG_MAX - 1LL)
#undef LLONG_MAX
#define LLONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
#undef ULLONG_MAX
#define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)



/* Minimum and maximum values a `signed long long int' can hold.  */
#undef LONG_LONG_MIN
#define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)
#undef LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__

/* Maximum value an `unsigned long long int' can hold.  (Minimum is 0).  */
#undef ULONG_LONG_MAX
#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)
# 188 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include-fixed/limits.h" 3 4
/* This administrivia gets added to the end of limits.h
   if the system has its own version of limits.h.  */
# 30 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 31 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 2

# 1 "repos/apache-mynewt-core/libc/baselibc/include/string.h" 1

# 1 "repos/apache-mynewt-core/libc/baselibc/include/string.h"
/*
 * string.h
 */
# 33 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 1
/*
 * stdio.h
 */
# 34 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 2




# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 39 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 2
# 53 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
#define CBOR_API 


#define CBOR_PRIVATE_API 






#define CBOR_INLINE_API static CBOR_INLINE



#define CBOR_INLINE __inline__
# 76 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"

# 76 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
typedef enum CborType {
    CborIntegerType = 0x00,
    CborByteStringType = 0x40,
    CborTextStringType = 0x60,
    CborArrayType = 0x80,
    CborMapType = 0xa0,
    CborTagType = 0xc0,
    CborSimpleType = 0xe0,
    CborBooleanType = 0xf5,
    CborNullType = 0xf6,
    CborUndefinedType = 0xf7,
    CborHalfFloatType = 0xf9,
    CborFloatType = 0xfa,
    CborDoubleType = 0xfb,

    CborInvalidType = 0xff /* equivalent to the break byte, so it will never be used */
} CborType;

typedef uint64_t CborTag;
typedef enum CborKnownTags {
    CborDateTimeStringTag = 0, /* RFC 3339 format: YYYY-MM-DD hh:mm:ss+zzzz */
    CborUnixTime_tTag = 1,
    CborPositiveBignumTag = 2,
    CborNegativeBignumTag = 3,
    CborDecimalTag = 4,
    CborBigfloatTag = 5,
    CborExpectedBase64urlTag = 21,
    CborExpectedBase64Tag = 22,
    CborExpectedBase16Tag = 23,
    CborUriTag = 32,
    CborBase64urlTag = 33,
    CborBase64Tag = 34,
    CborRegularExpressionTag = 35,
    CborMimeMessageTag = 36, /* RFC 2045-2047 */
    CborSignatureTag = 55799
} CborKnownTags;

/* Error API */

typedef enum CborError {
    CborNoError = 0,

    /* errors in all modes */
    CborUnknownError,
    CborErrorUnknownLength, /* request for length in array, map, or string with indeterminate length */
    CborErrorAdvancePastEOF,
    CborErrorIO,

    /* parser errors streaming errors */
    CborErrorGarbageAtEnd = 256,
    CborErrorUnexpectedEOF,
    CborErrorUnexpectedBreak,
    CborErrorUnknownType, /* can only heppen in major type 7 */
    CborErrorIllegalType, /* type not allowed here */
    CborErrorIllegalNumber,
    CborErrorIllegalSimpleType, /* types of value less than 32 encoded in two bytes */

    /* parser errors in strict mode parsing only */
    CborErrorUnknownSimpleType = 512,
    CborErrorUnknownTag,
    CborErrorInappropriateTagForType,
    CborErrorDuplicateObjectKeys,
    CborErrorInvalidUtf8TextString,

    /* encoder errors */
    CborErrorTooManyItems = 768,
    CborErrorTooFewItems,

    /* internal implementation errors */
    CborErrorDataTooLarge = 1024,
    CborErrorNestingTooDeep,
    CborErrorUnsupportedType,

    /* errors in converting to JSON */
    CborErrorJsonObjectKeyIsAggregate,
    CborErrorJsonObjectKeyNotString,
    CborErrorJsonNotImplemented,

    CborErrorOutOfMemory = ~0U / 2 + 1,
    CborErrorInternalError = ~0U
} CborError;

 const char *cbor_error_string(CborError error);

struct cbor_encoder_writer;

typedef int (cbor_encoder_write)(struct cbor_encoder_writer *, const char *data, int len);

typedef struct cbor_encoder_writer {
    cbor_encoder_write *write;
    int bytes_written;
} cbor_encoder_writer;

struct cbor_iovec {
    void *iov_base;
    size_t iov_len;
};

/* Encoder API */
struct CborEncoder {
    cbor_encoder_writer *writer;
    void *writer_arg;
    size_t added;
    int flags;
};
typedef struct CborEncoder CborEncoder;

static const size_t CborIndefiniteLength = 
# 183 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
                                          (0xffffffffU)
# 183 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                                                  ;


 void cbor_encoder_init(CborEncoder *encoder, cbor_encoder_writer *pwriter, int flags);
 CborError cbor_encode_uint(CborEncoder *encoder, uint64_t value);
 CborError cbor_encode_int(CborEncoder *encoder, int64_t value);
 CborError cbor_encode_negative_int(CborEncoder *encoder, uint64_t absolute_value);
 CborError cbor_encode_simple_value(CborEncoder *encoder, uint8_t value);
 CborError cbor_encode_tag(CborEncoder *encoder, CborTag tag);
 CborError cbor_encode_text_string(CborEncoder *encoder, const char *string, size_t length);
static __inline__ CborError cbor_encode_text_stringz(CborEncoder *encoder, const char *string)
{ return cbor_encode_text_string(encoder, string, strlen(string)); }
 CborError cbor_encode_byte_string(CborEncoder *encoder, const uint8_t *string, size_t length);
 CborError cbor_encode_byte_iovec(CborEncoder *encoder,
                                          const struct cbor_iovec iov[],
                                          int iov_len);
 CborError cbor_encode_floating_point(CborEncoder *encoder, CborType fpType, const void *value);
static __inline__ CborError cbor_encode_bytes_written(CborEncoder *encoder)
{ return (CborError) encoder->writer->bytes_written; }
static __inline__ CborError cbor_encode_boolean(CborEncoder *encoder, 
# 202 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
                                                                   _Bool 
# 202 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                                                                        value)
{ return cbor_encode_simple_value(encoder, (int)value - 1 + (CborBooleanType & 0x1f)); }
static __inline__ CborError cbor_encode_null(CborEncoder *encoder)
{ return cbor_encode_simple_value(encoder, CborNullType & 0x1f); }
static __inline__ CborError cbor_encode_undefined(CborEncoder *encoder)
{ return cbor_encode_simple_value(encoder, CborUndefinedType & 0x1f); }

static __inline__ CborError cbor_encode_half_float(CborEncoder *encoder, const void *value)
{ return cbor_encode_floating_point(encoder, CborHalfFloatType, value); }
static __inline__ CborError cbor_encode_float(CborEncoder *encoder, float value)
{ return cbor_encode_floating_point(encoder, CborFloatType, &value); }
static __inline__ CborError cbor_encode_double(CborEncoder *encoder, double value)
{ return cbor_encode_floating_point(encoder, CborDoubleType, &value); }

 CborError cbor_encoder_create_array(CborEncoder *encoder, CborEncoder *arrayEncoder, size_t length);
 CborError cbor_encoder_create_map(CborEncoder *encoder, CborEncoder *mapEncoder, size_t length);
 CborError cbor_encoder_create_indef_byte_string(CborEncoder *encoder, CborEncoder *stringEncoder);
 CborError cbor_encoder_close_container(CborEncoder *encoder, const CborEncoder *containerEncoder);
 CborError cbor_encoder_close_container_checked(CborEncoder *encoder, const CborEncoder *containerEncoder);

/* Parser API */

enum CborParserIteratorFlags
{
    CborIteratorFlag_IntegerValueTooLarge = 0x01,
    CborIteratorFlag_NegativeInteger = 0x02,
    CborIteratorFlag_UnknownLength = 0x04,
    CborIteratorFlag_ContainerIsMap = 0x20
};

struct cbor_decoder_reader;

typedef uint8_t (cbor_reader_get8)(struct cbor_decoder_reader *d, int offset);
typedef uint16_t (cbor_reader_get16)(struct cbor_decoder_reader *d, int offset);
typedef uint32_t (cbor_reader_get32)(struct cbor_decoder_reader *d, int offset);
typedef uint64_t (cbor_reader_get64)(struct cbor_decoder_reader *d, int offset);
typedef uintptr_t (cbor_memcmp)(struct cbor_decoder_reader *d, char *buf, int offset, size_t len);
typedef uintptr_t (cbor_memcpy)(struct cbor_decoder_reader *d, char *buf, int offset, size_t len);

struct cbor_decoder_reader {
    cbor_reader_get8 *get8;
    cbor_reader_get16 *get16;
    cbor_reader_get32 *get32;
    cbor_reader_get64 *get64;
    cbor_memcmp *cmp;
    cbor_memcpy *cpy;
    size_t message_size;
};

struct CborParser
{
    struct cbor_decoder_reader *d;
    int end;
    int flags;
};
typedef struct CborParser CborParser;

struct CborValue
{
    const CborParser *parser;
    int offset;
    uint32_t remaining;
    uint16_t extra;
    uint8_t type;
    uint8_t flags;
};
typedef struct CborValue CborValue;

 CborError cbor_parser_init(struct cbor_decoder_reader *d, int flags, CborParser *parser, CborValue *it);

static __inline__ 
# 272 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 272 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_at_end(const CborValue *it)
{ return it->remaining == 0; }
 CborError cbor_value_advance_fixed(CborValue *it);
 CborError cbor_value_advance(CborValue *it);
static __inline__ 
# 276 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 276 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_container(const CborValue *it)
{ return it->type == CborArrayType || it->type == CborMapType; }
 CborError cbor_value_enter_container(const CborValue *it, CborValue *recursed);
 CborError cbor_value_leave_container(CborValue *it, const CborValue *recursed);

 uint64_t _cbor_value_decode_int64_internal(const CborValue *value);
static __inline__ uint64_t _cbor_value_extract_int64_helper(const CborValue *value)
{
    return value->flags & CborIteratorFlag_IntegerValueTooLarge ?
                _cbor_value_decode_int64_internal(value) : value->extra;
}

static __inline__ 
# 288 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 288 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_valid(const CborValue *value)
{ return value && value->type != CborInvalidType; }
static __inline__ CborType cbor_value_get_type(const CborValue *value)
{ return (CborType)value->type; }

/* Null & undefined type */
static __inline__ 
# 294 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 294 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_null(const CborValue *value)
{ return value->type == CborNullType; }
static __inline__ 
# 296 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 296 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_undefined(const CborValue *value)
{ return value->type == CborUndefinedType; }

/* Booleans */
static __inline__ 
# 300 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 300 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_boolean(const CborValue *value)
{ return value->type == CborBooleanType; }
static __inline__ CborError cbor_value_get_boolean(const CborValue *value, 
# 302 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
                                                                        _Bool 
# 302 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                                                                             *result)
{
    ((cbor_value_is_boolean(value)) ? (void)0 : __assert_func(
# 304 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 304 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 304 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 304 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 304 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 304 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = !!value->extra;
    return CborNoError;
}

/* Simple types */
static __inline__ 
# 310 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 310 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_simple_type(const CborValue *value)
{ return value->type == CborSimpleType; }
static __inline__ CborError cbor_value_get_simple_type(const CborValue *value, uint8_t *result)
{
    ((cbor_value_is_simple_type(value)) ? (void)0 : __assert_func(
# 314 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 314 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 314 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 314 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 314 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 314 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = (uint8_t)value->extra;
    return CborNoError;
}

/* Integers */
static __inline__ 
# 320 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 320 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_integer(const CborValue *value)
{ return value->type == CborIntegerType; }
static __inline__ 
# 322 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 322 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_unsigned_integer(const CborValue *value)
{ return cbor_value_is_integer(value) && (value->flags & CborIteratorFlag_NegativeInteger) == 0; }
static __inline__ 
# 324 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 324 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_negative_integer(const CborValue *value)
{ return cbor_value_is_integer(value) && (value->flags & CborIteratorFlag_NegativeInteger); }

static __inline__ CborError cbor_value_get_raw_integer(const CborValue *value, uint64_t *result)
{
    ((cbor_value_is_integer(value)) ? (void)0 : __assert_func(
# 329 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 329 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 329 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 329 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 329 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 329 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = _cbor_value_extract_int64_helper(value);
    return CborNoError;
}

static __inline__ CborError cbor_value_get_uint64(const CborValue *value, uint64_t *result)
{
    ((cbor_value_is_unsigned_integer(value)) ? (void)0 : __assert_func(
# 336 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 336 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 336 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 336 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 336 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 336 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = _cbor_value_extract_int64_helper(value);
    return CborNoError;
}

static __inline__ CborError cbor_value_get_int64(const CborValue *value, int64_t *result)
{
    ((cbor_value_is_integer(value)) ? (void)0 : __assert_func(
# 343 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 343 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 343 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 343 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 343 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 343 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = (int64_t) _cbor_value_extract_int64_helper(value);
    if (value->flags & CborIteratorFlag_NegativeInteger)
        *result = -*result - 1;
    return CborNoError;
}

static __inline__ CborError cbor_value_get_int(const CborValue *value, int *result)
{
    ((cbor_value_is_integer(value)) ? (void)0 : __assert_func(
# 352 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 352 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 352 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 352 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 352 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 352 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = (int) _cbor_value_extract_int64_helper(value);
    if (value->flags & CborIteratorFlag_NegativeInteger)
        *result = -*result - 1;
    return CborNoError;
}

 CborError cbor_value_get_int64_checked(const CborValue *value, int64_t *result);
 CborError cbor_value_get_int_checked(const CborValue *value, int *result);

static __inline__ 
# 362 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 362 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_length_known(const CborValue *value)
{ return (value->flags & CborIteratorFlag_UnknownLength) == 0; }

/* Tags */
static __inline__ 
# 366 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 366 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_tag(const CborValue *value)
{ return value->type == CborTagType; }
static __inline__ CborError cbor_value_get_tag(const CborValue *value, CborTag *result)
{
    ((cbor_value_is_tag(value)) ? (void)0 : __assert_func(
# 370 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 370 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 370 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 370 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 370 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 370 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    *result = _cbor_value_extract_int64_helper(value);
    return CborNoError;
}
 CborError cbor_value_skip_tag(CborValue *it);

/* Strings */
static __inline__ 
# 377 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 377 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_byte_string(const CborValue *value)
{ return value->type == CborByteStringType; }
static __inline__ 
# 379 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 379 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_text_string(const CborValue *value)
{ return value->type == CborTextStringType; }

static __inline__ CborError cbor_value_get_string_length(const CborValue *value, size_t *length)
{
    ((cbor_value_is_byte_string(value) || cbor_value_is_text_string(value)) ? (void)0 : __assert_func(
# 384 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 384 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 384 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 384 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 384 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 384 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    if (!cbor_value_is_length_known(value))
        return CborErrorUnknownLength;
    uint64_t v = _cbor_value_extract_int64_helper(value);
    *length = v;
    if (*length != v)
        return CborErrorDataTooLarge;
    return CborNoError;
}

 CborError _cbor_value_copy_string(const CborValue *value, void *buffer,
                                                   size_t *buflen, CborValue *next);
 CborError _cbor_value_dup_string(const CborValue *value, void **buffer,
                                                  size_t *buflen, CborValue *next);

 CborError cbor_value_calculate_string_length(const CborValue *value, size_t *length);

static __inline__ CborError cbor_value_copy_text_string(const CborValue *value, char *buffer,
                                                      size_t *buflen, CborValue *next)
{
    ((cbor_value_is_text_string(value)) ? (void)0 : __assert_func(
# 404 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 404 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 404 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 404 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 404 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 404 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    return _cbor_value_copy_string(value, buffer, buflen, next);
}
static __inline__ CborError cbor_value_copy_byte_string(const CborValue *value, uint8_t *buffer,
                                                      size_t *buflen, CborValue *next)
{
    ((cbor_value_is_byte_string(value)) ? (void)0 : __assert_func(
# 410 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 410 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 410 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 410 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 410 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 410 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    return _cbor_value_copy_string(value, buffer, buflen, next);
}

static __inline__ CborError cbor_value_dup_text_string(const CborValue *value, char **buffer,
                                                     size_t *buflen, CborValue *next)
{
    ((cbor_value_is_text_string(value)) ? (void)0 : __assert_func(
# 417 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 417 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 417 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 417 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 417 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 417 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    return _cbor_value_dup_string(value, (void **)buffer, buflen, next);
}
static __inline__ CborError cbor_value_dup_byte_string(const CborValue *value, uint8_t **buffer,
                                                     size_t *buflen, CborValue *next)
{
    ((cbor_value_is_byte_string(value)) ? (void)0 : __assert_func(
# 423 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 423 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 423 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 423 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 423 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 423 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    return _cbor_value_dup_string(value, (void **)buffer, buflen, next);
}

/* ### TBD: partial reading API */

 CborError cbor_value_text_string_equals(const CborValue *value, const char *string, 
# 429 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
                                                                                            _Bool 
# 429 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                                                                                                 *result);

/* Maps and arrays */
static __inline__ 
# 432 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 432 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_array(const CborValue *value)
{ return value->type == CborArrayType; }
static __inline__ 
# 434 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 434 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_map(const CborValue *value)
{ return value->type == CborMapType; }

static __inline__ CborError cbor_value_get_array_length(const CborValue *value, size_t *length)
{
    ((cbor_value_is_array(value)) ? (void)0 : __assert_func(
# 439 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 439 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 439 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 439 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 439 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 439 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    if (!cbor_value_is_length_known(value))
        return CborErrorUnknownLength;
    uint64_t v = _cbor_value_extract_int64_helper(value);
    *length = v;
    if (*length != v)
        return CborErrorDataTooLarge;
    return CborNoError;
}

static __inline__ CborError cbor_value_get_map_length(const CborValue *value, size_t *length)
{
    ((cbor_value_is_map(value)) ? (void)0 : __assert_func(
# 451 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 451 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 451 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 451 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 451 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 451 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    if (!cbor_value_is_length_known(value))
        return CborErrorUnknownLength;
    uint64_t v = _cbor_value_extract_int64_helper(value);
    *length = v;
    if (*length != v)
        return CborErrorDataTooLarge;
    return CborNoError;
}

 CborError cbor_value_map_find_value(const CborValue *map, const char *string, CborValue *element);

/* Floating point */
static __inline__ 
# 464 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 464 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_half_float(const CborValue *value)
{ return value->type == CborHalfFloatType; }
 CborError cbor_value_get_half_float(const CborValue *value, void *result);

static __inline__ 
# 468 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 468 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_float(const CborValue *value)
{ return value->type == CborFloatType; }
static __inline__ CborError cbor_value_get_float(const CborValue *value, float *result)
{
    ((cbor_value_is_float(value)) ? (void)0 : __assert_func(
# 472 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 472 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 472 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 472 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 472 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 472 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    ((value->flags & CborIteratorFlag_IntegerValueTooLarge) ? (void)0 : __assert_func(
# 473 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 473 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 473 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 473 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 473 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 473 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    uint32_t data = (uint32_t)_cbor_value_decode_int64_internal(value);
    memcpy(result, &data, sizeof(*result));
    return CborNoError;
}

static __inline__ 
# 479 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
               _Bool 
# 479 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
                    cbor_value_is_double(const CborValue *value)
{ return value->type == CborDoubleType; }
static __inline__ CborError cbor_value_get_double(const CborValue *value, double *result)
{
    ((cbor_value_is_double(value)) ? (void)0 : __assert_func(
# 483 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 483 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 483 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 483 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 483 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 483 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    ((value->flags & CborIteratorFlag_IntegerValueTooLarge) ? (void)0 : __assert_func(
# 484 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 484 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 0, 
# 484 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 484 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   , 
# 484 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 3 4
   ((void *)0)
# 484 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h"
   ));
    uint64_t data = _cbor_value_decode_int64_internal(value);
    memcpy(result, &data, sizeof(*result));
    return CborNoError;
}

/* Human-readable (dump) API */
 CborError cbor_value_to_pretty_advance(FILE *out, CborValue *value);
static __inline__ CborError cbor_value_to_pretty(FILE *out, const CborValue *value)
{
    CborValue copy = *value;
    return cbor_value_to_pretty_advance(out, &copy);
}

struct mgmt_cbuf {
    struct CborParser parser;
    struct CborEncoder encoder;
    struct CborValue it;
};
# 24 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_constants.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_CONSTANTS_H 





/* OCF standard resource interfaces */
#define OC_NUM_STD_INTERFACES (7)
#define OC_RSRVD_IF_BASELINE "oic.if.baseline"
#define OC_BASELINE_IF_LEN (15)
#define OC_RSRVD_IF_LL "oic.if.ll"
#define OC_LL_IF_LEN (9)
#define OC_RSRVD_IF_B "oic.if.b"
#define OC_B_IF_LEN (8)
#define OC_RSRVD_IF_R "oic.if.r"
#define OC_R_IF_LEN (8)
#define OC_RSRVD_IF_RW "oic.if.rw"
#define OC_RW_IF_LEN (9)
#define OC_RSRVD_IF_A "oic.if.a"
#define OC_A_IF_LEN (8)
#define OC_RSRVD_IF_S "oic.if.s"
#define OC_S_IF_LEN (8)

/* OCF Core resource URIs */
#define OC_RSRVD_WELL_KNOWN_URI "/oic/res"
#define OC_MULTICAST_DISCOVERY_URI "/oic/res"
#define OC_RSRVD_DEVICE_URI "/oic/d"
#define OC_RSRVD_PLATFORM_URI "/oic/p"
# 25 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_HELPERS_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 21 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 2

# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 1

# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h"
/*
 * stdio.h
 */
# 23 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/string.h" 1
/*
 * string.h
 */
# 24 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 2





#define STRING_ARRAY_ITEM_MAX_LEN 24

typedef struct oc_string {
    uint16_t os_sz;
    uint8_t *os_str;
} oc_string_t;

typedef struct oc_array {
    uint16_t oa_sz;
    union {
        
# 39 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 3 4
       _Bool 
# 39 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h"
            *b;
        int64_t *i;
        double *d;
        char *s;
    } oa_arr;
} oc_array_t;

typedef struct oc_array oc_string_array_t;

#define oc_string(ocstring) ((char *)(ocstring).os_str)

void oc_new_string(oc_string_t *ocstring, const char str[]);
void oc_alloc_string(oc_string_t *ocstring, int size);
void oc_free_string(oc_string_t *ocstring);
void oc_concat_strings(oc_string_t *concat, const char *, const char *);
#define oc_string_len(ocstring) ((ocstring).os_sz ? (ocstring).os_sz - 1 : 0)

void _oc_new_array(oc_array_t *ocarray, uint8_t size, uint8_t elem_sz);
void _oc_free_array(oc_array_t *ocarray);

#define oc_new_int_array(ocarray,size) _oc_new_array(ocarray, size, sizeof(uint64_t))

#define oc_new_bool_array(ocarray,size) _oc_new_array(ocarray, size, sizeof(bool))

#define oc_new_double_array(ocarray,size) _oc_new_array(ocarray, size, sizeof(double))

#define oc_free_int_array(ocarray) _oc_free_array(ocarray)
#define oc_free_bool_array(ocarray) _oc_free_array(ocarray)
#define oc_free_double_array(ocarray) _oc_free_array(ocarray)
#define oc_int_array_size(ocintarray) ((ocintarray).oa_sz / sizeof(int64_t))
#define oc_bool_array_size(ocboolarray) ((ocboolarray).oa_sz / sizeof(bool))
#define oc_double_array_size(ocdoublearray) ((ocdoublearray).oa_sz / sizeof(double))

#define oc_int_array(ocintarray) (ocintarray.oa_arr.i)
#define oc_bool_array(ocboolarray) (ocboolarray.oa_arr.b)
#define oc_double_array(ocdoublearray) (ocdoublearray.oa_arr.d)

void _oc_alloc_string_array(oc_string_array_t *ocstringarray, uint8_t size);

# 77 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 3 4
_Bool 
# 77 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h"
    _oc_copy_string_to_string_array(oc_string_array_t *ocstringarray,
                                     const char str[], uint8_t index);

# 79 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h" 3 4
_Bool 
# 79 "repos/apache-mynewt-core/net/oic/include/oic/oc_helpers.h"
    _oc_string_array_add_item(oc_string_array_t *ocstringarray,
                               const char str[]);
#define oc_new_string_array(ocstringarray,size) (_oc_alloc_string_array(ocstringarray, size))

#define oc_free_string_array(ocs) (_oc_free_array(ocs))
#define oc_string_array_add_item(ocstringarray,str) (_oc_string_array_add_item(&(ocstringarray), str))

#define oc_string_array_get_item(ocstringarray,index) (&(ocstringarray.oa_arr.s[index * STRING_ARRAY_ITEM_MAX_LEN]))

#define oc_string_array_set_item(ocstringarray,str,index) (_oc_copy_string_to_string_array(&(ocstringarray), str, index))

#define oc_string_array_get_item_size(ocstringarray,index) (strlen(oc_string_array_get_item(ocstringarray, index)))

#define oc_string_array_get_allocated_size(ocstringarray) (ocstringarray.oa_sz / STRING_ARRAY_ITEM_MAX_LEN)
# 26 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 2






extern CborEncoder g_encoder, root_map, links_array;
extern CborError g_err;

struct os_mbuf;
void oc_rep_new(struct os_mbuf *m);
void oc_rep_reset(void);
int oc_rep_finalize(void);

#define oc_rep_object(name) &name ##_map
#define oc_rep_array(name) &name ##_array

#define oc_rep_set_double(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_double(&object ##_map, value); } while (0)





#define oc_rep_set_int(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_int(&object ##_map, value); } while (0)





#define oc_rep_set_uint(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_uint(&object ##_map, value); } while (0)





#define oc_rep_set_boolean(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_boolean(&object ##_map, value); } while (0)





#define oc_rep_set_text_string(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_text_string(&object ##_map, value, strlen(value)); } while (0)





#define oc_rep_set_byte_string(object,key,value,length) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_byte_string(&object ##_map, value, length); } while (0)





#define oc_rep_set_byte_string_iov(object,key,iov,iov_len) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); g_err |= cbor_encode_byte_iovec(&object ##_map, iov, iov_len); } while (0)





#define oc_rep_start_array(parent,key) do { CborEncoder key ##_array; g_err |= cbor_encoder_create_array(&parent, &key ##_array, CborIndefiniteLength)





#define oc_rep_end_array(parent,key) g_err |= cbor_encoder_close_container(&parent, &key ##_array); } while (0)




#define oc_rep_start_links_array() g_err |= cbor_encoder_create_array(&g_encoder, &links_array, CborIndefiniteLength)



#define oc_rep_end_links_array() g_err |= cbor_encoder_close_container(&g_encoder, &links_array)


#define oc_rep_start_root_object() g_err |= cbor_encoder_create_map(&g_encoder, &root_map, CborIndefiniteLength)


#define oc_rep_end_root_object() g_err |= cbor_encoder_close_container(&g_encoder, &root_map)


#define oc_rep_add_byte_string(parent,value) g_err |= cbor_encode_byte_string(&parent ##_array, value, strlen(value))


#define oc_rep_add_text_string(parent,value) g_err |= cbor_encode_text_string(&parent ##_array, value, strlen(value))


#define oc_rep_set_key(parent,key) g_err |= cbor_encode_text_string(&parent, key, strlen(key))


#define oc_rep_set_array(object,key) g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); oc_rep_start_array(object ##_map, key)



#define oc_rep_close_array(object,key) oc_rep_end_array(object ##_map, key)

#define oc_rep_start_object(parent,key) do { CborEncoder key ##_map; g_err |= cbor_encoder_create_map(&parent, &key ##_map, CborIndefiniteLength)




#define oc_rep_end_object(parent,key) g_err |= cbor_encoder_close_container(&parent, &key ##_map); } while (0)




#define oc_rep_object_array_start_item(key) oc_rep_start_object(key ##_array, key)


#define oc_rep_object_array_end_item(key) oc_rep_end_object(key ##_array, key)

#define oc_rep_set_object(object,key) g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); oc_rep_start_object(object ##_map, key)



#define oc_rep_close_object(object,key) oc_rep_end_object(object ##_map, key)

#define oc_rep_set_int_array(object,key,values,length) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); CborEncoder key ##_value_array; g_err |= cbor_encoder_create_array(&object ##_map, &key ##_value_array, length); int i; for (i = 0; i < length; i++) { g_err |= cbor_encode_int(&key ##_value_array, values[i]); } g_err |= cbor_encoder_close_container(&object ##_map, &key ##_value_array); } while (0)
# 158 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h"
#define oc_rep_set_bool_array(object,key,values,length) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); CborEncoder key ##_value_array; g_err |= cbor_encoder_create_array(&object ##_map, &key ##_value_array, length); int i; for (i = 0; i < length; i++) { g_err |= cbor_encode_boolean(&key ##_value_array, values[i]); } g_err |= cbor_encoder_close_container(&object ##_map, &key ##_value_array); } while (0)
# 171 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h"
#define oc_rep_set_double_array(object,key,values,length) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); CborEncoder key ##_value_array; g_err |= cbor_encoder_create_array(&object ##_map, &key ##_value_array, length); int i; for (i = 0; i < length; i++) { g_err |= cbor_encode_floating_point(&key ##_value_array, CborDoubleType, &values[i]); } g_err |= cbor_encoder_close_container(&object ##_map, &key ##_value_array); } while (0)
# 185 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h"
#define oc_rep_set_string_array(object,key,values) do { g_err |= cbor_encode_text_string(&object ##_map, #key, strlen(#key)); CborEncoder key ##_value_array; g_err |= cbor_encoder_create_array(&object ##_map, &key ##_value_array, oc_string_array_get_allocated_size(values)); int i; for (i = 0; i < oc_string_array_get_allocated_size(values); i++) { g_err |= cbor_encode_text_string( &key ##_value_array, oc_string_array_get_item(values, i), oc_string_array_get_item_size(values, i)); } g_err |= cbor_encoder_close_container(&object ##_map, &key ##_value_array); } while (0)
# 202 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h"
typedef enum {
  NIL = 0,
  INT = 0x01,
  DOUBLE = 0x02,
  BOOL = 0x03,
  BYTE_STRING = 0x04,
  STRING = 0x05,
  OBJECT = 0x06,
  ARRAY = 0x08,
  INT_ARRAY = 0x09,
  DOUBLE_ARRAY = 0x0A,
  BOOL_ARRAY = 0x0B,
  BYTE_STRING_ARRAY = 0x0C,
  STRING_ARRAY = 0x0D,
  OBJECT_ARRAY = 0x0E
} oc_rep_value_type_t;

typedef struct oc_rep_s
{
  oc_rep_value_type_t type;
  struct oc_rep_s *next;
  oc_string_t name;
  union
  {
    int64_t value_int;
    
# 227 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 3 4
   _Bool 
# 227 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h"
        value_boolean;
    double value_double;
    oc_string_t value_string;
    oc_array_t value_array;
    oc_string_array_t value_string_array;
    struct oc_rep_s *value_object;
    struct oc_rep_s *value_object_array;
  };
} oc_rep_t;

uint16_t oc_parse_rep(struct os_mbuf *m, uint16_t payload_off,
                      uint16_t payload_size, oc_rep_t **out_rep);

void oc_free_rep(oc_rep_t *rep);
# 23 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_uuid.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_UUID_H 







typedef struct
{
  uint8_t id[16];
} oc_uuid_t;

void oc_str_to_uuid(const char *str, oc_uuid_t *uuid);
void oc_uuid_to_str(const oc_uuid_t *uuid, char *buffer, int buflen);
void oc_gen_uuid(oc_uuid_t *uuid);
# 24 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri_const.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_RI_CONST_H 

typedef enum { OC_GET = 1, OC_POST, OC_PUT, OC_DELETE } oc_method_t;

typedef enum {
  OC_IF_BASELINE = 1 << 1,
  OC_IF_LL = 1 << 2,
  OC_IF_B = 1 << 3,
  OC_IF_R = 1 << 4,
  OC_IF_RW = 1 << 5,
  OC_IF_A = 1 << 6,
  OC_IF_S = 1 << 7,
} oc_interface_mask_t;

typedef enum {
  OC_STATUS_OK = 0,
  OC_STATUS_CREATED,
  OC_STATUS_CHANGED,
  OC_STATUS_DELETED,
  OC_STATUS_NOT_MODIFIED,
  OC_STATUS_BAD_REQUEST,
  OC_STATUS_UNAUTHORIZED,
  OC_STATUS_BAD_OPTION,
  OC_STATUS_FORBIDDEN,
  OC_STATUS_NOT_FOUND,
  OC_STATUS_METHOD_NOT_ALLOWED,
  OC_STATUS_NOT_ACCEPTABLE,
  OC_STATUS_REQUEST_ENTITY_TOO_LARGE,
  OC_STATUS_UNSUPPORTED_MEDIA_TYPE,
  OC_STATUS_INTERNAL_SERVER_ERROR,
  OC_STATUS_NOT_IMPLEMENTED,
  OC_STATUS_BAD_GATEWAY,
  OC_STATUS_SERVICE_UNAVAILABLE,
  OC_STATUS_GATEWAY_TIMEOUT,
  OC_STATUS_PROXYING_NOT_SUPPORTED,
  __NUM_OC_STATUS_CODES__,
  OC_IGNORE
} oc_status_t;

typedef enum oc_resource_properties {
  OC_DISCOVERABLE = (1 << 0),
  OC_OBSERVABLE = (1 << 1),
  OC_ACTIVE = (1 << 2),
  OC_SECURE = (1 << 4),
  OC_PERIODIC = (1 << 6),
  OC_TRANS_ENC = (1 << 7), /* Requires transport layer encryption. */
  OC_TRANS_AUTH = (1 << 8), /* Requires transport layer authentication. */
} oc_resource_properties_t;

#define OC_TRANS_SEC_MASK (OC_TRANS_ENC | OC_TRANS_AUTH)

typedef enum {
  OCF_RES = 0,
  OCF_P,






  __NUM_OC_CORE_RESOURCES__
} oc_core_resource_t;

#define NUM_OC_CORE_RESOURCES (__NUM_OC_CORE_RESOURCES__ + MAX_NUM_DEVICES)
# 25 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 2





struct oc_separate_response;
struct oc_response_buffer;
struct oc_endpoint;

typedef struct oc_response {
    struct oc_separate_response *separate_response;
    struct oc_response_buffer *response_buffer;
} oc_response_t;

typedef struct oc_request {
    struct oc_endpoint *origin;
    struct oc_resource *resource;
    const char *query;
    int query_len;
    oc_response_t *response;
    struct coap_packet_rx *packet;
} oc_request_t;

typedef void (*oc_request_handler_t)(oc_request_t *, oc_interface_mask_t);

typedef struct oc_resource {
  struct { struct oc_resource *sle_next; /* next element */ } next;
  int device;
  oc_string_t uri;
  oc_string_array_t types;
  oc_interface_mask_t interfaces;
  oc_interface_mask_t default_interface;
  oc_resource_properties_t properties;
  oc_request_handler_t get_handler;
  oc_request_handler_t put_handler;
  oc_request_handler_t post_handler;
  oc_request_handler_t delete_handler;
  struct os_callout callout;
  uint32_t observe_period_mseconds;
  uint8_t num_observers;
} oc_resource_t;

void oc_ri_init(void);

void oc_ri_shutdown(void);

int oc_status_code(oc_status_t key);

oc_resource_t *oc_ri_get_app_resource_by_uri(const char *uri);

oc_resource_t *oc_ri_get_app_resources(void);







int oc_ri_get_query_nth_key_value(const char *query, int query_len, char **key,
                                  int *key_len, char **value, int *value_len,
                                  int n);
int oc_ri_get_query_value(const char *query, int query_len, const char *key,
                          char **value);

oc_interface_mask_t oc_ri_get_interface_mask(char *iface, int if_len);

struct coap_packet_rx;
struct coap_packet;

# 93 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 3 4
_Bool 
# 93 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h"
    oc_ri_invoke_coap_entity_handler(struct coap_packet_rx *request,
                                      struct coap_packet *response,
                                      int32_t *offset,
                                      struct oc_endpoint *endpoint);
# 25 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/transport.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri_const.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
# 26 "repos/apache-mynewt-core/net/oic/include/oic/port/mynewt/transport.h" 2





#define OC_TRANSPORT_MAX 8

#define OC_TRANSPORT_USE_TCP (1 << 0)

struct oc_endpoint;

struct oc_transport {
    uint8_t ot_flags;
    uint8_t (*ot_ep_size)(const struct oc_endpoint *);
    int (*ot_ep_has_conn)(const struct oc_endpoint *);
    void (*ot_tx_ucast)(struct os_mbuf *);
    void (*ot_tx_mcast)(struct os_mbuf *);
    enum oc_resource_properties
         (*ot_get_trans_security)(const struct oc_endpoint *);
    char *(*ot_ep_str)(char *ptr, int maxlen, const struct oc_endpoint *);
    int (*ot_init)(void);
    void (*ot_shutdown)(void);
};

extern const struct oc_transport *oc_transports[8];

int8_t oc_transport_register(const struct oc_transport *);
int8_t oc_transport_lookup(const struct oc_transport *);
void oc_transport_unregister(const struct oc_transport *);
# 25 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 2





/*
 * OC endpoint data structure comes in different variations,
 * depending on type of transport.
 */
struct oc_ep_hdr {
    uint8_t oe_type:3; /* index to oc_transports array */
    uint8_t oe_flags:5; /* OC_ENDPOINT flags */
};

#define OC_ENDPOINT_MULTICAST (1 << 0)
#define OC_ENDPOINT_SECURED (1 << 1)

/*
 * Use this when reserving memory for oc_endpoint of unknown type.
 */
typedef struct oc_endpoint {
    struct oc_ep_hdr ep;
    uint8_t _res[23]; /* based on size of oc_endpoint_ip6 */
} oc_endpoint_t;

/*
 * Plain oc_endpoint for multicast target.
 */
struct oc_endpoint_plain {
    struct oc_ep_hdr ep;
};

static inline int
oc_endpoint_size(struct oc_endpoint *oe)
{
    ((oc_transports[oe->ep.oe_type]) ? (void)0 : __assert_func(
# 60 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 3 4
   ((void *)0)
# 60 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h"
   , 0, 
# 60 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 3 4
   ((void *)0)
# 60 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h"
   , 
# 60 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h" 3 4
   ((void *)0)
# 60 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_connectivity.h"
   ));
    return oc_transports[oe->ep.oe_type]->ot_ep_size(oe);
}

/*
 * Whether transport uses TCP-style headers or not.
 */
static inline int
oc_endpoint_use_tcp(struct oc_endpoint *oe)
{
    return oc_transports[oe->ep.oe_type]->ot_flags & (1 << 0);
}

/*
 * Whether underlying transport has connections or not.
 * This normally is indicated by whether TCP style header are used or not.
 * Allowing transport to override that.
 */
static inline int
oc_endpoint_has_conn(struct oc_endpoint *oe)
{
    const struct oc_transport *ot;

    ot = oc_transports[oe->ep.oe_type];
    if (ot->ot_ep_has_conn) {
        return ot->ot_ep_has_conn(oe);
    }
    return oc_endpoint_use_tcp(oe);
}

#define OC_MBUF_ENDPOINT(m) ((struct oc_endpoint *)((uint8_t *)m + sizeof(struct os_mbuf) + sizeof(struct os_mbuf_pkthdr)))







/*
 * Callback mechanism for connection-oriented transports, to be
 * called when new connection is established, and when an existing
 * connection is closed
 */
#define OC_ENDPOINT_CONN_EV_OPEN 1
#define OC_ENDPOINT_CONN_EV_CLOSE 2
struct oc_conn_cb {
    struct { struct oc_conn_cb *sle_next; /* next element */ } occ_next;
    void (*occ_func)(struct oc_endpoint *, int ev);
};
void oc_conn_cb_register(struct oc_conn_cb *cb);

struct oc_conn_ev {
    struct { struct oc_conn_ev *stqe_next; /* next element */ } oce_next;
    struct oc_endpoint oce_oe;
    int oce_type;
};
/*
 * Called by underlying connection-oriented transports to notify
 * about connection state changes.
 */
struct oc_conn_ev *oc_conn_ev_alloc(void);
void oc_conn_created(struct oc_conn_ev *);
void oc_conn_removed(struct oc_conn_ev *);

enum oc_resource_properties oc_get_trans_security(const struct oc_endpoint *oe);
int oc_connectivity_init(void);
void oc_connectivity_shutdown(void);

void oc_send_buffer(struct os_mbuf *);
void oc_send_multicast_message(struct os_mbuf *);

void oc_recv_message(struct os_mbuf *m);
# 49 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/port/oc_random.h" 1
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * Copyright (c) 2005, Swedish Institute of Computer Science
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 *
 */

#define OC_RANDOM_H 





/*
 * Initialize the pseudo-random generator.
 *
 */
void oc_random_init(unsigned short seed);

/*
 * Calculate a pseudo random number between 0 and 65535.
 *
 * \return A pseudo-random number between 0 and 65535.
 */
unsigned short oc_random_rand(void);

/* In gcc int rand() uses RAND_MAX and long random() uses RANDOM_MAX */
/* Since random_rand casts to unsigned short, we'll use this maxmimum */
#define RANDOM_RAND_MAX 65535U

void oc_random_destroy(void);
# 50 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h" 2







#define MAX(n,m) (((n) < (m)) ? (m) : (n))



#define MIN(n,m) (((n) < (m)) ? (n) : (m))



#define ABS(n) (((n) < 0) ? -(n) : (n))


#define COAP_MAX_PACKET_SIZE (COAP_MAX_HEADER_SIZE + MAX_PAYLOAD_SIZE)

/* MAX_PAYLOAD_SIZE can be different from 2^x so we need to get next lower 2^x
 * for COAP_MAX_BLOCK_SIZE */

#define COAP_MAX_BLOCK_SIZE (MAX_PAYLOAD_SIZE < 32 ? 16 : (MAX_PAYLOAD_SIZE < 64 ? 32 : (MAX_PAYLOAD_SIZE < 128 ? 64 : (MAX_PAYLOAD_SIZE < 256 ? 128 : (MAX_PAYLOAD_SIZE < 512 ? 256 : (MAX_PAYLOAD_SIZE < 1024 ? 512 : (MAX_PAYLOAD_SIZE < 2048 ? 1024 : 2048)))))))
# 89 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h"
/* bitmap for set options */
enum
{
  OPTION_MAP_SIZE = sizeof(uint8_t) * 8
};

#define SET_OPTION(packet,opt) ((packet)->options[opt / OPTION_MAP_SIZE] |= 1 << (opt % OPTION_MAP_SIZE))

#define IS_OPTION(packet,opt) ((packet)->options[opt / OPTION_MAP_SIZE] & (1 << (opt % OPTION_MAP_SIZE)))


/*
 * For COAP RX, structure stores the offsets and lengths of option fields
 * within the mbuf chain.
 */
struct coap_packet_rx {
    struct os_mbuf *m;

    uint8_t version;
    coap_message_type_t type;
    uint8_t code;
    uint16_t mid; /* message ID */

    uint8_t token_len;
    uint8_t token[8 /* The maximum number of bytes for the Token */];

    /* bitmap to check if option is set */
    uint8_t options[COAP_OPTION_SIZE1 / OPTION_MAP_SIZE + 1];

    /* parse options once and store */
    uint16_t content_format;
    uint32_t max_age;
# 131 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h"
    uint16_t uri_host_len;
    uint16_t uri_host_off;






    uint16_t uri_port;
    uint16_t uri_path_len;
    uint16_t uri_path_off;
    uint16_t accept;
    int32_t observe;




    uint32_t block2_num;
    uint8_t block2_more;
    uint16_t block2_size;
    uint32_t block2_offset;
    uint32_t block1_num;
    uint8_t block1_more;
    uint16_t block1_size;
    uint32_t block1_offset;
    uint32_t size2;
    uint32_t size1;
    uint16_t uri_query_len;
    uint16_t uri_query_off;
    uint8_t if_none_match;

    uint16_t payload_off;
    uint16_t payload_len;
};

/*
 * For CoAP TX, store pointers to user memory. All the TLVs need to be known
 * before header construction can begin.
 */
typedef struct coap_packet {
    uint8_t version;
    coap_message_type_t type;
    uint8_t code;
    uint16_t mid; /* message ID */

    uint8_t token_len;
    uint8_t token[8 /* The maximum number of bytes for the Token */];

    /* bitmap to check if option is set */
    uint8_t options[COAP_OPTION_SIZE1 / OPTION_MAP_SIZE + 1];

    /* parse options once and store; allows setting options in random order  */
    uint16_t content_format;
    uint32_t max_age;
# 195 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h"
    uint16_t uri_host_len;
    char *uri_host;






    uint16_t uri_port;
    uint16_t uri_path_len;
    char *uri_path;
    int32_t observe;
    uint16_t accept;




    uint32_t block2_num;
    uint8_t block2_more;
    uint16_t block2_size;
    uint32_t block2_offset;
    uint32_t block1_num;
    uint8_t block1_more;
    uint16_t block1_size;
    uint32_t block1_offset;
    uint32_t size2;
    uint32_t size1;
    uint16_t uri_query_len;
    char *uri_query;
    uint8_t if_none_match;

    uint16_t payload_len;
    uint8_t *payload;
    struct os_mbuf *payload_m;
} coap_packet_t;

/*
 * COAP statistics
 */
struct stats_coap_stats {
   
   
   
   
   
   
   
};

extern struct stats_coap_stats coap_stats;

/* option format serialization (TX) */
#define COAP_SERIALIZE_INT_OPT(pkt,m,number,field,text) if (IS_OPTION(pkt, number)) { OC_LOG(DEBUG, " %s [%u]\n", text, (unsigned int)pkt->field); if (coap_append_int_opt(m, number, current_number, pkt->field)) { goto err_mem; } current_number = number; }







#define COAP_SERIALIZE_BYTE_OPT(pkt,m,number,field,text) if (IS_OPTION(pkt, number)) { OC_LOG(DEBUG, " %s %u ", text, pkt->field ##_len); OC_LOG_HEX(LOG_LEVEL_DEBUG, pkt->field, pkt->field ##_len); if (coap_append_array_opt(m, number, current_number, pkt->field, pkt->field ##_len, '\0')) { goto err_mem; } current_number = number; }
# 265 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h"
#define COAP_SERIALIZE_STRING_OPT(pkt,m,number,field,splitter,text) if (IS_OPTION(pkt, number)) { OC_LOG(DEBUG, " %s", text); OC_LOG_STR(LOG_LEVEL_DEBUG, pkt->field, pkt->field ##_len); if (coap_append_array_opt(m, number, current_number, (uint8_t *)pkt->field, pkt->field ##_len, splitter)) { goto err_mem; } current_number = number; }
# 276 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h"
#define COAP_SERIALIZE_BLOCK_OPT(pkt,m,number,field,text) if (IS_OPTION(pkt, number)) { OC_LOG(DEBUG, " %s [%lu%s (%u B/blk)]\n", text, (unsigned long)pkt->field ##_num, pkt->field ##_more ? "+" : "", pkt->field ##_size); uint32_t block = pkt->field ##_num << 4; if (pkt->field ##_more) { block |= 0x8; } block |= 0xF & coap_log_2(pkt->field ##_size / 16); OC_LOG(DEBUG, " %s encoded: 0x%lX\n", text, (unsigned long)block); if (coap_append_int_opt(m, number, current_number, block)) { goto err_mem; } current_number = number; }
# 294 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/coap.h"
/* to store error code and human-readable payload */
extern coap_status_t erbium_status_code;
extern char *coap_error_message;

void coap_init_connection(void);
uint16_t coap_get_mid(void);

uint16_t coap_tcp_msg_size(uint8_t *hdr, int datalen);

void coap_init_message(coap_packet_t *, coap_message_type_t type,
                       uint8_t code, uint16_t mid);
int coap_serialize_message(coap_packet_t *, struct os_mbuf *m);
void coap_send_message(struct os_mbuf *m, int dup);
coap_status_t coap_parse_message(struct coap_packet_rx *request,
                                 struct os_mbuf **mp);

int coap_get_query_variable(coap_packet_t *, const char *name,
                            const char **output);
int coap_get_post_variable(coap_packet_t *, const char *name,
                           const char **output);

/*---------------------------------------------------------------------------*/

int coap_set_status_code(coap_packet_t *, unsigned int code);

int coap_set_token(coap_packet_t *, const uint8_t *token, size_t token_len);

int coap_get_header_content_format(struct coap_packet_rx *,
                                   unsigned int *format);
int coap_set_header_content_format(coap_packet_t *, unsigned int format);

int coap_get_header_accept(struct coap_packet_rx *, unsigned int *accept);
int coap_set_header_accept(coap_packet_t *, unsigned int accept);

int coap_get_header_max_age(struct coap_packet_rx *, uint32_t *age);
int coap_set_header_max_age(coap_packet_t *, uint32_t age);

int coap_get_header_etag(struct coap_packet_rx *, const uint8_t **etag);
int coap_set_header_etag(coap_packet_t *, const uint8_t *etag, size_t etag_len);

int coap_get_header_if_match(struct coap_packet_rx *, const uint8_t **etag);
int coap_set_header_if_match(coap_packet_t *, const uint8_t *etag,
                             size_t etag_len);

int coap_get_header_if_none_match(struct coap_packet_rx *);
int coap_set_header_if_none_match(coap_packet_t *);

int coap_get_header_proxy_uri(struct coap_packet_rx *,
  const char **uri); /* in-place string might not be 0-terminated. */
int coap_set_header_proxy_uri(coap_packet_t *, const char *uri);

int coap_get_header_proxy_scheme(struct coap_packet_rx *,
  const char **scheme); /* in-place string might not be 0-terminated. */
int coap_set_header_proxy_scheme(coap_packet_t *, const char *scheme);

int coap_get_header_uri_host(struct coap_packet_rx *,
  const char **host); /* in-place string might not be 0-terminated. */
int coap_set_header_uri_host(coap_packet_t *, const char *host);

int coap_get_header_uri_path(struct coap_packet_rx *, char *path, int maxlen);
                              /* in-place string might not be 0-terminated. */
int coap_set_header_uri_path(coap_packet_t *, const char *path);

int coap_get_header_uri_query(struct coap_packet_rx *, char *qry, int maxlen);
                              /* in-place string might not be 0-terminated. */
int coap_set_header_uri_query(coap_packet_t *, const char *query);

int coap_get_header_location_path(struct coap_packet_rx *,
  const char **path); /* in-place string might not be 0-terminated. */
int coap_set_header_location_path(coap_packet_t *,
                                  const char *path); /* also splits optional
                                                        query into
                                                        Location-Query option.
                                                        */

int coap_get_header_location_query(struct coap_packet_rx *,
  const char **query); /* in-place string might not be 0-terminated. */
int coap_set_header_location_query(coap_packet_t *, const char *query);

int coap_get_header_observe(struct coap_packet_rx *, uint32_t *observe);
int coap_set_header_observe(coap_packet_t *, uint32_t observe);

int coap_get_header_block2(struct coap_packet_rx *, uint32_t *num,
                           uint8_t *more, uint16_t *size, uint32_t *offset);
int coap_set_header_block2(coap_packet_t *, uint32_t num, uint8_t more,
                           uint16_t size);

int coap_get_header_block1(struct coap_packet_rx *, uint32_t *num,
                           uint8_t *more, uint16_t *size, uint32_t *offset);
int coap_set_header_block1(coap_packet_t *, uint32_t num, uint8_t more,
                           uint16_t size);

int coap_get_header_size2(struct coap_packet_rx *, uint32_t *size);
int coap_set_header_size2(coap_packet_t *, uint32_t size);

int coap_get_header_size1(struct coap_packet_rx *, uint32_t *size);
int coap_set_header_size1(coap_packet_t *, uint32_t size);

int coap_get_payload_copy(struct coap_packet_rx *, uint8_t *payload,
                          int maxlen);
int coap_get_payload(struct coap_packet_rx *pkt, struct os_mbuf **mp,
                     uint16_t *off);
int coap_set_payload(coap_packet_t *, struct os_mbuf *m, size_t length);
# 24 "libs/sensor_coap/src/sensor_coap.c" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_buffer.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_BUFFER_H 





struct os_mbuf;
struct oc_endpoint;
struct os_mbuf *oc_allocate_mbuf(struct oc_endpoint *oe);

void oc_send_message(struct os_mbuf *m);
# 25 "libs/sensor_coap/src/sensor_coap.c" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/


#define OC_CLIENT_STATE_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 21 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 2

# 1 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/constants.h" 1

# 1 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/constants.h"
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * Copyright (c) 2013, Institute for Pervasive Computing, ETH Zurich
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 */
# 23 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
# 24 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_ri_const.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
# 25 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 2






typedef enum { HIGH_QOS = 0, LOW_QOS } oc_qos_t;

typedef struct oc_client_response {
    struct coap_packet_rx *packet;
    struct oc_endpoint *origin;
    oc_status_t code;
    uint32_t observe_option;
} oc_client_response_t;

typedef struct oc_server_handle {
    oc_endpoint_t endpoint;
} oc_server_handle_t;

typedef enum {
    OC_STOP_DISCOVERY = 0,
    OC_CONTINUE_DISCOVERY
} oc_discovery_flags_t;

typedef oc_discovery_flags_t(oc_discovery_cb_t)(const char *, const char *,
                                                oc_string_array_t,
                                                oc_interface_mask_t,
                                                oc_server_handle_t *);

typedef void (*oc_response_handler_t)(oc_client_response_t *);

typedef struct oc_client_cb {
    struct { struct oc_client_cb *sle_next; /* next element */ } next;
    struct os_callout callout;
    oc_string_t uri;
    uint8_t token[8 /* The maximum number of bytes for the Token */];
    uint8_t token_len;
    uint16_t mid;

    oc_server_handle_t server;

    void *handler;

    
# 68 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 3 4
   _Bool 
# 68 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h"
        discovery;
    int32_t observe_seq;
    oc_clock_time_t timestamp;
    oc_qos_t qos;
    oc_method_t method;
} oc_client_cb_t;


# 75 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 3 4
_Bool 
# 75 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h"
    oc_ri_invoke_client_cb(struct coap_packet_rx *response,
                            oc_endpoint_t *);

oc_client_cb_t *oc_ri_alloc_client_cb(const char *uri,
                                      oc_server_handle_t *server,
                                      oc_method_t method, void *handler,
                                      oc_qos_t qos);

oc_client_cb_t *oc_ri_get_client_cb(const char *uri, oc_server_handle_t *server,
                                    oc_method_t method);

void oc_ri_remove_client_cb_by_mid(uint16_t mid);

oc_discovery_flags_t oc_ri_process_discovery_payload(struct coap_packet_rx *rsp,
                                                     oc_discovery_cb_t *handler,
                                                     oc_endpoint_t *);


# 92 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h" 3 4
_Bool 
# 92 "repos/apache-mynewt-core/net/oic/include/oic/oc_client_state.h"
    oc_ri_send_rst(oc_endpoint_t *endpoint, uint8_t *token,
                    uint8_t token_len, uint16_t mid);
# 26 "libs/sensor_coap/src/sensor_coap.c" 2
# 1 "libs/semihosting_console/include/console/console.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#define __SEMIHOSTING_CONSOLE_H__ 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/inttypes.h" 1
/*
 * inttypes.h
 */
# 23 "libs/semihosting_console/include/console/console.h" 2
# 1 "repos/apache-mynewt-core/kernel/os/include/os/mynewt.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
# 24 "libs/semihosting_console/include/console/console.h" 2





struct os_eventq;

/** @struct console_input
 * The console_input data structure represents a console input buffer.
 *
 * Each event added to the console avail_queue must have the
 * ev_arg field point to a console_input structure.
 */
struct console_input {
    /** Data buffer that the console uses to save received
     *  characters until a new line is received. */
    char line[(256)];
};

typedef void (*console_rx_cb)(void);
typedef int (*console_append_char_cb)(char *line, uint8_t byte);
typedef void (*completion_cb)(char *str, console_append_char_cb cb);

//  Implemented only for Semihosting Console.
void console_buffer(const char *buffer, unsigned int length); //  Add the string to the output buffer.
void console_printhex(uint8_t v); //  Write a char in hexadecimal to the output buffer.
void console_printfloat(float f); //  Write a float to the output buffer, with 1 decimal place.
void console_dump(const uint8_t *buffer, unsigned int len); //  Append "length" number of bytes from "buffer" to the output buffer in hex format.
void console_flush(void); //  Flush the output buffer to the console.

/**
 * De initializes the UART console.
 */
void console_deinit(void);
/**
 * Re Initializes the UART console.
 */
void console_reinit(void);
int console_init(console_rx_cb rx_cb);
int console_is_init(void);
void console_write(const char *str, int cnt);
void console_blocking_mode(void);
void console_non_blocking_mode(void);
void console_echo(int on);

int console_printf(const char *fmt, ...)
    __attribute__ ((format (printf, 1, 2)));;

void console_set_completion_cb(completion_cb cb);
int console_handle_char(uint8_t byte);

/* Set queue to send console line events to */
void console_line_queue_set(struct os_eventq *evq);
/* Put (handled) line event to console */
void console_line_event_put(struct os_event *ev);
/**
 * Global indicating whether console is silent or not
 */
extern 
# 82 "libs/semihosting_console/include/console/console.h" 3 4
      _Bool 
# 82 "libs/semihosting_console/include/console/console.h"
           g_silence_console;
/**
 * Global indicating whether console input is disabled or not
 */
extern 
# 86 "libs/semihosting_console/include/console/console.h" 3 4
      _Bool 
# 86 "libs/semihosting_console/include/console/console.h"
           g_console_input_ignore;


/**
 * Silences console output, input is still active
 *
 * @param silent Let console know if it needs to be silent,
 *        true for silence, false otherwise
 */
static void inline
console_silence(
# 96 "libs/semihosting_console/include/console/console.h" 3 4
               _Bool 
# 96 "libs/semihosting_console/include/console/console.h"
                    silent)
{
    g_silence_console = silent;
}


/**
 * Ignores console input, output is still active
 *
 * @param ignore Lets console know if input should be disabled,
 *        true for ignore input, false otherwise
 */
static void inline
console_input_ignore(
# 109 "libs/semihosting_console/include/console/console.h" 3 4
                    _Bool 
# 109 "libs/semihosting_console/include/console/console.h"
                         ignore)
{
    g_console_input_ignore = ignore;
}

extern int console_is_midline;
extern int console_out(int character);
extern void console_rx_restart(void);

int console_lock(int timeout);
int console_unlock(void);
# 27 "libs/sensor_coap/src/sensor_coap.c" 2
# 1 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 1
//  Post sensor data to CoAP server with JSON or CBOR encoding.  We call the Mynewt OIC
//  interface to encode and transmit CoAP messages.  For ESP8266, the OIC interface
//  is implemented by esp8266/transport.h.

#define __SENSOR_COAP_H__ 





//  sensor_value represents a decoded sensor data value. Since temperature may be integer (raw)
//  or float (computed), we use the struct to return both integer and float values.
//  val_type indicates whether it's an integer or float.
struct sensor_value {
    const char *key; //  "t" for raw temp, "tmp" for computed. When transmitted to CoAP Server or Collector Node, the key (field name) to be used.
    int val_type; //  The type of the sensor value. SENSOR_VALUE_TYPE_INT32 for int, SENSOR_VALUE_TYPE_FLOAT for float.
    uint16_t int_val; //  For raw temp, contains the raw temp integer value
    float float_val; //  For computed temp, contains the computed temp float value
};

///////////////////////////////////////////////////////////////////////////////
//  Sensor CoAP Functions

#define COAP_PORT_UNSECURED (5683) /*  Port number for CoAP Unsecured*/

struct oc_server_handle;

//  Init the Sensor CoAP module. Called by sysinit() during startup, defined in pkg.yml.
void init_sensor_coap(void);

//  Return true if the Sensor CoAP is ready for sending sensor data.

# 32 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 3 4
_Bool 
# 32 "libs/sensor_coap/include/sensor_coap/sensor_coap.h"
    sensor_coap_ready(void);

//  Create a new sensor post request to send to CoAP server.  coap_content_format is 
//  APPLICATION_JSON or APPLICATION_CBOR. If coap_content_format is 0, use the default format.

# 36 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 3 4
_Bool 
# 36 "libs/sensor_coap/include/sensor_coap/sensor_coap.h"
    init_sensor_post(struct oc_server_handle *server, const char *uri, int coap_content_format);

//  Send the sensor post request to CoAP server.

# 39 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 3 4
_Bool 
# 39 "libs/sensor_coap/include/sensor_coap/sensor_coap.h"
    do_sensor_post(void);

///////////////////////////////////////////////////////////////////////////////
//  JSON Common Encoding Macros


# 1 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define _JSON_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 1 3 4

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stdbool.h" 3 4
/* Copyright (C) 1998-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.16  Boolean type and values  <stdbool.h>
 */
# 24 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 2

# 1 "repos/apache-mynewt-core/libc/baselibc/include/ctype.h" 1

# 1 "repos/apache-mynewt-core/libc/baselibc/include/ctype.h"
/*
 * ctype.h
 *
 * This assumes ASCII.
 */


#define _CTYPE_H 

# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/extern.h" 1
/*
 * klibc/extern.h
 */
# 11 "repos/apache-mynewt-core/libc/baselibc/include/ctype.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/klibc/inline.h" 1
/*
 * klibc/inline.h
 */
# 12 "repos/apache-mynewt-core/libc/baselibc/include/ctype.h" 2





extern inline __attribute__((gnu_inline)) int isupper(int __c)
{
 return __c >= 'A' && __c <= 'Z';
}

extern inline __attribute__((gnu_inline)) int islower(int __c)
{
 return __c >= 'a' && __c <= 'z';
}

extern inline __attribute__((gnu_inline)) int isalpha(int __c)
{
 return islower(__c) || isupper(__c);
}

extern inline __attribute__((gnu_inline)) int isdigit(int __c)
{
 return ((unsigned)__c - '0') <= 9;
}

extern inline __attribute__((gnu_inline)) int isalnum(int __c)
{
 return isalpha(__c) || isdigit(__c);
}

extern inline __attribute__((gnu_inline)) int isascii(int __c)
{
 return !(__c & ~0x7f);
}

extern inline __attribute__((gnu_inline)) int isblank(int __c)
{
 return (__c == '\t') || (__c == ' ');
}

extern inline __attribute__((gnu_inline)) int iscntrl(int __c)
{
 return __c < 0x20;
}

extern inline __attribute__((gnu_inline)) int isspace(int __c)
{
 return __c == ' ' || __c == '\n' || __c == '\t' || __c == '\r';
}

extern inline __attribute__((gnu_inline)) int isxdigit(int __c)
{
 return isdigit(__c) || (__c >= 'a' && __c <= 'f') || (__c >= 'A' && __c <= 'F');
}

extern inline __attribute__((gnu_inline)) int ispunct(int __c)
{
 return (__c >= '!' && __c <= '/') ||
     (__c >= ':' && __c <= '@') ||
     (__c >= '[' && __c <= '`') ||
     (__c >= '{' && __c <= '~');
}

extern inline __attribute__((gnu_inline)) int isprint(int __c)
{
 return (__c >= 0x20 && __c <= 0x7e);
}

extern inline __attribute__((gnu_inline)) int isgraph(int __c)
{
 return (__c > 0x20 && __c < 0x7f);
}

extern inline __attribute__((gnu_inline)) int toupper(int __c)
{
 return islower(__c) ? (__c & ~32) : __c;
}

extern inline __attribute__((gnu_inline)) int tolower(int __c)
{
 return isupper(__c) ? (__c | 32) : __c;
}
# 26 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 2
# 1 "repos/apache-mynewt-core/libc/baselibc/include/stdio.h" 1
/*
 * stdio.h
 */
# 27 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 2
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 1 3

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 3
/* unified sys/types.h: 
   start with sef's sysvi386 version.
   merge go32 version -- a few ifdefs.
   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:

   typedef int gid_t;
   typedef int uid_t;
   typedef int dev_t;
   typedef int ino_t;
   typedef int mode_t;
   typedef int caddr_t;

   however, these aren't "reasonable" values, the sysvi386 ones make far 
   more sense, and should work sufficiently well (in particular, h8300 
   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
 */



# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */


#define _ANSIDECL_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/newlib.h" 1 3
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */
# 11 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_ansi.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 1 3

#define __SYS_CONFIG_H__ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/ieeefp.h" 1 3



/* This file can define macros to choose variations of the IEEE float
   format:

   _FLT_LARGEST_EXPONENT_IS_NORMAL

	Defined if the float format uses the largest exponent for finite
	numbers rather than NaN and infinity representations.  Such a
	format cannot represent NaNs or infinities at all, but it's FLT_MAX
	is twice the IEEE value.

   _FLT_NO_DENORMALS

	Defined if the float format does not support IEEE denormals.  Every
	float with a zero exponent is taken to be a zero representation.
 
   ??? At the moment, there are no equivalent macros above for doubles and
   the macros are not fully supported by --enable-newlib-hw-fp.

   __IEEE_BIG_ENDIAN

        Defined if the float format is big endian.  This is mutually exclusive
        with __IEEE_LITTLE_ENDIAN.

   __IEEE_LITTLE_ENDIAN
 
        Defined if the float format is little endian.  This is mutually exclusive
        with __IEEE_BIG_ENDIAN.

   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified for a
   platform or error will occur.

   __IEEE_BYTES_LITTLE_ENDIAN

        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a situation 
	whereby multiple words of an IEEE floating point are in big endian order, but the
	words themselves are little endian with respect to the bytes.

   _DOUBLE_IS_32BITS 

        This is used on platforms that support double by using the 32-bit IEEE
        float type.

   _FLOAT_ARG

        This represents what type a float arg is passed as.  It is used when the type is
        not promoted to double.
	

   __OBSOLETE_MATH_DEFAULT

	Default value for __OBSOLETE_MATH if that's not set by the user.
	It should be set here based on predefined feature macros.

   __OBSOLETE_MATH

	If set to 1 then some new math code will be disabled and older libm
	code will be used instead.  This is necessary because the new math
	code does not support all targets, it assumes that the toolchain has
	ISO C99 support (hexfloat literals, standard fenv semantics), the
	target has IEEE-754 conforming binary32 float and binary64 double
	(not mixed endian) representation, standard SNaN representation,
	double and single precision arithmetics has similar latency and it
	has no legacy SVID matherr support, only POSIX errno and fenv
	exception based error handling.
*/


/* ARM traditionally used big-endian words; and within those words the
   byte ordering was big or little endian depending upon the target.
   Modern floating-point formats are naturally ordered; in this case
   __VFP_FP__ will be defined, even if soft-float.  */


#define __IEEE_LITTLE_ENDIAN 
# 242 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/ieeefp.h" 3
/* necv70 was __IEEE_LITTLE_ENDIAN. */
# 452 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/ieeefp.h" 3
/* Use old math code by default.  */
#define __OBSOLETE_MATH_DEFAULT 1


#define __OBSOLETE_MATH __OBSOLETE_MATH_DEFAULT
# 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 1 3
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
# 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 2 3





/* exceptions first */







/* 16 bit integer machines */
# 115 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
/* For the PowerPC eabi, force the _impure_ptr to be in .sdata */
# 125 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
/* Configure small REENT structure for Xilinx MicroBlaze platforms */
# 192 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
/* This block should be kept in sync with GCC's limits.h.  The point
   of having these definitions here is to not include limits.h, which
   would pollute the user namespace, while still using types of the
   the correct widths when deciding how to define __int32_t and
   __int64_t.  */
# 217 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
/* End of block that should be kept in sync with GCC's limits.h.  */


#define _POINTER_INT long





#undef __RAND_MAX



#define __RAND_MAX 0x7fffffff
# 246 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
#define __EXPORT 



#define __IMPORT 


/* Define return type of read/write routines.  In POSIX, the return type
   for read()/write() is "ssize_t" but legacy newlib code has been using
   "int" for some time.  If not specified, "int" is defaulted.  */

#define _READ_WRITE_RETURN_TYPE int

/* Define `count' parameter of read/write routines.  In POSIX, the `count'
   parameter is "size_t" but legacy newlib code has been using "int" for some
   time.  If not specified, "int" is defaulted.  */

#define _READ_WRITE_BUFSIZE_TYPE int
# 272 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
/* See if small reent asked for at configuration time and
   is not chosen by the platform by default.  */
# 292 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/config.h" 3
/* If _MB_EXTENDED_CHARSETS_ALL is set, we want all of the extended
   charsets.  The extended charsets add a few functions and a couple
   of tables of a few K each. */
# 12 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_ansi.h" 2 3

/*  ISO C++.  */
# 31 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_ansi.h" 3
#define _BEGIN_STD_C 
#define _END_STD_C 
#define _NOTHROW 



#define _LONG_DOUBLE long double


/* Support gcc's __attribute__ facility.  */


#define _ATTRIBUTE(attrs) __attribute__ (attrs)




/*  The traditional meaning of 'extern inline' for GCC is not
  to emit the function body unless the address is explicitly
  taken.  However this behaviour is changing to match the C99
  standard, which uses 'extern inline' to indicate that the
  function body *must* be emitted.  Likewise, a function declared
  without either 'extern' or 'static' defaults to extern linkage
  (C99 6.2.2p5), and the compiler may choose whether to use the
  inline version or call the extern linkage version (6.7.4p6).
  If we are using GCC, but do not have the new behaviour, we need
  to use extern inline; if we are using a new GCC with the
  C99-compatible behaviour, or a non-GCC compiler (which we will
  have to hope is C99, since there is no other way to achieve the
  effect of omitting the function if it isn't referenced) we use
  'static inline', which c99 defines to mean more-or-less the same
  as the Gnu C 'extern inline'.  */




/* We're using GCC in C99 mode, or an unknown compiler which
  we just have to hope obeys the C99 semantics of inline.  */
#define _ELIDABLE_INLINE static __inline__



#define _NOINLINE __attribute__ ((__noinline__))
#define _NOINLINE_STATIC _NOINLINE static
# 21 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 1 3
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
# 22 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_types.h" 1 3
/*
 *  $Id$
 */


#define _MACHINE__TYPES_H 
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_default_types.h" 1 3
/*
 *  $Id$
 */
# 8 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_types.h" 2 3
# 23 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3

/* BSD types permitted by POSIX and always exposed as in Glibc.  Only provided
   for backward compatibility with BSD code.  The uintN_t standard types should
   be preferred in new code. */

typedef __uint8_t u_int8_t;


typedef __uint16_t u_int16_t;


typedef __uint32_t u_int32_t;


typedef __uint64_t u_int64_t;

typedef int register_t;
#define __BIT_TYPES_DEFINED__ 1
# 60 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 3
#define _SYS_TYPES_H 
/* <stddef.h> must be before <sys/_types.h> for __size_t considerations */
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */
# 63 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/


#define _SYS__TYPES_H 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/newlib.h" 1 3
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */
# 23 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 2 3

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_types.h" 1 3
/*
 *  $Id$
 */
# 25 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h" 1 3

#define __SYS_LOCK_H__ 

/* dummy lock routines for single-threaded aps */

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/newlib.h" 1 3
/* newlib.h.  Generated from newlib.hin by configure.  */
/* newlib.hin.  Manually edited from the output of autoheader to
   remove all PACKAGE_ macros which will collide with any user
   package using newlib header files and having its own package name,
   version, etc...  */
# 7 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/_ansi.h" 1 3
/* Provide support for both ANSI and non-ANSI environments.  */

/* To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
   files aren't affected).  */
# 8 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h" 2 3
# 33 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h" 3
struct __lock;
typedef struct __lock * _LOCK_T;
#define _LOCK_RECURSIVE_T _LOCK_T

#define __LOCK_INIT(class,lock) extern struct __lock __lock_ ## lock; class _LOCK_T lock = &__lock_ ## lock

#define __LOCK_INIT_RECURSIVE(class,lock) __LOCK_INIT(class,lock)

extern void __retarget_lock_init(_LOCK_T *lock);
#define __lock_init(lock) __retarget_lock_init(&lock)
extern void __retarget_lock_init_recursive(_LOCK_T *lock);
#define __lock_init_recursive(lock) __retarget_lock_init_recursive(&lock)
extern void __retarget_lock_close(_LOCK_T lock);
#define __lock_close(lock) __retarget_lock_close(lock)
extern void __retarget_lock_close_recursive(_LOCK_T lock);
#define __lock_close_recursive(lock) __retarget_lock_close_recursive(lock)
extern void __retarget_lock_acquire(_LOCK_T lock);
#define __lock_acquire(lock) __retarget_lock_acquire(lock)
extern void __retarget_lock_acquire_recursive(_LOCK_T lock);
#define __lock_acquire_recursive(lock) __retarget_lock_acquire_recursive(lock)
extern int __retarget_lock_try_acquire(_LOCK_T lock);
#define __lock_try_acquire(lock) __retarget_lock_try_acquire(lock)
extern int __retarget_lock_try_acquire_recursive(_LOCK_T lock);
#define __lock_try_acquire_recursive(lock) __retarget_lock_try_acquire_recursive(lock)

extern void __retarget_lock_release(_LOCK_T lock);
#define __lock_release(lock) __retarget_lock_release(lock)
extern void __retarget_lock_release_recursive(_LOCK_T lock);
#define __lock_release_recursive(lock) __retarget_lock_release_recursive(lock)
# 26 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 88 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;


/*
 * We need fpos_t for the following, but it doesn't have a leading "_",
 * so we use _fpos_t instead.
 */

typedef long _fpos_t; /* XXX must match off_t in <sys/types.h> */
    /* (and must be `long' for now) */
# 124 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 3
/* Defined by GCC provided <stddef.h> */
#undef __size_t



typedef unsigned int __size_t;
# 141 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 3
/* If __SIZE_TYPE__ is defined (gcc) we define ssize_t based on size_t.
   We simply change "unsigned" to "signed" for this single definition
   to make sure ssize_t and size_t only differ by their signedness. */
#define unsigned signed
typedef signed int _ssize_t;
#undef unsigned
# 156 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;

#define __need_wint_t 
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 1 3 4
/* Copyright (C) 1989-2017 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 */






/* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  */
# 46 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  */

/* On 4.3bsd-net2, make sure ansi.h is included, so we have
   one less case to deal with in the following.  */



/* On FreeBSD 5, machine/ansi.h does not exist anymore... */




/* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
   defined if the corresponding type is *not* defined.
   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_ */
# 92 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  */




/* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  */
# 117 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  */

/* Signed type of difference of two pointers.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 160 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* If this symbol has done its job, get rid of it.  */
#undef __need_ptrdiff_t



/* Unsigned type of `sizeof' something.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 238 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#undef __need_size_t



/* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  */

/* Define this type if we are doing the whole job,
   or if we want this type in particular.  */
# 347 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
#undef __need_wchar_t




#define _WINT_T 




typedef unsigned int wint_t;

#undef __need_wint_t


/*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
    are already defined.  */
/*  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.  */
/*  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.  */
# 398 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h" 3 4
/* A null pointer constant.  */


#undef NULL




#define NULL ((void *)0)





#undef __need_NULL



/* Offset of member MEMBER in a struct of type TYPE. */
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 160 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 2 3


/* Conversion state information.  */
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value; /* Value so far.  */
} _mbstate_t;



typedef _LOCK_T _flock_t;



/* Iconv descriptor type */
typedef void *_iconv_t;



#define _CLOCK_T_ unsigned long /* clock() */


typedef unsigned long /* clock() */ __clock_t;




#define _TIME_T_ __int_least64_t

typedef __int_least64_t __time_t;


#define _CLOCKID_T_ unsigned long


typedef unsigned long __clockid_t;

#define _TIMER_T_ unsigned long
typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef unsigned short __nlink_t;
typedef long __suseconds_t; /* microseconds (signed) */
typedef unsigned long __useconds_t; /* microseconds (unsigned) */


typedef __builtin_va_list __va_list;
# 64 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_stdint.h" 1 3
/*
 * Copyright (c) 2004, 2005 by
 * Ralf Corsepius, Ulm/Germany. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * is freely granted, provided that this notice is preserved.
 */
# 65 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3


# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/endian.h" 1 3

#define __MACHINE_ENDIAN_H__ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 1 3
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
# 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/endian.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/
# 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/endian.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_endian.h" 1 3
/* ARM configuration file.
   Copyright (c) 2015 ARM Ltd.  All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. The name of the company may not be used to endorse or promote
      products derived from this software without specific prior written
      permission.

   THIS SOFTWARE IS PROVIDED BY ARM LTD ``AS IS'' AND ANY EXPRESS OR IMPLIED
   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   IN NO EVENT SHALL ARM LTD BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */





#define _LITTLE_ENDIAN 1234
#define _BIG_ENDIAN 4321
#define _PDP_ENDIAN 3412




#define _BYTE_ORDER _LITTLE_ENDIAN
# 7 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/endian.h" 2 3


#define _QUAD_HIGHWORD 1
#define _QUAD_LOWWORD 0






#define LITTLE_ENDIAN _LITTLE_ENDIAN
#define BIG_ENDIAN _BIG_ENDIAN
#define PDP_ENDIAN _PDP_ENDIAN
#define BYTE_ORDER _BYTE_ORDER



#define __bswap16(_x) __builtin_bswap16(_x)
#define __bswap32(_x) __builtin_bswap32(_x)
#define __bswap64(_x) __builtin_bswap64(_x)
# 57 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/endian.h" 3
#define __htonl(_x) __bswap32(_x)
#define __htons(_x) __bswap16(_x)
#define __ntohl(_x) __bswap32(_x)
#define __ntohs(_x) __bswap16(_x)
# 68 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/select.h" 1 3

#define _SYS_SELECT_H 

/* We don't define fd_set and friends if we are compiling POSIX
   source, or if we have included (or may include as indicated
   by __USE_W32_SOCKETS) the W32api winsock[2].h header which
   defines Windows versions of them.   Note that a program which
   includes the W32api winsock[2].h header must know what it is doing;
   it must not call the Cygwin select function.
*/


# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 1 3
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
# 14 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_sigset.h" 1 3
/*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.4 (Berkeley) 5/4/95
 * $FreeBSD$
 */


#define _SYS__SIGSET_H_ 

typedef unsigned long __sigset_t;
# 15 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_timeval.h" 1 3
/*-
 * Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD$
 */


#define _SYS__TIMEVAL_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/
# 33 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_timeval.h" 2 3


typedef __suseconds_t suseconds_t;
#define _SUSECONDS_T_DECLARED 



typedef __int_least64_t time_t;
#define __time_t_defined 
#define _TIME_T_DECLARED 


/* This define is also used outside of Newlib, e.g. in MinGW-w64 */

#define _TIMEVAL_DEFINED 

/*
 * Structure returned by gettimeofday(2) system call, and used in other calls.
 */
struct timeval {
 time_t tv_sec; /* seconds */
 suseconds_t tv_usec; /* and microseconds */
};




#define timerclear(tvp) ((tvp)->tv_sec = (tvp)->tv_usec = 0)
#define timerisset(tvp) ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp,uvp,cmp) (((tvp)->tv_sec == (uvp)->tv_sec) ? ((tvp)->tv_usec cmp (uvp)->tv_usec) : ((tvp)->tv_sec cmp (uvp)->tv_sec))



#define timeradd(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0)
# 75 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_timeval.h" 3
#define timersub(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0)
# 16 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/select.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/timespec.h" 1 3
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */


#define _SYS_TIMESPEC_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/cdefs.h" 1 3
/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */

/* Written 2000 by Werner Almesberger */

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
 * $FreeBSD$
 */
# 38 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/timespec.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_timespec.h" 1 3
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */


#define _SYS__TIMESPEC_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types.h" 1 3
/* ANSI C namespace clean utility typedefs */

/* This file defines various typedefs needed by the system calls that support
   the C library.  Basically, they're just the POSIX versions with an '_'
   prepended.  Targets shall use <machine/_types.h> to define their own
   internal types if desired.

   There are three define patterns used for type definitions.  Lets assume
   xyz_t is a user type.

   The internal type definition uses __machine_xyz_t_defined.  It is defined by
   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
   must not be used in other files.

   User type definitions are guarded by __xyz_t_defined in glibc and
   _XYZ_T_DECLARED in BSD compatible systems.
*/
# 38 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_timespec.h" 2 3







struct timespec {
 time_t tv_sec; /* seconds */
 long tv_nsec; /* and nanoseconds */
};
# 39 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/timespec.h" 2 3


#define TIMEVAL_TO_TIMESPEC(tv,ts) do { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; } while (0)




#define TIMESPEC_TO_TIMEVAL(tv,ts) do { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; } while (0)







/*
 * Structure defined by POSIX.1b to be like a itimerval, but with
 * timespecs. Used in the timer_*() system calls.
 */
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};
# 17 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/select.h" 2 3


#define _SIGSET_T_DECLARED 
typedef __sigset_t sigset_t;


#define _SYS_TYPES_FD_SET 
/*
 * Select uses bit masks of file descriptors in longs.
 * These macros manipulate such bit fields (the filesystem macros use chars).
 * FD_SETSIZE may be defined by the user, but the default here
 * should be >= NOFILE (param.h).
 */

#define FD_SETSIZE 64


typedef unsigned long fd_mask;
#define NFDBITS (sizeof (fd_mask) * 8) /* bits per mask */

#define _howmany(x,y) (((x)+((y)-1))/(y))


/* We use a macro for fd_set so that including Sockets.h afterwards
   can work.  */
typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8) /* bits per mask */)-1))/((sizeof (fd_mask) * 8) /* bits per mask */))];
} _types_fd_set;

#define fd_set _types_fd_set

#define FD_SET(n,p) ((p)->fds_bits[(n)/NFDBITS] |= (1L << ((n) % NFDBITS)))
#define FD_CLR(n,p) ((p)->fds_bits[(n)/NFDBITS] &= ~(1L << ((n) % NFDBITS)))
#define FD_ISSET(n,p) ((p)->fds_bits[(n)/NFDBITS] & (1L << ((n) % NFDBITS)))
#define FD_ZERO(p) (__extension__ (void)({ size_t __i; char *__tmp = (char *)p; for (__i = 0; __i < sizeof (*(p)); ++__i) *__tmp++ = 0; }))
# 60 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/select.h" 3


int select (int __n, _types_fd_set *__readfds, _types_fd_set *__writefds, _types_fd_set *__exceptfds, struct timeval *__timeout) /* full-blown ANSI C */
                                                   ;

int pselect (int __n, _types_fd_set *__readfds, _types_fd_set *__writefds, _types_fd_set *__exceptfds, const struct timespec *__timeout, const sigset_t *__set) /* full-blown ANSI C */

                           ;



# 69 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
#define physadr physadr_t
#define quad quad_t


typedef __uint32_t in_addr_t; /* base type for internet address */
#define _IN_ADDR_T_DECLARED 



typedef __uint16_t in_port_t;
#define _IN_PORT_T_DECLARED 





/* also defined in mingw/gmon.h and in w32api/winsock[2].h */

typedef unsigned char u_char;
#define __u_char_defined 


typedef unsigned short u_short;
#define __u_short_defined 


typedef unsigned int u_int;
#define __u_int_defined 


typedef unsigned long u_long;
#define __u_long_defined 

#define _BSDTYPES_DEFINED 




typedef unsigned short ushort; /* System V compatibility */
typedef unsigned int uint; /* System V compatibility */
typedef unsigned long ulong; /* System V compatibility */



typedef __blkcnt_t blkcnt_t;
#define _BLKCNT_T_DECLARED 



typedef __blksize_t blksize_t;
#define _BLKSIZE_T_DECLARED 



typedef unsigned long /* clock() */ clock_t;
#define __clock_t_defined 
#define _CLOCK_T_DECLARED 
# 135 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 3
typedef long daddr_t;
#define __daddr_t_defined 


typedef char * caddr_t;
#define __caddr_t_defined 



typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
#define _FSBLKCNT_T_DECLARED 



typedef __id_t id_t; /* can hold a uid_t or pid_t */
#define _ID_T_DECLARED 



typedef __ino_t ino_t; /* inode number */
#define _INO_T_DECLARED 
# 165 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 3
/*
 * All these should be machine specific - right now they are all broken.
 * However, for all of Cygnus' embedded targets, we want them to all be
 * the same.  Otherwise things like sizeof (struct stat) might depend on
 * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
 */


typedef __off_t off_t; /* file offset */
#define _OFF_T_DECLARED 


typedef __dev_t dev_t; /* device number or struct cdev */
#define _DEV_T_DECLARED 


typedef __uid_t uid_t; /* user id */
#define _UID_T_DECLARED 


typedef __gid_t gid_t; /* group id */
#define _GID_T_DECLARED 



typedef __pid_t pid_t; /* process id */
#define _PID_T_DECLARED 



typedef __key_t key_t; /* IPC key */
#define _KEY_T_DECLARED 



typedef _ssize_t ssize_t;
#define _SSIZE_T_DECLARED 



typedef __mode_t mode_t; /* permissions */
#define _MODE_T_DECLARED 



typedef __nlink_t nlink_t; /* link count */
#define _NLINK_T_DECLARED 



typedef __clockid_t clockid_t;
#define __clockid_t_defined 
#define _CLOCKID_T_DECLARED 



typedef __timer_t timer_t;
#define __timer_t_defined 
#define _TIMER_T_DECLARED 



typedef __useconds_t useconds_t; /* microseconds (unsigned) */
#define _USECONDS_T_DECLARED 







typedef __int64_t sbintime_t;

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/features.h" 1 3
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2014.
 *
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */
# 239 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_pthreadtypes.h" 1 3
/*
 *  Written by Joel Sherrill <joel.sherrill@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2013, 2015.
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */


#define _SYS__PTHREADTYPES_H_ 



# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/sched.h" 1 3
/*
 *  Written by Joel Sherrill <joel@OARcorp.com>.
 *
 *  COPYRIGHT (c) 1989-2010.
 *  On-Line Applications Research Corporation (OAR).
 *
 *  Permission to use, copy, modify, and distribute this software for any
 *  purpose without fee is hereby granted, provided that this entire notice
 *  is included in all copies of any software which is or includes a copy
 *  or modification of this software.
 *
 *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
 *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
 *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 *
 *  $Id$
 */



#define _SYS_SCHED_H_ 

# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_timespec.h" 1 3
/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.5 (Berkeley) 5/4/95
 * from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
 *	$FreeBSD$
 */
# 25 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/sched.h" 2 3





/* Scheduling Policies */
/* Open Group Specifications Issue 6 */



#define SCHED_OTHER 0


#define SCHED_FIFO 1
#define SCHED_RR 2





/* Scheduling Parameters */
/* Open Group Specifications Issue 6 */

struct sched_param {
  int sched_priority; /* Process execution scheduling priority */
# 61 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/sched.h" 3
};






/* end of include file */
# 24 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_pthreadtypes.h" 2 3

/*
 *  2.5 Primitive System Data Types,  P1003.1c/D10, p. 19.
 */




typedef __uint32_t pthread_t; /* identify a thread */


/* P1003.1c/D10, p. 118-119 */
#define PTHREAD_SCOPE_PROCESS 0
#define PTHREAD_SCOPE_SYSTEM 1

/* P1003.1c/D10, p. 111 */
#define PTHREAD_INHERIT_SCHED 1 /* scheduling policy and associated */
                                      /*   attributes are inherited from */
                                      /*   the calling thread. */
#define PTHREAD_EXPLICIT_SCHED 2 /* set from provided attribute object */

/* P1003.1c/D10, p. 141 */
#define PTHREAD_CREATE_DETACHED 0
#define PTHREAD_CREATE_JOINABLE 1
# 61 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_pthreadtypes.h" 3
typedef struct {
  int is_initialized;
  void *stackaddr;
  int stacksize;
  int contentionscope;
  int inheritsched;
  int schedpolicy;
  struct sched_param schedparam;

  /* P1003.4b/D8, p. 54 adds cputime_clock_allowed attribute.  */



  int detachstate;
} pthread_attr_t;
# 154 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_pthreadtypes.h" 3
typedef __uint32_t pthread_mutex_t; /* identify a mutex */

typedef struct {
  int is_initialized;
# 168 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_pthreadtypes.h" 3
  int recursive;
} pthread_mutexattr_t;


#define _PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t) 0xFFFFFFFF)

/* Condition Variables */

typedef __uint32_t pthread_cond_t; /* identify a condition variable */

#define _PTHREAD_COND_INITIALIZER ((pthread_cond_t) 0xFFFFFFFF)

typedef struct {
  int is_initialized;
  clock_t clock; /* specifiy clock for timeouts */



} pthread_condattr_t; /* a condition attribute object */

/* Keys */

typedef __uint32_t pthread_key_t; /* thread-specific data keys */

typedef struct {
  int is_initialized; /* is this structure initialized? */
  int init_executed; /* has the initialization routine been run? */
} pthread_once_t; /* dynamic package initialization */

#define _PTHREAD_ONCE_INIT { 1, 0 } /* is initialized and not run */


/* POSIX Barrier Types */
# 212 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_pthreadtypes.h" 3
/* POSIX Spin Lock Types */





/* POSIX Reader/Writer Lock Types */
# 240 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3
# 1 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/types.h" 1 3
/*
 * Newlib targets may provide an own version of this file in their machine
 * directory to add custom user types for <sys/types.h>.
 */
# 241 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/types.h" 2 3



#undef __need_inttypes
# 28 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 2






#define JSON_VALUE_TYPE_BOOL (0)
#define JSON_VALUE_TYPE_UINT64 (1)
#define JSON_VALUE_TYPE_INT64 (2)
#define JSON_VALUE_TYPE_STRING (3)
#define JSON_VALUE_TYPE_ARRAY (4)
#define JSON_VALUE_TYPE_OBJECT (5)


# 41 "repos/apache-mynewt-core/encoding/json/include/json/json.h"
struct json_value {
    uint8_t jv_pad1;
    uint8_t jv_type;
    uint16_t jv_len;

    union {
        uint64_t u;
        float fl;
        char *str;
        struct {
            char **keys;
            struct json_value **values;
        } composite;
    } jv_val;
};

#define JSON_VALUE_STRING(__jv,__str) (__jv)->jv_type = JSON_VALUE_TYPE_STRING; (__jv)->jv_len = strlen(__str); (__jv)->jv_val.str = (__str);




#define JSON_VALUE_STRINGN(__jv,__str,__len) (__jv)->jv_type = JSON_VALUE_TYPE_STRING; (__jv)->jv_len = (uint16_t) (__len); (__jv)->jv_val.str = (__str);




#define JSON_VALUE_BOOL(__jv,__v) (__jv)->jv_type = JSON_VALUE_TYPE_BOOL; (__jv)->jv_val.u = (__v);



#define JSON_VALUE_INT(__jv,__v) (__jv)->jv_type = JSON_VALUE_TYPE_INT64; (__jv)->jv_val.u = (uint64_t) __v;



#define JSON_VALUE_UINT(__jv,__v) (__jv)->jv_type = JSON_VALUE_TYPE_UINT64; (__jv)->jv_val.u = (uint64_t) __v;



/* Encoding functions */
typedef int (*json_write_func_t)(void *buf, char *data,
        int len);

struct json_encoder {
    json_write_func_t je_write;
    void *je_arg;
    int je_wr_commas:1;
    char je_encode_buf[64];
};


#define JSON_NITEMS(x) (int)(sizeof(x)/sizeof(x[0]))

int json_encode_object_start(struct json_encoder *);
int json_encode_object_key(struct json_encoder *encoder, char *key);
int json_encode_object_entry(struct json_encoder *, char *,
        struct json_value *);
int json_encode_object_finish(struct json_encoder *);

int json_encode_array_name(struct json_encoder *encoder, char *name);
int json_encode_array_start(struct json_encoder *encoder);
int json_encode_array_value(struct json_encoder *encoder, struct json_value *val);
int json_encode_array_finish(struct json_encoder *encoder);

/* Json parser definitions */
typedef enum {
    t_integer,
    t_uinteger,
    t_real,
    t_string,
    t_boolean,
    t_character,
    t_object,
    t_structobject,
    t_array,
    t_check,
    t_ignore
} json_type;

struct json_enum_t {
    char *name;
    long long int value;
};

struct json_array_t {
    json_type element_type;
    union {
        struct {
            const struct json_attr_t *subtype;
            char *base;
            size_t stride;
        } objects;
        struct {
            char **ptrs;
            char *store;
            int storelen;
        } strings;
        struct {
            long long int *store;
        } integers;
        struct {
            long long unsigned int *store;
        } uintegers;
        struct {
            double *store;
        } reals;
        struct {
            
# 147 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 3 4
           _Bool 
# 147 "repos/apache-mynewt-core/encoding/json/include/json/json.h"
                *store;
        } booleans;
    } arr;
    int *count;
    int maxlen;
};

struct json_attr_t {
    char *attribute;
    json_type type;
    union {
        long long int *integer;
        long long unsigned int *uinteger;
        double *real;
        char *string;
        
# 162 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 3 4
       _Bool 
# 162 "repos/apache-mynewt-core/encoding/json/include/json/json.h"
            *boolean;
        char *character;
        struct json_array_t array;
        size_t offset;
    } addr;
    union {
        long long int integer;
        long long unsigned int uinteger;
        double real;
        
# 171 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 3 4
       _Bool 
# 171 "repos/apache-mynewt-core/encoding/json/include/json/json.h"
            boolean;
        char character;
        char *check;
    } dflt;
    size_t len;
    const struct json_enum_t *map;
    
# 177 "repos/apache-mynewt-core/encoding/json/include/json/json.h" 3 4
   _Bool 
# 177 "repos/apache-mynewt-core/encoding/json/include/json/json.h"
        nodefault;
};

struct json_buffer;

/* when you implement a json buffer, you must implement these functions */

/* returns the next character in the buffer or '\0'*/
typedef char (*json_buffer_read_next_byte_t)(struct json_buffer *);
/* returns the previous character in the buffer or '\0' */
typedef char (*json_buffer_read_prev_byte_t)(struct json_buffer *);
/* returns the number of characters read or zero */
typedef int (*json_buffer_readn_t)(struct json_buffer *, char *buf, int n);

struct json_buffer {
    json_buffer_readn_t jb_readn;
    json_buffer_read_next_byte_t jb_read_next;
    json_buffer_read_prev_byte_t jb_read_prev;
};

#define JSON_ATTR_MAX 31 /* max chars in JSON attribute name */
#define JSON_VAL_MAX 512 /* max chars in JSON value part */

int json_read_object(struct json_buffer *, const struct json_attr_t *);
int json_read_array(struct json_buffer *, const struct json_array_t *);

#define JSON_ERR_OBSTART 1 /* non-WS when expecting object start */
#define JSON_ERR_ATTRSTART 2 /* non-WS when expecting attrib start */
#define JSON_ERR_BADATTR 3 /* unknown attribute name */
#define JSON_ERR_ATTRLEN 4 /* attribute name too long */
#define JSON_ERR_NOARRAY 5 /* saw [ when not expecting array */
#define JSON_ERR_NOBRAK 6 /* array element specified, but no [ */
#define JSON_ERR_STRLONG 7 /* string value too long */
#define JSON_ERR_TOKLONG 8 /* token value too long */
#define JSON_ERR_BADTRAIL 9 /* garbage while expecting comma or } or ] */
#define JSON_ERR_ARRAYSTART 10 /* didn't find expected array start */
#define JSON_ERR_OBJARR 11 /* error while parsing object array */
#define JSON_ERR_SUBTOOLONG 12 /* too many array elements */
#define JSON_ERR_BADSUBTRAIL 13 /* garbage while expecting array comma */
#define JSON_ERR_SUBTYPE 14 /* unsupported array element type */
#define JSON_ERR_BADSTRING 15 /* error while string parsing */
#define JSON_ERR_CHECKFAIL 16 /* check attribute not matched */
#define JSON_ERR_NOPARSTR 17 /* can't support strings in parallel arrays */
#define JSON_ERR_BADENUM 18 /* invalid enumerated value */
#define JSON_ERR_QNONSTRING 19 /* saw quoted value when expecting nonstring */
#define JSON_ERR_NONQSTRING 19 /* didn't see quoted value when expecting string */
#define JSON_ERR_MISC 20 /* other data conversion error */
#define JSON_ERR_BADNUM 21 /* error while parsing a numerical argument */
#define JSON_ERR_NULLPTR 22 /* unexpected null value or attribute pointer */

/*
 * Use the following macros to declare template initializers for structobject
 * arrays.  Writing the equivalents out by hand is error-prone.
 *
 * JSON_STRUCT_OBJECT takes a structure name s, and a fieldname f in s.
 *
 * JSON_STRUCT_ARRAY takes the name of a structure array, a pointer to a an
 * initializer defining the subobject type, and the address of an integer to
 * store the length in.
 */
#define JSON_STRUCT_OBJECT(s,f) .addr.offset = offsetof(s, f)
#define JSON_STRUCT_ARRAY(a,e,n) .addr.array.element_type = t_structobject, .addr.array.arr.objects.subtype = e, .addr.array.arr.objects.base = (char*)a, .addr.array.arr.objects.stride = sizeof(a[0]), .addr.array.count = n, .addr.array.maxlen = (int)(sizeof(a)/sizeof(a[0]))
# 252 "repos/apache-mynewt-core/encoding/json/include/json/json.h"
/**
 *   @} OSEncoding
 * @} OSJSON
 */
# 46 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 2
#define COAP_CONTENT_FORMAT APPLICATION_JSON /*  Specify JSON content type and accept type in the CoAP header.*/
#define JSON_VALUE_TYPE_EXT_FLOAT (6) /*  For custom encoding of floats.*/

extern struct json_encoder coap_json_encoder; //  Note: We don't support concurrent encoding of JSON messages.
extern struct json_value coap_json_value; //  Custom JSON value being encoded.

void json_rep_new(struct os_mbuf *m); //  Prepare to write a new JSON CoAP payload into the mbuf.
void json_rep_reset(void); //  Close the current JSON CoAP payload.  Erase the JSON encoder.
int json_rep_finalize(void); //  Finalise the payload and return the payload size.
int json_encode_object_entry_ext(struct json_encoder *encoder, char *key, struct json_value *val); //  Custom encoder for floats.

//  Start the JSON representation.  Assume top level is object.
//  --> {
void json_rep_start_root_object(void);

//  End the JSON representation.  Assume top level is object.
//  {... --> {...}
void json_rep_end_root_object(void);

//  Assume we are writing an object now.  Write the key name and start a child array.  `_k` version does not stringify the key.
//  {a:b --> {a:b, key:[
#define json_rep_set_array(object,key) { json_encode_array_name(&coap_json_encoder, #key); json_encode_array_start(&coap_json_encoder); }
#define json_rep_set_array_k(object,key) { json_encode_array_name(&coap_json_encoder, key); json_encode_array_start(&coap_json_encoder); }

//  End the child array and resume writing the parent object.
//  {a:b, key:[... --> {a:b, key:[...]
#define json_rep_close_array(object,key) json_encode_array_finish(&coap_json_encoder)

//  Assume we have called set_array.  Start an array item, assumed to be an object.
//  [... --> [...,
#define json_rep_object_array_start_item(key) { json_encode_object_start(&coap_json_encoder); }

//  End an array item, assumed to be an object.
//  [... --> [...,
#define json_rep_object_array_end_item(key) { json_encode_object_finish(&coap_json_encoder); }

//  Define a float JSON value.
#define JSON_VALUE_EXT_FLOAT(__jv,__v) (__jv)->jv_type = JSON_VALUE_TYPE_EXT_FLOAT; (__jv)->jv_val.fl = (float) __v;



//  Encode a value into JSON: int, unsigned int, float, text, ... `_k` version does not stringify the key.
#define json_rep_set_int(object,key,value) { JSON_VALUE_INT (&coap_json_value, value); json_encode_object_entry (&coap_json_encoder, #key, &coap_json_value); }
#define json_rep_set_int_k(object,key,value) { JSON_VALUE_INT (&coap_json_value, value); json_encode_object_entry (&coap_json_encoder, key, &coap_json_value); }
#define json_rep_set_uint(object,key,value) { JSON_VALUE_UINT (&coap_json_value, value); json_encode_object_entry (&coap_json_encoder, #key, &coap_json_value); }
#define json_rep_set_uint_k(object,key,value) { JSON_VALUE_UINT (&coap_json_value, value); json_encode_object_entry (&coap_json_encoder, key, &coap_json_value); }
#define json_rep_set_float(object,key,value) { JSON_VALUE_EXT_FLOAT(&coap_json_value, value); json_encode_object_entry_ext(&coap_json_encoder, #key, &coap_json_value); }
#define json_rep_set_float_k(object,key,value) { JSON_VALUE_EXT_FLOAT(&coap_json_value, value); json_encode_object_entry_ext(&coap_json_encoder, key, &coap_json_value); }
#define json_rep_set_text_string(object,key,value) { JSON_VALUE_STRING (&coap_json_value, (char *) value); json_encode_object_entry (&coap_json_encoder, #key, &coap_json_value); }
#define json_rep_set_text_string_k(object,key,value) { JSON_VALUE_STRING (&coap_json_value, (char *) value); json_encode_object_entry (&coap_json_encoder, key, &coap_json_value); }



///////////////////////////////////////////////////////////////////////////////
//  JSON-Only Encoding Macros
# 121 "libs/sensor_coap/include/sensor_coap/sensor_coap.h"
///////////////////////////////////////////////////////////////////////////////
//  CBOR-Only Encoding Macros
# 145 "libs/sensor_coap/include/sensor_coap/sensor_coap.h"
///////////////////////////////////////////////////////////////////////////////
//  JSON and CBOR Coexistence Encoding Macros



//  JSON or CBOR encoding will be selected by the Sensor Network, which depends on whether we're sending
//  to CoAP Server (JSON) or Collector Node (CBOR)

# 1 "repos/apache-mynewt-core/net/oic/include/oic/oc_rep.h" 1
/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/
# 154 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 2
# 1 "repos/apache-mynewt-core/net/oic/include/oic/messaging/coap/constants.h" 1
/*
 * Copyright (c) 2016 Intel Corporation
 *
 * Copyright (c) 2013, Institute for Pervasive Computing, ETH Zurich
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of the Contiki operating system.
 */
# 155 "libs/sensor_coap/include/sensor_coap/sensor_coap.h" 2

#undef COAP_CONTENT_FORMAT
extern int oc_content_format; //  CoAP Payload encoding format: APPLICATION_JSON or APPLICATION_CBOR
#define JSON_ENC (oc_content_format == APPLICATION_JSON) /*  True if encoding format is JSON*/

//  From repos\apache-mynewt-core\net\oic\include\oic\oc_rep.h
//  Changed "#key" to "key" so that the key won't be stringified.

#define oc_rep_set_int_k(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, key, strlen(key)); g_err |= cbor_encode_int(&object ##_map, value); } while (0)





#define oc_rep_set_uint_k(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, key, strlen(key)); g_err |= cbor_encode_uint(&object ##_map, value); } while (0)





#define oc_rep_set_float_k(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, key, strlen(key)); g_err |= cbor_encode_float(&object ##_map, value); } while (0)





#define oc_rep_set_text_string_k(object,key,value) do { g_err |= cbor_encode_text_string(&object ##_map, key, strlen(key)); g_err |= cbor_encode_text_string(&object ##_map, value, strlen(value)); } while (0)





#define rep_start_root_object() oc_rep_start_root_object(); if (JSON_ENC) { json_rep_start_root_object(); }


#define rep_end_root_object() if (JSON_ENC) { json_rep_end_root_object(); } oc_rep_end_root_object();


#define rep_set_array(object,key) oc_rep_set_array(object, key); if (JSON_ENC) { json_rep_set_array(object, key); }


#define rep_close_array(object,key) if (JSON_ENC) { json_rep_close_array(object, key); } oc_rep_close_array(object, key);


#define rep_object_array_start_item(key) oc_rep_object_array_start_item(key); if (JSON_ENC) { json_rep_object_array_start_item(key); }


#define rep_object_array_end_item(key) if (JSON_ENC) { json_rep_object_array_end_item(key); } oc_rep_object_array_end_item(key);


//  oc_rep_set_int(object, key, value)
//  -> cbor_encode_text_string(&object##_map, #key, strlen(#key));
//     cbor_encode_int(&object##_map, value);      
//  oc_rep_set_key(parent, key)
//  -> cbor_encode_text_string(&parent, key, strlen(key))

#define rep_set_int(object,key,value) { if (JSON_ENC) { json_rep_set_int(object, key, value); } else { oc_rep_set_int(object, key, value); } }
#define rep_set_uint(object,key,value) { if (JSON_ENC) { json_rep_set_uint(object, key, value); } else { oc_rep_set_uint(object, key, value); } }
#define rep_set_float(object,key,value) { if (JSON_ENC) { json_rep_set_float(object, key, value); } else { oc_rep_set_double(object, key, value); } }
#define rep_set_text_string(object,key,value) { if (JSON_ENC) { json_rep_set_text_string(object, key, value); } else { oc_rep_set_text_string(object, key, value); } }

//  Same as above, except that the key is not stringified.
#define rep_set_int_k(object,key,value) { if (JSON_ENC) { json_rep_set_int(object, key, value); } else { oc_rep_set_int_k(object, key, value); } }
#define rep_set_uint_k(object,key,value) { if (JSON_ENC) { json_rep_set_uint(object, key, value); } else { oc_rep_set_uint_k(object, key, value); } }
#define rep_set_float_k(object,key,value) { if (JSON_ENC) { json_rep_set_float(object, key, value); } else { oc_rep_set_double_k(object, key, value); } }
#define rep_set_text_string_k(object,key,value) { if (JSON_ENC) { json_rep_set_text_string(object, key, value); } else { oc_rep_set_text_string_k(object, key, value); } }



///////////////////////////////////////////////////////////////////////////////
//  CP Macros for composing CoAP Payloads in JSON and CBOR
//  The format defined here is used by thethings.io for receiving sensor data

//  Compose the payload root.
#define CP_ROOT(children0) { rep_start_root_object(); { children0; } rep_end_root_object(); }





//  Given an object parent and an integer Sensor Value val, set the val's key/value in the object.
#define CP_SET_INT_VAL(parent0,val0) { assert(val0->val_type == SENSOR_VALUE_TYPE_INT32); rep_set_int_k(parent0, val0->key, val0->int_val); }




//  Given an object parent and a float Sensor Value val, set the val's key/value in the object.
#define CP_SET_FLOAT_VAL(parent0,val0) { assert(val0->val_type == SENSOR_VALUE_TYPE_FLOAT); rep_set_int_k(parent0, val0->key, val0->float_val); }




//  Set the key/value (integer) in the parent object.
#define CP_SET_INT(parent0,key0,value0) { rep_set_int(parent0, key0, value0); }



//  Set the key/value (float) in the parent object.
#define CP_SET_FLOAT(parent0,key0,value0) { rep_set_float(parent0, key0, value0); }



//  Create a new Item object in the parent array and set the Sensor Value's key/value.
//  Note: This macro is NOT recommended because it bloats the ROM size with float functions.  Call CP_ITEM_INT_VAL and CP_ITEM_FLOAT_VAL instead.
#define CP_ITEM_VAL(parent0,val0) { switch (val0->val_type) { case SENSOR_VALUE_TYPE_INT32: { CP_ITEM_INT_VAL(parent0, val0); break; } case SENSOR_VALUE_TYPE_FLOAT: { CP_ITEM_FLOAT_VAL(parent0, val0); break; } default: { assert(0); } /* Unknown type */ } }







//  Create a new Item object in the parent array and set the Sensor Value's key/value (integer).
#define CP_ITEM_INT_VAL(parent0,val0) { assert(val0->val_type == SENSOR_VALUE_TYPE_INT32); CP_ITEM_INT(parent0, val0->key, val0->int_val); }




//  Create a new Item object in the parent array and set the Sensor Value's key/value (float).
#define CP_ITEM_FLOAT_VAL(parent0,val0) { assert(val0->val_type == SENSOR_VALUE_TYPE_FLOAT); CP_ITEM_FLOAT(parent0, val0->key, val0->float_val); }




//  Compose an array under "object", named as "key".  Add "children" as array elements.
#define CP_ARRAY(object0,key0,children0) { rep_set_array(object0, key0); { children0; } rep_close_array(object0, key0); }





//  Append an array item under the array named "array".  Add "children" as the item key and value.
//    { <array>: [ ..., { <children> } ], ... }
#define CP_ITEM(array0,children0) { rep_object_array_start_item(array0); { children0; } rep_object_array_end_item(array0); }





//  Append a (key + int value) item to the array named "array":
//    { <array>: [ ..., {"key": <key0>, "value": <value0>} ], ... }
#define CP_ITEM_INT(array0,key0,value0) { CP_ITEM(array0, { rep_set_text_string(array0, key, key0); rep_set_int( array0, value, value0); }) }






//  Append a (key + unsigned int value) item to the array named "array":
//    { <array>: [ ..., {"key": <key0>, "value": <value0>} ], ... }
#define CP_ITEM_UINT(array0,key0,value0) { CP_ITEM(array0, { rep_set_text_string(array0, key, key0); rep_set_uint( array0, value, value0); }) }






//  Append a (key + float value) item to the array named "array":
//    { <array>: [ ..., {"key": <key0>, "value": <value0>} ], ... }
#define CP_ITEM_FLOAT(array0,key0,value0) { CP_ITEM(array0, { rep_set_text_string(array0, key, key0); rep_set_float( array0, value, value0); }) }






//  Append a (key + string value) item to the array named "array":
//    { <array>: [ ..., {"key": <key0>, "value": <value0>} ], ... }
#define CP_ITEM_STR(array0,key0,value0) { CP_ITEM(array0, { rep_set_text_string(array0, key, key0); rep_set_text_string(array0, value, value0); }) }
# 28 "libs/sensor_coap/src/sensor_coap.c" 2

# 1 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor_cnt_writer.h" 1
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#define CBOR_CNT_WRITER_H 

# 1 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor.h" 1
/****************************************************************************
**
** Copyright (C) 2015 Intel Corporation
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
** copies of the Software, and to permit persons to whom the Software is
** furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
** THE SOFTWARE.
**
****************************************************************************/
# 24 "repos/apache-mynewt-core/encoding/tinycbor/include/tinycbor/cbor_cnt_writer.h" 2






    /* use this count writer if you want to try out a cbor encoding to see
     * how long it would be (before allocating memory). This replaced the
     * code in tinycbor.h that would try to do this once the encoding failed
     * in a buffer.  Its much easier to understand this way (for me)
     */

struct CborCntWriter {
    struct cbor_encoder_writer enc;
};

static inline int
cbor_cnt_writer(struct cbor_encoder_writer *arg, const char *data, int len) {
    struct CborCntWriter *cb = (struct CborCntWriter *) arg;
    cb->enc.bytes_written += len;
    return CborNoError;
}

static inline void
cbor_cnt_writer_init(struct CborCntWriter *cb) {
    cb->enc.bytes_written = 0;
    cb->enc.write = &cbor_cnt_writer;
}
# 30 "libs/sensor_coap/src/sensor_coap.c" 2
///  Set a dummy writer so that CBOR encoder will not crash when JSON encoding is selected
static struct CborCntWriter cnt_writer;


#define OC_CLIENT_CB_TIMEOUT_SECS COAP_RESPONSE_TIMEOUT

///  Contains the CoAP headers.
static struct os_mbuf *oc_c_message;
///  Contains the CoAP payload body.
static struct os_mbuf *oc_c_rsp;
///  CoAP request
static coap_packet_t oc_c_request[1];
///  Because the CoAP JSON / CBOR buffers are shared, use this semaphore to prevent two CoAP requests from being composed at the same time.
static struct os_sem oc_sem;
///  True if the Sensor CoAP is ready for sending sensor data.
static 
# 45 "libs/sensor_coap/src/sensor_coap.c" 3 4
      _Bool 
# 45 "libs/sensor_coap/src/sensor_coap.c"
           oc_sensor_coap_ready = 
# 45 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                  0
# 45 "libs/sensor_coap/src/sensor_coap.c"
                                       ;
///  CoAP Payload encoding format: APPLICATION_JSON or APPLICATION_CBOR. If 0, let Sensor Network decide.
int oc_content_format = 0;

///////////////////////////////////////////////////////////////////////////////
//  CoAP Functions

///  Init the Sensor CoAP module. Called by sysinit() during startup, defined in pkg.yml.
void init_sensor_coap(void) {
    os_error_t rc = os_sem_init(&oc_sem, 1); //  Init to 1 token, so only 1 caller will be allowed.
    ((rc == OS_OK) ? (void)0 : __assert_func(
# 55 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 55 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 55 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 55 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 55 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 55 "libs/sensor_coap/src/sensor_coap.c"
   ));
    oc_sensor_coap_ready = 
# 56 "libs/sensor_coap/src/sensor_coap.c" 3 4
                          1
# 56 "libs/sensor_coap/src/sensor_coap.c"
                              ;
}

///  Return true if the Sensor CoAP is ready for sending sensor data.

# 60 "libs/sensor_coap/src/sensor_coap.c" 3 4
_Bool 
# 60 "libs/sensor_coap/src/sensor_coap.c"
    sensor_coap_ready(void) {
    return oc_sensor_coap_ready;
}

///  Handle CoAP response.
static void handle_coap_response(oc_client_response_t *data) {
    console_printf("handle_coap\n");
}

//  Serialise the CoAP request and payload into the final mbuf format for transmitting.
//  Forward the serialised mbuf to the background transmit task for transmitting.
static 
# 71 "libs/sensor_coap/src/sensor_coap.c" 3 4
      _Bool

# 72 "libs/sensor_coap/src/sensor_coap.c"
dispatch_coap_request(void)
{
    
# 74 "libs/sensor_coap/src/sensor_coap.c" 3 4
   _Bool 
# 74 "libs/sensor_coap/src/sensor_coap.c"
        ret = 
# 74 "libs/sensor_coap/src/sensor_coap.c" 3 4
              0
# 74 "libs/sensor_coap/src/sensor_coap.c"
                   ;
    ((oc_content_format) ? (void)0 : __assert_func(
# 75 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 75 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 75 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 75 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 75 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 75 "libs/sensor_coap/src/sensor_coap.c"
   ));
    int response_length =

        (oc_content_format == APPLICATION_JSON) ? json_rep_finalize() :


        (oc_content_format == APPLICATION_CBOR) ? oc_rep_finalize() :

        0; //  Unknown CoAP content format.

    if (response_length) {
        oc_c_request->payload_m = oc_c_rsp;
        oc_c_request->payload_len = response_length;
        coap_set_header_content_format(oc_c_request, oc_content_format); //  Either JSON or CBOR.
    } else {
        os_mbuf_free_chain(oc_c_rsp);
    }
    oc_c_rsp = 
# 92 "libs/sensor_coap/src/sensor_coap.c" 3 4
              ((void *)0)
# 92 "libs/sensor_coap/src/sensor_coap.c"
                  ;

    if (oc_c_message) {
        if (!coap_serialize_message(oc_c_request, oc_c_message)) {
            coap_send_message(oc_c_message, 0);
        } else {
            os_mbuf_free_chain(oc_c_message);
        }

        //  Deallocate the client callback for the message ID.  We won't be processing the response from server.  
        //  TODO: Handle errors from server.
        oc_ri_remove_client_cb_by_mid(oc_c_request->mid);

        oc_c_message = 
# 105 "libs/sensor_coap/src/sensor_coap.c" 3 4
                      ((void *)0)
# 105 "libs/sensor_coap/src/sensor_coap.c"
                          ;
        ret = 
# 106 "libs/sensor_coap/src/sensor_coap.c" 3 4
             1
# 106 "libs/sensor_coap/src/sensor_coap.c"
                 ;
    }
    os_error_t rc = os_sem_release(&oc_sem); //  Request completed.  Release the semaphore for another request.
    ((rc == OS_OK) ? (void)0 : __assert_func(
# 109 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 109 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 109 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 109 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 109 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 109 "libs/sensor_coap/src/sensor_coap.c"
   ));
    return ret;
}

///  Prepare a new CoAP request for transmitting sensor data.
static 
# 114 "libs/sensor_coap/src/sensor_coap.c" 3 4
      _Bool

# 115 "libs/sensor_coap/src/sensor_coap.c"
prepare_coap_request(oc_client_cb_t *cb, oc_string_t *query)
{
    coap_message_type_t type = COAP_TYPE_NON;

    oc_c_rsp = os_msys_get_pkthdr(0, 0);
    if (!oc_c_rsp) {
        return 
# 121 "libs/sensor_coap/src/sensor_coap.c" 3 4
              0
# 121 "libs/sensor_coap/src/sensor_coap.c"
                   ;
    }
    oc_c_message = oc_allocate_mbuf(&cb->server.endpoint);
    if (!oc_c_message) {
        goto free_rsp;
    }

    if (oc_content_format == APPLICATION_JSON) {

        json_rep_new(oc_c_rsp);

    }
    else if (oc_content_format == APPLICATION_CBOR) {

        oc_rep_new(oc_c_rsp);

    }
    else { ((0) ? (void)0 : __assert_func(
# 138 "libs/sensor_coap/src/sensor_coap.c" 3 4
          ((void *)0)
# 138 "libs/sensor_coap/src/sensor_coap.c"
          , 0, 
# 138 "libs/sensor_coap/src/sensor_coap.c" 3 4
          ((void *)0)
# 138 "libs/sensor_coap/src/sensor_coap.c"
          , 
# 138 "libs/sensor_coap/src/sensor_coap.c" 3 4
          ((void *)0)
# 138 "libs/sensor_coap/src/sensor_coap.c"
          )); } //  Unknown CoAP content format.

    coap_init_message(oc_c_request, type, cb->method, cb->mid);
    coap_set_header_accept(oc_c_request, oc_content_format); //  Either JSON or CBOR.
    coap_set_token(oc_c_request, cb->token, cb->token_len);
    coap_set_header_uri_path(oc_c_request, ((char *)(cb->uri).os_str));
    if (cb->observe_seq != -1) {
        coap_set_header_observe(oc_c_request, cb->observe_seq);
    }
    if (query && ((*query).os_sz ? (*query).os_sz - 1 : 0)) {
        coap_set_header_uri_query(oc_c_request, ((char *)(*query).os_str));
    }
    if (cb->observe_seq == -1 && cb->qos == LOW_QOS) {
        os_callout_reset(&cb->callout,
          (4) * (1000));
    }

    return 
# 155 "libs/sensor_coap/src/sensor_coap.c" 3 4
          1
# 155 "libs/sensor_coap/src/sensor_coap.c"
              ;
free_rsp:
    os_mbuf_free_chain(oc_c_rsp);
    oc_c_rsp = 
# 158 "libs/sensor_coap/src/sensor_coap.c" 3 4
              ((void *)0)
# 158 "libs/sensor_coap/src/sensor_coap.c"
                  ;
    return 
# 159 "libs/sensor_coap/src/sensor_coap.c" 3 4
          0
# 159 "libs/sensor_coap/src/sensor_coap.c"
               ;
}

///  Create a new sensor post request to send to CoAP server.

# 163 "libs/sensor_coap/src/sensor_coap.c" 3 4
_Bool

# 164 "libs/sensor_coap/src/sensor_coap.c"
init_sensor_post(struct oc_server_handle *server, const char *uri, int coap_content_format)
{
    ((oc_sensor_coap_ready) ? (void)0 : __assert_func(
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
   )); ((server) ? (void)0 : __assert_func(
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                  ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
                                  , 0, 
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                  ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
                                  , 
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                  ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
                                  )); ((uri) ? (void)0 : __assert_func(
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                   ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
                                                   , 0, 
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                   ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
                                                   , 
# 166 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                   ((void *)0)
# 166 "libs/sensor_coap/src/sensor_coap.c"
                                                   ));




    ((coap_content_format != 0) ? (void)0 : __assert_func(
# 171 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 171 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 171 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 171 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 171 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 171 "libs/sensor_coap/src/sensor_coap.c"
   )); //  CoAP Content Format not specified

    //  Lock the semaphore for preparing the CoAP request.
    os_error_t rc = os_sem_pend(&oc_sem, (
# 174 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                        (0xffffffffUL)
# 174 "libs/sensor_coap/src/sensor_coap.c"
                                        )); //  Allow only 1 task to be creating a sensor request at any time.
    ((rc == OS_OK) ? (void)0 : __assert_func(
# 175 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 175 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 175 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 175 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 175 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 175 "libs/sensor_coap/src/sensor_coap.c"
   ));

    oc_content_format = coap_content_format;
    oc_qos_t qos = LOW_QOS; //  Default to low QoS, no transactions.
    oc_response_handler_t handler = handle_coap_response;
    oc_client_cb_t *cb;
    
# 181 "libs/sensor_coap/src/sensor_coap.c" 3 4
   _Bool 
# 181 "libs/sensor_coap/src/sensor_coap.c"
        status = 
# 181 "libs/sensor_coap/src/sensor_coap.c" 3 4
                 0
# 181 "libs/sensor_coap/src/sensor_coap.c"
                      ;

    cb = oc_ri_alloc_client_cb(uri, server, OC_POST, handler, qos);
    if (!cb) {
        rc = os_sem_release(&oc_sem); //  Failed.  Release the semaphore.
        ((rc == OS_OK) ? (void)0 : __assert_func(
# 186 "libs/sensor_coap/src/sensor_coap.c" 3 4
       ((void *)0)
# 186 "libs/sensor_coap/src/sensor_coap.c"
       , 0, 
# 186 "libs/sensor_coap/src/sensor_coap.c" 3 4
       ((void *)0)
# 186 "libs/sensor_coap/src/sensor_coap.c"
       , 
# 186 "libs/sensor_coap/src/sensor_coap.c" 3 4
       ((void *)0)
# 186 "libs/sensor_coap/src/sensor_coap.c"
       ));
        return 
# 187 "libs/sensor_coap/src/sensor_coap.c" 3 4
              0
# 187 "libs/sensor_coap/src/sensor_coap.c"
                   ;
    }
    status = prepare_coap_request(cb, 
# 189 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                     ((void *)0)
# 189 "libs/sensor_coap/src/sensor_coap.c"
                                         );
    return status;
}

///  Send the sensor post request to CoAP server.

# 194 "libs/sensor_coap/src/sensor_coap.c" 3 4
_Bool

# 195 "libs/sensor_coap/src/sensor_coap.c"
do_sensor_post(void)
{
    return dispatch_coap_request();
}



///////////////////////////////////////////////////////////////////////////////
//  JSON Encoding Functions

///  Global JSON encoder. Note: We don't support concurrent encoding of JSON messages.
struct json_encoder coap_json_encoder;
///  JSON value currently being encoded.
struct json_value coap_json_value;
///  The mbuf that contains the outgoing CoAP payload.
static struct os_mbuf *coap_json_mbuf;

///  Write the JSON to the mbuf for the outgoing CoAP message.
int json_write_mbuf(void *buf, char *data, int len) {
    if (oc_content_format != APPLICATION_JSON) { return 0; } //  Exit if we are encoding CBOR, not JSON.
    ((coap_json_mbuf) ? (void)0 : __assert_func(
# 215 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 215 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 215 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 215 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 215 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 215 "libs/sensor_coap/src/sensor_coap.c"
   ));
    ((data) ? (void)0 : __assert_func(
# 216 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 216 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 216 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 216 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 216 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 216 "libs/sensor_coap/src/sensor_coap.c"
   ));
    //  console_printf("json "); console_buffer(data, len); console_printf("\n");  ////
    int rc = os_mbuf_append(coap_json_mbuf, data, len); ((rc == 0) ? (void)0 : __assert_func(
# 218 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                        ((void *)0)
# 218 "libs/sensor_coap/src/sensor_coap.c"
                                                        , 0, 
# 218 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                        ((void *)0)
# 218 "libs/sensor_coap/src/sensor_coap.c"
                                                        , 
# 218 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                        ((void *)0)
# 218 "libs/sensor_coap/src/sensor_coap.c"
                                                        ));
    if (rc) { return -1; }
    return 0;
}

///  Prepare to write a new JSON CoAP payload into the mbuf.
void json_rep_new(struct os_mbuf *m) {
    ((m) ? (void)0 : __assert_func(
# 225 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 225 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 225 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 225 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 225 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 225 "libs/sensor_coap/src/sensor_coap.c"
   ));
    json_rep_reset(); //  Erase the JSON encoder.
    coap_json_mbuf = m;


    //  Set a dummy writer so that CBOR encoder will not crash when JSON encoding is selected.
    cbor_cnt_writer_init(&cnt_writer);
    cbor_encoder_init(&g_encoder, &cnt_writer.enc, 0);

}

///  Close the current JSON CoAP payload.  Erase the JSON encoder.
void json_rep_reset(void) {
    coap_json_mbuf = 
# 238 "libs/sensor_coap/src/sensor_coap.c" 3 4
                    ((void *)0)
# 238 "libs/sensor_coap/src/sensor_coap.c"
                        ;
    memset(&coap_json_encoder, 0, sizeof(coap_json_encoder)); //  Erase the encoder.
    coap_json_encoder.je_write = json_write_mbuf;
}

///  Finalise the payload and return the payload size.
int json_rep_finalize(void) {
    ((coap_json_mbuf) ? (void)0 : __assert_func(
# 245 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 245 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 245 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 245 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 245 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 245 "libs/sensor_coap/src/sensor_coap.c"
   ));
    int size = (((struct os_mbuf_pkthdr *) ((uint8_t *)&(coap_json_mbuf)->om_data + sizeof(struct os_mbuf)))->omp_len);
#define DUMP_COAP 

    console_printf("NET payload size %d\n", size); struct os_mbuf *m = coap_json_mbuf;
    while (m) {
        console_buffer((const char *) (m->om_databuf + m->om_pkthdr_len), m->om_len);
        m = m->om_next.sle_next;
    } console_printf("\n");


    json_rep_reset();
    return size;
}

/// Start the JSON representation.  Assume top level is object.
/// ```
/// --> {
/// ```
void json_rep_start_root_object(void) {
    int rc = json_encode_object_start(&coap_json_encoder); ((rc == 0) ? (void)0 : __assert_func(
# 265 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                           ((void *)0)
# 265 "libs/sensor_coap/src/sensor_coap.c"
                                                           , 0, 
# 265 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                           ((void *)0)
# 265 "libs/sensor_coap/src/sensor_coap.c"
                                                           , 
# 265 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                           ((void *)0)
# 265 "libs/sensor_coap/src/sensor_coap.c"
                                                           ));
}

///  End the JSON representation.  Assume top level is object.
///  ```
///  {... --> {...}
///  ```
void json_rep_end_root_object(void) {
    int rc = json_encode_object_finish(&coap_json_encoder); ((rc == 0) ? (void)0 : __assert_func(
# 273 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                            ((void *)0)
# 273 "libs/sensor_coap/src/sensor_coap.c"
                                                            , 0, 
# 273 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                            ((void *)0)
# 273 "libs/sensor_coap/src/sensor_coap.c"
                                                            , 
# 273 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                                            ((void *)0)
# 273 "libs/sensor_coap/src/sensor_coap.c"
                                                            ));
}

static int json_encode_value_ext(struct json_encoder *encoder, struct json_value *jv);
static void split_float(float f, 
# 277 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                _Bool 
# 277 "libs/sensor_coap/src/sensor_coap.c"
                                     *neg, int *i, int *d);

///  Extended version of json_encode_object_entry that handles floats.  Original version: repos\apache-mynewt-core\encoding\json\src\json_encode.c
int
json_encode_object_entry_ext(struct json_encoder *encoder, char *key,
        struct json_value *val)
{
    ((encoder) ? (void)0 : __assert_func(
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
   )); ((key) ? (void)0 : __assert_func(
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
                    ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
                    , 0, 
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
                    ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
                    , 
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
                    ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
                    )); ((val) ? (void)0 : __assert_func(
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                 ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
                                 , 0, 
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                 ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
                                 , 
# 284 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                 ((void *)0)
# 284 "libs/sensor_coap/src/sensor_coap.c"
                                 ));
    int rc;

    if (encoder->je_wr_commas) {
        encoder->je_write(encoder->je_arg, ",", sizeof(",")-1);
        encoder->je_wr_commas = 0;
    }
    /* Write the key entry */
    encoder->je_write(encoder->je_arg, "\"", sizeof("\"")-1);
    encoder->je_write(encoder->je_arg, key, strlen(key));
    encoder->je_write(encoder->je_arg, "\": ", sizeof("\": ")-1);

    rc = json_encode_value_ext(encoder, val);
    if (rc != 0) {
        goto err;
    }
    encoder->je_wr_commas = 1;

    return (0);
err:
    return (rc);
}

///  Extended version of json_encode_value_ext that handles floats.  Original version: repos\apache-mynewt-core\encoding\json\src\json_encode.c
static int
json_encode_value_ext(struct json_encoder *encoder, struct json_value *jv)
{
    ((encoder) ? (void)0 : __assert_func(
# 311 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 311 "libs/sensor_coap/src/sensor_coap.c"
   , 0, 
# 311 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 311 "libs/sensor_coap/src/sensor_coap.c"
   , 
# 311 "libs/sensor_coap/src/sensor_coap.c" 3 4
   ((void *)0)
# 311 "libs/sensor_coap/src/sensor_coap.c"
   )); ((jv) ? (void)0 : __assert_func(
# 311 "libs/sensor_coap/src/sensor_coap.c" 3 4
                     ((void *)0)
# 311 "libs/sensor_coap/src/sensor_coap.c"
                     , 0, 
# 311 "libs/sensor_coap/src/sensor_coap.c" 3 4
                     ((void *)0)
# 311 "libs/sensor_coap/src/sensor_coap.c"
                     , 
# 311 "libs/sensor_coap/src/sensor_coap.c" 3 4
                     ((void *)0)
# 311 "libs/sensor_coap/src/sensor_coap.c"
                     ));
    int rc;
    int len;

    switch (jv->jv_type) {
        case (6) /*  For custom encoding of floats.*/: {
            //  Encode the float with 2 decimal places.
            
# 318 "libs/sensor_coap/src/sensor_coap.c" 3 4
           _Bool 
# 318 "libs/sensor_coap/src/sensor_coap.c"
                neg; int i, d;
            float f = jv->jv_val.fl;
            split_float(f, &neg, &i, &d); //  Split the float into neg, integer and decimal parts (two decimal places)
            len = sprintf(
                encoder->je_encode_buf,
                "%s%d.%02d",
                neg ? "-" : "", //  Sign
                i, //  Integer part
                d //  2 decimal places
            );
            encoder->je_write(encoder->je_arg, encoder->je_encode_buf, len);
            break;
        }
        default:
            rc = -1;
            goto err;
    }


    return (0);
err:
    return (rc);
}

///  Split the float f into 3 parts: neg is true if negative, the absolute integer part i, and the decimal part d, with 2 decimal places.
static void split_float(float f, 
# 343 "libs/sensor_coap/src/sensor_coap.c" 3 4
                                _Bool 
# 343 "libs/sensor_coap/src/sensor_coap.c"
                                     *neg, int *i, int *d) {
    *neg = (f < 0.0f); //  True if f is negative
    float f_abs = *neg ? -f : f; //  Absolute value of f
    *i = (int) f_abs; //  Integer part
    *d = ((int) (100.0f * f_abs)) % 100; //  Two decimal places
}
